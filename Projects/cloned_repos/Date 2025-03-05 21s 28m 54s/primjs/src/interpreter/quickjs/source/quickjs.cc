/*
 * QuickJS Javascript Engine
 *
 * Copyright (c) 2017-2019 Fabrice Bellard
 * Copyright (c) 2017-2019 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.

#include <assert.h>
#include <fenv.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(_WIN32)
#if defined(_MSC_VER)
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif
#include <windows.h>
#include <winsock.h>
extern "C" {
#include "quickjs/include/quickjs-libc.h"
}
#include <memoryapi.h>
#else
#include <sys/time.h>
#endif
#include <time.h>

#include <cstdint>
#include <cstdlib>
#if defined(ANDROID) || defined(__ANDROID__)
#include <errno.h>
#include <unistd.h>
#endif

#if defined(__APPLE__)
#include <malloc/malloc.h>
#elif defined(__linux__)
#include <malloc.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "quickjs/include/cutils.h"
#include "quickjs/include/libregexp.h"
#include "quickjs/include/list.h"
#include "quickjs/include/quickjs_version.h"
#ifdef __cplusplus
}
#endif

#include "gc/trace-gc.h"
#include "quickjs/include/quickjs-inner.h"

#ifdef __cplusplus
extern "C" {
#endif
#if defined(__aarch64__) && (defined(ANDROID) || defined(__ANDROID__)) && \
    !defined(CONFIG_BIGNUM) && !DISABLE_NANBOX
int64_t HEAP_TAG_OUTER = 0;
int64_t HEAP_TAG_INNER = 0;
#endif
#ifdef __cplusplus
}
#endif

#if !defined(BAZEL_TEST) && !defined(__WASI_SDK__) && \
    defined(ENABLE_QUICKJS_DEBUGGER)
#include "inspector/interface.h"
#endif  // BAZEL_TEST

#if defined(ANDROID) || defined(__ANDROID__)
#include <android/log.h>
#include <pthread.h>
#endif

#if defined(APPLE) || defined(__APPLE__) || \
    (defined(QJS_UNITTEST) && !defined(WIN32))
#include <pthread.h>
#endif

#ifdef ENABLE_COMPATIBLE_MM
#include "gc/collector.h"
#endif

#ifndef EMSCRIPTEN
#define EMSCRIPTEN
#endif

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconversion"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
#pragma clang diagnostic ignored "-Wunreachable-code"
// <Primjs end>
#if defined(EMSCRIPTEN)
#define DIRECT_DISPATCH 0
#else
#define DIRECT_DISPATCH 1
#endif

#if defined(__APPLE__)
#define MALLOC_OVERHEAD 0
#else
#define MALLOC_OVERHEAD 8
#endif

#if !defined(_WIN32) && !defined(__WASI_SDK__)
/* define it if printf uses the RNDN rounding mode instead of RNDNA */
#define CONFIG_PRINTF_RNDN
#endif

/* define to include Atomics.* operations which depend on the OS
   threads */
#if !defined(EMSCRIPTEN)
#define CONFIG_ATOMICS
#endif

/* dump object free */
// #define DUMP_FREE
// #define DUMP_CLOSURE

/* dump the occurence of the automatic GC */
// #define DUMP_GC
/* dump objects freed by the garbage collector */
// #define DUMP_GC_FREE

/* dump memory usage before running the garbage collector */
// #define DUMP_MEM 1
// #define DUMP_OBJECTS    /* dump objects in LEPUS_FreeContext */
// #define DUMP_ATOMS      /* dump atoms in LEPUS_FreeContext */
// #define DUMP_SHAPES     /* dump shapes in LEPUS_FreeContext */
// #define DUMP_MODULE_RESOLVE
// #define DUMP_PROMISE
// #define DUMP_READ_OBJECT

#if (defined(DUMP_LEAKS) || defined(DUMP_BYTECODE) || defined(DUMP_OBJECTS) || \
     defined(DUMP_ATOMS) || defined(DUMP_SHAPES) || defined(DUMP_GC_FREE) ||   \
     defined(DUMP_FREE)) &&                                                    \
    !defined(DUMP_QJS_VALUE)
#define DUMP_QJS_VALUE
#if defined(QJS_UNITTEST) && defined(printf)
#undef printf
#endif
#endif

/* test the GC by forcing it before each object allocation */
// #define FORCE_GC_AT_MALLOC

#ifdef CONFIG_ATOMICS
#include <errno.h>
#include <pthread.h>
#include <stdatomic.h>
#endif

// <primjs begin>

#if defined(ENABLE_PRIMJS_SNAPSHOT)
static const int NUM_OF_TOS_STATES = 3;
#endif

#if defined(ENABLE_PRIMJS_SNAPSHOT)
static pthread_mutex_t prim_init_mutex = PTHREAD_MUTEX_INITIALIZER;

static bool IS_PRIM_INITIALIZED = false;

#endif

#if defined(ENABLE_PRIMJS_TRACE) && PRINT_LOG_TO_FILE && \
    (defined(ANDROID) || defined(__ANDROID__))
FILE *log_f = nullptr;
#endif

// <primjs end>

/* number of typed array types */
#define JS_TYPED_ARRAY_COUNT \
  (JS_CLASS_FLOAT64_ARRAY - JS_CLASS_UINT8C_ARRAY + 1)
/* Typed Arrays */
static uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT] = {
    0, 0, 0, 1, 1, 2, 2,
#ifdef CONFIG_BIGNUM
    3, 3, /* BigInt64Array, BigUint64Array */
#endif
    2, 3};

#define typed_array_size_log2(classid) \
  (typed_array_size_log2[(classid)-JS_CLASS_UINT8C_ARRAY])

#define JS_MAX_LOCAL_VARS 65535
#define JS_STACK_SIZE_MAX 65535
#define JS_STRING_LEN_MAX ((1 << 30) - 1)

int JS_InitAtoms(LEPUSRuntime *rt);

QJS_STATIC void JS_FreeAtomStruct(LEPUSRuntime *rt, JSAtomStruct *p);
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
QJS_STATIC void JS_FreeStringCache(LEPUSRuntime *rt, JSString *p);
#endif
// <Primjs end>
QJS_STATIC void free_function_bytecode(LEPUSRuntime *rt,
                                       LEPUSFunctionBytecode *b);
static LEPUSValue js_call_c_function(LEPUSContext *ctx,
                                     LEPUSValueConst func_obj,
                                     LEPUSValueConst this_obj, int argc,
                                     LEPUSValueConst *argv, int flags);
static LEPUSValue js_call_bound_function(LEPUSContext *ctx,
                                         LEPUSValueConst func_obj,
                                         LEPUSValueConst this_obj, int argc,
                                         LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue JS_CallInternal(LEPUSContext *ctx,
                                      LEPUSValueConst func_obj,
                                      LEPUSValueConst this_obj,
                                      LEPUSValueConst new_target, int argc,
                                      LEPUSValue *argv, int flags);
QJS_STATIC LEPUSValue JS_CallFree(LEPUSContext *ctx, LEPUSValue func_obj,
                                  LEPUSValueConst this_obj, int argc,
                                  LEPUSValueConst *argv);
QJS_STATIC LEPUSValue JS_InvokeFree(LEPUSContext *ctx, LEPUSValue this_val,
                                    JSAtom atom, int argc,
                                    LEPUSValueConst *argv);
QJS_STATIC __exception int JS_ToArrayLengthFree(LEPUSContext *ctx,
                                                uint32_t *plen, LEPUSValue val,
                                                BOOL is_array_ctor);
QJS_STATIC LEPUSValue JS_EvalObject(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                    LEPUSValueConst val, int flags,
                                    int scope_idx);
LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowInternalError(LEPUSContext *ctx, const char *fmt, ...);

// <Primjs begin>
#if defined(DUMP_QJS_VALUE)
static __attribute__((unused)) void JS_DumpAtoms(LEPUSRuntime *rt);
static __attribute__((unused)) void JS_DumpString(LEPUSRuntime *rt,
                                                  const JSString *p);
static __attribute__((unused)) void JS_DumpStringNoPrint(LEPUSRuntime *rt,
                                                         const JSString *p,
                                                         char dump_buf[]);
static __attribute__((unused)) void JS_DumpObjectHeader(LEPUSRuntime *rt);
static __attribute__((unused)) void JS_DumpObject(LEPUSRuntime *rt,
                                                  LEPUSObject *p);
static __attribute__((unused)) void JS_DumpValueShort(LEPUSRuntime *rt,
                                                      LEPUSValueConst val);
static __attribute__((unused)) void JS_DumpValueShortNoPrint(
    LEPUSRuntime *rt, LEPUSValueConst val, char dump_buf[]);
static __attribute__((unused)) void JS_DumpValue(LEPUSContext *ctx,
                                                 LEPUSValueConst val);
static __attribute__((unused)) void JS_PrintValue(LEPUSContext *ctx,
                                                  const char *str,
                                                  LEPUSValueConst val);
static __attribute__((unused)) void JS_DumpShapes(LEPUSRuntime *rt);
#endif  // DUMP_QJS_VALUE
// <Primjs end>

QJS_STATIC void js_array_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func, int local_idx = -1);
QJS_STATIC void js_object_data_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_object_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                    LEPUS_MarkFunc *mark_func,
                                    int local_idx = -1);
QJS_STATIC void js_bytecode_function_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val);
QJS_STATIC void js_bytecode_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func,
                                          int local_idx = -1);
QJS_STATIC void js_bound_function_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_bound_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func,
                                       int local_idx = -1);
QJS_STATIC void js_for_in_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_for_in_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func,
                                        int local_idx = -1);
QJS_STATIC void js_regexp_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_array_buffer_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_typed_array_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_typed_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                    LEPUS_MarkFunc *mark_func,
                                    int local_idx = -1);
QJS_STATIC void js_proxy_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_proxy_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func, int local_idx = -1);
QJS_STATIC void js_map_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_map_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                            LEPUS_MarkFunc *mark_func, int local_idx = -1);
QJS_STATIC void js_map_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_map_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                     LEPUS_MarkFunc *mark_func,
                                     int local_idx = -1);
QJS_STATIC void js_array_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_array_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func,
                                       int local_idx = -1);
QJS_STATIC void js_regexp_string_iterator_finalizer(LEPUSRuntime *rt,
                                                    LEPUSValue val);
QJS_STATIC void js_regexp_string_iterator_mark(LEPUSRuntime *rt,
                                               LEPUSValueConst val,
                                               LEPUS_MarkFunc *mark_func,
                                               int local_idx = -1);
QJS_STATIC void js_generator_finalizer(LEPUSRuntime *rt, LEPUSValue obj);
QJS_STATIC void js_generator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                  LEPUS_MarkFunc *mark_func,
                                  int local_idx = -1);
QJS_STATIC void js_weakref_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_finalizationRegistry_finalizer(LEPUSRuntime *rt,
                                                  LEPUSValue val);
QJS_STATIC void js_finalizationRegistry_mark(LEPUSRuntime *rt,
                                             LEPUSValueConst val,
                                             LEPUS_MarkFunc *mark_func,
                                             int local_idx = -1);
QJS_STATIC void js_promise_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_promise_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                LEPUS_MarkFunc *mark_func, int local_idx = -1);
QJS_STATIC void js_promise_resolve_function_finalizer(LEPUSRuntime *rt,
                                                      LEPUSValue val);
QJS_STATIC void js_promise_resolve_function_mark(LEPUSRuntime *rt,
                                                 LEPUSValueConst val,
                                                 LEPUS_MarkFunc *mark_func,
                                                 int local_idx = -1);
QJS_STATIC LEPUSValue js_promise_resolve_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue JS_ToStringFree(LEPUSContext *ctx, LEPUSValue val);
QJS_STATIC int JS_ToInt32Free(LEPUSContext *ctx, int32_t *pres, LEPUSValue val);
QJS_STATIC int JS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                LEPUSValue val);
QJS_STATIC int JS_ToUint8ClampFree(LEPUSContext *ctx, int32_t *pres,
                                   LEPUSValue val);
QJS_STATIC LEPUSValue js_compile_regexp(LEPUSContext *ctx,
                                        LEPUSValueConst pattern,
                                        LEPUSValueConst flags);
QJS_STATIC void gc_decref(LEPUSRuntime *rt);
QJS_STATIC int JS_NewClass1(LEPUSRuntime *rt, LEPUSClassID class_id,
                            const LEPUSClassDef *class_def, JSAtom name);

typedef enum JSStrictEqModeEnum {
  JS_EQ_STRICT,
  JS_EQ_SAME_VALUE,
  JS_EQ_SAME_VALUE_ZERO,
} JSStrictEqModeEnum;

QJS_STATIC BOOL js_strict_eq2(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2,
                              JSStrictEqModeEnum eq_mode);
QJS_STATIC BOOL js_strict_eq(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2);
QJS_STATIC BOOL js_same_value(LEPUSContext *ctx, LEPUSValueConst op1,
                              LEPUSValueConst op2);
QJS_STATIC BOOL js_same_value_zero(LEPUSContext *ctx, LEPUSValueConst op1,
                                   LEPUSValueConst op2);
QJS_STATIC LEPUSValue JS_ToObjectFree(LEPUSContext *ctx, LEPUSValue val);
#ifdef CONFIG_BIGNUM
static void js_float_env_finalizer(LEPUSRuntime *rt, LEPUSValue val);
static LEPUSValue JS_NewBigFloat(LEPUSContext *ctx, bf_t *a);
static LEPUSValue JS_NewBigInt2(LEPUSContext *ctx, bf_t *a, BOOL force_bigint);
static LEPUSValue JS_NewBigInt(LEPUSContext *ctx, bf_t *a);
static int JS_ToBigInt64Free(LEPUSContext *ctx, int64_t *pres, LEPUSValue val);
static bf_t *JS_ToBigFloat(LEPUSContext *ctx, BOOL *pis_float, bf_t *buf,
                           LEPUSValueConst val);
#endif
LEPUSValue LEPUS_ThrowOutOfMemory(LEPUSContext *ctx);
QJS_STATIC LEPUSValue JS_ThrowTypeErrorRevokedProxy(LEPUSContext *ctx);
QJS_STATIC LEPUSValue js_proxy_call(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                    LEPUSValueConst this_obj, int argc,
                                    LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue js_proxy_call_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst func_obj,
                                                LEPUSValueConst new_target,
                                                int argc,
                                                LEPUSValueConst *argv);
QJS_STATIC LEPUSValueConst js_proxy_getPrototypeOf(LEPUSContext *ctx,
                                                   LEPUSValueConst obj);
QJS_STATIC int js_proxy_setPrototypeOf(LEPUSContext *ctx, LEPUSValueConst obj,
                                       LEPUSValueConst proto_val,
                                       BOOL throw_flag);
QJS_STATIC int js_proxy_isExtensible(LEPUSContext *ctx, LEPUSValueConst obj);
QJS_STATIC int js_proxy_preventExtensions(LEPUSContext *ctx,
                                          LEPUSValueConst obj);
QJS_STATIC int js_proxy_isArray(LEPUSContext *ctx, LEPUSValueConst obj);
QJS_STATIC int JS_CreateProperty(LEPUSContext *ctx, LEPUSObject *p, JSAtom prop,
                                 LEPUSValueConst val, LEPUSValueConst getter,
                                 LEPUSValueConst setter, int flags);
QJS_STATIC int js_string_memcmp(const JSString *p1, const JSString *p2,
                                int len);
QJS_STATIC void reset_weak_ref(LEPUSRuntime *rt, LEPUSObject *p);
QJS_STATIC uint32_t typed_array_get_length(LEPUSContext *ctx, LEPUSObject *p);
QJS_STATIC LEPUSValue JS_ThrowTypeErrorDetachedArrayBuffer(LEPUSContext *ctx);
QJS_STATIC LEPUSValue js_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags);
QJS_STATIC void js_async_function_resolve_finalizer(LEPUSRuntime *rt,
                                                    LEPUSValue val);
QJS_STATIC void js_async_function_resolve_mark(LEPUSRuntime *rt,
                                               LEPUSValueConst val,
                                               LEPUS_MarkFunc *mark_func,
                                               int local_idx = -1);
QJS_STATIC void js_free_module_def(LEPUSContext *ctx, LEPUSModuleDef *m);
QJS_STATIC LEPUSValue js_new_promise_capability(LEPUSContext *ctx,
                                                LEPUSValue *resolving_funcs,
                                                LEPUSValueConst ctor);
class ObjectCloneState;
QJS_STATIC __exception int perform_promise_then(
    LEPUSContext *ctx, LEPUSValueConst promise, LEPUSValueConst *resolve_reject,
    LEPUSValueConst *cap_resolving_funcs, ObjectCloneState *state = NULL);
QJS_STATIC LEPUSValue js_promise_resolve(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic);
QJS_STATIC LEPUSValue JS_ToNumber(LEPUSContext *ctx, LEPUSValueConst val);
QJS_STATIC int JS_NumberIsInteger(LEPUSContext *ctx, LEPUSValueConst val);
QJS_STATIC BOOL JS_NumberIsNegativeOrMinusZero(LEPUSContext *ctx,
                                               LEPUSValueConst val);
QJS_STATIC LEPUSValue JS_ToNumberFree(LEPUSContext *ctx, LEPUSValue val);
QJS_STATIC int JS_GetOwnPropertyInternal(LEPUSContext *ctx,
                                         LEPUSPropertyDescriptor *desc,
                                         LEPUSObject *p, JSAtom prop);
QJS_STATIC void js_free_desc(LEPUSContext *ctx, LEPUSPropertyDescriptor *desc);
QJS_STATIC void async_func_mark(LEPUSRuntime *rt, JSAsyncFunctionState *s,
                                LEPUS_MarkFunc *mark_func, int local_idx = -1);
QJS_STATIC void JS_AddIntrinsicBasicObjects(LEPUSContext *ctx);
QJS_STATIC void js_free_shape(LEPUSRuntime *rt, JSShape *sh);
QJS_STATIC void js_free_shape_null(LEPUSRuntime *rt, JSShape *sh);
QJS_STATIC int js_shape_prepare_update(LEPUSContext *ctx, LEPUSObject *p,
                                       JSShapeProperty **pprs);
QJS_STATIC int init_shape_hash(LEPUSRuntime *rt);
__exception int lepus_get_length32(LEPUSContext *ctx, uint32_t *pres,
                                   LEPUSValueConst obj);
QJS_STATIC __exception int js_get_length64(LEPUSContext *ctx, int64_t *pres,
                                           LEPUSValueConst obj);
QJS_STATIC void free_arg_list(LEPUSContext *ctx, LEPUSValue *tab, uint32_t len);
QJS_STATIC LEPUSValue *build_arg_list(LEPUSContext *ctx, uint32_t *plen,
                                      LEPUSValueConst array_arg);
QJS_STATIC BOOL js_get_fast_array(LEPUSContext *ctx, LEPUSValueConst obj,
                                  LEPUSValue **arrpp, uint32_t *countp);
QJS_STATIC LEPUSValue JS_CreateAsyncFromSyncIterator(LEPUSContext *ctx,
                                                     LEPUSValueConst sync_iter);
QJS_STATIC void js_c_function_data_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void js_c_function_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func,
                                        int local_idx = -1);
QJS_STATIC LEPUSValue js_c_function_data_call(LEPUSContext *ctx,
                                              LEPUSValueConst func_obj,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              int flags);
QJS_STATIC int js_module_ns_has(LEPUSContext *ctx, LEPUSValueConst obj,
                                JSAtom atom);
QJS_STATIC int js_proxy_get_own_property(LEPUSContext *ctx,
                                         LEPUSPropertyDescriptor *pdesc,
                                         LEPUSValueConst obj, JSAtom prop);
QJS_STATIC int js_proxy_define_own_property(LEPUSContext *ctx,
                                            LEPUSValueConst obj, JSAtom prop,
                                            LEPUSValueConst val,
                                            LEPUSValueConst getter,
                                            LEPUSValueConst setter, int flags);
QJS_STATIC int js_proxy_delete_property(LEPUSContext *ctx, LEPUSValueConst obj,
                                        JSAtom atom);
QJS_STATIC int js_proxy_get_own_property_names(LEPUSContext *ctx,
                                               LEPUSPropertyEnum **ptab,
                                               uint32_t *plen,
                                               LEPUSValueConst obj);
QJS_STATIC int js_proxy_has(LEPUSContext *ctx, LEPUSValueConst obj,
                            JSAtom atom);
QJS_STATIC LEPUSValue js_proxy_get(LEPUSContext *ctx, LEPUSValueConst obj,
                                   JSAtom atom, LEPUSValueConst receiver);
QJS_STATIC int js_proxy_set(LEPUSContext *ctx, LEPUSValueConst obj, JSAtom atom,
                            LEPUSValueConst value, LEPUSValueConst receiver,
                            int flags);
QJS_STATIC int js_string_get_own_property(LEPUSContext *ctx,
                                          LEPUSPropertyDescriptor *desc,
                                          LEPUSValueConst obj, JSAtom prop);
QJS_STATIC int js_string_define_own_property(LEPUSContext *ctx,
                                             LEPUSValueConst this_obj,
                                             JSAtom prop, LEPUSValueConst val,
                                             LEPUSValueConst getter,
                                             LEPUSValueConst setter, int flags);
QJS_STATIC int js_string_delete_property(LEPUSContext *ctx, LEPUSValueConst obj,
                                         JSAtom prop);
QJS_STATIC int js_arguments_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, JSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags);
QJS_STATIC int js_string_get_own_property_names(LEPUSContext *ctx,
                                                LEPUSPropertyEnum **ptab,
                                                uint32_t *plen,
                                                LEPUSValueConst obj);

static void find_name_info(const LEPUSFunctionBytecode *, const uint32_t,
                           DynBuf *);
static void add_pc2name_info(JSFunctionDef *s, uint32_t pc);
static void free_caller_slot(LEPUSRuntime *rt, CallerStrSlot *&slots,
                             uint32_t size);

static const LEPUSClassExoticMethods js_arguments_exotic_methods = {
    .define_own_property = js_arguments_define_own_property,
};
static const LEPUSClassExoticMethods js_string_exotic_methods = {
    .get_own_property = js_string_get_own_property,
    .get_own_property_names = js_string_get_own_property_names,
    .delete_property = js_string_delete_property,
    .define_own_property = js_string_define_own_property,
};
static const LEPUSClassExoticMethods js_proxy_exotic_methods = {
    .get_own_property = js_proxy_get_own_property,
    .get_own_property_names = js_proxy_get_own_property_names,
    .delete_property = js_proxy_delete_property,
    .define_own_property = js_proxy_define_own_property,
    .has_property = js_proxy_has,
    .get_property = js_proxy_get,
    .set_property = js_proxy_set,
};
static const LEPUSClassExoticMethods js_module_ns_exotic_methods = {
    .has_property = js_module_ns_has,
};

QJS_STATIC LEPUSValue js_instantiate_prototype(LEPUSContext *ctx,
                                               LEPUSObject *p, JSAtom atom,
                                               void *opaque);
QJS_STATIC LEPUSValue js_module_ns_autoinit(LEPUSContext *ctx, LEPUSObject *p,
                                            JSAtom atom, void *opaque);
QJS_STATIC LEPUSValue JS_InstantiateFunctionListItem2(LEPUSContext *ctx,
                                                      LEPUSObject *p,
                                                      JSAtom atom,
                                                      void *opaque);

static _Atomic LEPUSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;
#define QJSCallBackName(V)               \
  V(run_message_loop_on_pause)           \
  V(quit_message_loop_on_pause)          \
  V(get_messages)                        \
  V(send_response)                       \
  V(send_notification)                   \
  V(free_messages)                       \
  V(debugger_exception)                  \
  V(inspector_check)                     \
  V(console_message)                     \
  V(script_parsed_ntfy)                  \
  V(console_api_called_ntfy)             \
  V(script_fail_parse_ntfy)              \
  V(debugger_paused)                     \
  V(is_devtool_on)                       \
  V(send_response_with_view_id)          \
  V(send_ntfy_with_view_id)              \
  V(script_parsed_ntfy_with_view_id)     \
  V(script_fail_parse_ntfy_with_view_id) \
  V(set_session_enable_state)            \
  V(get_session_state)                   \
  V(console_api_called_ntfy_with_rid)    \
  V(get_session_enable_state)            \
  V(get_console_stack_trace)             \
  V(on_console_message)

#define PRIMJSCallBackName(V)  \
  V(print_by_alog)             \
  V(js_has_property)           \
  V(js_delete_property)        \
  V(js_get_own_property_names) \
  V(js_deep_equal_callback)    \
  V(jsarray_push)              \
  V(jsarray_pop)               \
  V(jsarray_find)              \
  V(jsarray_reverse)           \
  V(jsarray_slice)

LEPUS_BOOL LEPUS_IsNumber(LEPUSValueConst v) {
#ifdef CONFIG_BIGNUM
  int tag = LEPUS_VALUE_GET_TAG(v);
  return tag == LEPUS_TAG_INT || tag == LEPUS_TAG_BIG_INT ||
         tag == LEPUS_TAG_BIG_FLOAT || LEPUS_TAG_IS_FLOAT64(tag);
#else
  return LEPUS_VALUE_IS_INT(v) || LEPUS_VALUE_IS_FLOAT64(v);
#endif
}

// <Primjs begin>

void RegisterLepusType(LEPUSRuntime *rt, int32_t array_typeid,
                       int32_t table_typeid) {
#ifdef ENABLE_LEPUSNG
  rt->js_type_.array_typeid_ = array_typeid;
  rt->js_type_.table_typeid_ = table_typeid;
#endif
}

void LEPUS_RegisterNgType(LEPUSRuntime *rt, int32_t *types,
                          uint32_t input_size) {
#ifdef ENABLE_LEPUSNG
  int32_t *dst = &(rt->js_type_.array_typeid_),
          *end = dst + (sizeof(rt->js_type_) / sizeof(int32_t));

  for (uint32_t i = 0; dst < end && i < input_size; ++i, ++dst) {
    *dst = types[i];
  }
  return;
#endif
}

QJS_HIDE LEPUS_BOOL JS_LepusRefIsArray(LEPUSRuntime *rt, LEPUSValue v) {
#ifdef ENABLE_LEPUSNG
  if (rt && LEPUS_IsLepusRef(v)) {
    return LEPUS_GetLepusRefTag(v) == rt->js_type_.array_typeid_;
  }
#endif
  return FALSE;
}

QJS_HIDE LEPUS_BOOL JS_LepusRefIsTable(LEPUSRuntime *rt, LEPUSValue v) {
#ifdef ENABLE_LEPUSNG
  if (rt && LEPUS_IsLepusRef(v)) {
    return LEPUS_GetLepusRefTag(v) == rt->js_type_.table_typeid_;
  }
#endif
  return FALSE;
}

QJS_STATIC LEPUSValue JSRef2Value(LEPUSContext *ctx, LEPUSValue ref) {
#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(ref)) {
    LEPUSLepusRef *pref =
        static_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(ref));
    auto &obj = pref->lepus_val;
    if (LEPUS_VALUE_IS_OBJECT(obj)) {
      return obj;
    }
    return (obj = ctx->rt->js_callbacks_.convert_to_object(ctx, ref));
  }
#endif
  return ref;
}

// <Primjs end>

QJS_STATIC void js_trigger_gc(LEPUSRuntime *rt, size_t size) {
  BOOL force_gc;
#ifdef FORCE_GC_AT_MALLOC
  force_gc = TRUE;
#else
  force_gc = ((rt->malloc_state.malloc_size + size) > rt->malloc_gc_threshold);
#endif
  if (force_gc) {
#ifdef DUMP_GC
    printf("GC: size=%" PRIu64 "\n", (uint64_t)rt->malloc_state.malloc_size);
#endif
    LEPUS_RunGC(rt);
    rt->malloc_gc_threshold =
        rt->malloc_state.malloc_size + (rt->malloc_state.malloc_size >> 1);
  }
}

QJS_STATIC size_t js_malloc_usable_size_unknown(const void *ptr) { return 0; }

void *lepus_malloc_rt(LEPUSRuntime *rt, size_t size, int alloc_tag = 0) {
  return rt->mf.lepus_malloc(&rt->malloc_state, size, alloc_tag);
}

void lepus_free_rt(LEPUSRuntime *rt, void *ptr) {
#ifdef ENABLE_GC_DEBUG_TOOLS
  DCHECK(!rt->gc_enable);
#endif
  rt->mf.lepus_free(&rt->malloc_state, ptr);
}

void *lepus_realloc_rt(LEPUSRuntime *rt, void *ptr, size_t size,
                       int alloc_tag = 0) {
  return rt->mf.lepus_realloc(&rt->malloc_state, ptr, size, alloc_tag);
}

size_t lepus_malloc_usable_size_rt(LEPUSRuntime *rt, const void *ptr) {
  return rt->mf.lepus_malloc_usable_size(ptr);
}

void *lepus_mallocz_rt(LEPUSRuntime *rt, size_t size, int alloc_tag = 0) {
  void *ptr;
  ptr = lepus_malloc_rt(rt, size, alloc_tag);
  if (!ptr) return NULL;
  return memset(ptr, 0, size);
}

#ifdef CONFIG_BIGNUM
/* called by libbf */
static void *js_bf_realloc(void *opaque, void *ptr, size_t size) {
  LEPUSRuntime *rt = reinterpret_cast<LEPUSRuntime *>(opaque);
  return lepus_realloc_rt(rt, ptr, size);
}
#endif /* CONFIG_BIGNUM */

/* Throw out of memory in case of error */
void *lepus_malloc(LEPUSContext *ctx, size_t size, int alloc_tag = 0) {
  void *ptr;
  ptr = lepus_malloc_rt(ctx->rt, size, alloc_tag);
  if (unlikely(!ptr)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ptr;
}

/* Throw out of memory in case of error */
void *lepus_mallocz(LEPUSContext *ctx, size_t size, int alloc_tag = 0) {
  void *ptr;
  ptr = lepus_mallocz_rt(ctx->rt, size, alloc_tag);
  if (unlikely(!ptr)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ptr;
}

void lepus_free(LEPUSContext *ctx, void *ptr) {
  DCHECK(!ctx->gc_enable);
  lepus_free_rt(ctx->rt, ptr);
}

/* Throw out of memory in case of error */
void *lepus_realloc(LEPUSContext *ctx, void *ptr, size_t size,
                    int alloc_tag = 0) {
  void *ret;
  ret = lepus_realloc_rt(ctx->rt, ptr, size, alloc_tag);
  if (unlikely(!ret && size != 0)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ret;
}

/* store extra allocated size in *pslack if successful */
void *lepus_realloc2(LEPUSContext *ctx, void *ptr, size_t size, size_t *pslack,
                     int alloc_tag = 0) {
  void *ret;
  ret = lepus_realloc_rt(ctx->rt, ptr, size, alloc_tag);
  if (unlikely(!ret && size != 0)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  if (pslack) {
    size_t new_size = ctx->rt->mf.lepus_malloc_usable_size(ret);
    *pslack = (new_size > size) ? new_size - size : 0;
  }
  return ret;
}

size_t lepus_malloc_usable_size(LEPUSContext *ctx, const void *ptr) {
  return lepus_malloc_usable_size_rt(ctx->rt, ptr);
}

/* Throw out of memory exception in case of error */
char *lepus_strndup(LEPUSContext *ctx, const char *s, size_t n,
                    int alloc_tag = 0) {
  char *ptr;
  ptr = static_cast<char *>(lepus_malloc(ctx, n + 1, alloc_tag));
  if (ptr) {
    memcpy(ptr, s, n);
    ptr[n] = '\0';
  }
  return ptr;
}

char *js_strmalloc(const char *s, size_t n) {
  char *ptr;
  ptr = static_cast<char *>(system_malloc(n + 1));
  if (ptr) {
    memcpy(ptr, s, n);
    ptr[n] = '\0';
  }
  return ptr;
}

char *lepus_strdup(LEPUSContext *ctx, const char *str, int alloc_tag = 0) {
  return lepus_strndup(ctx, str, strlen(str), alloc_tag);
}

QJS_STATIC inline void js_dbuf_init(LEPUSContext *ctx, DynBuf *s) {
  dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)lepus_realloc_rt);
}

QJS_STATIC inline int is_digit(int c) { return c >= '0' && c <= '9'; }

static JSClassShortDef const js_std_class_def[] = {
    {JS_ATOM_Object, NULL, NULL},                       /* JS_CLASS_OBJECT */
    {JS_ATOM_Array, js_array_finalizer, js_array_mark}, /* JS_CLASS_ARRAY */
    {JS_ATOM_Error, NULL, NULL},                        /* JS_CLASS_ERROR */
    {JS_ATOM_Number, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_NUMBER */
    {JS_ATOM_String, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_STRING */
    {JS_ATOM_Boolean, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_BOOLEAN */
    {JS_ATOM_Symbol, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_SYMBOL */
    {JS_ATOM_Arguments, js_array_finalizer,
     js_array_mark},                 /* JS_CLASS_ARGUMENTS */
    {JS_ATOM_Arguments, NULL, NULL}, /* JS_CLASS_MAPPED_ARGUMENTS */
    {JS_ATOM_Date, js_object_data_finalizer,
     js_object_data_mark},          /* JS_CLASS_DATE */
    {JS_ATOM_Object, NULL, NULL},   /* JS_CLASS_MODULE_NS */
    {JS_ATOM_Function, NULL, NULL}, /* JS_CLASS_C_FUNCTION */
    {JS_ATOM_Function, js_bytecode_function_finalizer,
     js_bytecode_function_mark}, /* JS_CLASS_BYTECODE_FUNCTION */
    {JS_ATOM_Function, js_bound_function_finalizer,
     js_bound_function_mark}, /* JS_CLASS_BOUND_FUNCTION */
    {JS_ATOM_Function, js_c_function_data_finalizer,
     js_c_function_data_mark}, /* JS_CLASS_C_FUNCTION_DATA */
    {JS_ATOM_GeneratorFunction, js_bytecode_function_finalizer,
     js_bytecode_function_mark}, /* JS_CLASS_GENERATOR_FUNCTION */
    {JS_ATOM_ForInIterator, js_for_in_iterator_finalizer,
     js_for_in_iterator_mark},                   /* JS_CLASS_FOR_IN_ITERATOR */
    {JS_ATOM_RegExp, js_regexp_finalizer, NULL}, /* JS_CLASS_REGEXP */
    {JS_ATOM_ArrayBuffer, js_array_buffer_finalizer,
     NULL}, /* JS_CLASS_ARRAY_BUFFER */
    {JS_ATOM_SharedArrayBuffer, js_array_buffer_finalizer,
     NULL}, /* JS_CLASS_SHARED_ARRAY_BUFFER */
    {JS_ATOM_Uint8ClampedArray, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_UINT8C_ARRAY */
    {JS_ATOM_Int8Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_INT8_ARRAY */
    {JS_ATOM_Uint8Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_UINT8_ARRAY */
    {JS_ATOM_Int16Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_INT16_ARRAY */
    {JS_ATOM_Uint16Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_UINT16_ARRAY */
    {JS_ATOM_Int32Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_INT32_ARRAY */
    {JS_ATOM_Uint32Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_UINT32_ARRAY */
#ifdef CONFIG_BIGNUM
    {JS_ATOM_BigInt64Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_BIG_INT64_ARRAY */
    {JS_ATOM_BigUint64Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_BIG_UINT64_ARRAY */
#endif
    {JS_ATOM_Float32Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_FLOAT32_ARRAY */
    {JS_ATOM_Float64Array, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_FLOAT64_ARRAY */
    {JS_ATOM_DataView, js_typed_array_finalizer,
     js_typed_array_mark}, /* JS_CLASS_DATAVIEW */
#ifdef CONFIG_BIGNUM
    {JS_ATOM_BigInt, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_BIG_INT */
    {JS_ATOM_BigFloat, js_object_data_finalizer,
     js_object_data_mark}, /* JS_CLASS_BIG_FLOAT */
    {JS_ATOM_BigFloatEnv, js_float_env_finalizer,
     NULL}, /* JS_CLASS_FLOAT_ENV */
#endif
    {JS_ATOM_Map, js_map_finalizer, js_map_mark},     /* JS_CLASS_MAP */
    {JS_ATOM_Set, js_map_finalizer, js_map_mark},     /* JS_CLASS_SET */
    {JS_ATOM_WeakMap, js_map_finalizer, js_map_mark}, /* JS_CLASS_WEAKMAP */
    {JS_ATOM_WeakSet, js_map_finalizer, js_map_mark}, /* JS_CLASS_WEAKSET */
    {JS_ATOM_Map_Iterator, js_map_iterator_finalizer,
     js_map_iterator_mark}, /* JS_CLASS_MAP_ITERATOR */
    {JS_ATOM_Set_Iterator, js_map_iterator_finalizer,
     js_map_iterator_mark}, /* JS_CLASS_SET_ITERATOR */
    {JS_ATOM_Array_Iterator, js_array_iterator_finalizer,
     js_array_iterator_mark}, /* JS_CLASS_ARRAY_ITERATOR */
    {JS_ATOM_String_Iterator, js_array_iterator_finalizer,
     js_array_iterator_mark}, /* JS_CLASS_STRING_ITERATOR */
    {JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer,
     js_regexp_string_iterator_mark}, /* JS_CLASS_STRING_ITERATOR */
    {JS_ATOM_Generator, js_generator_finalizer,
     js_generator_mark}, /* JS_CLASS_GENERATOR */
};

int init_class_range(LEPUSRuntime *rt, JSClassShortDef const *tab, int start,
                     int count) {
  LEPUSClassDef cm_s, *cm = &cm_s;
  int i, class_id;

  for (i = 0; i < count; i++) {
    class_id = i + start;
    memset(cm, 0, sizeof(*cm));
    cm->finalizer = tab[i].finalizer;
    cm->gc_mark = tab[i].gc_mark;
    if (JS_NewClass1(rt, class_id, cm, tab[i].class_name) < 0) return -1;
  }
  return 0;
}

#ifdef ENABLE_PRIMJS_SNAPSHOT
bool primjs_snapshot_enabled() {
  if (gc_enabled()) {
    return true;
  }
  return false;
}
#endif

bool gc_enabled() {
#ifdef ENABLE_COMPATIBLE_MM
#ifdef ENABLE_TRACING_GC
  return true;
#else
  return GC_ENABLE & settingsFlag;
#endif
#else
  return false;
#endif
}

enum {
  INITIAL_HEAP_12 = 1,
  INITIAL_HEAP_20,
  INITIAL_HEAP_24,
};

int get_lepusng_heap_mode() {
#ifdef ENABLE_COMPATIBLE_MM
  if (LEPUSNG_HEAP_12 & settingsFlag) {
    return INITIAL_HEAP_12;
  } else if (LEPUSNG_HEAP_20 & settingsFlag) {
    return INITIAL_HEAP_20;
  } else if (LEPUSNG_HEAP_24 & settingsFlag) {
    return INITIAL_HEAP_24;
  } else {
    return 0;
  }
#else
  return 0;
#endif
}

bool effect_enabled() {
#ifdef ENABLE_COMPATIBLE_MM
  return EFFECT_ENABLE & settingsFlag;
#else
  return false;
#endif
}

bool lepusng_gc_disabled() {
#ifdef ENABLE_COMPATIBLE_MM
  return LEPUSNG_GC_DISABLE & settingsFlag;
#else
  return false;
#endif
}

static inline uint8_t *js_get_stack_pointer(void);
LEPUSRuntime *LEPUS_NewRuntime2(const LEPUSMallocFunctions *mf, void *opaque,
                                uint32_t mode) {
#ifdef ENABLE_COMPATIBLE_MM
  if (gc_enabled()) {
    return JS_NewRuntime2_GC(mf, opaque);
  }
#endif
  (void)mode;
  LEPUSRuntime *rt;
  JSMallocState ms;

  memset(&ms, 0, sizeof(ms));
  ms.opaque = opaque;
  ms.malloc_limit = -1;
#ifdef ENABLE_PRIMJS_SNAPSHOT
  bool primjs_is_active = primjs_snapshot_enabled();
#endif

#ifdef ENABLE_PRIMJS_SNAPSHOT
  const char *module_name = primjs_is_active ? MODULE_PRIMJS : MODULE_QUICK;
  MonitorEvent(MODULE_QUICK, DEFAULT_BIZ_NAME, "NewRuntime", module_name);
#else
  MonitorEvent(MODULE_QUICK, DEFAULT_BIZ_NAME, "NewRuntime", MODULE_QUICK);
#endif

  rt = static_cast<LEPUSRuntime *>(
      mf->lepus_malloc(&ms, sizeof(LEPUSRuntime), 0));

  if (!rt) return NULL;
  memset(rt, 0, sizeof(*rt));

  rt->qjsvaluevalue_allocator = new QJSValueValueSpace(rt);

#ifdef ENABLE_PRIMJS_SNAPSHOT
  rt->use_primjs = primjs_is_active;
#endif
  rt->mf = *mf;
#if defined(__aarch64__) && (defined(ANDROID) || defined(__ANDROID__)) && \
    !defined(CONFIG_BIGNUM) && !DISABLE_NANBOX
  HEAP_TAG_OUTER = (int64_t)rt & LEPUS_PTR_TAG;
  HEAP_TAG_INNER = HEAP_TAG_OUTER;
  LOGI("RC: HEAP_TAG_OUTER: %p, HEAP_TAG_INNER: %p", (void *)HEAP_TAG_OUTER,
       (void *)HEAP_TAG_INNER);
#endif
  if (!rt->mf.lepus_malloc_usable_size) {
    /* use dummy function if none provided */
    rt->mf.lepus_malloc_usable_size = js_malloc_usable_size_unknown;
  }
  rt->malloc_state = ms;
  rt->malloc_gc_threshold = 256 * 1024;

#ifdef CONFIG_BIGNUM
  bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);
#endif

  init_list_head(&rt->context_list);
  init_list_head(&rt->obj_list);
  // <Primjs begin>
  init_list_head(&rt->gc_bytecode_list);
  init_list_head(&rt->gc_obj_list);
  // <Primjs end>
#ifdef DUMP_LEAKS
  init_list_head(&rt->string_list);
#endif
  init_list_head(&rt->job_list);
  init_list_head(&rt->unhandled_rejections);
  init_list_head(&rt->async_func_sf);
  rt->ptr_handles = new PtrHandles(rt);

  if (JS_InitAtoms(rt)) goto fail;

  /* create the object, array and function classes */
  if (init_class_range(rt, js_std_class_def, JS_CLASS_OBJECT,
                       countof(js_std_class_def)) < 0)
    goto fail;
  rt->class_array[JS_CLASS_ARGUMENTS].exotic = &js_arguments_exotic_methods;
  rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;
  rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;

  rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;
  rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;
  rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;
  rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call =
      js_generator_function_call;
  // <Primjs begin>
#ifdef ENABLE_LEPUSNG
  rt->js_type_.array_typeid_ = -1;
  rt->js_type_.table_typeid_ = -1;
#endif
  // <Primjs end>
  if (init_shape_hash(rt)) goto fail;

#ifdef BUILD_ASYNC_STACK
  rt->current_micro_task = NULL;
#endif
  rt->stack_top = js_get_stack_pointer();
  rt->stack_size = LEPUS_DEFAULT_STACK_SIZE;
  rt->current_exception = LEPUS_NULL;

  // Primjs begin
  js_init_settings_options(rt);
  // Primjs end
  return rt;
fail:
  LEPUS_FreeRuntime(rt);
  return NULL;
}

void JS_ResetRuntimeForEffect(LEPUSRuntime *rt, const LEPUSMallocFunctions *mf,
                              void *opaque) {
  JSMallocState ms;

  memset(&ms, 0, sizeof(ms));
  ms.opaque = opaque;
  ms.malloc_limit = -1;
#ifdef ENABLE_PRIMJS_SNAPSHOT
  bool primjs_is_active = false;
#endif

  if (!rt) return;
  rt->gc_enable = false;

#ifdef ENABLE_PRIMJS_SNAPSHOT
  rt->use_primjs = primjs_is_active;
#endif
  rt->mf = *mf;
#if defined(__aarch64__) && (defined(ANDROID) || defined(__ANDROID__)) && \
    !defined(CONFIG_BIGNUM) && !DISABLE_NANBOX
  HEAP_TAG_OUTER = (int64_t)rt & LEPUS_PTR_TAG;
  HEAP_TAG_INNER = HEAP_TAG_OUTER;
  LOGI("EFFECT RC: HEAP_TAG_OUTER: %p, HEAP_TAG_INNER: %p",
       (void *)HEAP_TAG_OUTER, (void *)HEAP_TAG_INNER);
#endif
  if (!rt->mf.lepus_malloc_usable_size) {
    /* use dummy function if none provided */
    rt->mf.lepus_malloc_usable_size = js_malloc_usable_size_unknown;
  }
  rt->malloc_state = ms;

#ifdef CONFIG_BIGNUM
  bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);
#endif

  init_list_head(&rt->obj_list);
  // <Primjs begin>
  init_list_head(&rt->gc_bytecode_list);
  init_list_head(&rt->gc_obj_list);
  // <Primjs end>
  init_list_head(&rt->async_func_sf);

  if (JS_InitAtoms(rt)) goto fail;

  /* create the object, array and function classes */
  if (init_class_range(rt, js_std_class_def, JS_CLASS_OBJECT,
                       countof(js_std_class_def)) < 0)
    goto fail;
  rt->class_array[JS_CLASS_ARGUMENTS].exotic = &js_arguments_exotic_methods;
  rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;
  rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;

  rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;
  rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;
  rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;
  rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call =
      js_generator_function_call;

  if (init_shape_hash(rt)) goto fail;
  return;
fail:
  LEPUS_FreeRuntime(rt);
  return;
}

/* default memory allocation functions with memory limitation */
QJS_STATIC inline size_t js_def_malloc_usable_size(void *ptr) {
#if defined(__APPLE__)
  return malloc_size(ptr);
#elif defined(_WIN32)
  return _msize(ptr);
#elif defined(EMSCRIPTEN)
  return 0;
#elif defined(__linux__)
  return malloc_usable_size(ptr);
#else
  /* change this to `return 0;` if
   * compilation fails */
  return malloc_usable_size(ptr);
#endif
}

QJS_STATIC void *js_def_malloc(JSMallocState *s, size_t size,
                               int alloc_tag = 0) {
  void *ptr;

  /* Do not allocate zero bytes: behavior is platform dependent */
  assert(size != 0);

  if (unlikely(s->malloc_size + size > s->malloc_limit)) return NULL;

  ptr = malloc(size);
  if (!ptr) return NULL;

  s->malloc_count++;
  s->malloc_size += js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  return ptr;
}

QJS_STATIC void js_def_free(JSMallocState *s, void *ptr) {
  if (!ptr) return;

  s->malloc_count--;
  s->malloc_size -= js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  free(ptr);
}

QJS_STATIC void *js_def_realloc(JSMallocState *s, void *ptr, size_t size,
                                int alloc_tag = 0) {
  size_t old_size;

  if (!ptr) {
    if (size == 0) return NULL;
    return js_def_malloc(s, size);
  }
  old_size = js_def_malloc_usable_size(ptr);
  if (size == 0) {
    s->malloc_count--;
    s->malloc_size -= old_size + MALLOC_OVERHEAD;
    free(ptr);
    return NULL;
  }
  if (s->malloc_size + size - old_size > s->malloc_limit) return NULL;

  ptr = realloc(ptr, size);
  if (!ptr) return NULL;

  s->malloc_size += js_def_malloc_usable_size(ptr) - old_size;
  return ptr;
}

static const LEPUSMallocFunctions def_malloc_funcs = {
    js_def_malloc,
    js_def_free,
    js_def_realloc,
#if defined(__APPLE__)
    malloc_size,
#elif defined(_WIN32)
    (size_t(*)(const void *))_msize,
#elif defined(EMSCRIPTEN)
    NULL,
#elif defined(__linux__)
    (size_t(*)(const void *))malloc_usable_size,
#else
    /* change this to `NULL,` if compilation
       fails */
    malloc_usable_size,
#endif
};

LEPUSRuntime *LEPUS_NewRuntime(void) {
  settingsFlag = GetSettingsFlag();
#ifdef ENABLE_COMPATIBLE_MM
  if (gc_enabled() == TRUE) {
    return JS_NewRuntime_GC();
  }
#endif
  return LEPUS_NewRuntime2(&def_malloc_funcs, NULL, 0);
}

LEPUSRuntime *LEPUS_NewRuntimeWithMode(uint32_t mode) {
  settingsFlag = GetSettingsFlag();
#ifdef ENABLE_COMPATIBLE_MM
  if (gc_enabled() == TRUE) {
    return JS_NewRuntime_GC();
  }
#endif
  return LEPUS_NewRuntime2(&def_malloc_funcs, NULL, mode);
}

#ifdef ENABLE_COMPATIBLE_MM
#define CallGCFunc(GCFunc, rt_ctx, args...) \
  if (rt_ctx->gc_enable) {                  \
    return GCFunc(rt_ctx, ##args);          \
  }
#else
#define CallGCFunc(GCFunc, rt_ctx, args...)
#endif

#ifdef ENABLE_COMPATIBLE_MM
#define CallGCParserFunc(GCParserFunc, s, args...) \
  if (s->ctx->gc_enable) {                         \
    return GCParserFunc(s, ##args);                \
  }
#else
#define CallGCParserFunc(GCParserFunc, s, args...)
#endif

void LEPUS_SetMemoryLimit(LEPUSRuntime *rt, size_t limit) {
  CallGCFunc(JS_SetMemoryLimit_GC, rt, limit);
  rt->malloc_state.malloc_limit = limit;
}

/* use -1 to disable automatic GC */
void LEPUS_SetGCThreshold(LEPUSRuntime *rt, size_t gc_threshold) {
  rt->malloc_gc_threshold = gc_threshold;
}

void LEPUS_SetInterruptHandler(LEPUSRuntime *rt, LEPUSInterruptHandler *cb,
                               void *opaque) {
  rt->interrupt_handler = cb;
  rt->interrupt_opaque = opaque;
}

void LEPUS_SetCanBlock(LEPUSRuntime *rt, BOOL can_block) {
  rt->can_block = can_block;
}

/* return 0 if OK, < 0 if exception */
int LEPUS_EnqueueJob(LEPUSContext *ctx, LEPUSJobFunc *job_func, int argc,
                     LEPUSValueConst *argv) {
  CallGCFunc(JS_EnqueueJob_GC, ctx, job_func, argc, argv);
  LEPUSRuntime *rt = ctx->rt;
  JSJobEntry *e;
  int i;

  e = static_cast<JSJobEntry *>(
      lepus_malloc(ctx, sizeof(*e) + argc * sizeof(LEPUSValue)));
  if (!e) return -1;
  e->ctx = ctx;
  e->job_func = job_func;
  e->argc = argc;
  for (i = 0; i < argc; i++) {
    e->argv[i] = LEPUS_DupValue(ctx, argv[i]);
  }
  list_add_tail(&e->link, &rt->job_list);
  return 0;
}

BOOL LEPUS_IsJobPending(LEPUSRuntime *rt) { return !list_empty(&rt->job_list); }

/* return < 0 if exception, 0 if no job pending, 1 if a job was
   executed successfully. the context of the job is stored in '*pctx' */
int LEPUS_ExecutePendingJob(LEPUSRuntime *rt, LEPUSContext **pctx) {
  CallGCFunc(JS_ExecutePendingJob_GC, rt, pctx);
  LEPUSContext *ctx;
  JSJobEntry *e;
  LEPUSValue res;
  int i, ret;

  if (list_empty(&rt->job_list)) {
    *pctx = NULL;
    return 0;
  }

  /* get the first pending job and execute it */
  e = list_entry(rt->job_list.next, JSJobEntry, link);
  list_del(&e->link);
  ctx = e->ctx;
  res = e->job_func(e->ctx, e->argc, (LEPUSValueConst *)e->argv);
  for (i = 0; i < e->argc; i++) LEPUS_FreeValue(ctx, e->argv[i]);
  if (LEPUS_IsException(res))
    ret = -1;
  else
    ret = 1;
  LEPUS_FreeValue(ctx, res);
  lepus_free(ctx, e);
  *pctx = ctx;
  return ret;
}

QJS_STATIC inline uint32_t atom_get_free(const JSAtomStruct *p) {
  return (uintptr_t)p >> 1;
}

QJS_STATIC inline JSAtomStruct *atom_set_free(uint32_t v) {
  return (JSAtomStruct *)(((uintptr_t)v << 1) | 1);
}

/* Note: the string contents are uninitialized */
QJS_STATIC JSString *js_alloc_string_rt(LEPUSRuntime *rt, int max_len,
                                        int is_wide_char, BOOL is_const = 0) {
  JSString *str;
  int alloc_tag = is_const ? ALLOC_TAG_JSConstString : ALLOC_TAG_JSString;
  str = static_cast<JSString *>(lepus_malloc_rt(
      rt, sizeof(JSString) + (max_len << is_wide_char) + 1 - is_wide_char,
      alloc_tag));
  if (unlikely(!str)) return NULL;
  str->header.ref_count = 1;
  str->is_wide_char = is_wide_char;
  str->len = max_len;
  str->atom_type = 0;
  str->hash = 0;      /* optional but costless */
  str->hash_next = 0; /* optional */
#ifdef DUMP_LEAKS
  list_add_tail(&str->link, &rt->string_list);
#endif

#ifdef ENABLE_LEPUSNG
  // <Primjs begin>
  str->cache_ = NULL;
  // <Primjs end>
#endif
  return str;
}

JSString *js_alloc_string(LEPUSContext *ctx, int max_len, int is_wide_char) {
  JSString *p;
  p = js_alloc_string_rt(ctx->rt, max_len, is_wide_char);
  if (unlikely(!p)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return p;
}

/* same as LEPUS_FreeValueRT() but faster */
QJS_STATIC inline void js_free_string(LEPUSRuntime *rt, JSString *str) {
  if (--str->header.ref_count <= 0) {
    if (str->atom_type) {
      JS_FreeAtomStruct(rt, str);
    } else {
#ifdef DUMP_LEAKS
      list_del(&str->link);
#endif

#ifdef ENABLE_LEPUSNG
      // <Primjs begin>
      JS_FreeStringCache(rt, str);
      // <Primjs end>
#endif
      lepus_free_rt(rt, str);
    }
  }
}

void LEPUS_SetRuntimeInfo(LEPUSRuntime *rt, const char *s) {
  if (rt) {
    rt->rt_info = s;
    rt->is_lepusng =
        s ? (!strcmp(s, "Lynx_LepusNG") || !strcmp(s, "Lynx_LepusNG_RC"))
          : false;
    if (s && rt->gc_enable) {
#if defined(ANDROID) || defined(__ANDROID__) || defined(OS_IOS)
      if (rt->is_lepusng) {
        int lepusng_heap_mode = get_lepusng_heap_mode();
        size_t &cur_footprint_limit =
            rt->malloc_state.allocate_state.footprint_limit;
        switch (lepusng_heap_mode) {
          case INITIAL_HEAP_12:
            cur_footprint_limit =
                (cur_footprint_limit < 12 * MB) ? 12 * MB : cur_footprint_limit;
            break;
          case INITIAL_HEAP_20:
            cur_footprint_limit =
                (cur_footprint_limit < 20 * MB) ? 20 * MB : cur_footprint_limit;
            break;
          case INITIAL_HEAP_24:
            cur_footprint_limit =
                (cur_footprint_limit < 24 * MB) ? 24 * MB : cur_footprint_limit;
            break;
          default:
            cur_footprint_limit =
                (cur_footprint_limit < 32 * MB) ? 32 * MB : cur_footprint_limit;
            break;
        }
      }
#endif
      if ((!strcmp(s, "effect") && !effect_enabled()) ||
          (rt->is_lepusng && lepusng_gc_disabled()) ||
          (!strcmp(s, "Lynx_LepusNG_RC") || !strcmp(s, "Lynx_JS_RC"))) {
        JS_FreeRuntimeForEffect(rt);
        JS_ResetRuntimeForEffect(rt, &def_malloc_funcs, NULL);
      }
    }
#ifdef ENABLE_PRIMJS_SNAPSHOT
    const char *module_name = rt->use_primjs ? MODULE_PRIMJS : MODULE_QUICK;
    MonitorEvent(MODULE_QUICK, s, "SetRuntimeInfo", module_name);
#else
    MonitorEvent(MODULE_QUICK, s, "SetRuntimeInfo", MODULE_QUICK);
#endif
  }
}

void LEPUS_FreeRuntime(LEPUSRuntime *rt) {
  CallGCFunc(JS_FreeRuntime_GC, rt);
  struct list_head *el, *el1;
  int i;

  LEPUS_FreeValueRT(rt, rt->current_exception);

  list_for_each_safe(el, el1, &rt->context_list) {
    LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
    LEPUS_FreeContext(ctx);
  }

  list_for_each_safe(el, el1, &rt->job_list) {
    JSJobEntry *e = list_entry(el, JSJobEntry, link);
    for (i = 0; i < e->argc; i++) LEPUS_FreeValueRT(rt, e->argv[i]);
    lepus_free_rt(rt, e);
  }
  init_list_head(&rt->job_list);

  list_for_each_safe(el, el1, &rt->unhandled_rejections) {
    JSUnhandledRejectionEntry *e =
        list_entry(el, JSUnhandledRejectionEntry, link);
    LEPUS_FreeValueRT(rt, e->error);
    lepus_free_rt(rt, e);
  }
  init_list_head(&rt->unhandled_rejections);

  if (rt->qjsvaluevalue_allocator) {
    delete rt->qjsvaluevalue_allocator;
    rt->qjsvaluevalue_allocator = nullptr;
  }

  LEPUS_RunGC(rt);

#ifdef ENABLE_LEPUSNG
  // In LepusNG, the gc is performed twice to eliminate mem leak
  if (rt->rt_info && rt->is_lepusng) {
    LEPUS_RunGC(rt);
  }
#endif

#ifdef DUMP_LEAKS
  int exists_leak = 0;
  /* leaking objects */
  {
    BOOL header_done;
    LEPUSObject *p;
    int count;
    printf("DUMP_LEAKS: dump leaks...\n");

    /* remove the internal refcounts to display only the object
       referenced externally */
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      p->gc_header.mark = 0;
    }
    gc_decref(rt);

    count = 0;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count != 0) {
        count++;
      }
    }

    header_done = FALSE;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count != 0) {
        if (!header_done) {
          printf("DUMP_LEAKS: Object leaks: %d\n", count);
          JS_DumpObjectHeader(rt);
          header_done = TRUE;
        }
        JS_DumpObject(rt, p);
        exists_leak++;
      }
    }

    count = 0;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count == 0) {
        count++;
        exists_leak++;
      }
    }
    if (count != 0) {
      printf("DUMP_LEAKS: Secondary object leaks: %d\n", count);
    }
  }

  // assert(list_empty(&rt->obj_list));
#else
  if (!list_empty(&rt->obj_list)) {
    printf("LEPUS_FreeRuntime obj_list leak...\n");
  }
#endif

  /* free the classes */
  for (i = 0; i < rt->class_count; i++) {
    LEPUSClass *cl = &rt->class_array[i];
    if (cl->class_id != 0) {
      LEPUS_FreeAtomRT(rt, cl->class_name);
    }
  }
  lepus_free_rt(rt, rt->class_array);

#ifdef CONFIG_BIGNUM
  bf_context_end(&rt->bf_ctx);
#endif

#ifdef DUMP_LEAKS
  /* only the atoms defined in JS_InitAtoms() should be left */
  {
    BOOL header_done = FALSE;
    char dump_buf[4096], fmt_buf[1024];
#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);

    for (i = 0; i < rt->atom_size; i++) {
      JSAtomStruct *p = rt->atom_array[i];
      if (!atom_is_free(p) /* && p->str*/) {
        if (i >= JS_ATOM_END || p->header.ref_count != 1) {
          if (!header_done) {
            header_done = TRUE;
            if (rt->rt_info) {
              printf("DUMP_LEAKS: %s:1: atom leakage:", rt->rt_info);
            } else {
              printf("DUMP_LEAKS: Atom leaks:\n");
              printf("DUMP_LEAKS:     %6s %6s %s\n", "ID", "REFCNT", "NAME");
            }
          }
          dump_buf[0] = '\0';
          exists_leak++;
          if (rt->rt_info) {
            write(" ");
          } else {
            write("    %6u %6u ", i, p->header.ref_count);
          }
          switch (p->atom_type) {
            case JS_ATOM_TYPE_STRING:
              JS_DumpStringNoPrint(rt, p, dump_buf);
              break;
            case JS_ATOM_TYPE_GLOBAL_SYMBOL:
              write("Symbol.for(");
              JS_DumpStringNoPrint(rt, p, dump_buf);
              write(")");
              break;
            case JS_ATOM_TYPE_SYMBOL:
              if (p->hash == JS_ATOM_HASH_SYMBOL) {
                write("Symbol(");
                JS_DumpStringNoPrint(rt, p, dump_buf);
                write(")");
              } else {
                write("Private(");
                JS_DumpStringNoPrint(rt, p, dump_buf);
                write(")");
              }
              break;
          }
          if (rt->rt_info) {
            write(":%u", p->header.ref_count);
          } else {
            write("\n");
          }
          printf("DUMP_LEAKS: %s", dump_buf);
        }
      }
    }
#undef write
#ifndef DEBUG_MEMORY
    if (rt->rt_info && header_done) printf("\n");
#endif
  }
#endif

  /* free the atoms */
  for (i = 0; i < rt->atom_size; i++) {
    JSAtomStruct *p = rt->atom_array[i];
    if (!atom_is_free(p)) {
#ifdef DUMP_LEAKS
      list_del(&p->link);
#endif
// Primjs begin
#ifdef ENABLE_LEPUSNG
      JS_FreeStringCache(rt, p);
#endif
      // PrimJS end
      lepus_free_rt(rt, p);
    }
  }
  lepus_free_rt(rt, rt->atom_array);
  lepus_free_rt(rt, rt->atom_hash);
  lepus_free_rt(rt, rt->shape_hash);
#ifdef DUMP_LEAKS
  if (!list_empty(&rt->string_list)) {
    char dump_buf[4096], fmt_buf[1024];
#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
    if (rt->rt_info) {
      printf("DUMP_LEAKS: %s:1: string leakage:", rt->rt_info);
    } else {
      printf("DUMP_LEAKS: String leaks:\n");
      printf("DUMP_LEAKS:     %6s %s\n", "REFCNT", "VALUE");
    }
    list_for_each_safe(el, el1, &rt->string_list) {
      exists_leak++;
      dump_buf[0] = '\0';
      JSString *str = list_entry(el, JSString, link);
      if (rt->rt_info) {
        write(" ");
      } else {
        write("    %6u ", str->header.ref_count);
      }
      JS_DumpStringNoPrint(rt, str, dump_buf);
      if (rt->rt_info) {
        write(":%u", str->header.ref_count);
      } else {
        write("\n");
      }
      list_del(&str->link);
      lepus_free_rt(rt, str);
      printf("DUMP_LEAKS: %s", dump_buf);
    }
    if (rt->rt_info) write("\n");
#undef write
  }
  {
    JSMallocState *s = &rt->malloc_state;
    if (s->malloc_count > 1) {
      if (rt->rt_info) printf("DUMP_LEAKS: %s:1: ", rt->rt_info);
      printf("DUMP_LEAKS: Memory leak: %" PRIu64 " bytes lost in %" PRIu64
             " block%s\n",
             (uint64_t)(s->malloc_size - sizeof(LEPUSRuntime)),
             (uint64_t)(s->malloc_count - 1), &"s"[s->malloc_count == 2]);
    }
  }
#endif
  if (rt->ptr_handles) {
    delete rt->ptr_handles;
    rt->ptr_handles = nullptr;
  }

  {
    JSMallocState ms = rt->malloc_state;
    rt->mf.lepus_free(&ms, rt);
  }

#ifdef DEBUG_MEMORY
  if (exists_leak > 255) {
#ifdef __ANDROID__
    __android_log_print(ANDROID_LOG_FATAL, "LYNX",
                        "DUMP_LEAKS: Memory_leak_detected!");
#else
    printf("DUMP_LEAKS: Memory_leak_detected!\n");
#endif
    (*(int *)(0xfffffff))++;
    abort();
  }
#endif
}
#define malloc(s) malloc_is_forbidden(s)
#define free(p) free_is_forbidden(p)
#define realloc(p, s) realloc_is_forbidden(p, s)

#if defined(EMSCRIPTEN)
QJS_STATIC inline uintptr_t get_thread_stack_limit() {
#if defined(_WIN32)
  MEMORY_BASIC_INFORMATION mem;
  VirtualQuery(&mem, &mem, sizeof mem);
  return (uintptr_t)(mem.AllocationBase) + (52 * 1024);
#else
  uintptr_t stack_limit = 0;
  void *stack;
  size_t stack_size;
  pthread_attr_t attr;
  pthread_t tid = pthread_self();
#if defined(APPLE) || defined(__APPLE__)
  stack = pthread_get_stackaddr_np(tid);
  stack_size = pthread_get_stacksize_np(tid);
  stack_limit = reinterpret_cast<uintptr_t>(stack) - stack_size +
                (52 * 1024);  // reserve 52k
#else
  pthread_getattr_np(tid, &attr);
  pthread_attr_getstack(&attr, &stack, &stack_size);
  stack_limit =
      reinterpret_cast<uintptr_t>(stack) + (52 * 1024);  // reserve 52k
#endif
  pthread_attr_destroy(&attr);
  return stack_limit;
#endif
}

QJS_STATIC __attribute__((unused)) inline void js_print_stack(
    LEPUSContext *ctx) {
  DynBuf dbuf;
  js_dbuf_init(ctx, &dbuf);
  HandleScope func_scope(ctx, &dbuf.buf, HANDLE_TYPE_HEAP_OBJ);
  get_backtrace(ctx, &dbuf, FALSE, LEPUS_NULL, NULL, 0);
  char *stack = reinterpret_cast<char *>(dbuf.buf);
  if (!stack) {
    return;
  }
#if defined(ANDROID) || defined(__ANDROID__)
  size_t len = strlen(stack);
  size_t chunkCount = len / 1000;
  size_t index = 0;
  char ch;
  for (size_t i = 0; i < chunkCount; i++) {
    index = (i + 1) * 1000 - 1;
    ch = stack[index];
    stack[index] = '\0';
    if (i == 0) {
      __android_log_print(ANDROID_LOG_ERROR, "primjs", "%s", stack);
      stack[index] = ch;
    } else {
      __android_log_print(ANDROID_LOG_ERROR, "primjs", "%s",
                          stack + i * 1000 - 1);
      stack[index] = ch;
    }
  }
  if (index == 0) {
    __android_log_print(ANDROID_LOG_ERROR, "primjs", "%s",
                        stack + chunkCount * 1000);
  } else {
    __android_log_print(ANDROID_LOG_ERROR, "primjs", "%s",
                        stack + chunkCount * 1000 - 1);
  }
#elif defined(APPLE) || defined(__APPLE__) || defined(_WIN32)
  fprintf(stderr, "==== stack overflow ====\n%s\n", stack);
#endif
  if (ctx->rt->primjs_callbacks_.print_by_alog) {
    ctx->rt->primjs_callbacks_.print_by_alog(stack);
  }
  if (!ctx->gc_enable) dbuf_free(&dbuf);
}

QJS_STATIC inline uint8_t *js_get_stack_pointer(void) {
  return static_cast<uint8_t *>(__builtin_frame_address(0));
}

BOOL js_check_stack_overflow(LEPUSContext *ctx, size_t alloca_size) {
  static __thread uintptr_t stack_limit = 0;
  BOOL stack_overflow = FALSE;
  if (stack_limit == 0) {
    stack_limit =
        reinterpret_cast<uintptr_t>(js_get_stack_pointer()) - 400 * 1024;
  } else {
    stack_overflow =
        reinterpret_cast<uintptr_t>(js_get_stack_pointer()) - alloca_size <
        stack_limit;
    if (stack_overflow) {
      stack_limit = reinterpret_cast<uintptr_t>(get_thread_stack_limit());
      stack_overflow =
          reinterpret_cast<uintptr_t>(js_get_stack_pointer()) - alloca_size <
          stack_limit;
    }
  }
  return stack_overflow;
  // only print stack when stack overflow
  // js_print_stack(ctx);
  // return FALSE;
}
#else
/* Note: OS and CPU dependent */
static inline uint8_t *js_get_stack_pointer(void) {
  return __builtin_frame_address(0);
}

static inline BOOL js_check_stack_overflow(LEPUSContext *ctx,
                                           size_t alloca_size) {
  size_t size;
  size = ctx->rt->stack_top - js_get_stack_pointer();
  return unlikely((size + alloca_size) > ctx->rt->stack_size);
}
#endif

LEPUSValue LEPUS_ThrowOutOfMemory(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->in_out_of_memory) {
    rt->in_out_of_memory = TRUE;
    LEPUS_ThrowInternalError(ctx, "out of memory");
    rt->in_out_of_memory = FALSE;
  }
  return LEPUS_EXCEPTION;
}

// <Primjs begin>
void LEPUS_SetVirtualStackSize(LEPUSContext *ctx, uint32_t stack_size) {
  CallGCFunc(JS_SetVirtualStackSize_GC, ctx, stack_size);
#ifdef OS_IOS
  if (ctx->stack_pos != 0) {
    return;
  }
  ctx->rt->stack_size = stack_size;
  ctx->stack = static_cast<uint8_t *>(
      lepus_realloc(ctx, ctx->stack, ctx->rt->stack_size));

  if (ctx->stack == NULL) {
    ctx->rt->stack_size = 0;
  }
#endif
}
// <Primjs end>
// <primjs begin>
void PrimInit(LEPUSContext *ctx);
// <primjs end>
LEPUSContext *LEPUS_NewContextRaw(LEPUSRuntime *rt) {
  CallGCFunc(JS_NewContextRaw_GC, rt);
#if defined(ENABLE_PRIMJS_TRACE) && PRINT_LOG_TO_FILE && \
    (defined(ANDROID) || defined(__ANDROID__))
  pthread_mutex_lock(&prim_init_mutex);
  if (!log_f) {
    chdir("/data/local/tmp/");
    log_f = fopen("log.txt", "w");
    if (!log_f) {
      LOGE("open fail errno = %d reason = %s \n", errno, strerror(errno));
      abort();
    }
    LOGI("\nlogging to /data/local/tmp/log.txt! ---------\n\n");
  }
  pthread_mutex_unlock(&prim_init_mutex);
#endif
  LEPUSContext *ctx;
  int i;

  ctx = static_cast<LEPUSContext *>(lepus_mallocz_rt(rt, sizeof(LEPUSContext)));
  if (!ctx) return NULL;
  ctx->class_proto = static_cast<LEPUSValue *>(
      lepus_malloc_rt(rt, sizeof(ctx->class_proto[0]) * rt->class_count));
  if (!ctx->class_proto) {
    lepus_free_rt(rt, ctx);
    return NULL;
  }
  ctx->rt = rt;
#ifndef _WIN32
  ctx->allocate_state = NULL;
#endif

  list_add_tail(&ctx->link, &rt->context_list);
#ifdef CONFIG_BIGNUM
  ctx->bf_ctx = &rt->bf_ctx;
  ctx->fp_env.prec = 53;
  ctx->fp_env.flags = bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
#endif
  for (i = 0; i < rt->class_count; i++) ctx->class_proto[i] = LEPUS_NULL;
  ctx->regexp_ctor = LEPUS_NULL;
  ctx->promise_ctor = LEPUS_NULL;
  ctx->no_lepus_strict_mode = FALSE;
  init_list_head(&ctx->loaded_modules);
  JS_AddIntrinsicBasicObjects(ctx);
  // <Primjs begin>
#ifdef OS_IOS
  size_t allocate_stack_size = minify_virtual_stack_size_enabled()
                                   ? MINIFY_VIRTUAL_STACK_SIZE
                                   : DEFAULT_VIRTUAL_STACK_SIZE;
  ctx->stack = static_cast<uint8_t *>(lepus_malloc(ctx, allocate_stack_size));
  if (ctx->stack == NULL) {
    ctx->stack =
        static_cast<uint8_t *>(lepus_malloc(ctx, FALLBACK_VIRTUAL_STACK_SIZE));
    if (ctx->stack) {
      ctx->rt->stack_size = FALLBACK_VIRTUAL_STACK_SIZE;
    } else {
      ctx->rt->stack_size = 0;
    }
  } else {
    ctx->rt->stack_size = allocate_stack_size;
  }
#endif
  // ctx->stack_pos = 0;
  ctx->next_function_id = 1;   // for lepusNG sourcemap, need to start from 1
  ctx->debuginfo_outside = 2;  // 2: uninitialize, 1: true, 0: false
  ctx->lynx_target_sdk_version = nullptr;
  ctx->is_lepusng = rt->is_lepusng;
#ifdef QJS_UNITTEST
  ctx->debugger_need_polling = true;
#else
  if (rt->rt_info && rt->is_lepusng) {
    ctx->debugger_need_polling = true;
  }
#endif
  ctx->fg_ctx = static_cast<FinalizationRegistryContext *>(
      lepus_malloc(ctx, sizeof(FinalizationRegistryContext)));
  ctx->fg_ctx->ref_count = 1;
  ctx->fg_ctx->ctx = ctx;
  // <Primjs end>

  // <primjs begin>
#ifdef ENABLE_PRIMJS_SNAPSHOT
  if (ctx->rt->use_primjs) {
    PRIM_LOG("Use snapshot!\n");
  } else {
    PRIM_LOG("Use raw Quickjs!\n");
  }
#else
  PRIM_LOG("Use raw Quickjs!\n");
#endif
#if defined(ENABLE_PRIMJS_SNAPSHOT)
  pthread_mutex_lock(&prim_init_mutex);
  PrimInit(ctx);
  pthread_mutex_unlock(&prim_init_mutex);
#endif
  // <primjs end>
  return ctx;
}

QJS_STATIC void JS_AddIntrinsicWeakRef(LEPUSContext *ctx);
QJS_STATIC void JS_AddIntrinsicFinalizationRegistry(LEPUSContext *ctx);

LEPUSContext *LEPUS_NewContext(LEPUSRuntime *rt) {
  CallGCFunc(JS_NewContext_GC, rt);
  LEPUSContext *ctx;

  ctx = LEPUS_NewContextRaw(rt);
  if (!ctx) return NULL;

  ctx->ptr_handles = rt->ptr_handles;
  ctx->napi_scope = NULL;

  LEPUS_AddIntrinsicBaseObjects(ctx);
  LEPUS_AddIntrinsicDate(ctx);
  LEPUS_AddIntrinsicEval(ctx);
  LEPUS_AddIntrinsicStringNormalize(ctx);
  LEPUS_AddIntrinsicRegExp(ctx);
  LEPUS_AddIntrinsicJSON(ctx);
  LEPUS_AddIntrinsicProxy(ctx);
  LEPUS_AddIntrinsicMapSet(ctx);
  LEPUS_AddIntrinsicTypedArrays(ctx);
  LEPUS_AddIntrinsicPromise(ctx);
  JS_AddIntrinsicWeakRef(ctx);
  JS_AddIntrinsicFinalizationRegistry(ctx);

  return ctx;
}

void *LEPUS_GetContextOpaque(LEPUSContext *ctx) { return ctx->user_opaque; }

void LEPUS_SetContextOpaque(LEPUSContext *ctx, void *opaque) {
  ctx->user_opaque = opaque;
}

/* set the new value and free the old value after (freeing the value
   can reallocate the object data) */
QJS_STATIC inline void set_value(LEPUSContext *ctx, LEPUSValue *pval,
                                 LEPUSValue new_val) {
  LEPUSValue old_val;
  old_val = *pval;
  *pval = new_val;
  LEPUS_FreeValue(ctx, old_val);
}

void LEPUS_SetClassProto(LEPUSContext *ctx, LEPUSClassID class_id,
                         LEPUSValue obj) {
  CallGCFunc(JS_SetClassProto_GC, ctx, class_id, obj);
  LEPUSRuntime *rt = ctx->rt;
  assert(class_id < rt->class_count);
  set_value(ctx, &ctx->class_proto[class_id], obj);
}

LEPUSValue LEPUS_GetClassProto(LEPUSContext *ctx, LEPUSClassID class_id) {
  CallGCFunc(JS_GetClassProto_GC, ctx, class_id);
  LEPUSRuntime *rt = ctx->rt;
  assert(class_id < rt->class_count);
  return LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
}

typedef enum JSFreeModuleEnum {
  JS_FREE_MODULE_ALL,
  JS_FREE_MODULE_NOT_RESOLVED,
  JS_FREE_MODULE_NOT_EVALUATED,
} JSFreeModuleEnum;

/* XXX: would be more efficient with separate module lists */
QJS_STATIC void js_free_modules(LEPUSContext *ctx, JSFreeModuleEnum flag) {
  struct list_head *el, *el1;
  list_for_each_safe(el, el1, &ctx->loaded_modules) {
    LEPUSModuleDef *m = list_entry(el, LEPUSModuleDef, link);
    if (flag == JS_FREE_MODULE_ALL ||
        (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved) ||
        (flag == JS_FREE_MODULE_NOT_EVALUATED && !m->evaluated)) {
      js_free_module_def(ctx, m);
    }
  }
}

QJS_STATIC void free_finalization_registry_context(
    LEPUSRuntime *rt, struct FinalizationRegistryContext *fg_ctx) {
  if (--fg_ctx->ref_count == 0) {
    lepus_free_rt(rt, fg_ctx);
  }
  return;
}

void LEPUS_FreeContext(LEPUSContext *ctx) {
  CallGCFunc(JS_FreeContext_GC, ctx);
  LEPUSRuntime *rt = ctx->rt;
  int i;

#ifdef DUMP_ATOMS
  JS_DumpAtoms(ctx->rt);
#endif
#ifdef DUMP_SHAPES
  JS_DumpShapes(ctx->rt);
#endif

  struct list_head *el, *el1;
  js_free_modules(ctx, JS_FREE_MODULE_ALL);

  LEPUS_FreeValue(ctx, ctx->global_obj);
  LEPUS_FreeValue(ctx, ctx->global_var_obj);

  LEPUS_FreeValue(ctx, ctx->throw_type_error);
  LEPUS_FreeValue(ctx, ctx->eval_obj);

  LEPUS_FreeValue(ctx, ctx->array_proto_values);
  for (i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
    LEPUS_FreeValue(ctx, ctx->native_error_proto[i]);
  }
  for (i = 0; i < rt->class_count; i++) {
    LEPUS_FreeValue(ctx, ctx->class_proto[i]);
  }
  lepus_free_rt(rt, ctx->class_proto);
  LEPUS_FreeValue(ctx, ctx->iterator_proto);
  LEPUS_FreeValue(ctx, ctx->async_iterator_proto);
  LEPUS_FreeValue(ctx, ctx->promise_ctor);
  LEPUS_FreeValue(ctx, ctx->regexp_ctor);
  LEPUS_FreeValue(ctx, ctx->function_ctor);
  LEPUS_FreeValue(ctx, ctx->function_proto);
  // <Primjs begin>
#ifdef OS_IOS
  lepus_free(ctx, ctx->stack);
#endif
  // <Primjs end>

  js_free_shape_null(ctx->rt, ctx->array_shape);

  list_del(&ctx->link);

  lepus_free(ctx, ctx->lynx_target_sdk_version);

  ctx->fg_ctx->ctx = nullptr;
  free_finalization_registry_context(ctx->rt, ctx->fg_ctx);
  lepus_free_rt(ctx->rt, ctx);

#ifdef DUMP_MEM
  {
    LEPUSMemoryUsage stats;
    LEPUS_ComputeMemoryUsage(rt, &stats);
    LEPUS_DumpMemoryUsage(stdout, &stats, rt);
  }
#endif

#ifdef DUMP_OBJECTS
  LEPUS_RunGC(rt);
  {
    struct list_head *el;
    LEPUSObject *p;
    printf("JSObjects: {\n");
    JS_DumpObjectHeader(rt);
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      JS_DumpObject(rt, p);
    }
    printf("}\n");
  }
#endif
}

LEPUSRuntime *LEPUS_GetRuntime(LEPUSContext *ctx) { return ctx->rt; }

void LEPUS_SetMaxStackSize(LEPUSContext *ctx, size_t stack_size) {
  ctx->rt->stack_size = stack_size;
}

QJS_STATIC inline BOOL is_strict_mode(LEPUSContext *ctx) {
  LEPUSStackFrame *sf = ctx->rt->current_stack_frame;
  return (sf && (sf->js_mode & JS_MODE_STRICT));
}

#ifdef CONFIG_BIGNUM
static inline BOOL is_bignum_mode(LEPUSContext *ctx) {
  LEPUSStackFrame *sf = ctx->rt->current_stack_frame;
  return (sf && (sf->js_mode & JS_MODE_BIGINT));
}
#endif

LEPUSValue LEPUS_NewInt64(LEPUSContext *ctx, int64_t v) {
  CallGCFunc(JS_NewInt64_GC, ctx, v);
  if (v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
#ifdef CONFIG_BIGNUM
    if (is_bignum_mode(ctx)) {
      bf_t a_s, *a = &a_s;
      bf_init(ctx->bf_ctx, a);
      bf_set_si(a, v);
      return JS_NewBigInt(ctx, a);
    } else
#endif
    {
      return __JS_NewFloat64(ctx, (double)v);
    }
  }
}

QJS_STATIC force_inline LEPUSValue JS_NewUint32(LEPUSContext *ctx,
                                                uint32_t val) {
#ifdef CONFIG_BIGNUM
  return LEPUS_NewInt64(ctx, val);
#else
  LEPUSValue v;
  if (val <= 0x7fffffff) {
    v = LEPUS_MKVAL(LEPUS_TAG_INT, static_cast<int32_t>(val));
  } else {
    v = __JS_NewFloat64(ctx, val);
  }
  return v;
#endif
}

/* JSAtom support */

QJS_STATIC inline BOOL __JS_AtomIsConst(JSAtom v) {
#if defined(DUMP_LEAKS) && DUMP_LEAKS > 1
  return (int32_t)v <= 0;
#else
  return (int32_t)v < JS_ATOM_END;
#endif
}

QJS_STATIC inline int is_num(int c) { return c >= '0' && c <= '9'; }

/* return TRUE if the string is a number n with 0 <= n <= 2^32-1 */
QJS_STATIC inline BOOL is_num_string(uint32_t *pval, const JSString *p) {
  uint32_t n;
  uint64_t n64;
  int c, i, len;

  len = p->len;
  if (len == 0 || len > 10) return FALSE;
  if (p->is_wide_char)
    c = p->u.str16[0];
  else
    c = p->u.str8[0];
  if (is_num(c)) {
    if (c == '0') {
      if (len != 1) return FALSE;
      n = 0;
    } else {
      n = c - '0';
      for (i = 1; i < len; i++) {
        if (p->is_wide_char)
          c = p->u.str16[i];
        else
          c = p->u.str8[i];
        if (!is_num(c)) return FALSE;
        n64 = (uint64_t)n * 10 + (c - '0');
        if ((n64 >> 32) != 0) return FALSE;
        n = n64;
      }
    }
    *pval = n;
    return TRUE;
  } else {
    return FALSE;
  }
}

#ifdef ENABLE_LEPUSNG
static inline int32_t JS_GetIdxFromProp(JSAtom prop) {
  int idx = -1;
  if (__JS_AtomIsTaggedInt(prop)) {
    idx = __JS_AtomToUInt32(prop);
  }
  return idx;
}

// if prop is not found, the callback function returns LEPUS_UNINITIALIZED.
static inline LEPUSValue JSRefGetOwnProperty(LEPUSContext *ctx, LEPUSValue obj,
                                             JSAtom prop) {
  return ctx->rt->js_callbacks_.get_property(ctx, obj, prop,
                                             JS_GetIdxFromProp(prop));
}

static inline LEPUSValue JSRefGetProperty(LEPUSContext *ctx, LEPUSValue obj,
                                          JSAtom prop, LEPUSValueConst this_obj,
                                          BOOL throw_ref_error) {
  assert(LEPUS_IsLepusRef(obj));
  LEPUSValue ret = JSRefGetOwnProperty(ctx, obj, prop);
  if (!LEPUS_IsUninitialized(ret)) {
    return ret;
  }

  // find the property in prototype
  if (JS_LepusRefIsArray(ctx->rt, obj)) {
    return LEPUS_GetPropertyInternal(ctx, ctx->class_proto[JS_CLASS_ARRAY],
                                     prop, this_obj, throw_ref_error);
  } else if (JS_LepusRefIsTable(ctx->rt, obj)) {
    return LEPUS_GetPropertyInternal(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                     prop, this_obj, throw_ref_error);
  }
  return LEPUS_UNDEFINED;
}

static inline int32_t JSRefHasOwnProperty(LEPUSContext *ctx, LEPUSValue obj,
                                          JSAtom prop) {
  assert(LEPUS_IsLepusRef(obj));
  return ctx->rt->primjs_callbacks_.js_has_property(ctx, obj, prop,
                                                    JS_GetIdxFromProp(prop));
}

static inline int32_t JSRefHasProperty(LEPUSContext *ctx, LEPUSValue obj,
                                       JSAtom prop) {
  assert(LEPUS_IsLepusRef(obj));
  if (JSRefHasOwnProperty(ctx, obj, prop)) return 1;
  // if it's not found, find prop in the prototype
  if (JS_LepusRefIsArray(ctx->rt, obj)) {
    LEPUSValue array_proto = ctx->class_proto[JS_CLASS_ARRAY];
    return LEPUS_HasProperty(ctx, array_proto, prop);
  } else if (JS_LepusRefIsTable(ctx->rt, obj)) {
    LEPUSValue obj_proto = ctx->class_proto[JS_CLASS_OBJECT];
    return LEPUS_HasProperty(ctx, obj_proto, prop);
  }
  return 0;
}

static inline int32_t JSRefDeleteProperty(LEPUSContext *ctx, LEPUSValue obj,
                                          JSAtom prop) {
  assert(LEPUS_IsLepusRef(obj));
  return ctx->rt->primjs_callbacks_.js_delete_property(ctx, obj, prop,
                                                       JS_GetIdxFromProp(prop));
}
#endif

/* XXX: could use faster version ? */
QJS_STATIC inline uint32_t hash_string8(const uint8_t *str, size_t len,
                                        uint32_t h) {
  size_t i;

  for (i = 0; i < len; i++) h = h * 263 + str[i];
  return h;
}

QJS_STATIC inline uint32_t hash_string16(const uint16_t *str, size_t len,
                                         uint32_t h) {
  size_t i;

  for (i = 0; i < len; i++) h = h * 263 + str[i];
  return h;
}

QJS_STATIC uint32_t hash_string(const JSString *str, uint32_t h) {
  if (str->is_wide_char)
    h = hash_string16(str->u.str16, str->len, h);
  else
    h = hash_string8(str->u.str8, str->len, h);
  return h;
}

// <Primjs begin>
#if defined(DUMP_QJS_VALUE)
static __attribute__((unused)) void JS_DumpStringNoPrint(LEPUSRuntime *rt,
                                                         const JSString *p,
                                                         char dump_buf[]) {
  int i, c, sep;
  char fmt_buf[1024];

#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
  if (p == NULL) {
    write("<null>");
    return;
  }
  write("%d", p->header.ref_count);
  sep = (p->header.ref_count == 1) ? '\"' : '\'';
  write("%c", sep);
  for (i = 0; i < p->len; i++) {
    if (p->is_wide_char)
      c = p->u.str16[i];
    else
      c = p->u.str8[i];
    if (c == sep || c == '\\') {
      write("%c", '\\');
      write("%c", c);
    } else if (c >= ' ' && c <= 126) {
      write("%c", c);
    } else if (c == '\n') {
      write("%c", '\\');
      write("%c", 'n');
    } else {
      write("\\u%04x", c);
    }
  }
  write("%c", sep);

#undef write
}

static __attribute__((unused)) void JS_DumpString(LEPUSRuntime *rt,
                                                  const JSString *p) {
  char dump_buf[4096];
  dump_buf[0] = '\0';
  JS_DumpStringNoPrint(rt, p, dump_buf);
  printf("%s", dump_buf);
}

static __attribute__((unused)) void JS_DumpAtoms(LEPUSRuntime *rt) {
  JSAtomStruct *p;
  int h, i;
  /* This only dumps hashed atoms, not JS_ATOM_TYPE_SYMBOL atoms */
  printf("JSAtom count=%d size=%d hash_size=%d:\n", rt->atom_count,
         rt->atom_size, rt->atom_hash_size);
  printf("JSAtom hash table: {\n");
  for (i = 0; i < rt->atom_hash_size; i++) {
    h = rt->atom_hash[i];
    if (h) {
      printf("  %d:", i);
      while (h) {
        p = rt->atom_array[h];
        printf(" ");
        JS_DumpString(rt, p);
        h = p->hash_next;
      }
      printf("\n");
    }
  }
  printf("}\n");
  printf("JSAtom table: {\n");
  for (i = 0; i < rt->atom_size; i++) {
    p = rt->atom_array[i];
    if (!atom_is_free(p)) {
      printf("  %d: { %d %08x ", i, p->atom_type, p->hash);
      if (!(p->len == 0 && p->is_wide_char != 0)) JS_DumpString(rt, p);
      printf(" %d }\n", p->hash_next);
    }
  }
  printf("}\n");
}
#endif  // DUMP_QJS_VALUE
// <Primjs end>

QJS_STATIC int JS_ResizeAtomHash(LEPUSRuntime *rt, int new_hash_size) {
  JSAtomStruct *p;
  uint32_t new_hash_mask, h, i, hash_next1, j, *new_hash;

  assert((new_hash_size & (new_hash_size - 1)) == 0); /* power of two */
  new_hash_mask = new_hash_size - 1;
  new_hash = static_cast<uint32_t *>(lepus_mallocz_rt(
      rt, sizeof(rt->atom_hash[0]) * new_hash_size, ALLOC_TAG_WITHOUT_PTR));
  if (!new_hash) return -1;
  for (i = 0; i < rt->atom_hash_size; i++) {
    h = rt->atom_hash[i];
    while (h != 0) {
      p = rt->atom_array[h];
      hash_next1 = p->hash_next;
      /* add in new hash table */
      j = p->hash & new_hash_mask;
      p->hash_next = new_hash[j];
      new_hash[j] = h;
      h = hash_next1;
    }
  }
  if (!rt->gc_enable) lepus_free_rt(rt, rt->atom_hash);
  rt->atom_hash = new_hash;
  rt->atom_hash_size = new_hash_size;
  rt->atom_count_resize = JS_ATOM_COUNT_RESIZE(new_hash_size);
  //    JS_DumpAtoms(rt);
  return 0;
}

QJS_STATIC JSAtom __JS_NewAtomInit_NOGC(LEPUSRuntime *rt, const char *str,
                                        int len, int atom_type, int is_const);
QJS_STATIC JSAtom __JS_NewAtomInit(LEPUSRuntime *rt, const char *str, int len,
                                   int atom_type, int is_const);
int JS_InitAtoms(LEPUSRuntime *rt) {
  int i, len, atom_type;
  const char *p;

  rt->atom_hash_size = 0;
  rt->atom_hash = NULL;
  rt->atom_count = 0;
  rt->atom_size = 0;
  rt->atom_free_index = 0;
  if (JS_ResizeAtomHash(rt, 256)) /* there are at least 195 predefined atoms */
    return -1;

  p = js_atom_init;
  for (i = 1; i < JS_ATOM_END; i++) {
    if (i == JS_ATOM_Private_brand)
      atom_type = JS_ATOM_TYPE_PRIVATE;
    else if (i >= JS_ATOM_Symbol_toPrimitive)
      atom_type = JS_ATOM_TYPE_SYMBOL;
    else
      atom_type = JS_ATOM_TYPE_STRING;
    len = strlen(p);
#ifndef ENABLE_FORCE_GC
    if (__JS_NewAtomInit_NOGC(rt, p, len, atom_type, 1) == JS_ATOM_NULL)
#else
    if (__JS_NewAtomInit(rt, p, len, atom_type, 1) == JS_ATOM_NULL)
#endif
      return -1;
    p = p + len + 1;
  }
  return 0;
}

QJS_STATIC JSAtom JS_DupAtomRT(LEPUSRuntime *rt, JSAtom v) {
  JSAtomStruct *p;

  if (!__JS_AtomIsConst(v)) {
    p = rt->atom_array[v];
    p->header.ref_count++;
  }
  return v;
}

JSAtom LEPUS_DupAtom(LEPUSContext *ctx, JSAtom v) {
  LEPUSRuntime *rt;
  JSAtomStruct *p;

  if (!__JS_AtomIsConst(v)) {
    rt = ctx->rt;
    p = rt->atom_array[v];
    p->header.ref_count++;
  }
  return v;
}

QJS_HIDE JSAtomKindEnum JS_AtomGetKind(LEPUSContext *ctx, JSAtom v) {
  LEPUSRuntime *rt;
  JSAtomStruct *p;

  rt = ctx->rt;
  if (__JS_AtomIsTaggedInt(v)) return JS_ATOM_KIND_STRING;
  p = rt->atom_array[v];
  switch (p->atom_type) {
    case JS_ATOM_TYPE_STRING:
      return JS_ATOM_KIND_STRING;
    case JS_ATOM_TYPE_GLOBAL_SYMBOL:
      return JS_ATOM_KIND_SYMBOL;
    case JS_ATOM_TYPE_SYMBOL:
      switch (p->hash) {
        case JS_ATOM_HASH_SYMBOL:
          return JS_ATOM_KIND_SYMBOL;
        case JS_ATOM_HASH_PRIVATE:
          return JS_ATOM_KIND_PRIVATE;
        default:
          abort();
      }
    default:
      abort();
  }
}

QJS_HIDE BOOL JS_AtomIsString(LEPUSContext *ctx, JSAtom v) {
  return JS_AtomGetKind(ctx, v) == JS_ATOM_KIND_STRING;
}

JSAtom js_get_atom_index(LEPUSRuntime *rt, JSAtomStruct *p) {
  uint32_t i = p->hash_next; /* atom_index */
  if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {
    JSAtomStruct *p1;

    i = rt->atom_hash[p->hash & (rt->atom_hash_size - 1)];
    p1 = rt->atom_array[i];
    while (p1 != p) {
      assert(i != 0);
      i = p1->hash_next;
      p1 = rt->atom_array[i];
    }
  }
  return i;
}

/* string case (internal). Return JS_ATOM_NULL if error. 'str' is
   freed. */
JSAtom __JS_NewAtom(LEPUSRuntime *rt, JSString *str, int atom_type) {
  uint32_t h, h1, i;
  JSAtomStruct *p = nullptr;
  int len;
#ifdef ENABLE_COMPATIBLE_MM
  HandleScope func_scope(rt);
#endif

#if 0
    printf("__JS_NewAtom: ");  JS_DumpString(rt, str); printf("\n");
#endif
  if (atom_type < JS_ATOM_TYPE_SYMBOL) {
    /* str is not NULL */
    if (str->atom_type == atom_type) {
      /* str is the atom, return its index */
      i = js_get_atom_index(rt, str);
      /* reduce string refcount and increase atom's unless constant */
      if (!rt->gc_enable && __JS_AtomIsConst(i)) str->header.ref_count--;
      return i;
    }
    /* try and locate an already registered atom */
    len = str->len;
    h = hash_string(str, atom_type);
    h &= JS_ATOM_HASH_MASK;
    h1 = h & (rt->atom_hash_size - 1);
    i = rt->atom_hash[h1];
    while (i != 0) {
      p = rt->atom_array[i];
      if (p->hash == h && p->atom_type == atom_type && p->len == len &&
          js_string_memcmp(p, str, len) == 0) {
#ifdef ENABLE_COMPATIBLE_MM
        if (!rt->gc_enable && !__JS_AtomIsConst(i))
#else
        if (!__JS_AtomIsConst(i))
#endif
          p->header.ref_count++;
        goto done;
      }
      i = p->hash_next;
    }
  } else {
    h1 = 0; /* avoid warning */
    if (atom_type == JS_ATOM_TYPE_SYMBOL) {
      h = JS_ATOM_HASH_SYMBOL;
    } else {
      h = JS_ATOM_HASH_PRIVATE;
      atom_type = JS_ATOM_TYPE_SYMBOL;
    }
  }

#ifdef ENABLE_COMPATIBLE_MM
  func_scope.PushHandle(&p, HANDLE_TYPE_HEAP_OBJ);
#endif
  if (rt->atom_free_index == 0) {
    /* allow new atom entries */
    uint32_t new_size, start;
    JSAtomStruct **new_array;

    /* alloc new with size progression 3/2:
       4 6 9 13 19 28 42 63 94 141 211 316 474 711 1066 1599 2398 3597 5395 8092
       preallocating space for predefined atoms (at least 195).
     */
    new_size = max_int(211, rt->atom_size * 3 / 2);
    if (new_size > JS_ATOM_MAX) goto fail;
    /* XXX: should use realloc2 to use slack space */
    new_array = static_cast<JSAtomStruct **>(
        lepus_realloc_rt(rt, rt->atom_array, sizeof(*new_array) * new_size,
                         ALLOC_TAG_WITHOUT_PTR));
    if (!new_array) goto fail;
#ifdef ENABLE_COMPATIBLE_MM
    func_scope.PushHandle(new_array, HANDLE_TYPE_DIR_HEAP_OBJ);
#endif
    /* Note: the atom 0 is not used */
    start = rt->atom_size;
    if (start == 0) {
      /* JS_ATOM_NULL entry */
      p = static_cast<JSAtomStruct *>(
          lepus_mallocz_rt(rt, sizeof(JSAtomStruct), ALLOC_TAG_JSConstString));
      if (!p) {
        if (!rt->gc_enable) lepus_free_rt(rt, new_array);
        goto fail;
      }
      if (!rt->gc_enable) p->header.ref_count = 1; /* not refcounted */
      p->atom_type = JS_ATOM_TYPE_SYMBOL;
#ifdef DUMP_LEAKS
      list_add_tail(&p->link, &rt->string_list);
#endif
      new_array[0] = p;
      rt->atom_count++;
      start = 1;
    }
    rt->atom_size = new_size;
    rt->atom_array = new_array;
    rt->atom_free_index = start;
    for (i = start; i < new_size; i++) {
      uint32_t next;
      if (i == (new_size - 1))
        next = 0;
      else
        next = i + 1;
      rt->atom_array[i] = atom_set_free(next);
    }
  }

  if (str) {
    if (str->atom_type == 0) {
      p = str;
      p->atom_type = atom_type;
    } else {
      p = static_cast<JSAtomStruct *>(
          lepus_mallocz_rt(rt,
                           sizeof(JSString) + (str->len << str->is_wide_char) +
                               1 - str->is_wide_char,
                           ALLOC_TAG_JSString));
      if (unlikely(!p)) goto fail;
      if (!rt->gc_enable) p->header.ref_count = 1;
      p->is_wide_char = str->is_wide_char;
      p->len = str->len;
#ifdef DUMP_LEAKS
      list_add_tail(&p->link, &rt->string_list);
#endif
      memcpy(p->u.str8, str->u.str8,
             (str->len << str->is_wide_char) + 1 - str->is_wide_char);
      if (!rt->gc_enable) js_free_string(rt, str);
    }
  } else {
    p = static_cast<JSAtomStruct *>(lepus_mallocz_rt(
        rt, sizeof(JSAtomStruct), ALLOC_TAG_JSString)); /* empty wide string */
    if (!p) return JS_ATOM_NULL;
    if (!rt->gc_enable) p->header.ref_count = 1;
    p->is_wide_char = 1; /* Hack to represent NULL as a JSString */
    p->len = 0;
#ifdef DUMP_LEAKS
    list_add_tail(&p->link, &rt->string_list);
#endif
  }

  /* use an already free entry */
  i = rt->atom_free_index;
  rt->atom_free_index = atom_get_free(rt->atom_array[i]);
  rt->atom_array[i] = p;

  p->hash = h;
  p->hash_next = i; /* atom_index */
  p->atom_type = atom_type;

  rt->atom_count++;

  if (atom_type != JS_ATOM_TYPE_SYMBOL) {
    p->hash_next = rt->atom_hash[h1];
    rt->atom_hash[h1] = i;
    if (unlikely(rt->atom_count >= rt->atom_count_resize))
      JS_ResizeAtomHash(rt, rt->atom_hash_size * 2);
  }

  //    JS_DumpAtoms(rt);
  return i;

fail:
  i = JS_ATOM_NULL;
done:
  if (str && !rt->gc_enable) js_free_string(rt, str);
  return i;
}
QJS_STATIC JSAtom __attribute__((always_inline)) __attribute__((unused))
__JS_NewAtomInit_NOGC(LEPUSRuntime *rt, const char *str, int len, int atom_type,
                      int is_const) {
  JSString *p;
  p = js_alloc_string_rt(rt, len, 0, is_const);
  if (!p) return JS_ATOM_NULL;
  memcpy(p->u.str8, str, len);
  p->u.str8[len] = '\0';
  JSAtom ret = __JS_NewAtom(rt, p, atom_type);
  return ret;
}
/* only works with zero terminated 8 bit strings */
JSAtom __JS_NewAtomInit(LEPUSRuntime *rt, const char *str, int len,
                        int atom_type, int is_const = 0) {
  JSString *p;
  p = js_alloc_string_rt(rt, len, 0, is_const);
  if (!p) return JS_ATOM_NULL;
  HandleScope func_scope(rt);
  func_scope.PushHandle(p, HANDLE_TYPE_DIR_HEAP_OBJ);
  memcpy(p->u.str8, str, len);
  p->u.str8[len] = '\0';
  return __JS_NewAtom(rt, p, atom_type);
}

QJS_STATIC JSAtom __JS_FindAtom(LEPUSRuntime *rt, const char *str, size_t len,
                                int atom_type) {
  uint32_t h, h1, i;
  JSAtomStruct *p;

  h = hash_string8((const uint8_t *)str, len, JS_ATOM_TYPE_STRING);
  h &= JS_ATOM_HASH_MASK;
  h1 = h & (rt->atom_hash_size - 1);
  i = rt->atom_hash[h1];
  while (i != 0) {
    p = rt->atom_array[i];
    if (p->hash == h && p->atom_type == JS_ATOM_TYPE_STRING && p->len == len &&
        p->is_wide_char == 0 && memcmp(p->u.str8, str, len) == 0) {
      if (!rt->gc_enable && !__JS_AtomIsConst(i)) p->header.ref_count++;
      return i;
    }
    i = p->hash_next;
  }
  return JS_ATOM_NULL;
}

QJS_STATIC void JS_FreeAtomStruct(LEPUSRuntime *rt, JSAtomStruct *p) {
#if 0 /* JS_ATOM_NULL is not refcounted: __JS_AtomIsConst() includes 0 */
    if (unlikely(i == JS_ATOM_NULL)) {
        p->header.ref_count = INT32_MAX / 2;
        return;
    }
#endif
  uint32_t i = p->hash_next; /* atom_index */
  if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {
    JSAtomStruct *p0, *p1;
    uint32_t h0;

    h0 = p->hash & (rt->atom_hash_size - 1);
    i = rt->atom_hash[h0];
    p1 = rt->atom_array[i];
    if (p1 == p) {
      rt->atom_hash[h0] = p1->hash_next;
    } else {
      for (;;) {
        assert(i != 0);
        p0 = p1;
        i = p1->hash_next;
        p1 = rt->atom_array[i];
        if (p1 == p) {
          p0->hash_next = p1->hash_next;
          break;
        }
      }
    }
  }
  /* insert in free atom list */
  rt->atom_array[i] = atom_set_free(rt->atom_free_index);
  rt->atom_free_index = i;
  /* free the string structure */
#ifdef DUMP_LEAKS
  list_del(&p->link);
#endif
  // Primjs begin
#ifdef ENABLE_LEPUSNG
  JS_FreeStringCache(rt, p);
#endif
  // Primjs end
  lepus_free_rt(rt, p);
  rt->atom_count--;
  assert(rt->atom_count >= 0);
}

QJS_STATIC void __JS_FreeAtom(LEPUSRuntime *rt, uint32_t i) {
  JSAtomStruct *p;

  p = rt->atom_array[i];
  if (--p->header.ref_count > 0) return;
  JS_FreeAtomStruct(rt, p);
}

/* Warning: 'p' is freed */
JSAtom JS_NewAtomStr(LEPUSContext *ctx, JSString *p) {
  LEPUSRuntime *rt = ctx->rt;
  uint32_t n;
  if (is_num_string(&n, p)) {
    if (n <= JS_ATOM_MAX_INT) {
      if (!rt->gc_enable) js_free_string(rt, p);
      return __JS_AtomFromUInt32(n);
    }
  }
  /* XXX: should generate an exception */
  return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING);
}

#ifdef OS_IOS
static BOOL js_check_virtual_sp_overflow(LEPUSContext *ctx, size_t size) {
  if (ctx->stack_pos + size > ctx->rt->stack_size) {
    return TRUE;
  }
  return FALSE;
}

static BOOL js_check_virtual_outofmemory(LEPUSContext *ctx, size_t size) {
  if (ctx->stack == NULL) {
    return TRUE;
  }
  return FALSE;
}

static LEPUSValue *js_get_virtual_sp(LEPUSContext *ctx) {
  return (LEPUSValue *)(ctx->stack + ctx->stack_pos);
}

static void js_push_virtual_sp(LEPUSContext *ctx, size_t size) {
  ctx->stack_pos += size;
}

static void js_pop_virtual_sp(LEPUSContext *ctx, size_t size) {
  ctx->stack_pos -= size;
}
#endif

JSAtom LEPUS_NewAtomLen(LEPUSContext *ctx, const char *str, size_t len) {
  LEPUSValue val;

  if (len == 0 || !is_digit(*str)) {
    JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);
    if (atom) return atom;
  }
  val = LEPUS_NewStringLen(ctx, str, len);
  if (LEPUS_IsException(val)) return JS_ATOM_NULL;
#ifdef ENABLE_COMPATIBLE_MM
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
#endif
  return JS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(val));
}

JSAtom LEPUS_NewAtom(LEPUSContext *ctx, const char *str) {
  return LEPUS_NewAtomLen(ctx, str, strlen(str));
}

JSAtom LEPUS_NewAtomUInt32(LEPUSContext *ctx, uint32_t n) {
  CallGCFunc(JS_NewAtomUInt32_GC, ctx, n);
  if (n <= JS_ATOM_MAX_INT) {
    return __JS_AtomFromUInt32(n);
  } else {
    char buf[11];
    LEPUSValue val;
    snprintf(buf, sizeof(buf), "%u", n);
    val = LEPUS_NewString(ctx, buf);
    if (LEPUS_IsException(val)) return JS_ATOM_NULL;
    return __JS_NewAtom(ctx->rt, LEPUS_VALUE_GET_STRING(val),
                        JS_ATOM_TYPE_STRING);
  }
}

QJS_STATIC JSAtom JS_NewAtomInt64(LEPUSContext *ctx, int64_t n) {
  if ((uint64_t)n <= JS_ATOM_MAX_INT) {
    return __JS_AtomFromUInt32((uint32_t)n);
  } else {
    char buf[24];
    LEPUSValue val;
    snprintf(buf, sizeof(buf), "%" PRId64, n);
    val = LEPUS_NewString(ctx, buf);
    if (LEPUS_IsException(val)) return JS_ATOM_NULL;
    return __JS_NewAtom(ctx->rt, LEPUS_VALUE_GET_STRING(val),
                        JS_ATOM_TYPE_STRING);
  }
}

/* 'p' is freed */
QJS_STATIC LEPUSValue JS_NewSymbol(LEPUSContext *ctx, JSString *p,
                                   int atom_type) {
  LEPUSRuntime *rt = ctx->rt;
  JSAtom atom;
  atom = __JS_NewAtom(rt, p, atom_type);
  if (atom == JS_ATOM_NULL) return LEPUS_ThrowOutOfMemory(ctx);
  return LEPUS_MKPTR(LEPUS_TAG_SYMBOL, rt->atom_array[atom]);
}

/* descr must be a non-numeric string atom */
LEPUSValue JS_NewSymbolFromAtom(LEPUSContext *ctx, JSAtom descr,
                                int atom_type) {
  LEPUSRuntime *rt = ctx->rt;
  JSString *p;

  assert(!__JS_AtomIsTaggedInt(descr));
  assert(descr < rt->atom_size);
  p = rt->atom_array[descr];
  LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  return JS_NewSymbol(ctx, p, atom_type);
}

#define ATOM_GET_STR_BUF_SIZE 64

/* Should only be used for debug. */
const char *JS_AtomGetStrRT(LEPUSRuntime *rt, char *buf, int buf_size,
                            JSAtom atom) {
  if (__JS_AtomIsTaggedInt(atom)) {
    snprintf(buf, buf_size, "%u", __JS_AtomToUInt32(atom));
  } else {
    JSAtomStruct *p;
    assert(atom < rt->atom_size);
    if (atom == JS_ATOM_NULL) {
      snprintf(buf, buf_size, "<null>");
    } else {
      int i, c;
      char *q;
      JSString *str;

      q = buf;
      p = rt->atom_array[atom];
      assert(!atom_is_free(p));
      str = p;
      if (str) {
        if (!str->is_wide_char) {
          /* special case ASCII strings */
          c = 0;
          for (i = 0; i < str->len; i++) {
            c |= str->u.str8[i];
          }
          if (c < 0x80) return (const char *)str->u.str8;
        }
        for (i = 0; i < str->len; i++) {
          if (str->is_wide_char)
            c = str->u.str16[i];
          else
            c = str->u.str8[i];
          if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX) break;
          if (c < 128) {
            *q++ = c;
          } else {
            q += unicode_to_utf8((uint8_t *)q, c);
          }
        }
      }
      *q = '\0';
    }
  }
  return buf;
}

const char *JS_AtomGetStr(LEPUSContext *ctx, char *buf, int buf_size,
                          JSAtom atom) {
  return JS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);
}

LEPUSValue __JS_AtomToValue(LEPUSContext *ctx, JSAtom atom, BOOL force_string) {
  char buf[ATOM_GET_STR_BUF_SIZE];

  if (__JS_AtomIsTaggedInt(atom)) {
    snprintf(buf, sizeof(buf), "%u", __JS_AtomToUInt32(atom));
    return LEPUS_NewString(ctx, buf);
  } else {
    LEPUSRuntime *rt = ctx->rt;
    JSAtomStruct *p;
    assert(atom < rt->atom_size);
    p = rt->atom_array[atom];
    if (p->atom_type == JS_ATOM_TYPE_STRING) {
      goto ret_string;
    } else if (force_string) {
      if (p->len == 0 && p->is_wide_char != 0) {
        /* no description string */
        p = rt->atom_array[JS_ATOM_empty_string];
      }
    ret_string:
      return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
    } else {
      return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_SYMBOL, p));
    }
  }
}

static LEPUSValue JS_AtomToValue_RC(LEPUSContext *ctx, JSAtom atom) {
  return __JS_AtomToValue(ctx, atom, FALSE);
}

LEPUSValue LEPUS_AtomToValue(LEPUSContext *ctx, JSAtom atom) {
  CallGCFunc(JS_AtomToValue_GC, ctx, atom);
  return JS_AtomToValue_RC(ctx, atom);
}

LEPUSValue LEPUS_AtomToString(LEPUSContext *ctx, JSAtom atom) {
  CallGCFunc(JS_AtomToString_GC, ctx, atom);
  return __JS_AtomToValue(ctx, atom, TRUE);
}

/* return TRUE if the atom is an array index (i.e. 0 <= index <=
   2^32-2 and return its value */
BOOL JS_AtomIsArrayIndex(LEPUSContext *ctx, uint32_t *pval, JSAtom atom) {
  if (__JS_AtomIsTaggedInt(atom)) {
    *pval = __JS_AtomToUInt32(atom);
    return TRUE;
  } else {
    LEPUSRuntime *rt = ctx->rt;
    JSAtomStruct *p;
    uint32_t val;

    assert(atom < rt->atom_size);
    p = rt->atom_array[atom];
    if (p->atom_type == JS_ATOM_TYPE_STRING && is_num_string(&val, p) &&
        val != -1) {
      *pval = val;
      return TRUE;
    } else {
      *pval = 0;
      return FALSE;
    }
  }
}

/* This test must be fast if atom is not a numeric index (e.g. a
   method name). Return LEPUS_UNDEFINED if not a numeric
   index. LEPUS_EXCEPTION can also be returned. */
QJS_STATIC LEPUSValue JS_AtomIsNumericIndex1(LEPUSContext *ctx, JSAtom atom) {
  LEPUSRuntime *rt = ctx->rt;
  JSAtomStruct *p1;
  JSString *p;
  int c, len, ret;
  LEPUSValue num, str;

  if (__JS_AtomIsTaggedInt(atom))
    return LEPUS_NewInt32(ctx, __JS_AtomToUInt32(atom));
  assert(atom < rt->atom_size);
  p1 = rt->atom_array[atom];
  if (p1->atom_type != JS_ATOM_TYPE_STRING) return LEPUS_UNDEFINED;
  p = p1;
  len = p->len;
  if (p->is_wide_char) {
    const uint16_t *r = p->u.str16, *r_end = p->u.str16 + len;
    if (r >= r_end) return LEPUS_UNDEFINED;
    c = *r;
    if (c == '-') {
      if (r >= r_end) return LEPUS_UNDEFINED;
      r++;
      c = *r;
      /* -0 case is specific */
      if (c == '0' && len == 2) goto minus_zero;
    }
    /* XXX: should test NaN, but the tests do not check it */
    if (!is_num(c)) {
      /* XXX: String should be normalized, therefore 8-bit only */
      const uint16_t nfinity16[7] = {'n', 'f', 'i', 'n', 'i', 't', 'y'};
      if (!(c == 'I' && (r_end - r) == 8 &&
            !memcmp(r + 1, nfinity16, sizeof(nfinity16))))
        return LEPUS_UNDEFINED;
    }
  } else {
    const uint8_t *r, *r_end;
    r = p->u.str8;
    r_end = p->u.str8 + len;
    if (r >= r_end) return LEPUS_UNDEFINED;
    c = *r;
    if (c == '-') {
      if (r >= r_end) return LEPUS_UNDEFINED;
      r++;
      c = *r;
      /* -0 case is specific */
      if (c == '0' && len == 2) {
      minus_zero:
        return __JS_NewFloat64(ctx, -0.0);
      }
    }
    if (!is_num(c)) {
      if (!(c == 'I' && (r_end - r) == 8 && !memcmp(r + 1, "nfinity", 7)))
        return LEPUS_UNDEFINED;
    }
  }
  /* XXX: bignum: would be better to only accept integer to avoid
     relying on current floating point precision */
  /* this is ECMA CanonicalNumericIndexString primitive */
  num = JS_ToNumber(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  if (LEPUS_IsException(num)) return num;
  str = JS_ToString_RC(ctx, num);
  if (LEPUS_IsException(str)) {
    LEPUS_FreeValue(ctx, num);
    return str;
  }
  ret = js_string_compare(ctx, p, LEPUS_VALUE_GET_STRING(str));
  LEPUS_FreeValue(ctx, str);
  if (ret == 0) {
    return num;
  } else {
    LEPUS_FreeValue(ctx, num);
    return LEPUS_UNDEFINED;
  }
}

/* return -1 if exception or TRUE/FALSE */
QJS_STATIC int JS_AtomIsNumericIndex(LEPUSContext *ctx, JSAtom atom) {
  LEPUSValue num;
  num = JS_AtomIsNumericIndex1(ctx, atom);
  if (likely(LEPUS_IsUndefined(num))) return FALSE;
  if (LEPUS_IsException(num)) return -1;
  LEPUS_FreeValue(ctx, num);
  return TRUE;
}

void LEPUS_FreeAtom(LEPUSContext *ctx, JSAtom v) {
#ifdef ENABLE_GC_DEBUG_TOOLS
  DCHECK(!ctx->gc_enable);
#endif
  if (!__JS_AtomIsConst(v)) __JS_FreeAtom(ctx->rt, v);
}

void LEPUS_FreeAtomRT(LEPUSRuntime *rt, JSAtom v) {
#ifdef ENABLE_GC_DEBUG_TOOLS
  DCHECK(!rt->gc_enable);
#endif
  if (!__JS_AtomIsConst(v)) __JS_FreeAtom(rt, v);
}

/* return TRUE if 'v' is a symbol with a string description */
QJS_STATIC BOOL JS_AtomSymbolHasDescription(LEPUSContext *ctx, JSAtom v) {
  LEPUSRuntime *rt;
  JSAtomStruct *p;

  rt = ctx->rt;
  if (__JS_AtomIsTaggedInt(v)) return FALSE;
  p = rt->atom_array[v];
  return (((p->atom_type == JS_ATOM_TYPE_SYMBOL &&
            p->hash == JS_ATOM_HASH_SYMBOL) ||
           p->atom_type == JS_ATOM_TYPE_GLOBAL_SYMBOL) &&
          !(p->len == 0 && p->is_wide_char != 0));
}

QJS_STATIC __attribute__((unused)) void print_atom(LEPUSContext *ctx,
                                                   JSAtom atom) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  const char *p;
  int i;

  /* XXX: should handle embedded null characters */
  /* XXX: should move encoding code to JS_AtomGetStr */
  p = JS_AtomGetStr(ctx, buf, sizeof(buf), atom);
  for (i = 0; p[i]; i++) {
    int c = (unsigned char)p[i];
    if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
          (c == '_' || c == '$') || (c >= '0' && c <= '9' && i > 0)))
      break;
  }
  if (i > 0 && p[i] == '\0') {
    printf("%s", p);
  } else {
    printf("%c", '"');
    printf("%.*s", i, p);
    for (; p[i]; i++) {
      int c = (unsigned char)p[i];
      if (c == '\"' || c == '\\') {
        printf("%c", '\\');
        printf("%c", c);
      } else if (c >= ' ' && c <= 126) {
        printf("%c", c);
      } else if (c == '\n') {
        printf("%c", '\\');
        printf("%c", 'n');
      } else {
        printf("\\u%04x", c);
      }
    }
    printf("%c", '\"');
  }
}

static const char *JS_ToCStringLen2_RC(LEPUSContext *ctx, size_t *plen,
                                       LEPUSValueConst val1, BOOL cesu8);

/* free with LEPUS_FreeCString() */
const char *LEPUS_AtomToCString(LEPUSContext *ctx, JSAtom atom) {
  CallGCFunc(JS_AtomToCString_GC, ctx, atom);
  LEPUSValue str;
  const char *cstr;

  str = LEPUS_AtomToString(ctx, atom);
  if (LEPUS_IsException(str)) return NULL;
  cstr = JS_ToCStringLen2_RC(ctx, NULL, str, 0);
  LEPUS_FreeValue(ctx, str);
  return cstr;
}

#ifndef NO_QUICKJS_COMPILER
/* return a string atom containing name concatenated with str1 */
QJS_STATIC JSAtom js_atom_concat_str(LEPUSContext *ctx, JSAtom name,
                                     const char *str1) {
  LEPUSValue str;
  JSAtom atom;
  const char *cstr;
  char *cstr2;
  size_t len, len1;

  str = LEPUS_AtomToString(ctx, name);
  if (LEPUS_IsException(str)) return JS_ATOM_NULL;
  HandleScope func_scope(ctx, &str, HANDLE_TYPE_LEPUS_VALUE);
  cstr = LEPUS_ToCStringLen2(ctx, &len, str, 0);
  if (!cstr) goto fail;
  len1 = strlen(str1);
  cstr2 = static_cast<char *>(
      lepus_malloc(ctx, len + len1 + 1, ALLOC_TAG_WITHOUT_PTR));
  if (!cstr2) goto fail;
  func_scope.PushHandle(cstr2, HANDLE_TYPE_DIR_HEAP_OBJ);
  memcpy(cstr2, cstr, len);
  memcpy(cstr2 + len, str1, len1);
  cstr2[len + len1] = '\0';
  atom = LEPUS_NewAtomLen(ctx, cstr2, len + len1);
  if (!ctx->gc_enable) {
    lepus_free(ctx, cstr2);
    LEPUS_FreeCString(ctx, cstr);
    LEPUS_FreeValue(ctx, str);
  }
  return atom;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeCString(ctx, cstr);
    LEPUS_FreeValue(ctx, str);
  }
  return JS_ATOM_NULL;
}
#endif

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC JSAtom js_atom_concat_num(LEPUSContext *ctx, JSAtom name,
                                     uint32_t n) {
  char buf[16];
  snprintf(buf, sizeof(buf), "%u", n);
  return js_atom_concat_str(ctx, name, buf);
}
#endif
QJS_STATIC inline BOOL JS_IsEmptyString(LEPUSValueConst v) {
  return (LEPUS_VALUE_IS_STRING(v) && LEPUS_VALUE_GET_STRING(v)->len == 0) ||
         (JS_IsSeparableString(v) && JS_GetSeparableString(v)->len == 0);
}

/* LEPUSClass support */

/* a new class ID is allocated if *pclass_id != 0 */
LEPUSClassID LEPUS_NewClassID(LEPUSClassID *pclass_id) {
  LEPUSClassID class_id;
  /* XXX: make it thread safe */
  class_id = *pclass_id;
  if (class_id == 0) {
    class_id = js_class_id_alloc++;
    *pclass_id = class_id;
  }
  return class_id;
}

BOOL LEPUS_IsRegisteredClass(LEPUSRuntime *rt, LEPUSClassID class_id) {
  return (class_id < rt->class_count &&
          rt->class_array[class_id].class_id != 0);
}

/* create a new object internal class. Return -1 if error, 0 if
   OK. The finalizer can be NULL if none is needed. */
QJS_STATIC int JS_NewClass1(LEPUSRuntime *rt, LEPUSClassID class_id,
                            const LEPUSClassDef *class_def, JSAtom name) {
  int new_size, i;
  LEPUSClass *cl, *new_class_array;
  struct list_head *el;

  if (class_id < rt->class_count && rt->class_array[class_id].class_id != 0)
    return -1;

  if (class_id >= rt->class_count) {
    new_size = max_int(JS_CLASS_INIT_COUNT,
                       max_int(class_id + 1, rt->class_count * 3 / 2));

    /* reallocate the context class prototype array, if any */
    list_for_each(el, &rt->context_list) {
      LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
      LEPUSValue *new_tab;
      new_tab = static_cast<LEPUSValue *>(lepus_realloc_rt(
          rt, ctx->class_proto, sizeof(ctx->class_proto[0]) * new_size,
          ALLOC_TAG_WITHOUT_PTR));
      if (!new_tab) return -1;
      for (i = rt->class_count; i < new_size; i++) new_tab[i] = LEPUS_NULL;
      ctx->class_proto = new_tab;
    }
    /* reallocate the class array */
    new_class_array = static_cast<LEPUSClass *>(
        lepus_realloc_rt(rt, rt->class_array, sizeof(LEPUSClass) * new_size,
                         ALLOC_TAG_WITHOUT_PTR));
    if (!new_class_array) return -1;
    memset(new_class_array + rt->class_count, 0,
           (new_size - rt->class_count) * sizeof(LEPUSClass));
    rt->class_array = new_class_array;
    rt->class_count = new_size;
  }
  cl = &rt->class_array[class_id];
  cl->class_id = class_id;
  cl->class_name = JS_DupAtomRT(rt, name);
  cl->finalizer = class_def->finalizer;
  cl->gc_mark = class_def->gc_mark;
  cl->call = class_def->call;
  cl->exotic = class_def->exotic;
  return 0;
}

int LEPUS_NewClass(LEPUSRuntime *rt, LEPUSClassID class_id,
                   const LEPUSClassDef *class_def) {
  int ret, len;
  JSAtom name;

  len = strlen(class_def->class_name);
  name = __JS_FindAtom(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);
  if (name == JS_ATOM_NULL) {
    name =
        __JS_NewAtomInit(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);
    if (name == JS_ATOM_NULL) return -1;
  }
  HandleScope func_scope(rt);
  func_scope.PushLEPUSAtom(name);
  ret = JS_NewClass1(rt, class_id, class_def, name);
  if (!rt->gc_enable) LEPUS_FreeAtomRT(rt, name);
  return ret;
}

QJS_STATIC LEPUSValue js_new_string8(LEPUSContext *ctx, const uint8_t *buf,
                                     int len) {
  JSString *str;

  if (len <= 0) {
    return LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  }
  str = js_alloc_string(ctx, len, 0);
  if (!str) return LEPUS_EXCEPTION;
  memcpy(str->u.str8, buf, len);
  str->u.str8[len] = '\0';
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

QJS_STATIC LEPUSValue js_new_string16(LEPUSContext *ctx, const uint16_t *buf,
                                      int len) {
  JSString *str;
  str = js_alloc_string(ctx, len, 1);
  if (!str) return LEPUS_EXCEPTION;
  memcpy(str->u.str16, buf, len * 2);
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

QJS_STATIC LEPUSValue js_new_string_char(LEPUSContext *ctx, uint16_t c) {
  if (c < 0x100) {
    uint8_t ch8 = c;
    return js_new_string8(ctx, &ch8, 1);
  } else {
    uint16_t ch16 = c;
    return js_new_string16(ctx, &ch16, 1);
  }
}

QJS_STATIC LEPUSValue js_sub_string(LEPUSContext *ctx, JSString *p, int start,
                                    int end) {
  int len = end - start;
  if (start == 0 && end == p->len) {
    return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  }
  if (p->is_wide_char && len > 0) {
    JSString *str;
    int i;
    uint16_t c = 0;
    for (i = start; i < end; i++) {
      c |= p->u.str16[i];
    }
    if (c > 0xFF) return js_new_string16(ctx, p->u.str16 + start, len);

    str = js_alloc_string(ctx, len, 0);
    if (!str) return LEPUS_EXCEPTION;
    for (i = 0; i < len; i++) {
      str->u.str8[i] = p->u.str16[start + i];
    }
    str->u.str8[len] = '\0';
    return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
  } else {
    return js_new_string8(ctx, p->u.str8 + start, len);
  }
}

/* It is valid to call string_buffer_end() and all string_buffer functions even
   if string_buffer_init() or another string_buffer function returns an error.
   If the error_status is set, string_buffer_end() returns LEPUS_EXCEPTION.
 */
QJS_STATIC int string_buffer_init2(LEPUSContext *ctx, StringBuffer *s, int size,
                                   int is_wide) {
  s->ctx = ctx;
  s->size = size;
  s->len = 0;
  s->is_wide_char = is_wide;
  s->error_status = 0;
  s->str = js_alloc_string(ctx, size, is_wide);
  if (unlikely(!s->str)) {
    s->size = 0;
    return s->error_status = -1;
  }
#ifdef DUMP_LEAKS
  /* the StringBuffer may reallocate the JSString, only link it at the end */
  list_del(&s->str->link);
#endif
  return 0;
}

QJS_STATIC inline int string_buffer_init(LEPUSContext *ctx, StringBuffer *s,
                                         int size) {
  return string_buffer_init2(ctx, s, size, 0);
}

QJS_STATIC void string_buffer_free(StringBuffer *s) {
  lepus_free(s->ctx, s->str);
  s->str = NULL;
}

QJS_STATIC int string_buffer_set_error(StringBuffer *s) {
  if (!s->ctx->gc_enable) lepus_free(s->ctx, s->str);
  s->str = NULL;
  s->size = 0;
  s->len = 0;
  return s->error_status = -1;
}

QJS_STATIC no_inline int string_buffer_widen(StringBuffer *s, int size) {
  JSString *str;
  size_t slack;
  int i;

  if (s->error_status) return -1;

  str = static_cast<JSString *>(lepus_realloc2(s->ctx, s->str,
                                               sizeof(JSString) + (size << 1),
                                               &slack, ALLOC_TAG_JSString));
  if (!str) return string_buffer_set_error(s);
  size += slack >> 1;
  for (i = s->len; i-- > 0;) {
    str->u.str16[i] = str->u.str8[i];
  }
  s->is_wide_char = 1;
  s->size = size;
  s->str = str;
  return 0;
}

QJS_STATIC no_inline int string_buffer_realloc(StringBuffer *s, int new_len,
                                               int c) {
  JSString *new_str;
  int new_size;
  size_t new_size_bytes, slack;

  if (s->error_status) return -1;

  if (new_len > JS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(s->ctx, "string too long");
    return string_buffer_set_error(s);
  }
  new_size = min_int(max_int(new_len, s->size * 3 / 2), JS_STRING_LEN_MAX);
  if (!s->is_wide_char && c >= 0x100) {
    return string_buffer_widen(s, new_size);
  }
  new_size_bytes =
      sizeof(JSString) + (new_size << s->is_wide_char) + 1 - s->is_wide_char;
  new_str = static_cast<JSString *>(lepus_realloc2(
      s->ctx, s->str, new_size_bytes, &slack, ALLOC_TAG_JSString));
  if (!new_str) return string_buffer_set_error(s);
  new_size = min_int(new_size + (slack >> s->is_wide_char), JS_STRING_LEN_MAX);
  s->size = new_size;
  s->str = new_str;
  return 0;
}

QJS_STATIC no_inline int string_buffer_putc_slow(StringBuffer *s, uint32_t c) {
  if (unlikely(s->len >= s->size)) {
    if (string_buffer_realloc(s, s->len + 1, c)) return -1;
  }
  if (s->is_wide_char) {
    s->str->u.str16[s->len++] = c;
  } else if (c < 0x100) {
    s->str->u.str8[s->len++] = c;
  } else {
    if (string_buffer_widen(s, s->size)) return -1;
    s->str->u.str16[s->len++] = c;
  }
  return 0;
}

/* 0 <= c <= 0xff */
int string_buffer_putc8(StringBuffer *s, uint32_t c) {
  if (unlikely(s->len >= s->size)) {
    if (string_buffer_realloc(s, s->len + 1, c)) return -1;
  }
  if (s->is_wide_char) {
    s->str->u.str16[s->len++] = c;
  } else {
    s->str->u.str8[s->len++] = c;
  }
  return 0;
}

/* 0 <= c <= 0xffff */
int string_buffer_putc16(StringBuffer *s, uint32_t c) {
  if (likely(s->len < s->size)) {
    if (s->is_wide_char) {
      s->str->u.str16[s->len++] = c;
      return 0;
    } else if (c < 0x100) {
      s->str->u.str8[s->len++] = c;
      return 0;
    }
  }
  return string_buffer_putc_slow(s, c);
}

/* 0 <= c <= 0x10ffff */
int string_buffer_putc(StringBuffer *s, uint32_t c) {
  if (unlikely(c >= 0x10000)) {
    /* surrogate pair */
    c -= 0x10000;
    if (string_buffer_putc16(s, (c >> 10) + 0xd800)) return -1;
    c = (c & 0x3ff) + 0xdc00;
  }
  return string_buffer_putc16(s, c);
}

QJS_STATIC int string_get(const JSString *p, int idx) {
  return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];
}

int string_getc(const JSString *p, int *pidx) {
  int idx, c, c1;
  idx = *pidx;
  if (p->is_wide_char) {
    c = p->u.str16[idx++];
    if (c >= 0xd800 && c < 0xdc00 && idx < p->len) {
      c1 = p->u.str16[idx];
      if (c1 >= 0xdc00 && c1 < 0xe000) {
        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
        idx++;
      }
    }
  } else {
    c = p->u.str8[idx++];
  }
  *pidx = idx;
  return c;
}

int string_buffer_write8(StringBuffer *s, const uint8_t *p, int len) {
  int i;

  if (s->len + len > s->size) {
    if (string_buffer_realloc(s, s->len + len, 0)) return -1;
  }
  if (s->is_wide_char) {
    for (i = 0; i < len; i++) {
      s->str->u.str16[s->len + i] = p[i];
    }
    s->len += len;
  } else {
    memcpy(&s->str->u.str8[s->len], p, len);
    s->len += len;
  }
  return 0;
}

QJS_STATIC int string_buffer_write16(StringBuffer *s, const uint16_t *p,
                                     int len) {
  int c = 0, i;

  for (i = 0; i < len; i++) {
    c |= p[i];
  }
  if (s->len + len > s->size) {
    if (string_buffer_realloc(s, s->len + len, c)) return -1;
  } else if (!s->is_wide_char && c >= 0x100) {
    if (string_buffer_widen(s, s->size)) return -1;
  }
  if (s->is_wide_char) {
    memcpy(&s->str->u.str16[s->len], p, len << 1);
    s->len += len;
  } else {
    for (i = 0; i < len; i++) {
      s->str->u.str8[s->len + i] = p[i];
    }
    s->len += len;
  }
  return 0;
}

/* appending an ASCII string */
QJS_STATIC int string_buffer_puts8(StringBuffer *s, const char *str) {
  return string_buffer_write8(s, (const uint8_t *)str, strlen(str));
}

int string_buffer_concat(StringBuffer *s, const JSString *p, uint32_t from,
                         uint32_t to) {
  if (to <= from) return 0;
  if (p->is_wide_char)
    return string_buffer_write16(s, p->u.str16 + from, to - from);
  else
    return string_buffer_write8(s, p->u.str8 + from, to - from);
}

QJS_STATIC int string_buffer_concat_value(StringBuffer *s, LEPUSValueConst v) {
  JSString *p;
  LEPUSValue v1;
  int res;

  if (s->error_status) {
    /* prevent exception overload */
    return -1;
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(v))) {
    v1 = JS_ToString_RC(s->ctx, v);
    if (LEPUS_IsException(v1)) return string_buffer_set_error(s);
    p = LEPUS_VALUE_GET_STRING(v1);
    res = string_buffer_concat(s, p, 0, p->len);
    LEPUS_FreeValue(s->ctx, v1);
    return res;
  }
  p = LEPUS_VALUE_GET_STRING(v);
  return string_buffer_concat(s, p, 0, p->len);
}

QJS_STATIC int string_buffer_concat_value_free(StringBuffer *s, LEPUSValue v) {
  JSString *p;
  int res;

  if (s->error_status) {
    /* prevent exception overload */
    LEPUS_FreeValue(s->ctx, v);
    return -1;
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(v))) {
    v = JS_ToStringFree(s->ctx, v);
    if (LEPUS_IsException(v)) return string_buffer_set_error(s);
  }
  p = LEPUS_VALUE_GET_STRING(v);
  res = string_buffer_concat(s, p, 0, p->len);
  LEPUS_FreeValue(s->ctx, v);
  return res;
}

int string_buffer_fill(StringBuffer *s, int c, int count) {
  /* XXX: optimize */
  if (s->len + count > s->size) {
    if (string_buffer_realloc(s, s->len + count, c)) return -1;
  }
  while (count-- > 0) {
    if (string_buffer_putc16(s, c)) return -1;
  }
  return 0;
}

QJS_STATIC LEPUSValue string_buffer_end(StringBuffer *s) {
  JSString *str;
  str = s->str;
  if (s->error_status) return LEPUS_EXCEPTION;
  if (s->len == 0) {
    if (!s->ctx->gc_enable) lepus_free(s->ctx, str);
    s->str = NULL;
    return LEPUS_AtomToString(s->ctx, JS_ATOM_empty_string);
  }
  if (s->len < s->size) {
    /* smaller size so lepus_realloc should not fail, but OK if it does */
    /* XXX: should add some slack to avoid unnecessary calls */
    /* XXX: might need to use malloc+free to ensure smaller size */
    str = static_cast<JSString *>(lepus_realloc_rt(
        s->ctx->rt, str,
        sizeof(JSString) + (s->len << s->is_wide_char) + 1 - s->is_wide_char,
        ALLOC_TAG_JSString));
    if (str == NULL) str = s->str;
    s->str = str;
  }
  if (!s->is_wide_char) str->u.str8[s->len] = 0;
#ifdef DUMP_LEAKS
  list_add_tail(&str->link, &s->ctx->rt->string_list);
#endif
  str->is_wide_char = s->is_wide_char;
  str->len = s->len;
  s->str = NULL;
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

/* create a string from a UTF-8 buffer */
LEPUSValue LEPUS_NewStringLen(LEPUSContext *ctx, const char *buf,
                              size_t buf_len) {
  CallGCFunc(JS_NewStringLen_GC, ctx, buf, buf_len);
  const uint8_t *p, *p_end, *p_start, *p_next;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;
  size_t len1;

  p_start = (const uint8_t *)buf;
  p_end = p_start + buf_len;
  p = p_start;
  while (p < p_end && *p < 128) p++;
  len1 = p - p_start;
  if (len1 > JS_STRING_LEN_MAX)
    return LEPUS_ThrowInternalError(ctx, "string too long");
  if (p == p_end) {
    /* ASCII string */
    return js_new_string8(ctx, (const uint8_t *)buf, buf_len);
  } else {
    if (string_buffer_init(ctx, b, buf_len)) goto fail;
    string_buffer_write8(b, p_start, len1);
    while (p < p_end) {
      if (*p < 128) {
        string_buffer_putc8(b, *p++);
      } else {
        /* parse utf-8 sequence, return 0xFFFFFFFF for error */
        c = unicode_from_utf8(p, p_end - p, &p_next);
        if (c < 0x10000) {
          p = p_next;
        } else if (c <= 0x10FFFF) {
          p = p_next;
          /* surrogate pair */
          c -= 0x10000;
          string_buffer_putc16(b, (c >> 10) + 0xd800);
          c = (c & 0x3ff) + 0xdc00;
        } else {
          /* invalid char */
          c = 0xfffd;
          /* skip the invalid chars */
          /* XXX: seems incorrect. Why not just use c = *p++; ? */
          while (p < p_end && (*p >= 0x80 && *p < 0xc0)) p++;
          if (p < p_end) {
            p++;
            while (p < p_end && (*p >= 0x80 && *p < 0xc0)) p++;
          }
        }
        string_buffer_putc16(b, c);
      }
    }
  }
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_ConcatString3(LEPUSContext *ctx, const char *str1,
                                       LEPUSValue str2, const char *str3) {
  StringBuffer b_s, *b = &b_s;
  int len1, len3;
  JSString *p;

  if (unlikely(!LEPUS_VALUE_IS_STRING(str2))) {
    str2 = JS_ToStringFree(ctx, str2);
    if (LEPUS_IsException(str2)) goto fail;
  }
  p = LEPUS_VALUE_GET_STRING(str2);
  len1 = strlen(str1);
  len3 = strlen(str3);

  if (string_buffer_init2(ctx, b, len1 + p->len + len3, p->is_wide_char))
    goto fail;

  string_buffer_write8(b, (const uint8_t *)str1, len1);
  string_buffer_concat(b, p, 0, p->len);
  string_buffer_write8(b, (const uint8_t *)str3, len3);

  LEPUS_FreeValue(ctx, str2);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str2);
  return LEPUS_EXCEPTION;
}

LEPUSValue LEPUS_NewString(LEPUSContext *ctx, const char *str) {
  CallGCFunc(JS_NewString_GC, ctx, str);
  return LEPUS_NewStringLen(ctx, str, strlen(str));
}

LEPUSValue LEPUS_NewAtomString(LEPUSContext *ctx, const char *str) {
  CallGCFunc(JS_NewAtomString_GC, ctx, str);
  JSAtom atom = LEPUS_NewAtom(ctx, str);
  if (atom == JS_ATOM_NULL) return LEPUS_EXCEPTION;
  LEPUSValue val = LEPUS_AtomToString(ctx, atom);
  LEPUS_FreeAtom(ctx, atom);
  return val;
}

/* return (NULL, 0) if exception. */
/* return pointer into a JSString with a live ref_count */
/* cesu8 determines if non-BMP1 codepoints are encoded as 1 or 2 utf-8 sequences
 */
static const char *JS_ToCStringLen2_RC(LEPUSContext *ctx, size_t *plen,
                                       LEPUSValueConst val1, BOOL cesu8) {
  LEPUSValue val;
  JSString *str, *str_new;
  int pos, len, c, c1;
  uint8_t *q;

  if (!LEPUS_VALUE_IS_STRING(val1)) {
    val = JS_ToString_RC(ctx, val1);
    if (LEPUS_IsException(val)) goto fail;
  } else {
    val = LEPUS_DupValue(ctx, val1);
  }

  str = LEPUS_VALUE_GET_STRING(val);
  len = str->len;
  if (!str->is_wide_char) {
    const uint8_t *src = str->u.str8;
    int count;

    /* count the number of non-ASCII characters */
    /* Scanning the whole string is required for ASCII strings,
       and computing the number of non-ASCII bytes is less expensive
       than testing each byte, hence this method is faster for ASCII
       strings, which is the most common case.
     */
    count = 0;
    for (pos = 0; pos < len; pos++) {
      count += src[pos] >> 7;
    }
    if (count == 0) {
      if (plen) *plen = len;
      return (const char *)src;
    }
    str_new = js_alloc_string(ctx, len + count, 0);
    if (!str_new) goto fail;
    q = str_new->u.str8;
    for (pos = 0; pos < len; pos++) {
      c = src[pos];
      if (c < 0x80) {
        *q++ = c;
      } else {
        *q++ = (c >> 6) | 0xc0;
        *q++ = (c & 0x3f) | 0x80;
      }
    }
  } else {
    const uint16_t *src = str->u.str16;
    /* Allocate 3 bytes per 16 bit code point. Surrogate pairs may
       produce 4 bytes but use 2 code points.
     */
    str_new = js_alloc_string(ctx, len * 3, 0);
    if (!str_new) goto fail;
    q = str_new->u.str8;
    pos = 0;
    while (pos < len) {
      c = src[pos++];
      if (c < 0x80) {
        *q++ = c;
      } else {
        if (c >= 0xd800 && c < 0xdc00) {
          if (pos < len && !cesu8) {
            c1 = src[pos];
            if (c1 >= 0xdc00 && c1 < 0xe000) {
              pos++;
              /* surrogate pair */
              c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
            } else {
              /* Keep unmatched surrogate code points */
              /* c = 0xfffd; */ /* error */
            }
          } else {
            /* Keep unmatched surrogate code points */
            /* c = 0xfffd; */ /* error */
          }
        }
        q += unicode_to_utf8(q, c);
      }
    }
  }

  *q = '\0';
  str_new->len = q - str_new->u.str8;
  LEPUS_FreeValue(ctx, val);
  if (plen) *plen = str_new->len;
  return (const char *)str_new->u.str8;
fail:
  if (plen) *plen = 0;
  return NULL;
}

const char *LEPUS_ToCStringLen2(LEPUSContext *ctx, size_t *plen,
                                LEPUSValueConst val1, BOOL cesu8) {
  CallGCFunc(JS_ToCStringLen2_GC, ctx, plen, val1, cesu8);
  return JS_ToCStringLen2_RC(ctx, plen, val1, cesu8);
}

void LEPUS_FreeCString(LEPUSContext *ctx, const char *ptr) {
  DCHECK(!ctx->gc_enable);
  JSString *p;
  if (!ptr) return;
  /* purposely removing constness */
  p = (JSString *)(void *)(ptr - offsetof(JSString, u));
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
}

QJS_STATIC int memcmp16_8(const uint16_t *src1, const uint8_t *src2, int len) {
  int c, i;
  for (i = 0; i < len; i++) {
    c = src1[i] - src2[i];
    if (c != 0) return c;
  }
  return 0;
}

QJS_STATIC int memcmp16(const uint16_t *src1, const uint16_t *src2, int len) {
  int c, i;
  for (i = 0; i < len; i++) {
    c = src1[i] - src2[i];
    if (c != 0) return c;
  }
  return 0;
}

QJS_STATIC int js_string_memcmp(const JSString *p1, const JSString *p2,
                                int len) {
  int res;

  if (likely(!p1->is_wide_char)) {
    if (likely(!p2->is_wide_char))
      res = memcmp(p1->u.str8, p2->u.str8, len);
    else
      res = -memcmp16_8(p2->u.str16, p1->u.str8, len);
  } else {
    if (!p2->is_wide_char)
      res = memcmp16_8(p1->u.str16, p2->u.str8, len);
    else
      res = memcmp16(p1->u.str16, p2->u.str16, len);
  }
  return res;
}

/* return < 0, 0 or > 0 */
int js_string_compare(LEPUSContext *ctx, const JSString *p1,
                      const JSString *p2) {
  int res, len;
  len = min_int(p1->len, p2->len);
  res = js_string_memcmp(p1, p2, len);
  if (res == 0) {
    if (p1->len == p2->len)
      res = 0;
    else if (p1->len < p2->len)
      res = -1;
    else
      res = 1;
  }
  return res;
}

QJS_STATIC void copy_str16(uint16_t *dst, const JSString *p, int offset,
                           int len) {
  if (p->is_wide_char) {
    memcpy(dst, p->u.str16 + offset, len * 2);
  } else {
    const uint8_t *src1 = p->u.str8 + offset;
    int i;

    for (i = 0; i < len; i++) dst[i] = src1[i];
  }
}

QJS_STATIC LEPUSValue JS_ConcatString1(LEPUSContext *ctx, const JSString *p1,
                                       const JSString *p2) {
  JSString *p;
  uint32_t len;
  int is_wide_char;

  len = p1->len + p2->len;
  if (len > JS_STRING_LEN_MAX)
    return LEPUS_ThrowInternalError(ctx, "string too long");
  is_wide_char = p1->is_wide_char | p2->is_wide_char;
  p = js_alloc_string(ctx, len, is_wide_char);
  if (!p) return LEPUS_EXCEPTION;
  if (!is_wide_char) {
    memcpy(p->u.str8, p1->u.str8, p1->len);
    memcpy(p->u.str8 + p1->len, p2->u.str8, p2->len);
    p->u.str8[len] = '\0';
  } else {
    copy_str16(p->u.str16, p1, 0, p1->len);
    copy_str16(p->u.str16 + p1->len, p2, 0, p2->len);
  }
  return LEPUS_MKPTR(LEPUS_TAG_STRING, p);
}

/* op1 and op2 are converted to strings. For convience, op1 or op2 =
   LEPUS_EXCEPTION are accepted and return LEPUS_EXCEPTION.  */
LEPUSValue JS_ConcatStringOriginal(LEPUSContext *ctx, LEPUSValue op1,
                                   LEPUSValue op2) {
  LEPUSValue ret;
  JSString *p1, *p2;

  if (unlikely(!LEPUS_VALUE_IS_STRING(op1))) {
    op1 = JS_ToStringFree(ctx, op1);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      return LEPUS_EXCEPTION;
    }
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(op2))) {
    op2 = JS_ToStringFree(ctx, op2);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      return LEPUS_EXCEPTION;
    }
  }
  p1 = LEPUS_VALUE_GET_STRING(op1);
  p2 = LEPUS_VALUE_GET_STRING(op2);

  /* XXX: could also check if p1 is empty */
  if (p2->len == 0) {
    goto ret_op1;
  }
  if (p1->header.ref_count == 1 && p1->is_wide_char == p2->is_wide_char &&
      ctx->rt->mf.lepus_malloc_usable_size(p1) >=
          sizeof(*p1) + ((p1->len + p2->len) << p2->is_wide_char) + 1 -
              p1->is_wide_char) {
    /* Concatenate in place in available space at the end of p1 */
    if (p1->is_wide_char) {
      memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);
      p1->len += p2->len;
    } else {
      memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);
      p1->len += p2->len;
      p1->u.str8[p1->len] = '\0';
    }
  ret_op1:
    LEPUS_FreeValue(ctx, op2);
    return op1;
  }
  ret = JS_ConcatString1(ctx, p1, p2);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return ret;
}

QJS_STATIC LEPUSValue JS_ConcatSeparableString(LEPUSContext *ctx,
                                               LEPUSValue op1, LEPUSValue op2) {
  LEPUSValue ret;
  JSString *p1, *p2;

  if (unlikely(!LEPUS_IsString(op1))) {
    op1 = JS_ToStringFree(ctx, op1);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      return LEPUS_EXCEPTION;
    }
  }

  if (unlikely(!(LEPUS_IsString(op2)))) {
    op2 = JS_ToStringFree(ctx, op2);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      return LEPUS_EXCEPTION;
    }
  }

  auto *separable_string = static_cast<JSSeparableString *>(
      lepus_malloc(ctx, sizeof(JSSeparableString)));
  if (!separable_string) return LEPUS_EXCEPTION;
  uint8_t is_wide_char = 0;
  uint32_t len = 0;
  uint32_t depth = 1;
  if (JS_IsSeparableString(op1)) {
    auto *p = JS_GetSeparableString(op1);
    is_wide_char = p->is_wide_char;
    len = p->len;
    depth = p->depth + 1;
  } else {
    p1 = LEPUS_VALUE_GET_STRING(op1);
    is_wide_char = p1->is_wide_char;
    len = p1->len;
  }

  if (JS_IsSeparableString(op2)) {
    auto *p = JS_GetSeparableString(op2);
    is_wide_char |= p->is_wide_char;
    len += p->len;
    depth = (p->depth >= depth) ? p->depth + 1 : depth;
  } else {
    p2 = LEPUS_VALUE_GET_STRING(op2);
    is_wide_char |= p2->is_wide_char;
    len += p2->len;
  }

  separable_string->header.ref_count = 1;
  separable_string->len = len;
  separable_string->is_wide_char = is_wide_char;
  separable_string->depth = depth;
  separable_string->left_op = op1;
  separable_string->right_op = op2;
  separable_string->flat_content = LEPUS_UNDEFINED;
  return LEPUS_MKPTR(LEPUS_TAG_SEPARABLE_STRING, separable_string);
}

LEPUSValue JS_ConcatString(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2) {
  if (separable_string_disabled(ctx->rt)) {
    return JS_ConcatStringOriginal(ctx, op1, op2);
  }
  return JS_ConcatSeparableString(ctx, op1, op2);
}

void JS_FreeSeparableString(LEPUSRuntime *rt, LEPUSValue val) {
  assert(JS_IsSeparableString(val));
  auto *cur = JS_GetSeparableString(val);
  CStack stack(rt, cur->depth);

  cur->header.ref_count++;
  while (cur || !stack.Empty()) {
    while (cur) {
      if (--cur->header.ref_count == 0) {
        if (LEPUS_IsUndefined(cur->flat_content)) {
          stack.Push(cur);
          if (JS_IsSeparableString(cur->left_op)) {
            cur = JS_GetSeparableString(cur->left_op);
            continue;
          }
          LEPUS_FreeValueRT(rt, cur->left_op);
        } else {
          LEPUS_FreeValueRT(rt, cur->flat_content);
          lepus_free_rt(rt, cur);
        }
      }
      cur = nullptr;
    }

    if (!stack.Empty()) {
      cur = stack.Top();
      stack.Pop();
      auto right_op = cur->right_op;
      lepus_free_rt(rt, cur);
      if (JS_IsSeparableString(right_op)) {
        cur = JS_GetSeparableString(right_op);
      } else {
        LEPUS_FreeValueRT(rt, right_op);
        cur = nullptr;
      }
    }
  }
}

LEPUSValue JS_GetSeparableStringContentNotDup(LEPUSContext *ctx,
                                              LEPUSValue val) {
  assert(JS_IsSeparableString(val));
  auto *separable_string = JS_GetSeparableString(val);

  if (LEPUS_VALUE_IS_STRING(separable_string->flat_content)) {
    return separable_string->flat_content;
  }

  StringBuffer b_s, *b = &b_s;
  string_buffer_init2(ctx, b, separable_string->len,
                      separable_string->is_wide_char);

  CStack stack(ctx->rt, separable_string->depth);
  auto *cur = separable_string;
  while (cur || !stack.Empty()) {
    while (cur) {
      if (LEPUS_IsUndefined(cur->flat_content)) {
        stack.Push(cur);
        if (JS_IsSeparableString(cur->left_op)) {
          cur = JS_GetSeparableString(cur->left_op);
          continue;
        } else {
          string_buffer_concat_value(b, cur->left_op);
        }
      } else {
        string_buffer_concat_value(b, cur->flat_content);
      }
      cur = nullptr;
    }

    if (!stack.Empty()) {
      cur = stack.Top();
      stack.Pop();
      if (!JS_IsSeparableString(cur->right_op)) {
        string_buffer_concat_value(b, cur->right_op);
        cur = nullptr;
      } else {
        cur = JS_GetSeparableString(cur->right_op);
      }
    }
  }
  separable_string->flat_content = string_buffer_end(b);
  LEPUS_FreeValue(ctx, separable_string->left_op);
  LEPUS_FreeValue(ctx, separable_string->right_op);
  separable_string->left_op = LEPUS_NULL;
  separable_string->right_op = LEPUS_NULL;
  return separable_string->flat_content;
}

LEPUSValue JS_GetSeparableStringContent(LEPUSContext *ctx, LEPUSValue val) {
  return LEPUS_DupValue(ctx, JS_GetSeparableStringContentNotDup(ctx, val));
}

QJS_STATIC int init_shape_hash(LEPUSRuntime *rt) {
  rt->shape_hash_bits = 4; /* 16 shapes */
  rt->shape_hash_size = 1 << rt->shape_hash_bits;
  rt->shape_hash_count = 0;
  rt->shape_hash = static_cast<JSShape **>(
      lepus_mallocz_rt(rt, sizeof(rt->shape_hash[0]) * rt->shape_hash_size));
  if (!rt->shape_hash) return -1;
  return 0;
}

/* same magic hash multiplier as the Linux kernel */
QJS_STATIC uint32_t shape_hash(uint32_t h, uint32_t val) {
  return (h + val) * 0x9e370001;
}

/* truncate the shape hash to 'hash_bits' bits */
QJS_STATIC uint32_t get_shape_hash(uint32_t h, int hash_bits) {
  return h >> (32 - hash_bits);
}

QJS_STATIC uint32_t shape_initial_hash(LEPUSObject *proto) {
  uint32_t h;
  h = shape_hash(1, (uintptr_t)proto);
  if (sizeof(proto) > 4) h = shape_hash(h, (uint64_t)(uintptr_t)proto >> 32);
  return h;
}

int resize_shape_hash(LEPUSRuntime *rt, int new_shape_hash_bits) {
  int new_shape_hash_size, i;
  uint32_t h;
  JSShape **new_shape_hash, *sh, *sh_next;

  new_shape_hash_size = 1 << new_shape_hash_bits;
  new_shape_hash = static_cast<JSShape **>(
      lepus_mallocz_rt(rt, sizeof(rt->shape_hash[0]) * new_shape_hash_size,
                       ALLOC_TAG_WITHOUT_PTR));
  if (!new_shape_hash) return -1;
  for (i = 0; i < rt->shape_hash_size; i++) {
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh_next) {
      sh_next = sh->shape_hash_next;
      h = get_shape_hash(sh->hash, new_shape_hash_bits);
      sh->shape_hash_next = new_shape_hash[h];
      new_shape_hash[h] = sh;
    }
  }
  if (!rt->gc_enable) lepus_free_rt(rt, rt->shape_hash);
  rt->shape_hash_bits = new_shape_hash_bits;
  rt->shape_hash_size = new_shape_hash_size;
  rt->shape_hash = new_shape_hash;
  return 0;
}

void js_shape_hash_link(LEPUSRuntime *rt, JSShape *sh) {
  uint32_t h;
  h = get_shape_hash(sh->hash, rt->shape_hash_bits);
  sh->shape_hash_next = rt->shape_hash[h];
  rt->shape_hash[h] = sh;
  rt->shape_hash_count++;
}

void js_shape_hash_unlink(LEPUSRuntime *rt, JSShape *sh) {
  uint32_t h;
  JSShape **psh;

  h = get_shape_hash(sh->hash, rt->shape_hash_bits);
  psh = &rt->shape_hash[h];
  while (*psh != sh) {
    if (*psh == nullptr) return;
    psh = &(*psh)->shape_hash_next;
  }
  *psh = sh->shape_hash_next;
  rt->shape_hash_count--;
}

/* create a new empty shape with prototype 'proto' */
QJS_STATIC no_inline JSShape *js_new_shape2(LEPUSContext *ctx,
                                            LEPUSObject *proto, int hash_size,
                                            int prop_size) {
  LEPUSRuntime *rt = ctx->rt;
  void *sh_alloc;
  JSShape *sh;

  /* resize the shape hash table if necessary */
  if (2 * (rt->shape_hash_count + 1) > rt->shape_hash_size) {
    resize_shape_hash(rt, rt->shape_hash_bits + 1);
  }

  sh_alloc = lepus_malloc(ctx, get_shape_size(hash_size, prop_size),
                          ALLOC_TAG_JSShape);
  if (!sh_alloc) return NULL;
  sh = get_shape_from_alloc(sh_alloc, hash_size);
  sh->header.ref_count = 1;
  sh->gc_header.mark = 0;
  if (proto) LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, proto));
  sh->proto = proto;
  memset(sh->prop_hash_end - hash_size, 0,
         sizeof(sh->prop_hash_end[0]) * hash_size);
  sh->prop_hash_mask = hash_size - 1;
  sh->prop_count = 0;
  sh->prop_size = prop_size;

  /* insert in the hash table */
  sh->hash = shape_initial_hash(proto);
  sh->is_hashed = TRUE;
  sh->has_small_array_index = FALSE;
  js_shape_hash_link(ctx->rt, sh);
  return sh;
}

QJS_STATIC JSShape *js_new_shape(LEPUSContext *ctx, LEPUSObject *proto) {
  return js_new_shape2(ctx, proto, JS_PROP_INITIAL_HASH_SIZE,
                       JS_PROP_INITIAL_SIZE);
}

/* The shape is cloned. The new shape is not inserted in the shape
   hash table */
QJS_STATIC JSShape *js_clone_shape(LEPUSContext *ctx, JSShape *sh1) {
  JSShape *sh;
  void *sh_alloc, *sh_alloc1;
  size_t size;
  JSShapeProperty *pr;
  uint32_t i, hash_size;

  hash_size = sh1->prop_hash_mask + 1;
  size = get_shape_size(hash_size, sh1->prop_size);
  sh_alloc = lepus_malloc(ctx, size);
  if (!sh_alloc) return NULL;
  sh_alloc1 = get_alloc_from_shape(sh1);
  memcpy(sh_alloc, sh_alloc1, size);
  sh = get_shape_from_alloc(sh_alloc, hash_size);
  sh->header.ref_count = 1;
  sh->gc_header.mark = 0;
  sh->is_hashed = FALSE;
  if (sh->proto) {
    LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  }
  for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
    LEPUS_DupAtom(ctx, pr->atom);
  }
  return sh;
}

JSShape *js_dup_shape(JSShape *sh) {
  sh->header.ref_count++;
  return sh;
}

QJS_STATIC void js_free_shape0(LEPUSRuntime *rt, JSShape *sh) {
  uint32_t i;
  JSShapeProperty *pr;
  if (sh->header.ref_count < 0) {
    return;
  }

  assert(sh->header.ref_count == 0);
  if (sh->is_hashed) js_shape_hash_unlink(rt, sh);
  if (sh->proto != NULL) {
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  }
  pr = get_shape_prop(sh);
  for (i = 0; i < sh->prop_count; i++) {
    LEPUS_FreeAtomRT(rt, pr->atom);
    pr++;
  }
  lepus_free_rt(rt, get_alloc_from_shape(sh));
}

QJS_STATIC void js_free_shape(LEPUSRuntime *rt, JSShape *sh) {
  if (unlikely(--sh->header.ref_count <= 0)) {
    js_free_shape0(rt, sh);
  }
}

QJS_STATIC void js_free_shape_null(LEPUSRuntime *rt, JSShape *sh) {
  if (sh) js_free_shape(rt, sh);
}

/* make space to hold at least 'count' properties */
no_inline int resize_properties(LEPUSContext *ctx, JSShape **psh,
                                LEPUSObject *p, uint32_t count) {
  JSShape *sh;
  uint32_t new_size, new_hash_size, new_hash_mask, i;
  JSShapeProperty *pr;
  void *sh_alloc;
  intptr_t h;

  sh = *psh;
  new_size = max_int(count, sh->prop_size * 3 / 2);
  /* Reallocate prop array first to avoid crash or size inconsistency
     in case of memory allocation failure */
  if (p) {
    JSProperty *new_prop;
    new_prop = static_cast<JSProperty *>(lepus_realloc(
        ctx, p->prop, sizeof(new_prop[0]) * new_size, ALLOC_TAG_WITHOUT_PTR));
    if (unlikely(!new_prop)) return -1;
    p->prop = new_prop;
  }
  new_hash_size = sh->prop_hash_mask + 1;
  while (new_hash_size < new_size) new_hash_size = 2 * new_hash_size;
  if (new_hash_size != (sh->prop_hash_mask + 1)) {
    JSShape *old_sh;
    /* resize the hash table and the properties */
    old_sh = sh;
    sh_alloc = lepus_mallocz(ctx, get_shape_size(new_hash_size, new_size),
                             ALLOC_TAG_JSShape);
    if (!sh_alloc) return -1;
#ifndef _WIN32
    if (ctx->gc_enable) set_hash_size(sh_alloc, new_hash_size);
#endif
    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
    /* copy all the fields and the properties */
    memcpy(sh, old_sh,
           sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
    new_hash_mask = new_hash_size - 1;
    sh->prop_hash_mask = new_hash_mask;
    memset(sh->prop_hash_end - new_hash_size, 0,
           sizeof(sh->prop_hash_end[0]) * new_hash_size);
    for (i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {
      if (pr->atom != JS_ATOM_NULL) {
        h = ((uintptr_t)pr->atom & new_hash_mask);
        pr->hash_next = sh->prop_hash_end[-h - 1];
        sh->prop_hash_end[-h - 1] = i + 1;
      }
    }
    if (!ctx->gc_enable) lepus_free(ctx, get_alloc_from_shape(old_sh));
  } else {
    /* only resize the properties */
    sh_alloc = lepus_realloc(ctx, get_alloc_from_shape(sh),
                             get_shape_size(new_hash_size, new_size),
                             ALLOC_TAG_JSShape);
    if (unlikely(!sh_alloc)) return -1;
#ifndef _WIN32
    if (ctx->gc_enable) set_hash_size(sh_alloc, new_hash_size);
#endif
    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
  }
  *psh = sh;
  sh->prop_size = new_size;
  return 0;
}

QJS_STATIC int add_shape_property(LEPUSContext *ctx, JSShape **psh,
                                  LEPUSObject *p, JSAtom atom, int prop_flags) {
  LEPUSRuntime *rt = ctx->rt;
  JSShape *sh = *psh;
  JSShapeProperty *pr, *prop;
  uint32_t hash_mask, new_shape_hash = 0;
  intptr_t h;

  /* update the shape hash */
  if (sh->is_hashed) {
    js_shape_hash_unlink(rt, sh);
    new_shape_hash = shape_hash(shape_hash(sh->hash, atom), prop_flags);
  }

  if (unlikely(sh->prop_count >= sh->prop_size)) {
    if (resize_properties(ctx, psh, p, sh->prop_count + 1)) {
      /* in case of error, reinsert in the hash table.
         sh is still valid if resize_properties() failed */
      if (sh->is_hashed) js_shape_hash_link(rt, sh);
      return -1;
    }
    sh = *psh;
  }
  if (sh->is_hashed) {
    sh->hash = new_shape_hash;
    js_shape_hash_link(rt, sh);
  }
  /* Initialize the new shape property.
     The object property at p->prop[sh->prop_count] is uninitialized */
  prop = get_shape_prop(sh);
  pr = &prop[sh->prop_count++];
  pr->atom = LEPUS_DupAtom(ctx, atom);
  pr->flags = prop_flags;
  sh->has_small_array_index |= __JS_AtomIsTaggedInt(atom);
  /* add in hash table */
  hash_mask = sh->prop_hash_mask;
  h = atom & hash_mask;
  pr->hash_next = sh->prop_hash_end[-h - 1];
  sh->prop_hash_end[-h - 1] = sh->prop_count;
  return 0;
}

/* find a hashed empty shape matching the prototype. Return NULL if
   not found */
QJS_STATIC JSShape *find_hashed_shape_proto(LEPUSRuntime *rt,
                                            LEPUSObject *proto) {
  JSShape *sh1;
  uint32_t h, h1;

  h = shape_initial_hash(proto);
  h1 = get_shape_hash(h, rt->shape_hash_bits);
  for (sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
    if (sh1->hash == h && sh1->proto == proto && sh1->prop_count == 0) {
      return sh1;
    }
  }
  return NULL;
}

/* find a hashed shape matching sh + (prop, prop_flags). Return NULL if
   not found */
QJS_STATIC JSShape *find_hashed_shape_prop(LEPUSRuntime *rt, JSShape *sh,
                                           JSAtom atom, int prop_flags) {
  JSShape *sh1;
  uint32_t h, h1, i, n;

  h = sh->hash;
  h = shape_hash(h, atom);
  h = shape_hash(h, prop_flags);
  h1 = get_shape_hash(h, rt->shape_hash_bits);
  for (sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
    /* we test the hash first so that the rest is done only if the
       shapes really match */
    if (sh1->hash == h && sh1->proto == sh->proto &&
        sh1->prop_count == ((n = sh->prop_count) + 1)) {
      for (i = 0; i < n; i++) {
        if (unlikely(sh1->prop[i].atom != sh->prop[i].atom) ||
            unlikely(sh1->prop[i].flags != sh->prop[i].flags))
          goto next;
      }
      if (unlikely(sh1->prop[n].atom != atom) ||
          unlikely(sh1->prop[n].flags != prop_flags))
        goto next;
      return sh1;
    }
  next:;
  }
  return NULL;
}

QJS_STATIC __attribute__((unused)) void JS_DumpShape(LEPUSRuntime *rt, int i,
                                                     JSShape *sh) {
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  int j;

  /* XXX: should output readable class prototype */
  printf("%5d %3d%c %14p %5d %5d", i, sh->header.ref_count, " *"[sh->is_hashed],
         (void *)sh -> proto, sh -> prop_size, sh -> prop_count);
  for (j = 0; j < sh->prop_count; j++) {
    printf(" %s",
           JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), sh->prop[j].atom));
  }
  printf("\n");
}

QJS_STATIC __attribute__((unused)) void JS_DumpShapes(LEPUSRuntime *rt) {
  int i;
  JSShape *sh;
  struct list_head *el;
  LEPUSObject *p;

  printf("JSShapes: {\n");
  printf("%5s %4s %14s %5s %5s %s\n", "SLOT", "REFS", "PROTO", "SIZE", "COUNT",
         "PROPS");
  for (i = 0; i < rt->shape_hash_size; i++) {
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
      JS_DumpShape(rt, i, sh);
      assert(sh->is_hashed);
    }
  }
  /* dump non-hashed shapes */
  list_for_each(el, &rt->obj_list) {
    p = list_entry(el, LEPUSObject, link);
    if (!p->shape->is_hashed) {
      JS_DumpShape(rt, -1, p->shape);
    }
  }
  printf("}\n");
}

QJS_HIDE LEPUSValue JS_NewObjectFromShape(LEPUSContext *ctx, JSShape *sh,
                                          LEPUSClassID class_id) {
  LEPUSObject *p;

  js_trigger_gc(ctx->rt, sizeof(LEPUSObject));
  p = static_cast<LEPUSObject *>(lepus_malloc(ctx, sizeof(LEPUSObject)));
  if (unlikely(!p)) goto fail;
  p->header.ref_count = 1;
  p->gc_header.mark = 0;
  p->class_id = class_id;
  p->extensible = TRUE;
  p->free_mark = 0;
  p->is_exotic = 0;
  p->fast_array = 0;
  p->is_constructor = 0;
  p->is_uncatchable_error = 0;
  p->is_class = 0;
  p->tmp_mark = 0;
  p->first_weak_ref = NULL;
  p->u.opaque = NULL;
  p->shape = sh;
  p->prop = static_cast<JSProperty *>(
      lepus_malloc(ctx, sizeof(JSProperty) * sh->prop_size));
  if (unlikely(!p->prop)) {
    lepus_free(ctx, p);
  fail:
    js_free_shape(ctx->rt, sh);
    return LEPUS_EXCEPTION;
  }

  switch (class_id) {
    case JS_CLASS_OBJECT:
      break;
    case JS_CLASS_ARRAY: {
      JSProperty *pr;
      p->is_exotic = 1;
      p->fast_array = 1;
      p->u.array.u.values = NULL;
      p->u.array.count = 0;
      p->u.array.u1.size = 0;
      /* the length property is always the first one */
      if (likely(sh == ctx->array_shape)) {
        pr = &p->prop[0];
      } else {
        /* only used for the first array */
        /* cannot fail */
        pr = add_property(ctx, p, JS_ATOM_length,
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH);
      }
      pr->u.value = LEPUS_NewInt32(ctx, 0);
    } break;
    case JS_CLASS_C_FUNCTION:
      p->prop[0].u.value = LEPUS_UNDEFINED;
      break;
    case JS_CLASS_ARGUMENTS:
    case JS_CLASS_UINT8C_ARRAY ... JS_CLASS_FLOAT64_ARRAY:
      p->is_exotic = 1;
      p->fast_array = 1;
      p->u.array.u.ptr = NULL;
      p->u.array.count = 0;
      break;
    case JS_CLASS_DATAVIEW:
      p->u.array.u.ptr = NULL;
      p->u.array.count = 0;
      break;
    case JS_CLASS_NUMBER:
    case JS_CLASS_STRING:
    case JS_CLASS_BOOLEAN:
    case JS_CLASS_SYMBOL:
    case JS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
    case JS_CLASS_BIG_INT:
    case JS_CLASS_BIG_FLOAT:
#endif
      p->u.object_data = LEPUS_UNDEFINED;
      goto set_exotic;
    case JS_CLASS_REGEXP:
      p->u.regexp.pattern = NULL;
      p->u.regexp.bytecode = NULL;
      goto set_exotic;
    default:
    set_exotic:
      if (ctx->rt->class_array[class_id].exotic) {
        p->is_exotic = 1;
      }
      break;
  }
  list_add_tail(&p->link, &ctx->rt->obj_list);
  return LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
}

QJS_STATIC LEPUSObject *get_proto_obj(LEPUSValueConst proto_val) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(proto_val))
    return NULL;
  else
    return LEPUS_VALUE_GET_OBJ(proto_val);
}

/* WARNING: proto must be an object or LEPUS_NULL */
static LEPUSValue JS_NewObjectProtoClass_RC(LEPUSContext *ctx,
                                            LEPUSValueConst proto_val,
                                            LEPUSClassID class_id) {
  JSShape *sh;
  LEPUSObject *proto;

  proto = get_proto_obj(proto_val);
  sh = find_hashed_shape_proto(ctx->rt, proto);
  if (likely(sh)) {
    sh = js_dup_shape(sh);
  } else {
    sh = js_new_shape(ctx, proto);
    if (!sh) return LEPUS_EXCEPTION;
  }
  return JS_NewObjectFromShape(ctx, sh, class_id);
}

LEPUSValue LEPUS_NewObjectProtoClass(LEPUSContext *ctx,
                                     LEPUSValueConst proto_val,
                                     LEPUSClassID class_id) {
  CallGCFunc(JS_NewObjectProtoClass_GC, ctx, proto_val, class_id);
  return JS_NewObjectProtoClass_RC(ctx, proto_val, class_id);
}

#if 0
static LEPUSValue JS_GetObjectData(LEPUSContext *ctx, LEPUSValueConst obj)
{
    LEPUSObject *p;

    if (LEPUS_VALUE_IS_OBJECT(obj)) {
        p = LEPUS_VALUE_GET_OBJ(obj);
        switch(p->class_id) {
        case JS_CLASS_NUMBER:
        case JS_CLASS_STRING:
        case JS_CLASS_BOOLEAN:
        case JS_CLASS_SYMBOL:
        case JS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
        case JS_CLASS_BIG_INT:
        case JS_CLASS_BIG_FLOAT:
#endif
            return LEPUS_DupValue(ctx, p->u.object_data);
        }
    }
    return LEPUS_UNDEFINED;
}
#endif

QJS_STATIC int JS_SetObjectData(LEPUSContext *ctx, LEPUSValueConst obj,
                                LEPUSValue val) {
  LEPUSObject *p;

  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    switch (p->class_id) {
      case JS_CLASS_NUMBER:
      case JS_CLASS_STRING:
      case JS_CLASS_BOOLEAN:
      case JS_CLASS_SYMBOL:
      case JS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT:
      case JS_CLASS_BIG_FLOAT:
#endif
        if (!ctx->gc_enable) {
          LEPUS_FreeValue(ctx, p->u.object_data);
        }
        p->u.object_data = val;
        return 0;
    }
  }
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, val);
  }
  if (!LEPUS_IsException(obj)) LEPUS_ThrowTypeError(ctx, "invalid object type");
  return -1;
}

LEPUSValue LEPUS_NewObjectClass(LEPUSContext *ctx, int class_id) {
  CallGCFunc(JS_NewObjectClass_GC, ctx, class_id);
  return JS_NewObjectProtoClass_RC(ctx, ctx->class_proto[class_id], class_id);
}

LEPUSValue LEPUS_NewObjectProto(LEPUSContext *ctx, LEPUSValueConst proto) {
  CallGCFunc(JS_NewObjectProto_GC, ctx, proto);
  return JS_NewObjectProtoClass_RC(ctx, proto, JS_CLASS_OBJECT);
}

LEPUSValue PRIM_JS_NewArray(LEPUSContext *ctx) {
  return JS_NewObjectFromShape(ctx, js_dup_shape(ctx->array_shape),
                               JS_CLASS_ARRAY);
}

LEPUSValue LEPUS_NewArray(LEPUSContext *ctx) {
  CallGCFunc(JS_NewArray_GC, ctx);
  return JS_NewObjectFromShape(ctx, js_dup_shape(ctx->array_shape),
                               JS_CLASS_ARRAY);
}

// <primjs begin>
LEPUSValue PRIM_JS_NewObject(LEPUSContext *ctx) {
  /* inline LEPUS_NewObjectClass(ctx, JS_CLASS_OBJECT); */
  return JS_NewObjectProtoClass_RC(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                   JS_CLASS_OBJECT);
}
// <primjs end>

LEPUSValue LEPUS_NewObject(LEPUSContext *ctx) {
  CallGCFunc(JS_NewObject_GC, ctx);
  /* inline LEPUS_NewObjectClass(ctx, JS_CLASS_OBJECT); */
  return JS_NewObjectProtoClass_RC(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                   JS_CLASS_OBJECT);
}

QJS_STATIC void js_function_set_properties(LEPUSContext *ctx, LEPUSObject *p,
                                           JSAtom name, int len) {
  /* ES6 feature non compatible with ES5.1: length is configurable */
  /*
   * It's guaranteed that the object p doesn't have these two props;
   */
  JSProperty *pr;
  static constexpr int32_t prop_flag = LEPUS_PROP_CONFIGURABLE;
  pr = add_property(ctx, p, JS_ATOM_length, prop_flag);
  if (pr) pr->u.value = LEPUS_NewInt32(ctx, len);
  pr = add_property(ctx, p, JS_ATOM_name, prop_flag);
  if (pr) pr->u.value = LEPUS_AtomToString(ctx, name);
  return;
}

#ifdef ENABLE_QUICKJS_DEBUGGER
static void js_bytecode_function_set_name(LEPUSContext *ctx,
                                          LEPUSFunctionBytecode *b,
                                          LEPUSValue name) {
  if (b->has_debug && LEPUS_VALUE_IS_STRING(name)) {
    if (b->debug.func_name && !ctx->gc_enable)
      js_free_string(ctx->rt, b->debug.func_name);
    b->debug.func_name = LEPUS_VALUE_GET_STRING(name);
  } else if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, name);
  }
  return;
}
#endif

BOOL lepus_class_has_bytecode(LEPUSClassID class_id) {
  return (class_id == JS_CLASS_BYTECODE_FUNCTION ||
          class_id == JS_CLASS_GENERATOR_FUNCTION ||
          class_id == JS_CLASS_ASYNC_FUNCTION ||
          class_id == JS_CLASS_ASYNC_GENERATOR_FUNCTION);
}

/* return NULL without exception if not a function or no bytecode */
QJS_HIDE LEPUSFunctionBytecode *JS_GetFunctionBytecode(LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return NULL;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (!lepus_class_has_bytecode(p->class_id)) return NULL;
  return p->u.func.function_bytecode;
}

void js_method_set_home_object(LEPUSContext *ctx, LEPUSValueConst func_obj,
                               LEPUSValueConst home_obj) {
  CallGCFunc(js_method_set_home_object_gc, ctx, func_obj, home_obj);
  LEPUSObject *p, *p1;
  LEPUSFunctionBytecode *b;

  if (LEPUS_VALUE_IS_NOT_OBJECT(func_obj)) return;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (!lepus_class_has_bytecode(p->class_id)) return;
  b = p->u.func.function_bytecode;
  if (b->need_home_object) {
    p1 = p->u.func.home_object;
    if (p1) {
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
    }
    if (LEPUS_VALUE_IS_OBJECT(home_obj))
      p1 = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, home_obj));
    else
      p1 = NULL;
    p->u.func.home_object = p1;
  }
}

QJS_STATIC LEPUSValue js_get_function_name(LEPUSContext *ctx, JSAtom name) {
  LEPUSValue name_str;

  name_str = LEPUS_AtomToString(ctx, name);
  if (JS_AtomSymbolHasDescription(ctx, name)) {
    name_str = JS_ConcatString3(ctx, "[", name_str, "]");
  }
  return name_str;
}

/* Modify the name of a method according to the atom and
   'flags'. 'flags' is a bitmask of LEPUS_PROP_HAS_GET and
   LEPUS_PROP_HAS_SET. Also set the home object of the method.
   Return < 0 if exception. */
int js_method_set_properties(LEPUSContext *ctx, LEPUSValueConst func_obj,
                             JSAtom name, int flags, LEPUSValueConst home_obj) {
  LEPUSValue name_str;

  name_str = js_get_function_name(ctx, name);
  if (flags & LEPUS_PROP_HAS_GET) {
    name_str = JS_ConcatString3(ctx, "get ", name_str, "");
  } else if (flags & LEPUS_PROP_HAS_SET) {
    name_str = JS_ConcatString3(ctx, "set ", name_str, "");
  }
  if (LEPUS_IsException(name_str)) return -1;
  if (JS_DefinePropertyValue_RC(ctx, func_obj, JS_ATOM_name, name_str,
                                LEPUS_PROP_CONFIGURABLE) < 0)
    return -1;
  js_method_set_home_object(ctx, func_obj, home_obj);

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (js_is_bytecode_function(func_obj)) {
    js_bytecode_function_set_name(ctx, JS_GetFunctionBytecode(func_obj),
                                  LEPUS_ToString(ctx, name_str));
  }
#endif
  return 0;
}

/* Note: at least 'length' arguments will be readable in 'argv' */
QJS_STATIC LEPUSValue JS_NewCFunction3(LEPUSContext *ctx, LEPUSCFunction *func,
                                       const char *name, int length,
                                       LEPUSCFunctionEnum cproto, int magic,
                                       LEPUSValueConst proto_val) {
  LEPUSValue func_obj;
  LEPUSObject *p;
  JSAtom name_atom;

  func_obj = JS_NewObjectProtoClass_RC(ctx, proto_val, JS_CLASS_C_FUNCTION);
  if (LEPUS_IsException(func_obj)) return func_obj;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.cfunc.c_function.generic = func;
  p->u.cfunc.length = length;
  p->u.cfunc.cproto = cproto;
  p->u.cfunc.magic = magic;
  p->is_constructor = (cproto == LEPUS_CFUNC_constructor ||
                       cproto == LEPUS_CFUNC_constructor_magic ||
                       cproto == LEPUS_CFUNC_constructor_or_func ||
                       cproto == LEPUS_CFUNC_constructor_or_func_magic);
  if (!name) {
    name = "";
  }
  name_atom = LEPUS_NewAtom(ctx, name);
  js_function_set_properties(ctx, p, name_atom, length);
  LEPUS_FreeAtom(ctx, name_atom);
  return func_obj;
}

/* Note: at least 'length' arguments will be readable in 'argv' */
LEPUSValue LEPUS_NewCFunction2(LEPUSContext *ctx, LEPUSCFunction *func,
                               const char *name, int length,
                               LEPUSCFunctionEnum cproto, int magic) {
  CallGCFunc(JS_NewCFunction2_GC, ctx, func, name, length, cproto, magic);
  return JS_NewCFunction3(ctx, func, name, length, cproto, magic,
                          ctx->function_proto);
}

QJS_STATIC void js_c_function_data_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  JSCFunctionDataRecord *s = static_cast<JSCFunctionDataRecord *>(
      LEPUS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA));
  int i;

  if (s) {
    for (i = 0; i < s->data_len; i++) {
      LEPUS_FreeValueRT(rt, s->data[i]);
    }
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void js_c_function_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func,
                                        int local_idx) {
  JSCFunctionDataRecord *s = static_cast<JSCFunctionDataRecord *>(
      LEPUS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA));
  int i;

  if (s) {
    for (i = 0; i < s->data_len; i++) {
      JS_MarkValue_RC(rt, s->data[i], mark_func);
    }
  }
}

LEPUSValue JS_ThrowStackOverflow(LEPUSContext *ctx) {
  return LEPUS_ThrowInternalError(ctx, "stack overflow");
}

QJS_STATIC LEPUSValue js_c_function_data_call(LEPUSContext *ctx,
                                              LEPUSValueConst func_obj,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              int flags) {
  JSCFunctionDataRecord *s = static_cast<JSCFunctionDataRecord *>(
      LEPUS_GetOpaque(func_obj, JS_CLASS_C_FUNCTION_DATA));
  LEPUSValueConst *arg_buf;
  int i;

  // <Primjs begin>
#ifdef OS_IOS
  size_t arg_size = 0;
  LEPUSValue ret;
#endif
  /* XXX: could add the function on the stack for debug */
  if (unlikely(argc < s->length)) {
#ifdef OS_IOS
    arg_size = sizeof(arg_buf[0]) * s->length;
    if (js_check_virtual_outofmemory(ctx, arg_size)) {
      return LEPUS_ThrowOutOfMemory(ctx);
    }
    if (js_check_virtual_sp_overflow(ctx, arg_size)) {
      return JS_ThrowStackOverflow(ctx);
    }

    arg_buf = js_get_virtual_sp(ctx);
    js_push_virtual_sp(ctx, arg_size);
#elif !defined(OS_WIN)
    arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(arg_buf[0]) * s->length));
#else
    arg_buf =
        static_cast<LEPUSValue *>(_alloca(sizeof(arg_buf[0]) * s->length));
#endif
    for (i = 0; i < argc; i++) arg_buf[i] = argv[i];
    for (i = argc; i < s->length; i++) arg_buf[i] = LEPUS_UNDEFINED;
  } else {
    arg_buf = argv;
  }
#ifdef OS_IOS
  ret = s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);
  js_pop_virtual_sp(ctx, arg_size);
  return ret;
#else
  return s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);
#endif
  // <Primjs end>
}

LEPUSValue LEPUS_NewCFunctionData(LEPUSContext *ctx, LEPUSCFunctionData *func,
                                  int length, int magic, int data_len,
                                  LEPUSValueConst *data) {
  CallGCFunc(JS_NewCFunctionData_GC, ctx, func, length, magic, data_len, data);
  JSCFunctionDataRecord *s;
  LEPUSValue func_obj;
  int i;

  func_obj = JS_NewObjectProtoClass_RC(ctx, ctx->function_proto,
                                       JS_CLASS_C_FUNCTION_DATA);
  if (LEPUS_IsException(func_obj)) return func_obj;
  s = static_cast<JSCFunctionDataRecord *>(
      lepus_malloc(ctx, sizeof(*s) + data_len * sizeof(LEPUSValue)));
  if (!s) {
    LEPUS_FreeValue(ctx, func_obj);
    return LEPUS_EXCEPTION;
  }
  s->func = func;
  s->length = length;
  s->data_len = data_len;
  s->magic = magic;
  for (i = 0; i < data_len; i++) s->data[i] = LEPUS_DupValue(ctx, data[i]);
  LEPUS_SetOpaque(func_obj, s);
  js_function_set_properties(ctx, LEPUS_VALUE_GET_OBJ(func_obj),
                             JS_ATOM_empty_string, length);
  return func_obj;
}

QJS_STATIC void free_property(LEPUSRuntime *rt, JSProperty *pr,
                              int prop_flags) {
  if (unlikely(prop_flags & LEPUS_PROP_TMASK)) {
    if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
      if (pr->u.getset.getter)
        LEPUS_FreeValueRT(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
      if (pr->u.getset.setter)
        LEPUS_FreeValueRT(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
    } else if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
      free_var_ref(rt, pr->u.var_ref);
    } else if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
    }
  } else {
    LEPUS_FreeValueRT(rt, pr->u.value);
  }
}

__attribute__((always_inline)) JSShapeProperty *find_own_property1(
    LEPUSObject *p, JSAtom atom) {
  JSShape *sh;
  JSShapeProperty *pr, *prop;
  intptr_t h;
  sh = p->shape;
  h = (uintptr_t)atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h - 1];
  prop = get_shape_prop(sh);
  while (h) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      return pr;
    }
    h = pr->hash_next;
  }
  return NULL;
}

#ifdef QJS_UNITTEST
JSShapeProperty *find_own_property(
#else
QJS_STATIC force_inline JSShapeProperty *find_own_property(
#endif
    JSProperty **ppr, LEPUSObject *p, JSAtom atom) {
  JSShape *sh;
  JSShapeProperty *pr, *prop;
  intptr_t h;
  sh = p->shape;
  h = (uintptr_t)atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h - 1];
  prop = get_shape_prop(sh);
  while (h) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      *ppr = &p->prop[h - 1];
      /* the compiler should be able to assume that pr != NULL here */
      return pr;
    }
    h = pr->hash_next;
  }
  *ppr = NULL;
  return NULL;
}

/* indicate that the object may be part of a function prototype cycle */
QJS_STATIC void set_cycle_flag(LEPUSContext *ctx, LEPUSValueConst obj) {}

void free_var_ref(LEPUSRuntime *rt, JSVarRef *var_ref) {
  if (var_ref) {
    assert(var_ref->header.ref_count > 0);
    if (--var_ref->header.ref_count == 0) {
      if (var_ref->is_detached) {
        LEPUS_FreeValueRT(rt, var_ref->value);
      }
      lepus_free_rt(rt, var_ref);
    }
  }
}

QJS_STATIC void js_array_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  int i;

  for (i = 0; i < p->u.array.count; i++) {
    LEPUS_FreeValueRT(rt, p->u.array.u.values[i]);
  }
  lepus_free_rt(rt, p->u.array.u.values);
}

QJS_STATIC void js_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  int i;

  for (i = 0; i < p->u.array.count; i++) {
    JS_MarkValue_RC(rt, p->u.array.u.values[i], mark_func);
  }
}

QJS_STATIC void js_object_data_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUS_FreeValueRT(rt, p->u.object_data);
  p->u.object_data = LEPUS_UNDEFINED;
}

QJS_STATIC void js_object_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                    LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JS_MarkValue_RC(rt, p->u.object_data, mark_func);
}

QJS_STATIC void js_bytecode_function_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val) {
  LEPUSObject *p1, *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSFunctionBytecode *b;
  JSVarRef **var_refs;
  int i;

  p1 = p->u.func.home_object;
  if (p1) {
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
  }
  b = p->u.func.function_bytecode;
  if (b) {
    var_refs = p->u.func.var_refs;
    if (var_refs) {
      for (i = 0; i < b->closure_var_count; i++) free_var_ref(rt, var_refs[i]);
      lepus_free_rt(rt, var_refs);
    }
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
  }
}

QJS_STATIC void js_bytecode_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func,
                                          int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSVarRef **var_refs = p->u.func.var_refs;
  LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
  int i;

  if (p->u.func.home_object) {
    JS_MarkValue_RC(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object),
                    mark_func);
  }
  if (b) {
    if (var_refs) {
      for (i = 0; i < b->closure_var_count; i++) {
        JSVarRef *var_ref = var_refs[i];
        if (var_ref) {
          JS_MarkValue_RC(rt, LEPUS_MKPTR(LEPUS_TAG_VAR_REF, var_ref),
                          mark_func);
        }
      }
    }
    /* must mark the function bytecode because template objects may be
       part of a cycle */
    JS_MarkValue_RC(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), mark_func);
  }
}

QJS_STATIC void js_bound_function_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSBoundFunction *bf = p->u.bound_function;
  int i;

  LEPUS_FreeValueRT(rt, bf->func_obj);
  LEPUS_FreeValueRT(rt, bf->this_val);
  for (i = 0; i < bf->argc; i++) {
    LEPUS_FreeValueRT(rt, bf->argv[i]);
  }
  lepus_free_rt(rt, bf);
}

QJS_STATIC void js_bound_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func,
                                       int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSBoundFunction *bf = p->u.bound_function;
  int i;

  JS_MarkValue_RC(rt, bf->func_obj, mark_func);
  JS_MarkValue_RC(rt, bf->this_val, mark_func);
  for (i = 0; i < bf->argc; i++) JS_MarkValue_RC(rt, bf->argv[i], mark_func);
}

QJS_STATIC void js_for_in_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSForInIterator *it = p->u.for_in_iterator;
  LEPUS_FreeValueRT(rt, it->obj);
  lepus_free_rt(rt, it);
}

QJS_STATIC void js_for_in_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func,
                                        int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSForInIterator *it = p->u.for_in_iterator;
  JS_MarkValue_RC(rt, it->obj, mark_func);
}

QJS_STATIC void free_object_struct(LEPUSRuntime *rt, LEPUSObject *p) {
  int i;
  LEPUSClassFinalizer *finalizer;
  JSShape *sh;
  JSShapeProperty *pr;

  /* free all the fields */
  sh = p->shape;
  if (sh == NULL) {
    return;
  }
  pr = get_shape_prop(sh);
  for (i = 0; i < sh->prop_count; i++) {
    free_property(rt, &p->prop[i], pr->flags);
    pr++;
  }
  lepus_free_rt(rt, p->prop);
  js_free_shape(rt, sh);

  /* fail safe */
  p->shape = NULL;
  p->prop = NULL;

  if (unlikely(p->first_weak_ref)) {
    reset_weak_ref(rt, p);
    p->first_weak_ref = NULL;
  }

  finalizer = rt->class_array[p->class_id].finalizer;
  if (finalizer) (*finalizer)(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));

  /* fail safe */
  p->class_id = 0;
  p->u.opaque = NULL;
  p->u.func.var_refs = NULL;
  p->u.func.home_object = NULL;
}

QJS_STATIC void free_object2(LEPUSRuntime *rt, LEPUSObject *p) {
  if (p->free_mark) {
    /* already freed (happen when freeing cycles) */
    return;
  }
  /* indicate that the object is being freed */
  p->free_mark = 1;
  /* prevent double free the object */
  /* remove from the global object list */
  list_del(&p->link);
  free_object_struct(rt, p);
  if (rt->in_gc_sweep) {
    list_add_tail(&p->link, &rt->free_obj_list);
  } else {
    lepus_free_rt(rt, p);
  }
}

QJS_STATIC void free_object(LEPUSRuntime *rt, LEPUSObject *p) {
  assert(p->header.ref_count == 0);
  if (!rt->in_gc_sweep) free_object2(rt, p);
}

bool LEPUS_IsGCMode(LEPUSContext *ctx) { return ctx->gc_enable; }
bool LEPUS_IsGCModeRT(LEPUSRuntime *rt) { return rt->gc_enable; }

#ifdef ENABLE_LEPUSNG
QJS_STATIC void JSRefFinalizer(LEPUSRuntime *rt, LEPUSValue val) {
  auto &lepus_val =
      reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(val))->lepus_val;
  if (LEPUS_IsObject(lepus_val)) {
    auto *js_val_p = LEPUS_VALUE_GET_OBJ(lepus_val);
    if (js_val_p->header.ref_count == 1) {
      lepus_val = LEPUS_UNDEFINED;
    }
  }
  rt->in_gc_sweep = FALSE;
  rt->js_callbacks_.free_value(rt, val);
  rt->in_gc_sweep = TRUE;
}
#endif

/* called with the ref_count of 'v' reaches zero. */
void __JS_FreeValueRT(LEPUSRuntime *rt, LEPUSValue v) {
#ifdef ENABLE_GC_DEBUG_TOOLS
  DCHECK(!rt->gc_enable);
#endif
  int64_t tag = LEPUS_VALUE_GET_TAG(v);

#ifdef DUMP_FREE
  {
    printf("Freeing ");
    if (tag == LEPUS_TAG_OBJECT) {
      JS_DumpObject(rt, LEPUS_VALUE_GET_OBJ(v));
    } else {
      JS_DumpValueShort(rt, v);
      printf("\n");
    }
  }
#endif

  switch (tag) {
    case LEPUS_TAG_STRING: {
      JSString *p = LEPUS_VALUE_GET_STRING(v);
      if (p->atom_type) {
        JS_FreeAtomStruct(rt, p);
      } else {
#ifdef DUMP_LEAKS
        list_del(&p->link);
#endif

#ifdef ENABLE_LEPUSNG
        // <Primjs begin>
        JS_FreeStringCache(rt, p);
        // <Primjs end>
#endif
        lepus_free_rt(rt, p);
      }
    } break;
    case LEPUS_TAG_SEPARABLE_STRING: {
      JS_FreeSeparableString(rt, v);
    } break;
    case LEPUS_TAG_OBJECT:
      free_object(rt, LEPUS_VALUE_GET_OBJ(v));
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      free_function_bytecode(
          rt, static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(v)));
      break;
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_MODULE:
      abort(); /* never freed here */
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *bf = reinterpret_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      bf_delete(&bf->num);
      lepus_free_rt(rt, bf);
    } break;
#else
#ifdef ENABLE_LEPUSNG
    // <Primjs begin>
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *bf = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      lepus_free_rt(rt, bf);
      break;
    }
    case LEPUS_TAG_LEPUS_REF: {
      if (rt->js_callbacks_.free_value) {
        if (rt->in_gc_sweep) {
          JSRefFinalizer(rt, v);
          break;
        }
        rt->js_callbacks_.free_value(rt, v);
      }
      break;
    }
    // <Primjs end>
#endif
#endif
    case LEPUS_TAG_SYMBOL: {
      JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(v));
      JS_FreeAtomStruct(rt, p);
    } break;
    default:
#if defined(__aarch64__) && !defined(OS_WIN) && !defined(CONFIG_BIGNUM) && \
    !DISABLE_NANBOX
      printf("__JS_FreeValue: unknown tag=%p\n", (void *)tag);
#else
      printf("__JS_FreeValue: unknown tag=%" PRId64 "\n", tag);
#endif
      abort();
  }
}

void __JS_FreeValue(LEPUSContext *ctx, LEPUSValue v) {
  __JS_FreeValueRT(ctx->rt, v);
}

void LEPUS_FreeValue(LEPUSContext *ctx, LEPUSValue v) {
  DCHECK(!ctx->gc_enable);
  if (LEPUS_VALUE_HAS_REF_COUNT(v)) {
    LEPUSRefCountHeader *p = (LEPUSRefCountHeader *)LEPUS_VALUE_GET_PTR(v);
    if (--p->ref_count <= 0) {
      __JS_FreeValue(ctx, v);
    }
  }
}

void LEPUS_FreeValueRT(LEPUSRuntime *rt, LEPUSValue v) {
  if (LEPUS_VALUE_HAS_REF_COUNT(v)) {
    LEPUSRefCountHeader *p = (LEPUSRefCountHeader *)LEPUS_VALUE_GET_PTR(v);
    if (--p->ref_count <= 0) {
      __JS_FreeValueRT(rt, v);
    }
  }
}
/* garbage collection */

QJS_STATIC BOOL has_children(LEPUSValueConst val) {
  switch (LEPUS_VALUE_GET_TAG(val)) {
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_FUNCTION_BYTECODE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_LEPUS_REF:
      return TRUE;
    default:
      return FALSE;
  }
}

static void JS_MarkValue_RC(LEPUSRuntime *rt, LEPUSValueConst val,
                            LEPUS_MarkFunc *mark_func, int local_idx) {
  if (LEPUS_VALUE_HAS_REF_COUNT(val) && has_children(val)) {
    mark_func(rt, val, local_idx);
  }
}

void LEPUS_MarkValue(LEPUSRuntime *rt, LEPUSValueConst val,
                     LEPUS_MarkFunc *mark_func, int local_idx = -1) {
  CallGCFunc(JS_MarkValue_GC, rt, val, mark_func, local_idx);
  JS_MarkValue_RC(rt, val, mark_func, local_idx);
  return;
}

QJS_STATIC void mark_children(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func, int local_idx = -1) {
  // <Primjs begin>
  rt->c_stack_depth++;
  // <Primjs end>
  switch (LEPUS_VALUE_GET_TAG(val)) {
#ifdef ENABLE_LEPUSNG
    // Primjs begin
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSLepusRef *pref = (LEPUSLepusRef *)(LEPUS_VALUE_GET_PTR(val));
      if (LEPUS_VALUE_IS_OBJECT(pref->lepus_val)) {
        mark_func(rt, pref->lepus_val, local_idx);
      }
      break;
    }
    // Primjs end
#endif
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
      JSShapeProperty *prs;
      JSShape *sh;
      int i;
      sh = p->shape;
      mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_SHAPE, sh), local_idx);
      /* mark all the fields */
      prs = get_shape_prop(sh);
      if (p->class_id != JS_CLASS_WeakRef) {
        if (sh == nullptr) return;
        for (i = 0; i < sh->prop_count; i++) {
          JSProperty *pr = &p->prop[i];
          if (prs->atom != JS_ATOM_NULL) {
            if (prs->flags & LEPUS_PROP_TMASK) {
              if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
                if (pr->u.getset.getter)
                  mark_func(rt,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter),
                            local_idx);
                if (pr->u.getset.setter)
                  mark_func(rt,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter),
                            local_idx);
              } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
                JS_MarkValue_RC(rt,
                                LEPUS_MKPTR(LEPUS_TAG_VAR_REF, pr->u.var_ref),
                                mark_func);
              } else if ((prs->flags & LEPUS_PROP_TMASK) ==
                         LEPUS_PROP_AUTOINIT) {
                /* nothing to do */
              }
            } else {
              JS_MarkValue_RC(rt, pr->u.value, mark_func);
            }
          }
          prs++;
        }
      }
      if (p->class_id != JS_CLASS_OBJECT) {
        LEPUSClassGCMark *gc_mark;
        gc_mark = rt->class_array[p->class_id].gc_mark;
        if (gc_mark)
          gc_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), mark_func, -1);
      }
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      /* the template objects can be part of a cycle */
      {
        LEPUSFunctionBytecode *b =
            static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
        int i;
        for (i = 0; i < b->cpool_count; i++) {
          JS_MarkValue_RC(rt, b->cpool[i], mark_func);
        }
      }
      break;
    case LEPUS_TAG_VAR_REF: {
      JSVarRef *var_ref = static_cast<JSVarRef *>(LEPUS_VALUE_GET_PTR(val));
      /* the refcount of stack values is not incremented, hence
         the test */
      if (var_ref->is_detached) {
        JS_MarkValue_RC(rt, *var_ref->pvalue, mark_func);
      }
    } break;
    case LEPUS_TAG_ASYNC_FUNCTION: {
      JSAsyncFunctionData *s =
          static_cast<JSAsyncFunctionData *>(LEPUS_VALUE_GET_PTR(val));
      if (s->is_active) async_func_mark(rt, &s->func_state, mark_func);
      JS_MarkValue_RC(rt, s->resolving_funcs[0], mark_func);
      JS_MarkValue_RC(rt, s->resolving_funcs[1], mark_func);
    } break;
    case LEPUS_TAG_SHAPE: {
      JSShape *sh = static_cast<JSShape *>(LEPUS_VALUE_GET_PTR(val));
      if (sh->proto != NULL) {
        mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto), local_idx);
      }
    } break;
    default:
      /* no children */
      break;
  }
  // <Primjs begin>
  rt->c_stack_depth--;
  // <Primjs end>
}

#if 0
/* not useful until realms are supported */
static void mark_context(LEPUSRuntime *rt, LEPUSContext *ctx)
{
    int i;
    struct list_head *el;

    list_for_each(el, &ctx->loaded_modules) {
        LEPUSModuleDef *m = list_entry(el, LEPUSModuleDef, link);
        JS_MarkValue_RC(rt, m->module_ns);
        JS_MarkValue_RC(rt, m->func_obj);
    }

    JS_MarkValue_RC(rt, ctx->current_exception);

    for(i = 0; i < rt->class_count; i++)
        JS_MarkValue_RC(rt, ctx->class_proto[i]);
    JS_MarkValue_RC(rt, ctx->regexp_ctor);
    JS_MarkValue_RC(rt, ctx->function_ctor);
    JS_MarkValue_RC(rt, ctx->function_proto);
    JS_MarkValue_RC(rt, ctx->iterator_proto);
    JS_MarkValue_RC(rt, ctx->async_iterator_proto);
    JS_MarkValue_RC(rt, ctx->array_proto_values);

    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++)
        JS_MarkValue_RC(rt, ctx->native_error_proto[i]);

    JS_MarkValue_RC(rt, ctx->throw_type_error);
    JS_MarkValue_RC(rt, ctx->global_obj);
    JS_MarkValue_RC(rt, ctx->global_var_obj);
}
#endif

/* 1 = possible member of a cycle
   2 = member of a cycle
*/

QJS_STATIC void gc_decref_mark(LEPUSRuntime *rt, LEPUSValueConst obj);

// #define DUMP_GC_DECREF

#ifdef DUMP_GC_DECREF
static int decref_indent;
#endif

QJS_STATIC void gc_decref_child(LEPUSRuntime *rt, LEPUSValueConst obj,
                                int local_idx = -1) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));

#ifdef DUMP_LEAKS
#ifdef DUMP_GC_DECREF
  {
    int i;
    for (i = 0; i < decref_indent; i++) printf("  ");
    if (LEPUS_IsObject(obj)) {
      JS_DumpObject(rt, p);
    } else {
      JS_DumpValueShort(rt, obj);
      printf("\n");
    }
  }
#endif
  if (p->header.ref_count <= 0) {
    printf("%p: invalid refcount (%d)\n", p, p->header.ref_count);
    if (LEPUS_IsObject(obj)) {
      JS_DumpObject(rt, p);
    } else {
      JS_DumpValueShort(rt, obj);
    }
  }
#endif
  assert(p->header.ref_count > 0);
  p->header.ref_count--;

  // <Primjs begin>
  if (LEPUS_IsLepusRef(obj)) {
    // should mark lepus_val
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_VALUE_IS_NOT_OBJECT(lepus_val) || p->header.ref_count > 0) {
      return;
    }
    p = LEPUS_VALUE_GET_OBJ(lepus_val);
    assert(p->header.ref_count > 0);
    p->header.ref_count--;
    obj = lepus_val;
  }
  // <Primjs end>
  gc_decref_mark(rt, obj);
}
// <Primjs begin>
#define MAX_CSTACK_DEPTH 32
#define GC_LINK_MASK 0xF0
#define GC_mark_MASK 0x0F
#define GC_IN_LINK 0x10
QJS_STATIC BOOL insert_to_cache_list(LEPUSRuntime *rt,
                                     struct list_head *bytecode_list,
                                     struct list_head *obj_list,
                                     LEPUSValueConst obj) {
  if (rt->c_stack_depth > MAX_CSTACK_DEPTH) {
    if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(obj)) {
      LEPUSFunctionBytecode *b =
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
      if ((b->gc_header.mark & GC_LINK_MASK) == 0) {
        b->gc_header.mark |= GC_IN_LINK;
        list_add_tail(&b->gc_link, bytecode_list);
      }
      return TRUE;
    }
    if (LEPUS_VALUE_IS_OBJECT(obj)) {
      LEPUSObject *b = LEPUS_VALUE_GET_OBJ(obj);
      if ((b->gc_header.mark & GC_LINK_MASK) == 0) {
        b->gc_header.mark |= GC_IN_LINK;
        if (rt->el_next == &b->link) rt->el_next = rt->el_next->next;
        list_del(&b->link);
        list_add_tail(&b->link, obj_list);
      }
      return TRUE;
    }
  }
  return FALSE;
}
// <Primjs end>
QJS_STATIC void gc_decref_mark(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  // <Primjs begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 0) {
    if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                             obj) == TRUE)
      return;
    // <Primjs end>
    p->gc_header.mark = 1;
#ifdef DUMP_GC_DECREF
    decref_indent++;
#endif
    mark_children(rt, obj, gc_decref_child);
#ifdef DUMP_GC_DECREF
    decref_indent--;
#endif
  }
}

QJS_STATIC void gc_decref(LEPUSRuntime *rt) {
  struct list_head *el;
  LEPUSObject *p;

  list_for_each(el, &rt->obj_list) {
    p = list_entry(el, LEPUSObject, link);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }
// <Primjs begin>
gc_decref_label:
  while (!list_empty(&rt->gc_bytecode_list)) {
    LEPUSFunctionBytecode *b =
        list_entry(rt->gc_bytecode_list.next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
    b->gc_header.mark &= GC_mark_MASK;
  }

  while (!list_empty(&rt->gc_obj_list)) {
    LEPUSObject *b = list_entry(rt->gc_obj_list.next, LEPUSObject, link);
    list_del(&b->link);
    list_add_tail(&b->link, &rt->obj_list);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, b));
    b->gc_header.mark &= GC_mark_MASK;
  }
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_decref_label;
  // <Primjs end>
}

QJS_STATIC void gc_scan_incref(LEPUSRuntime *rt, LEPUSValueConst obj, BOOL);

QJS_STATIC void gc_scan_incref_child(LEPUSRuntime *rt, LEPUSValueConst obj,
                                     int local_idx = -1) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  p->header.ref_count++;
  // <Primjs begin>
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (p->header.ref_count > 1 || LEPUS_VALUE_IS_NOT_OBJECT(lepus_val)) {
      return;
    }

    obj = lepus_val;
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->header.ref_count++;
  }
  if ((p->gc_header.mark & GC_mark_MASK) != 0) {
    // <Primjs end>
    gc_scan_incref(rt, obj, TRUE);
  }
}

QJS_STATIC void gc_scan_incref(LEPUSRuntime *rt, LEPUSValueConst obj,
                               BOOL insert_cache) {
  // <Primjs begin>
  if (insert_cache == TRUE &&
      insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list, obj) ==
          TRUE)
    return;
  // <Primjs end>

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p) return;
  if (LEPUS_IsObject(obj)) {
    // <Primjs begin>
    uint8_t v = p->gc_header.mark & GC_LINK_MASK;
    if (v == GC_IN_LINK) return;
    // <Primjs end>
    /* remove the tmp_obj_list and update the next object to
       explore */
    if (rt->el_next == &p->link) rt->el_next = rt->el_next->next;
    /* add to rt->obj_list */
    list_del(&p->link);
    list_add_tail(&p->link, &rt->obj_list);
    // <Primjs begin>
  } else if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(obj)) {
    LEPUSFunctionBytecode *b =
        static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
    uint8_t v = b->gc_header.mark & GC_LINK_MASK;
    if (v == GC_IN_LINK) return;
  }
  p->gc_header.mark = 0; /* not freed */
  // <Primjs end>
  mark_children(rt, obj, gc_scan_incref_child);
}

QJS_STATIC void gc_scan_obj(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  // <Primjs begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 1 && p->header.ref_count > 0) {
    // <Primjs end>
    gc_scan_incref(rt, obj, TRUE);
  }
}
// <Primjs begin>
QJS_STATIC void gc_scan_obj_set_mark2(LEPUSRuntime *rt, LEPUSValueConst obj,
                                      int local_idx = -1) {
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_VALUE_IS_NOT_OBJECT(lepus_val)) return;
    obj = lepus_val;
  }

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  if ((p->gc_header.mark & GC_mark_MASK) == 1) {
    if (p->header.ref_count > 0) {
      gc_scan_incref(rt, obj, FALSE);
    } else {
      p->gc_header.mark = 2;
      if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                               obj) == TRUE)
        return;
      mark_children(rt, obj, gc_scan_obj_set_mark2);
    }
  }
}
// <Primjs end>

QJS_STATIC void gc_scan_obj2(LEPUSRuntime *rt, LEPUSValueConst obj);

QJS_STATIC void gc_scan_incref_child2(LEPUSRuntime *rt, LEPUSValueConst obj,
                                      int local_idx = -1) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  p->header.ref_count++;
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (p->header.ref_count > 1 || LEPUS_VALUE_IS_NOT_OBJECT(lepus_val)) {
      return;
    }
    obj = lepus_val;
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->header.ref_count++;
  }
  gc_scan_obj2(rt, obj);
}

QJS_STATIC void gc_scan_obj2(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  // <Primjs begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 2) {
    // <Primjs end>
    p->gc_header.mark = 3;
    // <Primjs begin>
    if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                             obj) == TRUE)
      return;
    // <Primjs end>
    mark_children(rt, obj, gc_scan_incref_child2);
  }
}
// <Primjs begin>
QJS_STATIC void traverse_bytecode(LEPUSRuntime *rt, struct list_head *list,
                                  LEPUS_MarkFunc *mark_func) {
  while (!list_empty(list)) {
    LEPUSFunctionBytecode *b =
        list_entry(list->next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    b->gc_header.mark &= GC_mark_MASK;
    mark_children(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), mark_func);
  }
}
QJS_STATIC void remove_gc_list(LEPUSObject *p, LEPUSRuntime *rt) {
  list_del(&p->link);
  list_add_tail(&p->link, &rt->tmp_obj_list);
  p->gc_header.mark &= GC_mark_MASK;
}
QJS_STATIC void traverse_object(LEPUSRuntime *rt, struct list_head *list,
                                LEPUS_MarkFunc *mark_func) {
  while (!list_empty(list)) {
    LEPUSObject *p = list_entry(list->next, LEPUSObject, link);
    remove_gc_list(p, rt);
    mark_children(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), mark_func);
  }
}

QJS_STATIC void traverse_incref_list(LEPUSRuntime *rt) {
  while (!list_empty(&rt->gc_bytecode_list)) {
    LEPUSFunctionBytecode *b =
        list_entry(rt->gc_bytecode_list.next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    b->gc_header.mark &= GC_mark_MASK;
    gc_scan_incref(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), TRUE);
  }

  while (!list_empty(&rt->gc_obj_list)) {
    LEPUSObject *p = list_entry(rt->gc_obj_list.next, LEPUSObject, link);
    remove_gc_list(p, rt);
    gc_scan_incref(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), TRUE);
  }
}
// <Primjs end>
QJS_STATIC void gc_scan(LEPUSRuntime *rt) {
  struct list_head *el;
  LEPUSObject *p;

  /* move obj_list to tmp_obj_list */
  list_add(&rt->tmp_obj_list, &rt->obj_list);
  list_del(&rt->obj_list);
  init_list_head(&rt->obj_list);

  /* keep the objects with a refcount > 0 and their children. After
     this pass, obj_list contains the objects to be deleted. Their
     mark is 2. */
  for (el = rt->tmp_obj_list.next; el != &rt->tmp_obj_list; el = rt->el_next) {
    rt->el_next = el->next; /* may be modified by gc_scan_obj() */
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }
// <Primjs begin>
gc_scan_incref_label:
  traverse_incref_list(rt);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_incref_label;

  for (el = rt->tmp_obj_list.next; el != &rt->tmp_obj_list; el = rt->el_next) {
    rt->el_next = el->next; /* may be modified by gc_scan_obj() */
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj_set_mark2(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }

gc_scan_obj_set_mark2_label:
  traverse_bytecode(rt, &rt->gc_bytecode_list, gc_scan_obj_set_mark2);
  traverse_object(rt, &rt->gc_obj_list, gc_scan_obj_set_mark2);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_obj_set_mark2_label;

  /* restore the refcount of the objects to be deleted. After this
     pass, their mark is 3 */
  list_for_each(el, &rt->tmp_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj2(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }

gc_scan_incref_child2_label:
  traverse_bytecode(rt, &rt->gc_bytecode_list, gc_scan_incref_child2);
  traverse_object(rt, &rt->gc_obj_list, gc_scan_incref_child2);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_incref_child2_label;
  // <Primjs end>
}

QJS_STATIC void gc_free_cycles(LEPUSRuntime *rt) {
  struct list_head *el, *el1;
  LEPUSObject *p;
#ifdef DUMP_GC_FREE
  BOOL header_done = FALSE;
#endif
  init_list_head(&rt->free_obj_list);
  rt->in_gc_sweep = TRUE;
  list_for_each_safe(el, el1, &rt->tmp_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    assert(p->gc_header.mark == 3);
#ifdef DUMP_GC_FREE
    if (!header_done) {
      printf("Freeing cycles:\n");
      JS_DumpObjectHeader(rt);
      header_done = TRUE;
    }
    JS_DumpObject(rt, p);
#endif
    free_object2(rt, p);
  }
  rt->in_gc_sweep = FALSE;

  /* free all the object structures */
  list_for_each_safe(el, el1, &rt->free_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    lepus_free_rt(rt, p);
  }
}

QJS_STATIC void gc_detach_async_var_refs(LEPUSRuntime *rt) {
  list_head *el, *var_el;
  struct JSAsyncFunctionState *s;
  struct JSVarRef *var_ref;
  list_for_each(el, &rt->async_func_sf) {
    s = list_entry(el, JSAsyncFunctionState, link);
    list_for_each(var_el, &s->frame.var_ref_list) {
      var_ref = list_entry(var_el, JSVarRef, link);
      LEPUS_DupValueRT(rt, *var_ref->pvalue);
      var_ref->is_detached = 1;
    }
  }
  return;
}

QJS_STATIC void gc_reset_async_var_refs(LEPUSRuntime *rt) {
  list_head *el, *var_el;
  struct JSAsyncFunctionState *s;
  struct JSVarRef *var_ref;
  int32_t var_idx, is_arg;
  list_for_each(el, &rt->async_func_sf) {
    s = list_entry(el, JSAsyncFunctionState, link);
    const auto &sf = s->frame;
    list_for_each(var_el, &sf.var_ref_list) {
      var_ref = list_entry(var_el, JSVarRef, link);
      LEPUS_FreeValueRT(rt, *var_ref->pvalue);
      var_ref->is_detached = 0;
    }
  }
  return;
}

void LEPUS_RunGC(LEPUSRuntime *rt) {
  CallGCFunc(JS_RunGC_GC, rt);
  TRACE_EVENT("RunGC");
  /* decrement the reference of the children of each object. mark =
     1 after this pass. */
  // <Primjs begin>
  rt->c_stack_depth = 0;
  /*
   * Temporaily detach all closure variable references of async functions
   * to ensure that externally referenced stack variables are not destroyed.
   */
  gc_detach_async_var_refs(rt);
  // <Primjs end>
  gc_decref(rt);

  /* keep the GC objects with a non zero refcount and their childs */
  gc_scan(rt);
  // <Primjs begin>
  /*
   * After the marking phase is complete, restore the closure variable reference
  of async funtions.
   */
  gc_reset_async_var_refs(rt);
  // <Primjs end>

  /* free the GC objects in a cycle */
  gc_free_cycles(rt);
  return;
}

/* Return true during the GC sweep phase (can be useful inside in finalizer) */
BOOL LEPUS_IsInGCSweep(LEPUSRuntime *rt) { return rt->in_gc_sweep; }

/* Return false if not an object or if the object has already been
   freed (zombie objects are visible in finalizers when freeing
   cycles). */
static BOOL JS_IsLiveObject(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p;
  if (!LEPUS_IsObject(obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  return !p->free_mark;
}

/* Compute memory used by various object types */
/* XXX: poor man's approach to handling multiply referenced objects */
typedef struct JSMemoryUsage_helper {
  double memory_used_count;
  double str_count;
  double str_size;
  double lepus_func_count;
  double lepus_func_size;
  double lepus_func_code_size;
  double lepus_func_pc2line_count;
  double lepus_func_pc2line_size;
} JSMemoryUsage_helper;

#if LYNX_SIMPLIFY
QJS_STATIC void compute_value_size(LEPUSValueConst val,
                                   JSMemoryUsage_helper *hp);

QJS_STATIC void compute_jsstring_size(JSString *str, JSMemoryUsage_helper *hp) {
  if (!str->atom_type) { /* atoms are handled separately */
    double s_ref_count = str->header.ref_count;
    hp->str_count += 1 / s_ref_count;
    hp->str_size += ((sizeof(*str) + (str->len << str->is_wide_char) + 1 -
                      str->is_wide_char) /
                     s_ref_count);
  }
}

QJS_STATIC void compute_bytecode_size(LEPUSFunctionBytecode *b,
                                      JSMemoryUsage_helper *hp) {
  int memory_used_count, lepus_func_size, i;
  double ref_count = b->header.ref_count;

  memory_used_count = 0;
  lepus_func_size = offsetof(LEPUSFunctionBytecode, debug);
  if (b->vardefs) {
    lepus_func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);
  }
  if (b->cpool) {
    lepus_func_size += b->cpool_count * sizeof(*b->cpool);
    for (i = 0; i < b->cpool_count; i++) {
      LEPUSValueConst val = b->cpool[i];
      compute_value_size(val, hp);
    }
  }
  if (b->closure_var) {
    lepus_func_size += b->closure_var_count * sizeof(*b->closure_var);
  }
  if (!b->read_only_bytecode && b->byte_code_buf) {
    hp->lepus_func_code_size += b->byte_code_len / ref_count;
  }
  if (b->has_debug) {
    lepus_func_size += sizeof(*b) - offsetof(LEPUSFunctionBytecode, debug);
    if (b->debug.source) {
      memory_used_count++;
      lepus_func_size += b->debug.source_len + 1;
    }
    if (b->debug.pc2line_len) {
      memory_used_count++;
      hp->lepus_func_pc2line_count += 1 / ref_count;
      hp->lepus_func_pc2line_size += b->debug.pc2line_len / ref_count;
    }
  }
  hp->lepus_func_size += lepus_func_size / ref_count;
  hp->lepus_func_count += 1 / ref_count;
  hp->memory_used_count += memory_used_count / ref_count;
}

QJS_STATIC void compute_value_size(LEPUSValueConst val,
                                   JSMemoryUsage_helper *hp) {
  switch (LEPUS_VALUE_GET_TAG(val)) {
    case LEPUS_TAG_STRING:
      compute_jsstring_size(LEPUS_VALUE_GET_STRING(val), hp);
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      compute_bytecode_size(
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val)), hp);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT:
      /* should track JSBigFloat usage */
      break;
#endif
  }
}

void LEPUS_ComputeMemoryUsage(LEPUSRuntime *rt, LEPUSMemoryUsage *s) {
  memset(s, 0, sizeof(*s));
  if (rt->gc_enable) {
    struct malloc_state *allocate_state = &(rt->malloc_state.allocate_state);
    s->malloc_size = allocate_state->cur_malloc_size;
    s->malloc_limit = allocate_state->footprint_limit;
    s->memory_used_size = allocate_state->footprint;
    return;
  }
  struct list_head *el, *el1;
  int i;
  JSMemoryUsage_helper mem = {0}, *hp = &mem;

  s->malloc_count = rt->malloc_state.malloc_count;
  s->malloc_size = rt->malloc_state.malloc_size;
  s->malloc_limit = rt->malloc_state.malloc_limit;

  s->memory_used_count = 2; /* rt + rt->class_array */
  s->memory_used_size =
      sizeof(LEPUSRuntime) + sizeof(LEPUSValue) * rt->class_count;

  list_for_each(el, &rt->context_list) {
    LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
    JSShape *sh = ctx->array_shape;
    s->memory_used_count += 2; /* ctx + ctx->class_proto */
    s->memory_used_size +=
        sizeof(LEPUSContext) + sizeof(LEPUSValue) * rt->class_count;
    s->binary_object_count += ctx->binary_object_count;
    s->binary_object_size += ctx->binary_object_size;

    /* the hashed shapes are counted separately */
    if (sh && !sh->is_hashed) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }
    list_for_each(el1, &ctx->loaded_modules) {
      LEPUSModuleDef *m = list_entry(el1, LEPUSModuleDef, link);
      s->memory_used_count += 1;
      s->memory_used_size += sizeof(*m);
      if (m->req_module_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->req_module_entries_count * sizeof(*m->req_module_entries);
      }
      if (m->export_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->export_entries_count * sizeof(*m->export_entries);
        for (i = 0; i < m->export_entries_count; i++) {
          JSExportEntry *me = &m->export_entries[i];
          if (me->export_type == JS_EXPORT_TYPE_LOCAL && me->u.local.var_ref) {
            /* potential multiple count */
            s->memory_used_count += 1;
            compute_value_size(me->u.local.var_ref->value, hp);
          }
        }
      }
      if (m->star_export_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->star_export_entries_count * sizeof(*m->star_export_entries);
      }
      if (m->import_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->import_entries_count * sizeof(*m->import_entries);
      }
      compute_value_size(m->module_ns, hp);
      compute_value_size(m->func_obj, hp);
    }
  }
  list_for_each(el, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    JSShape *sh = p->shape;
    JSShapeProperty *prs;
    s->obj_count++;
    if (p->prop) {
      s->memory_used_count++;
      s->prop_size += sh->prop_size * sizeof(*p->prop);
      s->prop_count += sh->prop_count;
      prs = get_shape_prop(sh);
      for (i = 0; i < sh->prop_count; i++) {
        JSProperty *pr = &p->prop[i];
        if (prs->atom != JS_ATOM_NULL && !(prs->flags & LEPUS_PROP_TMASK)) {
          compute_value_size(pr->u.value, hp);
        }
        prs++;
      }
    }
    /* the hashed shapes are counted separately */
    if (!sh->is_hashed) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }

    switch (p->class_id) {
      case JS_CLASS_ARRAY:     /* u.array | length */
      case JS_CLASS_ARGUMENTS: /* u.array | length */
        s->array_count++;
        if (p->fast_array) {
          s->fast_array_count++;
          if (p->u.array.u.values) {
            s->memory_used_count++;
            s->memory_used_size +=
                p->u.array.count * sizeof(*p->u.array.u.values);
            s->fast_array_elements += p->u.array.count;
            for (i = 0; i < p->u.array.count; i++) {
              compute_value_size(p->u.array.u.values[i], hp);
            }
          }
        }
        break;
      case JS_CLASS_NUMBER:  /* u.object_data */
      case JS_CLASS_STRING:  /* u.object_data */
      case JS_CLASS_BOOLEAN: /* u.object_data */
      case JS_CLASS_SYMBOL:  /* u.object_data */
      case JS_CLASS_DATE:    /* u.object_data */
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT:   /* u.object_data */
      case JS_CLASS_BIG_FLOAT: /* u.object_data */
#endif
        compute_value_size(p->u.object_data, hp);
        break;
      case JS_CLASS_C_FUNCTION: /* u.cfunc */
        s->c_func_count++;
        break;
      case JS_CLASS_BYTECODE_FUNCTION: /* u.func */
      {
        LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
        JSVarRef **var_refs = p->u.func.var_refs;
        /* home_object: object will be accounted for in list scan */
        if (var_refs) {
          s->memory_used_count++;
          s->lepus_func_size += b->closure_var_count * sizeof(*var_refs);
          for (i = 0; i < b->closure_var_count; i++) {
            if (var_refs[i]) {
              double ref_count = var_refs[i]->header.ref_count;
              s->memory_used_count += 1 / ref_count;
              s->lepus_func_size += sizeof(*var_refs[i]) / ref_count;
              /* handle non object closed values */
              if (var_refs[i]->pvalue == &var_refs[i]->value) {
                /* potential multiple count */
                compute_value_size(var_refs[i]->value, hp);
              }
            }
          }
        }
        compute_bytecode_size(b, hp);
      } break;
      case JS_CLASS_BOUND_FUNCTION: /* u.bound_function */
      {
        JSBoundFunction *bf = p->u.bound_function;
        /* func_obj and this_val are objects */
        for (i = 0; i < bf->argc; i++) {
          compute_value_size(bf->argv[i], hp);
        }
        s->memory_used_count += 1;
        s->memory_used_size += sizeof(*bf) + bf->argc * sizeof(*bf->argv);
      } break;
      case JS_CLASS_C_FUNCTION_DATA: /* u.c_function_data_record */
      {
        JSCFunctionDataRecord *fd = p->u.c_function_data_record;
        if (fd) {
          for (i = 0; i < fd->data_len; i++) {
            compute_value_size(fd->data[i], hp);
          }
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*fd) + fd->data_len * sizeof(*fd->data);
        }
      } break;
      case JS_CLASS_REGEXP: /* u.regexp */
        compute_jsstring_size(p->u.regexp.pattern, hp);
        compute_jsstring_size(p->u.regexp.bytecode, hp);
        break;

      case JS_CLASS_FOR_IN_ITERATOR: /* u.for_in_iterator */
      {
        JSForInIterator *it = p->u.for_in_iterator;
        if (it) {
          compute_value_size(it->obj, hp);
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*it);
        }
      } break;
      case JS_CLASS_ARRAY_BUFFER:        /* u.array_buffer */
      case JS_CLASS_SHARED_ARRAY_BUFFER: /* u.array_buffer */
      {
        JSArrayBuffer *abuf = p->u.array_buffer;
        if (abuf) {
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*abuf);
          if (abuf->data) {
            s->memory_used_count += 1;
            s->memory_used_size += abuf->byte_length;
          }
        }
      } break;
      case JS_CLASS_GENERATOR:    /* u.generator_data */
      case JS_CLASS_UINT8C_ARRAY: /* u.typed_array / u.array */
      case JS_CLASS_INT8_ARRAY:   /* u.typed_array / u.array */
      case JS_CLASS_UINT8_ARRAY:  /* u.typed_array / u.array */
      case JS_CLASS_INT16_ARRAY:  /* u.typed_array / u.array */
      case JS_CLASS_UINT16_ARRAY: /* u.typed_array / u.array */
      case JS_CLASS_INT32_ARRAY:  /* u.typed_array / u.array */
      case JS_CLASS_UINT32_ARRAY: /* u.typed_array / u.array */
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT64_ARRAY:  /* u.typed_array / u.array */
      case JS_CLASS_BIG_UINT64_ARRAY: /* u.typed_array / u.array */
#endif
      case JS_CLASS_FLOAT32_ARRAY: /* u.typed_array / u.array */
      case JS_CLASS_FLOAT64_ARRAY: /* u.typed_array / u.array */
      case JS_CLASS_DATAVIEW:      /* u.typed_array */
#ifdef CONFIG_BIGNUM
      case JS_CLASS_FLOAT_ENV: /* u.float_env */
#endif
      case JS_CLASS_MAP:                      /* u.map_state */
      case JS_CLASS_SET:                      /* u.map_state */
      case JS_CLASS_WEAKMAP:                  /* u.map_state */
      case JS_CLASS_WEAKSET:                  /* u.map_state */
      case JS_CLASS_MAP_ITERATOR:             /* u.map_iterator_data */
      case JS_CLASS_SET_ITERATOR:             /* u.map_iterator_data */
      case JS_CLASS_ARRAY_ITERATOR:           /* u.array_iterator_data */
      case JS_CLASS_STRING_ITERATOR:          /* u.array_iterator_data */
      case JS_CLASS_PROXY:                    /* u.proxy_data */
      case JS_CLASS_PROMISE:                  /* u.promise_data */
      case JS_CLASS_PROMISE_RESOLVE_FUNCTION: /* u.promise_function_data */
      case JS_CLASS_PROMISE_REJECT_FUNCTION:  /* u.promise_function_data */
      case JS_CLASS_ASYNC_FUNCTION_RESOLVE:   /* u.async_function_data */
      case JS_CLASS_ASYNC_FUNCTION_REJECT:    /* u.async_function_data */
      case JS_CLASS_ASYNC_FROM_SYNC_ITERATOR: /* u.async_from_sync_iterator_data
                                               */
      case JS_CLASS_ASYNC_GENERATOR:          /* u.async_generator_data */
                                              /* TODO */
      default:
        /* XXX: class definition should have an opaque block size */
        if (p->u.opaque) {
          s->memory_used_count += 1;
        }
        break;
    }
  }
  s->obj_size += s->obj_count * sizeof(LEPUSObject);

  /* hashed shapes */
  s->memory_used_count++; /* rt->shape_hash */
  s->memory_used_size += sizeof(rt->shape_hash[0]) * rt->shape_hash_size;
  for (i = 0; i < rt->shape_hash_size; i++) {
    JSShape *sh;
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }
  }

  /* atoms */
  s->memory_used_count += 2; /* rt->atom_array, rt->atom_hash */
  s->atom_count = rt->atom_count;
  s->atom_size = sizeof(rt->atom_array[0]) * rt->atom_size +
                 sizeof(rt->atom_hash[0]) * rt->atom_hash_size;
  for (i = 0; i < rt->atom_size; i++) {
    JSAtomStruct *p = rt->atom_array[i];
    if (!atom_is_free(p)) {
      s->atom_size +=
          (sizeof(*p) + (p->len << p->is_wide_char) + 1 - p->is_wide_char);
    }
  }
  s->str_count = round(mem.str_count);
  s->str_size = round(mem.str_size);
  s->lepus_func_count = round(mem.lepus_func_count);
  s->lepus_func_size = round(mem.lepus_func_size);
  s->lepus_func_code_size = round(mem.lepus_func_code_size);
  s->lepus_func_pc2line_count = round(mem.lepus_func_pc2line_count);
  s->lepus_func_pc2line_size = round(mem.lepus_func_pc2line_size);

  s->memory_used_count += round(mem.memory_used_count) + s->atom_count +
                          s->str_count + s->obj_count + s->shape_count +
                          s->lepus_func_count + s->lepus_func_pc2line_count;
  s->memory_used_size += s->atom_size + s->str_size + s->obj_size +
                         s->prop_size + s->shape_size + s->lepus_func_size +
                         s->lepus_func_code_size + s->lepus_func_pc2line_size;
}

void LEPUS_DumpMemoryUsage(FILE *fp, const LEPUSMemoryUsage *s,
                           LEPUSRuntime *rt) {
  if (rt && rt->gc_enable) {
    fprintf(fp,
            "QuickJS memory usage -- \n  malloc_size: %lld\n  malloc_limit: "
            "%lld\n  memory_used_size: %lld",
            s->malloc_size, s->malloc_limit, s->memory_used_size);
    return;
  }
  fprintf(fp,
          "QuickJS memory usage -- "
#ifdef CONFIG_BIGNUM
          "BigNum "
#endif
          " %d-bit, malloc limit: %" PRId64 "\n\n",
          (int)sizeof(void *) * 8, (int64_t)(ssize_t)s->malloc_limit);
#if 1
  if (rt) {
    static const struct {
      const char *name;
      size_t size;
    } object_types[] = {
        {"LEPUSRuntime", sizeof(LEPUSRuntime)},
        {"LEPUSContext", sizeof(LEPUSContext)},
        {"LEPUSObject", sizeof(LEPUSObject)},
        {"JSString", sizeof(JSString)},
        {"LEPUSFunctionBytecode", sizeof(LEPUSFunctionBytecode)},
    };
    int i, usage_size_ok = 0;
    for (i = 0; i < countof(object_types); i++) {
      unsigned int size = object_types[i].size;
      void *p = lepus_malloc_rt(rt, size);
      if (p) {
        unsigned int size1 = lepus_malloc_usable_size_rt(rt, p);
        if (size1 >= size) {
          usage_size_ok = 1;
          fprintf(fp, "  %3u + %-2u  %s\n", size, size1 - size,
                  object_types[i].name);
        }
        lepus_free_rt(rt, p);
      }
    }
    if (!usage_size_ok) {
      fprintf(fp, "  malloc_usable_size unavailable\n");
    }
    {
      int obj_classes[JS_CLASS_INIT_COUNT + 1] = {0};
      int class_id;
      struct list_head *el;
      list_for_each(el, &rt->obj_list) {
        LEPUSObject *p = list_entry(el, LEPUSObject, link);
        obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;
      }
      fprintf(fp,
              "\n"
              "LEPUSObject classes\n");
      if (obj_classes[0])
        fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[0], 0, "none");
      for (class_id = 1; class_id < JS_CLASS_INIT_COUNT; class_id++) {
        if (obj_classes[class_id]) {
          char buf[ATOM_GET_STR_BUF_SIZE];
          fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[class_id], class_id,
                  JS_AtomGetStrRT(rt, buf, sizeof(buf),
                                  js_std_class_def[class_id - 1].class_name));
        }
      }
      if (obj_classes[JS_CLASS_INIT_COUNT])
        fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[JS_CLASS_INIT_COUNT], 0,
                "other");
    }
    fprintf(fp, "\n");
  }
#endif
  fprintf(fp, "%-20s %8s %8s\n", "NAME", "COUNT", "SIZE");

  if (s->malloc_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per block)\n",
            "memory allocated", s->malloc_count, s->malloc_size,
            (double)s->malloc_size / s->malloc_count);
    fprintf(fp,
            "%-20s %8" PRId64 " %8" PRId64
            "  (%d overhead, %0.1f average slack)\n",
            "memory used", s->memory_used_count, s->memory_used_size,
            MALLOC_OVERHEAD,
            ((double)(s->malloc_size - s->memory_used_size) /
             s->memory_used_count));
  }
  if (s->atom_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per atom)\n", "atoms",
            s->atom_count, s->atom_size, (double)s->atom_size / s->atom_count);
  }
  if (s->str_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per string)\n",
            "strings", s->str_count, s->str_size,
            (double)s->str_size / s->str_count);
  }
  if (s->obj_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per object)\n",
            "objects", s->obj_count, s->obj_size,
            (double)s->obj_size / s->obj_count);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per object)\n",
            "  properties", s->prop_count, s->prop_size,
            (double)s->prop_count / s->obj_count);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per shape)\n",
            "  shapes", s->shape_count, s->shape_size,
            (double)s->shape_size / s->shape_count);
  }
  if (s->lepus_func_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "\n", "bytecode functions",
            s->lepus_func_count, s->lepus_func_size);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per function)\n",
            "  bytecode", s->lepus_func_count, s->lepus_func_code_size,
            (double)s->lepus_func_code_size / s->lepus_func_count);
    if (s->lepus_func_pc2line_count) {
      fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per function)\n",
              "  pc2line", s->lepus_func_pc2line_count,
              s->lepus_func_pc2line_size,
              (double)s->lepus_func_pc2line_size / s->lepus_func_pc2line_count);
    }
  }
  if (s->c_func_count) {
    fprintf(fp, "%-20s %8" PRId64 "\n", "C functions", s->c_func_count);
  }
  if (s->array_count) {
    fprintf(fp, "%-20s %8" PRId64 "\n", "arrays", s->array_count);
    if (s->fast_array_count) {
      fprintf(fp, "%-20s %8" PRId64 "\n", "  fast arrays", s->fast_array_count);
      fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per fast array)\n",
              "  elements", s->fast_array_elements,
              s->fast_array_elements * (int)sizeof(LEPUSValue),
              (double)s->fast_array_elements / s->fast_array_count);
    }
  }
  if (s->binary_object_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "\n", "binary objects",
            s->binary_object_count, s->binary_object_size);
  }
}

#endif

LEPUSValue LEPUS_GetGlobalObject(LEPUSContext *ctx) {
  CallGCFunc(JS_GetGlobalObject_GC, ctx);
  return LEPUS_DupValue(ctx, ctx->global_obj);
}

/* WARNING: obj is freed */
LEPUSValue LEPUS_Throw(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUSRuntime *rt = ctx->rt;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, rt->current_exception);
  rt->current_exception = obj;
  rt->exception_needs_backtrace = LEPUS_IsError(ctx, obj);
  if (LEPUS_IsObject(rt->current_exception) &&
      find_own_property1(LEPUS_VALUE_GET_OBJ(rt->current_exception),
                         JS_ATOM_stack))
    rt->exception_needs_backtrace = FALSE;
  return LEPUS_EXCEPTION;
}

/* return the pending exception (cannot be called twice). */
LEPUSValue LEPUS_GetException(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue val;
  val = rt->current_exception;
  rt->current_exception = LEPUS_NULL;
  rt->exception_needs_backtrace = FALSE;
  return val;
}
#ifndef NO_QUICKJS_COMPILER
QJS_STATIC void dbuf_put_leb128(DynBuf *s, uint32_t v) {
  uint32_t a;
  for (;;) {
    a = v & 0x7f;
    v >>= 7;
    if (v != 0) {
      dbuf_putc(s, a | 0x80);
    } else {
      dbuf_putc(s, a);
      break;
    }
  }
}

QJS_STATIC void dbuf_put_sleb128(DynBuf *s, int32_t v1) {
  uint32_t v = v1;
  dbuf_put_leb128(s, (2 * v) ^ -(v >> 31));
}

// <Primjs begin>
QJS_STATIC void dbuf_put_leb128_u64(DynBuf *s, uint64_t v) {
  uint64_t a;
  for (;;) {
    a = v & 0x7f;
    v >>= 7;
    if (v != 0) {
      dbuf_putc(s, a | 0x80);
    } else {
      dbuf_putc(s, a);
      break;
    }
  }
}

QJS_STATIC void dbuf_put_sleb128_u64(DynBuf *s, int64_t v1) {
  uint64_t v = v1;
  dbuf_put_leb128_u64(s, (2 * v) ^ -(v >> 63));
}
// <Primjs begin>
#endif

QJS_STATIC int get_leb128(uint32_t *pval, const uint8_t *buf,
                          const uint8_t *buf_end) {
  const uint8_t *ptr = buf;
  uint32_t v, a, i;
  v = 0;
  for (i = 0; i < 5; i++) {
    if (unlikely(ptr >= buf_end)) break;
    a = *ptr++;
    v |= (a & 0x7f) << (i * 7);
    if (!(a & 0x80)) {
      *pval = v;
      return ptr - buf;
    }
  }
  *pval = 0;
  return -1;
}

QJS_STATIC int get_sleb128(int32_t *pval, const uint8_t *buf,
                           const uint8_t *buf_end) {
  int ret;
  uint32_t val;
  ret = get_leb128(&val, buf, buf_end);
  if (ret < 0) {
    *pval = 0;
    return -1;
  }
  *pval = (val >> 1) ^ -(val & 1);
  return ret;
}

// <Primjs begin>
int get_leb128_u64(uint64_t *pval, const uint8_t *buf, const uint8_t *buf_end) {
  const uint8_t *ptr = buf;
  uint64_t v, a, i;
  v = 0;
  for (i = 0; i < 10; i++) {
    if (unlikely(ptr >= buf_end)) break;
    a = *ptr++;
    v |= (a & 0x7f) << (i * 7);
    if (!(a & 0x80)) {
      *pval = v;
      return ptr - buf;
    }
  }
  *pval = 0;
  return -1;
}

int get_sleb128_u64(int64_t *pval, const uint8_t *buf, const uint8_t *buf_end) {
  int ret;
  uint64_t val;
  ret = get_leb128_u64(&val, buf, buf_end);
  if (ret < 0) {
    *pval = 0;
    return -1;
  }
  *pval = (val >> 1) ^ -(val & 1);
  return ret;
}
// <Primjs end>

/* <Primjs begin> */ int64_t /* <Primjs end> */ find_line_num(
    LEPUSContext *ctx, LEPUSFunctionBytecode *b, uint32_t pc_value) {
  const uint8_t *p_end, *p;
  // <Primjs begin>
  int ret, pc;
  int64_t v, line_num, new_line_num;
  // <Primjs end>

  unsigned int op;

  if (!b->has_debug || !b->debug.pc2line_buf) {
    /* function was stripped */
    return -1;
  }

  p = b->debug.pc2line_buf;
  p_end = p + b->debug.pc2line_len;
  pc = 0;
  line_num = b->debug.line_num;
  while (p < p_end) {
    op = *p++;
    if (op == 0) {
      // <Primjs begin>
      uint64_t val;
      ret = get_leb128_u64(&val, p, p_end);
      // <Primjs end>
      if (ret < 0) goto fail;
      pc += val;
      p += ret;
      // <Primjs begin>
      ret = get_sleb128_u64(&v, p, p_end);
      // <Primjs end>
      if (ret < 0) {
      fail:
        /* should never happen */
        return b->debug.line_num;
      }
      p += ret;
      new_line_num = line_num + v;
    } else {
      op -= PC2LINE_OP_FIRST;
      pc += (op / PC2LINE_RANGE);
      new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;
    }
    if (pc_value < pc) return line_num;
    line_num = new_line_num;
  }
  return line_num;
}

/* in order to avoid executing arbitrary code during the stack trace
   generation, we only look at simple 'name' properties containing a
   string. */
const char *get_func_name(LEPUSContext *ctx, LEPUSValueConst func) {
  JSProperty *pr;
  JSShapeProperty *prs;
  LEPUSValueConst val;

  if (LEPUS_VALUE_IS_NOT_OBJECT(func)) return NULL;
  prs = find_own_property(&pr, LEPUS_VALUE_GET_OBJ(func), JS_ATOM_name);
  if (!prs) return NULL;
  if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_NORMAL) return NULL;
  val = pr->u.value;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  if (!(LEPUS_IsString(val))) return NULL;
  return LEPUS_ToCStringLen2(ctx, NULL, val, 0);
}

#ifdef BUILD_ASYNC_STACK
QJS_STATIC void build_async_backtrace(LEPUSContext *ctx, const uint8_t *cur_pc,
                                      DynBuf *dbuf, BOOL is_debug_mode,
                                      LEPUSValueConst error_obj);
#endif

void build_backtrace_frame(LEPUSContext *ctx, LEPUSStackFrame *sf, DynBuf *dbuf,
                           const uint8_t *cur_pc, BOOL is_async,
                           BOOL is_debug_mode, LEPUSValueConst error_obj) {
  const char *func_name_str;
  const char *str1;
  LEPUSObject *p;

  func_name_str = get_func_name(ctx, sf->cur_func);
  HandleScope func_scope(ctx, &func_name_str, HANDLE_TYPE_CSTRING);
  if (!func_name_str || func_name_str[0] == '\0')
    str1 = "<anonymous>";
  else
    str1 = func_name_str;
  if (is_async)
    dbuf_printf(dbuf, "    at (async)%s", str1);
  else
    dbuf_printf(dbuf, "    at %s", str1);
  if (!ctx->gc_enable) LEPUS_FreeCString(ctx, func_name_str);

  p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
  if (p && lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b;
    char atom_buf[ATOM_GET_STR_BUF_SIZE];
    // <Primjs begin>
    int64_t line_num1;
    // <Primjs end>
    b = p->u.func.function_bytecode;
    if (b->has_debug) {
      if (sf == ctx->rt->current_stack_frame) {
        if (!cur_pc) {
          line_num1 = b->debug.line_num;
        } else {
          line_num1 = find_line_num(ctx, b, cur_pc - b->byte_code_buf - 1);
        }
#ifdef ENABLE_QUICKJS_DEBUGGER
        // get exception line number
        if (is_debug_mode) {
          LEPUS_DefinePropertyValue(
              ctx, error_obj, JS_ATOM_lineNumber,
              LEPUS_NewInt64(ctx, line_num1),
              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
        }
#endif
      } else {
        line_num1 = find_line_num(ctx, b, sf->cur_pc - b->byte_code_buf - 1);
      }
      dbuf_printf(
          dbuf, " (%s",
          JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename));
      if (b->function_id == 0 || ctx->debugger_mode) {
        // output actual line and column number
        if (line_num1 != -1) {
          // <Primjs begin>
          int type = line_num1 >> LINE_COLUMN_TYPE_SHIFT;
          if (type == 1) {
            int line =
                line_num1 & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
            uint64_t column =
                ((line_num1 ^ ((uint64_t)1 << 62)) >> LINE_NUMBER_BITS_COUNT);
            dbuf_printf(dbuf, ":%d:%" PRIu64, line, column);
          } else if (type == 0) {
            int line =
                line_num1 & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
            int column = line_num1 >> OLD_LINE_NUMBER_BITS_COUNT;
            dbuf_printf(dbuf, ":%d:%d", line, column);
          } else {
            dbuf_printf(dbuf, ":-1:-1");
          }
          // <Primjs end>
        } else {
          dbuf_printf(dbuf, ":-1:-1");
        }
      } else {
        // output function id and pc index for lynx redbox
        // To be consistent with lepus, delete '()'
        dbuf_printf(dbuf, ":%" PRIu32, b->function_id - 1);
        if (sf == ctx->rt->current_stack_frame) {
          dbuf_printf(dbuf, ":%" PRIu32,
                      (uint32_t)(cur_pc - b->byte_code_buf - 1));
        } else {
          dbuf_printf(dbuf, ":%" PRIu32,
                      (uint32_t)(sf->cur_pc - b->byte_code_buf - 1));
        }
      }
      dbuf_putc(dbuf, ')');
    }
  } else {
    dbuf_printf(dbuf, " (native)");
  }
  dbuf_putc(dbuf, '\n');
}

#define JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)

/* if filename != NULL, an additional level is added with the filename
   and line number information (used for parse error). If 'pc' !=
   NULL, it is used as the cur_pc value for the current stack frame */
void build_backtrace(LEPUSContext *ctx, LEPUSValueConst error_obj,
                     const char *filename,
                     /* <Primjs begin> */ int64_t line_num, /* <Primjs end> */
                     const uint8_t *cur_pc, int backtrace_flags,
                     uint8_t is_parse_error) {
  BOOL is_debug_mode = FALSE;
#ifdef ENABLE_QUICKJS_DEBUGGER
  is_debug_mode = ctx->debugger_mode;
#endif

  LEPUSStackFrame *sf;
  LEPUSValue str = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &str, HANDLE_TYPE_LEPUS_VALUE);
  DynBuf dbuf;

  ctx->rt->exception_needs_backtrace = FALSE;
  js_dbuf_init(ctx, &dbuf);
  func_scope.PushHandle(&dbuf.buf, HANDLE_TYPE_HEAP_OBJ);
  if (filename) {
    dbuf_printf(&dbuf, "    at %s", filename);
    if (line_num != -1) {
      // <Primjs begin>
      int type = line_num >> LINE_COLUMN_TYPE_SHIFT;
      if (type == 1) {
        // 64 bit line&col
        int line = line_num & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
        uint64_t column =
            ((line_num ^ ((uint64_t)1 << 62)) >> LINE_NUMBER_BITS_COUNT);
        dbuf_printf(&dbuf, ":%d:%" PRIu64, line, column);
      } else if (type == 0) {
        // 32 bit line&col
        int line = line_num & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
        int column = line_num >> OLD_LINE_NUMBER_BITS_COUNT;
        dbuf_printf(&dbuf, ":%d:%d", line, column);
      } else {
        dbuf_printf(&dbuf, ":-1:-1");
      }
      // <Primjs end>
    } else {
      dbuf_printf(&dbuf, ":-1:-1");
    }
    dbuf_putc(&dbuf, '\n');
    str = LEPUS_NewString(ctx, filename);
    LEPUS_DefinePropertyValue(ctx, error_obj, JS_ATOM_fileName, str,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    LEPUS_DefinePropertyValue(ctx, error_obj, JS_ATOM_lineNumber,
                              LEPUS_NewInt32(ctx, line_num),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }

  get_backtrace(ctx, &dbuf, is_debug_mode, error_obj, cur_pc, backtrace_flags);
#ifdef BUILD_ASYNC_STACK
  build_async_backtrace(ctx, cur_pc, &dbuf, is_debug_mode, error_obj);
#endif
  dbuf_putc(&dbuf, '\0');
  if (dbuf_error(&dbuf))
    str = LEPUS_NULL;
  else
    str = LEPUS_NewString(ctx, (char *)dbuf.buf);
  if (!ctx->gc_enable) dbuf_free(&dbuf);
  LEPUS_DefinePropertyValue(ctx, error_obj, JS_ATOM_stack, str,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);

  // <Primjs begin>
// if there is an exception, debugger set system paused if necessary
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (is_debug_mode && !is_parse_error &&
      ctx->rt->debugger_callbacks_.debugger_exception) {
    ctx->rt->debugger_callbacks_.debugger_exception(ctx);
  }
#endif
  // <Primjs end>
}

void get_backtrace(LEPUSContext *ctx, DynBuf *dbuf, BOOL is_debug_mode,
                   LEPUSValueConst error_obj, const uint8_t *cur_pc,
                   int backtrace_flags) {
  LEPUSStackFrame *sf;
  const char *func_name_str;
  const char *str1;
  LEPUSObject *p;

  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
    if (backtrace_flags & JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {
      backtrace_flags &= ~JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;
      continue;
    }
    build_backtrace_frame(ctx, sf, dbuf, cur_pc, FALSE, is_debug_mode,
                          error_obj);
  }
}

LEPUSValue LEPUS_NewError(LEPUSContext *ctx) {
  CallGCFunc(JS_NewError_GC, ctx);
  return LEPUS_NewObjectClass(ctx, JS_CLASS_ERROR);
}

LEPUSValue JS_ThrowError(LEPUSContext *ctx, JSErrorEnum error_num,
                         const char *fmt, va_list ap) {
  char buf[256];
  LEPUSValue obj = LEPUS_UNDEFINED, ret;
  HandleScope func_scope(ctx, &obj, HANDLE_TYPE_LEPUS_VALUE);

  vsnprintf(buf, sizeof(buf), fmt, ap);
  obj = LEPUS_NewObjectProtoClass(ctx, ctx->native_error_proto[error_num],
                                  JS_CLASS_ERROR);
  if (unlikely(LEPUS_IsException(obj))) {
    /* out of memory: throw LEPUS_NULL to avoid recursing */
    obj = LEPUS_NULL;
  } else {
    LEPUSValue str = LEPUS_NewString(ctx, buf);
    func_scope.PushHandle(&str, HANDLE_TYPE_LEPUS_VALUE);
    LEPUS_DefinePropertyValue(ctx, obj, JS_ATOM_message, str,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }
  ret = LEPUS_Throw(ctx, obj);
  return ret;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowSyntaxError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowTypeError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

int __attribute__((format(printf, 3, 4)))
JS_ThrowTypeErrorOrFalse(LEPUSContext *ctx, int flags, const char *fmt, ...) {
  va_list ap;

  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
    va_start(ap, fmt);
    JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);
    va_end(ap);
    return -1;
  } else {
    return FALSE;
  }
}

/* never use it directly */
LEPUSValue __attribute__((format(printf, 3, 4)))
__JS_ThrowTypeErrorAtom(LEPUSContext *ctx, JSAtom atom, const char *fmt, ...) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowTypeError(ctx, fmt,
                              JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
}

/* never use it directly */
QJS_STATIC LEPUSValue __attribute__((format(printf, 3, 4)))
__JS_ThrowSyntaxErrorAtom(LEPUSContext *ctx, JSAtom atom, const char *fmt,
                          ...) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowSyntaxError(ctx, fmt,
                                JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
}

/* %s is replaced by 'atom'. The macro is used so that gcc can check
    the format string. */
#define JS_ThrowTypeErrorAtom(ctx, fmt, atom) \
  __JS_ThrowTypeErrorAtom(ctx, atom, fmt, "")
#define JS_ThrowSyntaxErrorAtom(ctx, fmt, atom) \
  __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, "")

int JS_ThrowTypeErrorReadOnly(LEPUSContext *ctx, int flags, JSAtom atom) {
  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
    JS_ThrowTypeErrorAtom(ctx, "'%s' is read-only", atom);
    return -1;
  } else {
    return FALSE;
  }
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowReferenceError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = JS_ThrowError(ctx, JS_REFERENCE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowRangeError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = JS_ThrowError(ctx, JS_RANGE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowInternalError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = JS_ThrowError(ctx, JS_INTERNAL_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue JS_ThrowTypeErrorNotAnObject(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "not an object");
}

QJS_STATIC LEPUSValue JS_ThrowTypeErrorNotASymbol(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "not a symbol");
}

LEPUSValue JS_ThrowReferenceErrorNotDefined(LEPUSContext *ctx, JSAtom name) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowReferenceError(ctx, "%s is not defined",
                                   JS_AtomGetStr(ctx, buf, sizeof(buf), name));
}

LEPUSValue JS_ThrowReferenceErrorUninitialized(LEPUSContext *ctx, JSAtom name) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowReferenceError(
      ctx, "%s is not initialized",
      name == JS_ATOM_NULL ? "lexical variable"
                           : JS_AtomGetStr(ctx, buf, sizeof(buf), name));
}

QJS_STATIC LEPUSValue JS_ThrowTypeErrorInvalidClass(LEPUSContext *ctx,
                                                    int class_id) {
  LEPUSRuntime *rt = ctx->rt;
  char buf[ATOM_GET_STR_BUF_SIZE];
  JSAtom name;
  name = rt->class_array[class_id].class_name;
  return JS_ThrowTypeErrorAtom(ctx, "%s object expected", name);
}

LEPUSValue JS_ThrowTypeErrorNotFunction(LEPUSContext *ctx) {
  LEPUSStackFrame *sf = ctx->rt->current_stack_frame;
  LEPUSFunctionBytecode *b = nullptr;
  LEPUSValue ret;
  DynBuf name;

  if (ctx->is_lepusng || ctx->debuginfo_outside == 1 || !sf ||
      !js_is_bytecode_function(sf->cur_func)) {
    return LEPUS_ThrowTypeError(ctx, "not a function");
  }
  dbuf_init(&name);
  HandleScope func_scope{ctx, &name.buf, HANDLE_TYPE_HEAP_OBJ};

  b = LEPUS_VALUE_GET_OBJ(sf->cur_func)->u.func.function_bytecode;
  find_name_info(b, sf->cur_pc - b->byte_code_buf, &name);
  ret = LEPUS_ThrowTypeError(ctx, "%s is not a function", name.buf);
  if (!ctx->gc_enable) dbuf_free(&name);
  return ret;
}

/* return -1 (exception) or TRUE/FALSE */
int JS_SetPrototypeInternal(LEPUSContext *ctx, LEPUSValueConst obj,
                            LEPUSValueConst proto_val, BOOL throw_flag) {
  CallGCFunc(JS_SetPrototypeInternal_GC, ctx, obj, proto_val, throw_flag);
  LEPUSObject *proto, *p, *p1;
  JSShape *sh;

  if (throw_flag) {
    if (LEPUS_VALUE_IS_NULL(obj) || LEPUS_VALUE_IS_UNDEFINED(obj)) goto not_obj;
  } else {
    if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto not_obj;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_VALUE_IS_NOT_OBJECT(proto_val)) {
    if (!LEPUS_VALUE_IS_NULL(proto_val)) {
    not_obj:
      JS_ThrowTypeErrorNotAnObject(ctx);
      return -1;
    }
    proto = NULL;
  } else {
    proto = LEPUS_VALUE_GET_OBJ(proto_val);
  }

  if (throw_flag && LEPUS_VALUE_IS_NOT_OBJECT(obj)) return TRUE;

  if (unlikely(p->class_id == JS_CLASS_PROXY))
    return js_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);
  sh = p->shape;
  if (sh->proto == proto) return TRUE;
  if (!p->extensible) {
    if (throw_flag) {
      LEPUS_ThrowTypeError(ctx, "object is not extensible");
      return -1;
    } else {
      return FALSE;
    }
  }
  if (proto) {
    /* check if there is a cycle */
    p1 = proto;
    do {
      if (p1 == p) {
        if (throw_flag) {
          LEPUS_ThrowTypeError(ctx, "circular prototype chain");
          return -1;
        } else {
          return FALSE;
        }
      }
      /* Note: for Proxy objects, proto is NULL */
      p1 = p1->shape->proto;
    } while (p1 != NULL);
    LEPUS_DupValue(ctx, proto_val);
  }

  if (js_shape_prepare_update(ctx, p, NULL)) return -1;
  sh = p->shape;
  if (sh->proto) LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  sh->proto = proto;
  return TRUE;
}

/* return -1 (exception) or TRUE/FALSE */
int LEPUS_SetPrototype(LEPUSContext *ctx, LEPUSValueConst obj,
                       LEPUSValueConst proto_val) {
  CallGCFunc(JS_SetPrototype_GC, ctx, obj, proto_val);
  return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);
}

/* Return an Object, LEPUS_NULL or LEPUS_EXCEPTION in case of Proxy object. */
static LEPUSValueConst JS_GetPrototype_RC(LEPUSContext *ctx,
                                          LEPUSValueConst val) {
  LEPUSObject *p;

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      val = ctx->class_proto[JS_CLASS_BIG_INT];
      break;
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx)) {
        val = ctx->class_proto[JS_CLASS_BIG_INT];
      } else {
        val = ctx->class_proto[JS_CLASS_NUMBER];
      }
      break;
    case LEPUS_TAG_FLOAT64:
      val = ctx->class_proto[JS_CLASS_NUMBER];
      break;
    case LEPUS_TAG_BIG_FLOAT:
      val = ctx->class_proto[JS_CLASS_BIG_FLOAT];
      break;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
      val = ctx->class_proto[JS_CLASS_NUMBER];
      break;
#endif
    case LEPUS_TAG_BOOL:
      val = ctx->class_proto[JS_CLASS_BOOLEAN];
      break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING:
      val = ctx->class_proto[JS_CLASS_STRING];
      break;
    case LEPUS_TAG_SYMBOL:
      val = ctx->class_proto[JS_CLASS_SYMBOL];
      break;
    case LEPUS_TAG_OBJECT:
      p = LEPUS_VALUE_GET_OBJ(val);
      if (unlikely(p->class_id == JS_CLASS_PROXY)) {
        val = js_proxy_getPrototypeOf(ctx, val);
      } else {
        p = p->shape->proto;
        if (!p)
          val = LEPUS_NULL;
        else {
          val = LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
        }
      }
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    default:
      val = LEPUS_NULL;
      break;
  }
  return val;
}

LEPUSValueConst LEPUS_GetPrototype(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_GetPrototype_GC, ctx, val);
  return JS_GetPrototype_RC(ctx, val);
}

static LEPUSValue JS_GetPropertyInternal_RC(LEPUSContext *ctx,
                                            LEPUSValueConst obj, JSAtom prop,
                                            LEPUSValueConst this_obj,
                                            BOOL throw_ref_error);

/* return TRUE, FALSE or (-1) in case of exception */
QJS_STATIC int JS_OrdinaryIsInstanceOf(LEPUSContext *ctx, LEPUSValueConst val,
                                       LEPUSValueConst obj) {
  LEPUSValue obj_proto;
  LEPUSObject *proto;
  const LEPUSObject *p, *proto1;
  BOOL ret;

  if (!LEPUS_IsFunction(ctx, obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id == JS_CLASS_BOUND_FUNCTION) {
    JSBoundFunction *s = p->u.bound_function;
    return JS_IsInstanceOf_RC(ctx, val, s->func_obj);
  }

  /* Only explicitly boxed values are instances of constructors */
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  ret = FALSE;
  obj_proto = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_prototype, obj, 0);
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj_proto)) {
    if (!LEPUS_IsException(obj_proto))
      LEPUS_ThrowTypeError(ctx,
                           "operand 'prototype' property is not an object");
    ret = -1;
    goto done;
  }
  proto = LEPUS_VALUE_GET_OBJ(obj_proto);
  p = LEPUS_VALUE_GET_OBJ(val);
  for (;;) {
    proto1 = p->shape->proto;
    if (!proto1) {
      if (p->class_id == JS_CLASS_PROXY) {
        LEPUSValueConst proto_val;
        proto_val = JS_GetPrototype_RC(
            ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, (LEPUSObject *)p));
        if (LEPUS_IsException(proto_val)) {
          ret = -1;
          goto done;
        }
        proto1 = LEPUS_VALUE_GET_OBJ(proto_val);
        if (!proto1) break;
      } else {
        break;
      }
    }
    p = proto1;
    if (proto == p) {
      ret = TRUE;
      break;
    }
  }
done:
  LEPUS_FreeValue(ctx, obj_proto);
  return ret;
}

/* return TRUE, FALSE or (-1) in case of exception */
static int JS_IsInstanceOf_RC(LEPUSContext *ctx, LEPUSValueConst val,
                              LEPUSValueConst obj) {
  LEPUSValue method;
  // <Primjs begin>
  obj = JSRef2Value(ctx, obj);
  // <Primjs end>

  if (!LEPUS_IsObject(obj)) goto fail;
  method =
      JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_Symbol_hasInstance, obj, 0);
  if (LEPUS_IsException(method)) return -1;
  if (!LEPUS_IsNull(method) && !LEPUS_IsUndefined(method)) {
    LEPUSValue ret;
    ret = JS_CallFree(ctx, method, obj, 1, &val);
    return JS_ToBoolFree_RC(ctx, ret);
  }

  /* legacy case */
  if (!LEPUS_IsFunction(ctx, obj)) {
  fail:
    LEPUS_ThrowTypeError(ctx, "invalid 'instanceof' right operand");
    return -1;
  }
  return JS_OrdinaryIsInstanceOf(ctx, val, obj);
}

int LEPUS_IsInstanceOf(LEPUSContext *ctx, LEPUSValueConst val,
                       LEPUSValueConst obj) {
  CallGCFunc(JS_IsInstanceOf_GC, ctx, val, obj);
  return JS_IsInstanceOf_RC(ctx, val, obj);
}

#ifdef QJS_UNITTEST
LEPUSValue GetLEPUSPropertyValue(JSProperty *pr) {
  if (pr) {
    return pr->u.value;
  }
  return LEPUS_MKVAL(LEPUS_TAG_NULL, 0);
}

uint32_t GetLEPUSShapePropertyFlags(JSShapeProperty *prs) {
  if (prs) {
    return prs->flags;
  }
  return 0;
}
#endif

/* return the value associated to the autoinit property or an exception */
typedef LEPUSValue JSAutoInitFunc(LEPUSContext *ctx, LEPUSObject *p,
                                  JSAtom atom, void *opaque);

QJS_STATIC int JS_AutoInitProperty(LEPUSContext *ctx, LEPUSObject *p,
                                   JSAtom prop, JSProperty *pr,
                                   JSShapeProperty *prs) {
  LEPUSValue val;
  JSAutoInitFunc *func;

  if (js_shape_prepare_update(ctx, p, &prs)) return -1;
  func = pr->u.init.init_func;
  /* 'func' shall not modify the object properties 'pr' */
  val = func(ctx, p, prop, pr->u.init.opaque);
  prs->flags &= ~LEPUS_PROP_TMASK;
  pr->u.value = LEPUS_UNDEFINED;
  if (LEPUS_IsException(val)) return -1;
  pr->u.value = val;
  return 0;
}

static LEPUSValue JS_GetPropertyInternal_RC(LEPUSContext *ctx,
                                            LEPUSValueConst obj, JSAtom prop,
                                            LEPUSValueConst this_obj,
                                            BOOL throw_ref_error) {
  return JS_GetPropertyInternalImpl(ctx, obj, prop, this_obj, throw_ref_error);
}

LEPUSValue LEPUS_GetPropertyInternal(LEPUSContext *ctx, LEPUSValueConst obj,
                                     JSAtom prop, LEPUSValueConst this_obj,
                                     BOOL throw_ref_error) {
  CallGCFunc(JS_GetPropertyInternal_GC, ctx, obj, prop, this_obj,
             throw_ref_error);
  return JS_GetPropertyInternal_RC(ctx, obj, prop, this_obj, throw_ref_error);
}

LEPUSValue JS_GetPropertyInternalImpl(LEPUSContext *ctx, LEPUSValueConst obj,
                                      JSAtom prop, LEPUSValueConst this_obj,
                                      BOOL throw_ref_error) {
  LEPUSObject *p;
  JSProperty *pr;
  JSShapeProperty *prs;
  int64_t tag;
  char buf[ATOM_GET_STR_BUF_SIZE];

  tag = LEPUS_VALUE_GET_TAG(obj);
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
  if (tag == LEPUS_TAG_LEPUS_REF) {
    if (ctx->rt->js_callbacks_.get_property) {
      return JSRefGetProperty(ctx, obj, prop, this_obj, throw_ref_error);
    }
  }
#endif
  // <Primjs end>

  if (unlikely(tag != LEPUS_TAG_OBJECT)) {
    switch (tag) {
      case LEPUS_TAG_NULL:
        // <Primjs begin>
        // if not in the strict mode, read properties from null will return null
        if (ctx->no_lepus_strict_mode) {
          return LEPUS_NULL;
        } else {
          return JS_ThrowTypeErrorAtom(ctx, "cannot read property '%s' of null",
                                       prop);
        }
        // <Primjs end>
      case LEPUS_TAG_UNDEFINED:
        if (ctx->no_lepus_strict_mode) {
          return LEPUS_NULL;
        } else {
          return JS_ThrowTypeErrorAtom(
              ctx, "cannot read property '%s' of undefined", prop);
        }
      case LEPUS_TAG_EXCEPTION:
        return LEPUS_EXCEPTION;
      case LEPUS_TAG_STRING: {
        JSString *p1 = LEPUS_VALUE_GET_STRING(obj);
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx, ch;
          idx = __JS_AtomToUInt32(prop);
          if (idx < p1->len) {
            if (p1->is_wide_char)
              ch = p1->u.str16[idx];
            else
              ch = p1->u.str8[idx];
            return js_new_string_char(ctx, ch);
          }
        } else if (prop == JS_ATOM_length) {
          return LEPUS_NewInt32(ctx, p1->len);
        }
      } break;
      case LEPUS_TAG_SEPARABLE_STRING: {
        auto *separable_string = JS_GetSeparableString(obj);
        if (prop == JS_ATOM_length) {
          return LEPUS_NewInt32(ctx, separable_string->len);
        } else if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx, ch;
          idx = __JS_AtomToUInt32(prop);
          if (idx < separable_string->len) {
            return JS_GetPropertyInternalImpl(
                ctx, JS_GetSeparableStringContentNotDup(ctx, obj), prop,
                this_obj, throw_ref_error);
          }
        }
      } break;
      // <Primjs begin>
#ifdef ENABLE_LEPUSNG
      case LEPUS_TAG_BIG_INT:
        return LEPUS_UNDEFINED;
#endif
        // <Primjs end>
      default:
        break;
    }
    /* cannot raise an exception */
    p = LEPUS_VALUE_GET_OBJ(JS_GetPrototype_RC(ctx, obj));
    if (!p) return LEPUS_UNDEFINED;
  } else {
    p = LEPUS_VALUE_GET_OBJ(obj);
  }

  for (;;) {
    prs = find_own_property(&pr, p, prop);
    if (prs) {
      /* found */
      if (unlikely(prs->flags & LEPUS_PROP_TMASK)) {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          if (unlikely(!pr->u.getset.getter)) {
            return LEPUS_UNDEFINED;
          } else {
            LEPUSValue func =
                LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter);
            /* Note: the field could be removed in the getter */
            func = LEPUS_DupValue(ctx, func);
            return JS_CallFree(ctx, func, this_obj, 0, NULL);
          }
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          LEPUSValue val = *pr->u.var_ref->pvalue;
          if (unlikely(LEPUS_IsUninitialized(val)))
            return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
          return LEPUS_DupValue(ctx, val);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* Instantiate property and retry */
          if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
            return LEPUS_EXCEPTION;
          continue;
        }
      } else {
        return LEPUS_DupValue(ctx, pr->u.value);
      }
    }
    if (unlikely(p->is_exotic)) {
      /* exotic behaviors */
      if (p->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx = __JS_AtomToUInt32(prop);
          if (idx < p->u.array.count) {
            /* we avoid duplicating the code */
            return LEPUS_GetPropertyUint32(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), idx);
          } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
                     p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
            goto typed_array_oob;
          }
        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
          int ret;
          ret = JS_AtomIsNumericIndex(ctx, prop);
          if (ret != 0) {
            if (ret < 0) return LEPUS_EXCEPTION;
          typed_array_oob:
            /* when array is detached, return undefined */
            return LEPUS_UNDEFINED;
          }
        }
      } else {
        const LEPUSClassExoticMethods *em =
            ctx->rt->class_array[p->class_id].exotic;
        if (em) {
          if (em->get_property) {
            /* XXX: should pass throw_ref_error */
            return em->get_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop,
                                    this_obj);
          }
          if (em->get_own_property) {
            LEPUSPropertyDescriptor desc;
            int ret;

            ret = em->get_own_property(ctx, &desc,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop);
            if (ret < 0) return LEPUS_EXCEPTION;
            if (ret) {
              if (desc.flags & LEPUS_PROP_GETSET) {
                LEPUS_FreeValue(ctx, desc.setter);
                return JS_CallFree(ctx, desc.getter, this_obj, 0, NULL);
              } else {
                return desc.value;
              }
            }
          }
        }
      }
    }
    p = p->shape->proto;
    if (!p) break;
  }
  if (unlikely(throw_ref_error)) {
    return JS_ThrowReferenceErrorNotDefined(ctx, prop);
  } else {
    return LEPUS_UNDEFINED;
  }
}

LEPUSValue JS_ThrowTypeErrorPrivateNotFound(LEPUSContext *ctx, JSAtom atom) {
  return JS_ThrowTypeErrorAtom(ctx, "private class field '%s' does not exist",
                               atom);
}

/* Private fields can be added even on non extensible objects or
   Proxies */
int JS_DefinePrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                          LEPUSValueConst name, LEPUSValue val) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  JSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    goto fail;
  }
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name))) {
    JS_ThrowTypeErrorNotASymbol(ctx);
    goto fail;
  }
  prop = js_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    JS_ThrowTypeErrorAtom(ctx, "private class field '%s' already exists", prop);
    goto fail;
  }
  pr = add_property(ctx, p, prop, LEPUS_PROP_C_W_E);
  if (unlikely(!pr)) {
  fail:
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  pr->u.value = val;
  return 0;
}

LEPUSValue JS_GetPrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                              LEPUSValueConst name) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  JSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj)))
    return JS_ThrowTypeErrorNotAnObject(ctx);
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name)))
    return JS_ThrowTypeErrorNotASymbol(ctx);
  prop = js_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (!prs) {
    JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
    return LEPUS_EXCEPTION;
  }
  return LEPUS_DupValue(ctx, pr->u.value);
}

int JS_SetPrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                       LEPUSValueConst name, LEPUSValue val) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  JSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    goto fail;
  }
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name))) {
    JS_ThrowTypeErrorNotASymbol(ctx);
    goto fail;
  }
  prop = js_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (!prs) {
    JS_ThrowTypeErrorPrivateNotFound(ctx, prop);
  fail:
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  set_value(ctx, &pr->u.value, val);
  return 0;
}

int JS_AddBrand(LEPUSContext *ctx, LEPUSValueConst obj,
                LEPUSValueConst home_obj) {
  LEPUSObject *p, *p1;
  JSShapeProperty *prs;
  JSProperty *pr;
  LEPUSValue brand;
  JSAtom brand_atom;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(home_obj))) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p = LEPUS_VALUE_GET_OBJ(home_obj);
  prs = find_own_property(&pr, p, JS_ATOM_Private_brand);
  if (!prs) {
    brand = JS_NewSymbolFromAtom(ctx, JS_ATOM_brand, JS_ATOM_TYPE_PRIVATE);
    if (LEPUS_IsException(brand)) return -1;
    /* if the brand is not present, add it */
    pr = add_property(ctx, p, JS_ATOM_Private_brand, LEPUS_PROP_C_W_E);
    if (!pr) {
      LEPUS_FreeValue(ctx, brand);
      return -1;
    }
    pr->u.value = LEPUS_DupValue(ctx, brand);
  } else {
    brand = LEPUS_DupValue(ctx, pr->u.value);
  }
  brand_atom = js_symbol_to_atom(ctx, brand);

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    LEPUS_FreeAtom(ctx, brand_atom);
    return -1;
  }
  p1 = LEPUS_VALUE_GET_OBJ(obj);
  pr = add_property(ctx, p1, brand_atom, LEPUS_PROP_C_W_E);
  LEPUS_FreeAtom(ctx, brand_atom);
  if (!pr) return -1;
  pr->u.value = LEPUS_UNDEFINED;
  return 0;
}

int JS_CheckBrand(LEPUSContext *ctx, LEPUSValueConst obj,
                  LEPUSValueConst func) {
  LEPUSObject *p, *p1, *home_obj;
  JSShapeProperty *prs;
  JSProperty *pr;
  LEPUSValueConst brand;

  /* get the home object of 'func' */
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func))) {
  not_obj:
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p1 = LEPUS_VALUE_GET_OBJ(func);
  if (!lepus_class_has_bytecode(p1->class_id)) goto not_obj;
  home_obj = p1->u.func.home_object;
  if (!home_obj) goto not_obj;
  prs = find_own_property(&pr, home_obj, JS_ATOM_Private_brand);
  if (!prs) {
    LEPUS_ThrowTypeError(ctx, "expecting <brand> private field");
    return -1;
  }
  brand = pr->u.value;
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(brand))) goto not_obj;

  /* get the brand array of 'obj' */
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) goto not_obj;
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (LEPUSValue)brand));
  if (!prs) {
    LEPUS_ThrowTypeError(ctx, "invalid brand on object");
    return -1;
  }
  return 0;
}

QJS_STATIC int num_keys_cmp(const void *p1, const void *p2, void *opaque) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  JSAtom atom1 = ((const LEPUSPropertyEnum *)p1)->atom;
  JSAtom atom2 = ((const LEPUSPropertyEnum *)p2)->atom;
  uint32_t v1, v2;
  BOOL atom1_is_integer, atom2_is_integer;

  atom1_is_integer = JS_AtomIsArrayIndex(ctx, &v1, atom1);
  atom2_is_integer = JS_AtomIsArrayIndex(ctx, &v2, atom2);
  assert(atom1_is_integer && atom2_is_integer);
  if (v1 < v2)
    return -1;
  else if (v1 == v2)
    return 0;
  else
    return 1;
}

QJS_STATIC void js_free_prop_enum(LEPUSContext *ctx, LEPUSPropertyEnum *tab,
                                  uint32_t len) {
  uint32_t i;
  if (tab) {
    for (i = 0; i < len; i++) LEPUS_FreeAtom(ctx, tab[i].atom);
    lepus_free(ctx, tab);
  }
}

/* return < 0 in case if exception, 0 if OK. ptab and its atoms must
   be freed by the user. */
QJS_STATIC int __exception
JS_GetOwnPropertyNamesInternal(LEPUSContext *ctx, LEPUSPropertyEnum **ptab,
                               uint32_t *plen, LEPUSObject *p, int flags) {
  int32_t i, j;
  JSShape *sh;
  JSShapeProperty *prs;
  LEPUSPropertyEnum *tab_atom, *tab_exotic;
  JSAtom atom;
  uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;
  uint32_t num_index, str_index, sym_index, exotic_count;
  BOOL is_enumerable, num_sorted;
  uint32_t num_key;
  JSAtomKindEnum kind;

  /* clear pointer for consistency in case of failure */
  *ptab = NULL;
  *plen = 0;

  /* compute the number of returned properties */
  num_keys_count = 0;
  str_keys_count = 0;
  sym_keys_count = 0;
  exotic_count = 0;
  tab_exotic = NULL;
  sh = p->shape;
  for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
    atom = prs->atom;
    if (atom != JS_ATOM_NULL) {
      is_enumerable = ((prs->flags & LEPUS_PROP_ENUMERABLE) != 0);
      kind = JS_AtomGetKind(ctx, atom);
      if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
          ((flags >> kind) & 1) != 0) {
        /* need to raise an exception in case of the module
           name space (implicit GetOwnProperty) */
        if (unlikely((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) &&
            (flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY))) {
          JSVarRef *var_ref = p->prop[i].u.var_ref;
          if (unlikely(LEPUS_IsUninitialized(*var_ref->pvalue))) {
            JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
            return -1;
          }
        }
        if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
          num_keys_count++;
        } else if (kind == JS_ATOM_KIND_STRING) {
          str_keys_count++;
        } else {
          sym_keys_count++;
        }
      }
    }
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      /* the implicit GetOwnProperty raises an exception if the
         typed array is detached */
      if ((flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY)) &&
          (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
           p->class_id <= JS_CLASS_FLOAT64_ARRAY) &&
          typed_array_is_detached(ctx, p) &&
          typed_array_get_length(ctx, p) != 0) {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        return -1;
      }
      num_keys_count += p->u.array.count;
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->get_own_property_names) {
        if (em->get_own_property_names(ctx, &tab_exotic, &exotic_count,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p)))
          return -1;
        for (i = 0; i < exotic_count; i++) {
          atom = tab_exotic[i].atom;
          kind = JS_AtomGetKind(ctx, atom);
          if (((flags >> kind) & 1) != 0) {
            is_enumerable = FALSE;
            if (flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY)) {
              LEPUSPropertyDescriptor desc;
              int res;
              /* set the "is_enumerable" field if necessary */
              res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
              if (res < 0) {
                js_free_prop_enum(ctx, tab_exotic, exotic_count);
                return -1;
              }
              if (res) {
                is_enumerable = ((desc.flags & LEPUS_PROP_ENUMERABLE) != 0);
                js_free_desc(ctx, &desc);
              }
              tab_exotic[i].is_enumerable = is_enumerable;
            }
            if (!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) {
              if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
                num_keys_count++;
              } else if (kind == JS_ATOM_KIND_STRING) {
                str_keys_count++;
              } else {
                sym_keys_count++;
              }
            }
          }
        }
      }
    }
  }

  /* fill them */

  atom_count = num_keys_count + str_keys_count + sym_keys_count;
  if (atom_count > JS_ATOM_MAX_INT) {
    LEPUS_ThrowRangeError(ctx, "Too many properties to enumerate");
    js_free_prop_enum(ctx, tab_exotic, exotic_count);
    return -1;
  }
  /* avoid allocating 0 bytes */
  tab_atom = static_cast<LEPUSPropertyEnum *>(
      lepus_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1)));
  if (!tab_atom) {
    js_free_prop_enum(ctx, tab_exotic, exotic_count);
    return -1;
  }

  num_index = 0;
  str_index = num_keys_count;
  sym_index = str_index + str_keys_count;

  num_sorted = TRUE;
  sh = p->shape;
  for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
    atom = prs->atom;
    if (atom != JS_ATOM_NULL) {
      is_enumerable = ((prs->flags & LEPUS_PROP_ENUMERABLE) != 0);
      kind = JS_AtomGetKind(ctx, atom);
      if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
          ((flags >> kind) & 1) != 0) {
        if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
          j = num_index++;
          num_sorted = FALSE;
        } else if (kind == JS_ATOM_KIND_STRING) {
          j = str_index++;
        } else {
          j = sym_index++;
        }
        tab_atom[j].atom = LEPUS_DupAtom(ctx, atom);
        tab_atom[j].is_enumerable = is_enumerable;
      }
    }
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      for (i = 0; i < p->u.array.count; i++) {
        tab_atom[num_index].atom = __JS_AtomFromUInt32(i);
        if (tab_atom[num_index].atom == JS_ATOM_NULL) {
          js_free_prop_enum(ctx, tab_exotic, exotic_count);
          js_free_prop_enum(ctx, tab_atom, num_index);
          return -1;
        }
        tab_atom[num_index].is_enumerable = TRUE;
        num_index++;
      }
    }
    if (exotic_count > 0) {
      for (i = 0; i < exotic_count; i++) {
        atom = tab_exotic[i].atom;
        is_enumerable = tab_exotic[i].is_enumerable;
        kind = JS_AtomGetKind(ctx, atom);
        if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
            ((flags >> kind) & 1) != 0) {
          if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
            j = num_index++;
            num_sorted = FALSE;
          } else if (kind == JS_ATOM_KIND_STRING) {
            j = str_index++;
          } else {
            j = sym_index++;
          }
          tab_atom[j].atom = atom;
          tab_atom[j].is_enumerable = is_enumerable;
        } else {
          LEPUS_FreeAtom(ctx, atom);
        }
      }
    }
    lepus_free(ctx, tab_exotic);
  }

  assert(num_index == num_keys_count);
  assert(str_index == num_keys_count + str_keys_count);
  assert(sym_index == atom_count);

  if (num_keys_count != 0 && !num_sorted) {
    rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp, ctx);
  }
  *ptab = tab_atom;
  *plen = atom_count;
  return 0;
}

int LEPUS_GetOwnPropertyNames(LEPUSContext *ctx, LEPUSPropertyEnum **ptab,
                              uint32_t *plen, LEPUSValueConst obj, int flags) {
  CallGCFunc(JS_GetOwnPropertyNames_GC, ctx, ptab, plen, obj, flags);
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,
                                        LEPUS_VALUE_GET_OBJ(obj), flags);
}

/* Return -1 if exception,
   FALSE if the property does not exist, TRUE if it exists. If TRUE is
   returned, the property descriptor 'desc' is filled present. */
QJS_STATIC int JS_GetOwnPropertyInternal(LEPUSContext *ctx,
                                         LEPUSPropertyDescriptor *desc,
                                         LEPUSObject *p, JSAtom prop) {
  JSShapeProperty *prs;
  JSProperty *pr;

retry:
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    if (desc) {
      desc->flags = prs->flags & LEPUS_PROP_C_W_E;
      desc->getter = LEPUS_UNDEFINED;
      desc->setter = LEPUS_UNDEFINED;
      desc->value = LEPUS_UNDEFINED;
      if (unlikely(prs->flags & LEPUS_PROP_TMASK)) {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          desc->flags |= LEPUS_PROP_GETSET;
          if (pr->u.getset.getter)
            desc->getter = LEPUS_DupValue(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (pr->u.getset.setter)
            desc->setter = LEPUS_DupValue(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          LEPUSValue val = *pr->u.var_ref->pvalue;
          if (unlikely(LEPUS_IsUninitialized(val))) {
            JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
            return -1;
          }
          desc->value = LEPUS_DupValue(ctx, val);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* Instantiate property and retry */
          if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) return -1;
          goto retry;
        }
      } else {
        desc->value = LEPUS_DupValue(ctx, pr->u.value);
      }
    } else {
      /* for consistency, send the exception even if desc is NULL */
      if (unlikely((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF)) {
        if (unlikely(LEPUS_IsUninitialized(*pr->u.var_ref->pvalue))) {
          JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
          return -1;
        }
      } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
        /* nothing to do: delay instantiation until actual value and/or
         * attributes are read */
      }
    }
    return TRUE;
  }
  if (p->is_exotic) {
    if (p->fast_array) {
      /* specific case for fast arrays */
      if (__JS_AtomIsTaggedInt(prop)) {
        uint32_t idx;
        idx = __JS_AtomToUInt32(prop);
        if (idx < p->u.array.count) {
          if (desc) {
            desc->flags = LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE;
            if (p->class_id == JS_CLASS_ARRAY ||
                p->class_id == JS_CLASS_ARGUMENTS)
              desc->flags |= LEPUS_PROP_CONFIGURABLE;
            desc->getter = LEPUS_UNDEFINED;
            desc->setter = LEPUS_UNDEFINED;
            desc->value = LEPUS_GetPropertyUint32(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), idx);
          }
          return TRUE;
        }
      }
      /* 10.4.5.9: If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is true, return
       * false.*/
      // if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
      //     p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
      //   int ret;
      //   ret = JS_AtomIsNumericIndex(ctx, prop);
      //   if (ret != 0) {
      //     if (ret < 0) return -1;
      //     if (typed_array_is_detached(ctx, p)) {
      //       JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
      //       return -1;
      //     }
      //   }
      // }
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->get_own_property) {
        return em->get_own_property(ctx, desc, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p),
                                    prop);
      }
    }
  }
  return FALSE;
}

int LEPUS_GetOwnProperty(LEPUSContext *ctx, LEPUSPropertyDescriptor *desc,
                         LEPUSValueConst obj, JSAtom prop) {
  CallGCFunc(JS_GetOwnProperty_GC, ctx, desc, obj, prop);
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  return JS_GetOwnPropertyInternal(ctx, desc, LEPUS_VALUE_GET_OBJ(obj), prop);
}

/* return -1 if exception (Proxy object only) or TRUE/FALSE */
int LEPUS_IsExtensible(LEPUSContext *ctx, LEPUSValueConst obj) {
  CallGCFunc(JS_IsExtensible_GC, ctx, obj);
  LEPUSObject *p;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (unlikely(p->class_id == JS_CLASS_PROXY))
    return js_proxy_isExtensible(ctx, obj);
  else
    return p->extensible;
}

/* return -1 if exception (Proxy object only) or TRUE/FALSE */
int LEPUS_PreventExtensions(LEPUSContext *ctx, LEPUSValueConst obj) {
  CallGCFunc(JS_PreventExtensions_GC, ctx, obj);
  LEPUSObject *p;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (unlikely(p->class_id == JS_CLASS_PROXY))
    return js_proxy_preventExtensions(ctx, obj);
  p->extensible = FALSE;
  return TRUE;
}

/* return -1 if exception otherwise TRUE or FALSE */
int LEPUS_HasProperty(LEPUSContext *ctx, LEPUSValueConst obj, JSAtom prop) {
  CallGCFunc(JS_HasProperty_GC, ctx, obj, prop);
  LEPUSObject *p;
  int ret;
  // <Primjs begin>

#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(obj)) {
    return JSRefHasProperty(ctx, obj, prop);
  }
#endif

  // <Primjs end>
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  for (;;) {
    if (p->is_exotic) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->has_property)
        return em->has_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop);
    }
    ret = JS_GetOwnPropertyInternal(ctx, NULL, p, prop);
    if (ret != 0) return ret;
    if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
        p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
      ret = JS_AtomIsNumericIndex(ctx, prop);
      if (ret != 0) {
        if (ret < 0) return -1;
        /* the detached array test was done in
           JS_GetOwnPropertyInternal() */
        return FALSE;
      }
    }
    p = p->shape->proto;
    if (!p) break;
  }
  return FALSE;
}

/* val must be a symbol */
QJS_HIDE JSAtom js_symbol_to_atom(LEPUSContext *ctx, LEPUSValue val) {
  JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
  return js_get_atom_index(ctx->rt, p);
}

/* return JS_ATOM_NULL in case of exception */
JSAtom js_value_to_atom(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(js_value_to_atom_gc, ctx, val);
  JSAtom atom;
  if (LEPUS_VALUE_IS_INT(val) &&
      (uint32_t)LEPUS_VALUE_GET_INT(val) <= JS_ATOM_MAX_INT) {
    /* fast path for integer values */
    atom = __JS_AtomFromUInt32(LEPUS_VALUE_GET_INT(val));
  } else if (LEPUS_VALUE_IS_SYMBOL(val)) {
    JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
    atom = LEPUS_DupAtom(ctx, js_get_atom_index(ctx->rt, p));
  } else {
    LEPUSValue str;
    str = LEPUS_ToPropertyKey(ctx, val);
    if (LEPUS_IsException(str)) return JS_ATOM_NULL;
    if (LEPUS_VALUE_IS_SYMBOL(str)) {
      atom = js_symbol_to_atom(ctx, str);
    } else {
      atom = JS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(str));
    }
  }
  return atom;
}

LEPUSValue JS_GetPropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                               LEPUSValue prop) {
  JSAtom atom;
  LEPUSValue ret;

  if (likely(LEPUS_VALUE_IS_OBJECT(this_obj) && LEPUS_VALUE_IS_INT(prop))) {
    LEPUSObject *p;
    uint32_t idx;
    /* fast path for array access */
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    idx = LEPUS_VALUE_GET_INT(prop);
    switch (p->class_id) {
      case JS_CLASS_ARRAY:
      case JS_CLASS_ARGUMENTS:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_DupValue(ctx, p->u.array.u.values[idx]);
      case JS_CLASS_INT8_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);
      case JS_CLASS_UINT8C_ARRAY:
      case JS_CLASS_UINT8_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);
      case JS_CLASS_INT16_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);
      case JS_CLASS_UINT16_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);
      case JS_CLASS_INT32_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);
      case JS_CLASS_UINT32_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT64_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);
      case JS_CLASS_BIG_UINT64_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return LEPUS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);
#endif
      case JS_CLASS_FLOAT32_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);
      case JS_CLASS_FLOAT64_ARRAY:
        if (unlikely(idx >= p->u.array.count)) goto slow_path;
        return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);
      default:
        goto slow_path;
    }
  } else {
  slow_path:
    atom = js_value_to_atom(ctx, prop);
    LEPUS_FreeValue(ctx, prop);
    if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
    ret = JS_GetPropertyInternal_RC(ctx, this_obj, atom, this_obj, 0);
    LEPUS_FreeAtom(ctx, atom);
    return ret;
  }
}

LEPUSValue LEPUS_GetPropertyUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   uint32_t idx) {
  CallGCFunc(JS_GetPropertyUint32_GC, ctx, this_obj, idx);
  return JS_GetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx));
}

/* Check if an object has a generalized numeric property. Return value:
   -1 for exception,
   TRUE if property exists, stored into *pval,
   FALSE if proprty does not exist.
 */
QJS_STATIC int JS_TryGetPropertyInt64(LEPUSContext *ctx, LEPUSValueConst obj,
                                      int64_t idx, LEPUSValue *pval) {
  LEPUSValue val = LEPUS_UNDEFINED;
  JSAtom prop;
  int present;

  if (likely((uint64_t)idx <= JS_ATOM_MAX_INT)) {
    /* fast path */
    present = LEPUS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx));
    if (present > 0) {
      val = JS_GetPropertyValue(ctx, obj, LEPUS_NewInt32(ctx, idx));
      if (unlikely(LEPUS_IsException(val))) present = -1;
    }
  } else {
    prop = JS_NewAtomInt64(ctx, idx);
    present = -1;
    if (likely(prop != JS_ATOM_NULL)) {
      present = LEPUS_HasProperty(ctx, obj, prop);
      if (present > 0) {
        val = JS_GetPropertyInternal_RC(ctx, obj, prop, obj, 0);
        if (unlikely(LEPUS_IsException(val))) present = -1;
      }
      LEPUS_FreeAtom(ctx, prop);
    }
  }
  *pval = val;
  return present;
}

QJS_STATIC LEPUSValue JS_GetPropertyInt64(LEPUSContext *ctx,
                                          LEPUSValueConst obj, int64_t idx) {
  JSAtom prop;
  LEPUSValue val;

  if ((uint64_t)idx <= INT32_MAX) {
    /* fast path for fast arrays */
    return JS_GetPropertyValue(ctx, obj, LEPUS_NewInt32(ctx, idx));
  }
  prop = JS_NewAtomInt64(ctx, idx);
  if (prop == JS_ATOM_NULL) return LEPUS_EXCEPTION;

  val = JS_GetPropertyInternal_RC(ctx, obj, prop, obj, 0);
  LEPUS_FreeAtom(ctx, prop);
  return val;
}

LEPUSValue LEPUS_GetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                const char *prop) {
  CallGCFunc(JS_GetPropertyStr_GC, ctx, this_obj, prop);
  JSAtom atom;
  LEPUSValue ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = JS_GetPropertyInternal_RC(ctx, this_obj, atom, this_obj, 0);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

/* Note: the property value is not initialized. Return NULL if memory
   error. */
JSProperty *add_property(LEPUSContext *ctx, LEPUSObject *p, JSAtom prop,
                         int prop_flags) {
  JSShape *sh, *new_sh;

  sh = p->shape;
  if (sh->is_hashed) {
    /* try to find an existing shape */
    new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);
    if (new_sh) {
      /* matching shape found: use it */
      /*  the property array may need to be resized */
      if (new_sh->prop_size != sh->prop_size) {
        JSProperty *new_prop;
        new_prop = static_cast<JSProperty *>(lepus_realloc(
            ctx, p->prop, sizeof(p->prop[0]) * new_sh->prop_size));
        if (!new_prop) return NULL;
        p->prop = new_prop;
      }
      p->shape = js_dup_shape(new_sh);
      js_free_shape(ctx->rt, sh);
      return &p->prop[new_sh->prop_count - 1];
    } else if (sh->header.ref_count != 1) {
      /* if the shape is shared, clone it */
      new_sh = js_clone_shape(ctx, sh);
      if (!new_sh) return NULL;
      /* hash the cloned shape */
      new_sh->is_hashed = TRUE;
      js_shape_hash_link(ctx->rt, new_sh);
      js_free_shape(ctx->rt, p->shape);
      p->shape = new_sh;
    }
  }
  assert(p->shape->header.ref_count == 1);
  if (add_shape_property(ctx, &p->shape, p, prop, prop_flags)) return NULL;
  return &p->prop[p->shape->prop_count - 1];
}

/* can be called on Array or Arguments objects. return < 0 if
   memory alloc error. */
QJS_STATIC no_inline __exception int convert_fast_array_to_array(
    LEPUSContext *ctx, LEPUSObject *p) {
  JSProperty *pr;
  JSShape *sh;
  LEPUSValue *tab;
  uint32_t i, len, new_count;

  if (js_shape_prepare_update(ctx, p, NULL)) return -1;
  len = p->u.array.count;
  /* resize the properties once to simplify the error handling */
  sh = p->shape;
  new_count = sh->prop_count + len;
  if (new_count > sh->prop_size) {
    if (resize_properties(ctx, &p->shape, p, new_count)) return -1;
  }

  tab = p->u.array.u.values;
  for (i = 0; i < len; i++) {
    /* add_property cannot fail here but
       __JS_AtomFromUInt32(i) fails for i > INT32_MAX */
    pr = add_property(ctx, p, __JS_AtomFromUInt32(i), LEPUS_PROP_C_W_E);
    pr->u.value = *tab++;
  }
  lepus_free(ctx, p->u.array.u.values);
  p->u.array.count = 0;
  p->u.array.u.values = NULL; /* fail safe */
  p->u.array.u1.size = 0;
  p->fast_array = 0;
  return 0;
}

QJS_STATIC int delete_property(LEPUSContext *ctx, LEPUSObject *p, JSAtom atom) {
  JSShape *sh;
  JSShapeProperty *pr, *lpr, *prop;
  JSProperty *pr1;
  uint32_t lpr_idx;
  intptr_t h, h1;

redo:
  sh = p->shape;
  h1 = atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h1 - 1];
  prop = get_shape_prop(sh);
  lpr = NULL;
  lpr_idx = 0; /* prevent warning */
  while (h != 0) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      /* found ! */
      if (!(pr->flags & LEPUS_PROP_CONFIGURABLE)) return FALSE;
      /* realloc the shape if needed */
      if (lpr) lpr_idx = lpr - get_shape_prop(sh);
      if (js_shape_prepare_update(ctx, p, &pr)) return -1;
      sh = p->shape;
      /* remove property */
      if (lpr) {
        lpr = get_shape_prop(sh) + lpr_idx;
        lpr->hash_next = pr->hash_next;
      } else {
        sh->prop_hash_end[-h1 - 1] = pr->hash_next;
      }
      /* free the entry */
      pr1 = &p->prop[h - 1];
      free_property(ctx->rt, pr1, pr->flags);
      LEPUS_FreeAtom(ctx, pr->atom);
      /* put default values */
      pr->flags = 0;
      pr->atom = JS_ATOM_NULL;
      pr1->u.value = LEPUS_UNDEFINED;
      return TRUE;
    }
    lpr = pr;
    h = pr->hash_next;
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      uint32_t idx;
      if (JS_AtomIsArrayIndex(ctx, &idx, atom) && idx < p->u.array.count) {
        if (p->class_id == JS_CLASS_ARRAY ||
            p->class_id == JS_CLASS_ARGUMENTS) {
          /* Special case deleting the last element of a fast Array */
          if (idx == p->u.array.count - 1) {
            LEPUS_FreeValue(ctx, p->u.array.u.values[idx]);
            p->u.array.count = idx;
            return TRUE;
          }
          if (convert_fast_array_to_array(ctx, p)) return -1;
          goto redo;
        } else {
          return FALSE; /* not configurable */
        }
      }
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->delete_property) {
        return em->delete_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), atom);
      }
    }
  }
  /* not found */
  return TRUE;
}

QJS_STATIC int call_setter(LEPUSContext *ctx, LEPUSObject *setter,
                           LEPUSValueConst this_obj, LEPUSValue val,
                           int flags) {
  LEPUSValue ret, func;
  if (likely(setter)) {
    func = LEPUS_MKPTR(LEPUS_TAG_OBJECT, setter);
    /* Note: the field could be removed in the setter */
    func = LEPUS_DupValue(ctx, func);
    ret = JS_CallFree(ctx, func, this_obj, 1, (LEPUSValueConst *)&val);
    LEPUS_FreeValue(ctx, val);
    if (LEPUS_IsException(ret)) return -1;
    LEPUS_FreeValue(ctx, ret);
    return TRUE;
  } else {
    LEPUS_FreeValue(ctx, val);
    if ((flags & LEPUS_PROP_THROW) ||
        ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
      LEPUS_ThrowTypeError(ctx, "no setter for property");
      return -1;
    }
    return FALSE;
  }
}

/* set the array length and remove the array elements if necessary. */
int set_array_length(LEPUSContext *ctx, LEPUSObject *p, JSProperty *prop,
                     LEPUSValue val, int flags) {
  uint32_t len, idx, cur_len;
  int i, ret;

  ret = JS_ToArrayLengthFree(ctx, &len, val, FALSE);
  if (ret) return -1;
  if (likely(p->fast_array)) {
    uint32_t old_len = p->u.array.count;
    if (len < old_len) {
      for (i = len; i < old_len; i++) {
        LEPUS_FreeValue(ctx, p->u.array.u.values[i]);
      }
      p->u.array.count = len;
    }
#ifdef CONFIG_BIGNUM
    set_value(ctx, &prop->u.value, JS_NewUint32(ctx, len));
#else
    prop->u.value = JS_NewUint32(ctx, len);
#endif
  } else {
    /* Note: length is always a uint32 because the object is an
       array */
    LEPUS_ToUint32(ctx, &cur_len, prop->u.value);
    if (len < cur_len) {
      uint32_t d;
      JSShape *sh;
      JSShapeProperty *pr;

      d = cur_len - len;
      sh = p->shape;
      if (d <= sh->prop_count) {
        JSAtom atom;

        /* faster to iterate */
        while (cur_len > len) {
          atom = LEPUS_NewAtomUInt32(ctx, cur_len - 1);
          ret = delete_property(ctx, p, atom);
          LEPUS_FreeAtom(ctx, atom);
          if (unlikely(!ret)) {
            /* unlikely case: property is not
               configurable */
            break;
          }
          cur_len--;
        }
      } else {
        /* faster to iterate thru all the properties. Need two
           passes in case one of the property is not
           configurable */
        cur_len = len;
        for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
          if (pr->atom != JS_ATOM_NULL &&
              JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
            if (idx >= cur_len && !(pr->flags & LEPUS_PROP_CONFIGURABLE)) {
              cur_len = idx + 1;
            }
          }
        }

        for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
          if (pr->atom != JS_ATOM_NULL &&
              JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
            if (idx >= cur_len) {
              /* remove the property */
              delete_property(ctx, p, pr->atom);
              /* WARNING: the shape may have been modified */
              sh = p->shape;
              pr = get_shape_prop(sh) + i;
            }
          }
        }
      }
    } else {
      cur_len = len;
    }
    set_value(ctx, &p->prop[0].u.value, JS_NewUint32(ctx, cur_len));
    if (unlikely(cur_len > len)) {
      return JS_ThrowTypeErrorOrFalse(ctx, flags, "not configurable");
    }
  }
  return TRUE;
}

/* Preconditions: 'p' must be of class JS_CLASS_ARRAY, p->fast_array =
   TRUE and p->extensible = TRUE */
QJS_STATIC int add_fast_array_element(LEPUSContext *ctx, LEPUSObject *p,
                                      LEPUSValue val, int flags) {
  uint32_t new_len, array_len;
  /* extend the array by one */
  /* XXX: convert to slow array if new_len > 2^31-1 elements */
  new_len = p->u.array.count + 1;
  /* update the length if necessary. We assume that if the length is
     not an integer, then if it >= 2^31.  */
  if (likely(LEPUS_VALUE_IS_INT(p->prop[0].u.value))) {
    array_len = LEPUS_VALUE_GET_INT(p->prop[0].u.value);
    if (new_len > array_len) {
      if (unlikely(!(get_shape_prop(p->shape)->flags & LEPUS_PROP_WRITABLE))) {
        LEPUS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
      }
      p->prop[0].u.value = LEPUS_NewInt32(ctx, new_len);
    }
  }
  if (unlikely(new_len > p->u.array.u1.size)) {
    uint32_t new_size;
    size_t slack;
    LEPUSValue *new_array_prop;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);
    new_array_prop = static_cast<LEPUSValue *>(lepus_realloc2(
        ctx, p->u.array.u.values, sizeof(LEPUSValue) * new_size, &slack));
    if (!new_array_prop) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }
    new_size += slack / sizeof(*new_array_prop);
    p->u.array.u.values = new_array_prop;
    p->u.array.u1.size = new_size;
  }
  p->u.array.u.values[new_len - 1] = val;
  p->u.array.count = new_len;
  return TRUE;
}

QJS_STATIC void js_free_desc(LEPUSContext *ctx, LEPUSPropertyDescriptor *desc) {
  LEPUS_FreeValue(ctx, desc->getter);
  LEPUS_FreeValue(ctx, desc->setter);
  LEPUS_FreeValue(ctx, desc->value);
}

/* generic (and slower) version of LEPUS_SetProperty() for Reflect.set() */
int JS_SetPropertyGeneric(LEPUSContext *ctx, LEPUSObject *p, JSAtom prop,
                          LEPUSValue val, LEPUSValueConst this_obj, int flags) {
  CallGCFunc(JS_SetPropertyGeneric_GC, ctx, p, prop, val, this_obj, flags);
  int ret;
  LEPUSPropertyDescriptor desc;

  while (p != NULL) {
    if (p->is_exotic) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->set_property) {
        ret = em->set_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop, val,
                               this_obj, flags);
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
    }

    ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
    if (ret < 0) return ret;
    if (ret) {
      if (desc.flags & LEPUS_PROP_GETSET) {
        LEPUSObject *setter;
        if (LEPUS_IsUndefined(desc.setter))
          setter = NULL;
        else
          setter = LEPUS_VALUE_GET_OBJ(desc.setter);
        ret = call_setter(ctx, setter, this_obj, val, flags);
        LEPUS_FreeValue(ctx, desc.getter);
        LEPUS_FreeValue(ctx, desc.setter);
        return ret;
      } else {
        LEPUS_FreeValue(ctx, desc.value);
        if (!(desc.flags & LEPUS_PROP_WRITABLE)) {
          goto read_only_error;
        }
      }
      break;
    }
    p = p->shape->proto;
  }
  this_obj = JSRef2Value(ctx, this_obj);
  if (!LEPUS_IsObject(this_obj))
    return JS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");

  p = LEPUS_VALUE_GET_OBJ(this_obj);

  /* modify the property in this_obj if it already exists */
  ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
  if (ret < 0) return ret;
  if (ret) {
    if (desc.flags & LEPUS_PROP_GETSET) {
      LEPUS_FreeValue(ctx, desc.getter);
      LEPUS_FreeValue(ctx, desc.setter);
      LEPUS_FreeValue(ctx, val);
      return JS_ThrowTypeErrorOrFalse(ctx, flags, "setter is forbidden");
    } else {
      LEPUS_FreeValue(ctx, desc.value);
      if (!(desc.flags & LEPUS_PROP_WRITABLE) ||
          p->class_id == JS_CLASS_MODULE_NS) {
      read_only_error:
        LEPUS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
      }
    }
    ret = JS_DefineProperty_RC(ctx, this_obj, prop, val, LEPUS_UNDEFINED,
                               LEPUS_UNDEFINED, LEPUS_PROP_HAS_VALUE);
    LEPUS_FreeValue(ctx, val);
    return ret;
  }

  ret = JS_CreateProperty(ctx, p, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
                          flags | LEPUS_PROP_HAS_VALUE |
                              LEPUS_PROP_HAS_ENUMERABLE |
                              LEPUS_PROP_HAS_WRITABLE |
                              LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_C_W_E);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

static int JS_SetPropertyInternal_RC(LEPUSContext *ctx,
                                     LEPUSValueConst this_obj, JSAtom prop,
                                     LEPUSValue val, int flags) {
  return JS_SetPropertyInternalImpl(ctx, this_obj, prop, val, flags);
}

int LEPUS_SetPropertyInternal(LEPUSContext *ctx, LEPUSValueConst this_obj,
                              JSAtom prop, LEPUSValue val, int flags) {
  CallGCFunc(JS_SetPropertyInternal_GC, ctx, this_obj, prop, val, flags);
  return JS_SetPropertyInternal_RC(ctx, this_obj, prop, val, flags);
}

/* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is
   freed by the function. 'flags' is a bitmask of LEPUS_PROP_NO_ADD,
   LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT. If LEPUS_PROP_NO_ADD is set,
   the new property is not added and an error is raised. */

int JS_SetPropertyInternalImpl(LEPUSContext *ctx, LEPUSValueConst this_obj,
                               JSAtom prop, LEPUSValue val, int flags) {
  LEPUSObject *p, *p1;
  JSShapeProperty *prs;
  JSProperty *pr;
  int64_t tag;
  LEPUSPropertyDescriptor desc;
  int ret;
  char buf[ATOM_GET_STR_BUF_SIZE];
  intptr_t offset = 0;

  tag = LEPUS_VALUE_GET_TAG(this_obj);
#ifdef ENABLE_LEPUSNG
  // <Primjs begin>
  if (tag == LEPUS_TAG_LEPUS_REF) {
    LEPUSValue prop_str = LEPUS_UNDEFINED;
    int idx = -1;
    if (__JS_AtomIsTaggedInt(prop)) {
      idx = __JS_AtomToUInt32(prop);
    } else {
      prop_str = LEPUS_AtomToString(ctx, prop);
    }
    LEPUSValue ret =
        ctx->rt->js_callbacks_.set_property(ctx, this_obj, prop_str, idx, val);
    LEPUS_FreeValue(ctx, prop_str);

    if (LEPUS_IsException(ret)) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }

    if (LEPUS_IsUndefined(ret)) {
      auto cache = static_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(this_obj))
                       ->lepus_val;
      if (LEPUS_VALUE_IS_OBJECT(cache)) {
        JS_SetPropertyInternalImpl(ctx, cache, prop, val, flags);
      } else {
        LEPUS_FreeValue(ctx, val);
      }
      return TRUE;
    }
    this_obj = ret;
    tag = LEPUS_VALUE_GET_TAG(this_obj);
  }
#endif
  // <Primjs end>
  if (unlikely(tag != LEPUS_TAG_OBJECT)) {
    switch (tag) {
      case LEPUS_TAG_NULL:
        LEPUS_FreeValue(ctx, val);
        // if not in the strict mode, set properties of null will do nothing and
        // will not throw exception
        if (ctx->no_lepus_strict_mode) {
          return 0;
        } else {
          JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null", prop);
          return -1;
        }
      case LEPUS_TAG_UNDEFINED:
        LEPUS_FreeValue(ctx, val);
        if (ctx->no_lepus_strict_mode) {
          return 0;
        } else {
          JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined",
                                prop);
          return -1;
        }
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
      case LEPUS_TAG_BIG_INT:
        p = NULL;
        p1 = NULL;
        goto prototype_lookup;
#endif
        // <Primjs end>
      default:
        /* even on a primitive type we can have setters on the prototype */
        p = NULL;
        p1 = LEPUS_VALUE_GET_OBJ(JS_GetPrototype_RC(ctx, this_obj));
        goto prototype_lookup;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(this_obj);
retry:
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    if (likely((prs->flags & (LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE |
                              LEPUS_PROP_LENGTH)) == LEPUS_PROP_WRITABLE)) {
      /* fast case */
      set_value(ctx, &pr->u.value, val);
      return TRUE;
    } else if ((prs->flags & (LEPUS_PROP_LENGTH | LEPUS_PROP_WRITABLE)) ==
               (LEPUS_PROP_LENGTH | LEPUS_PROP_WRITABLE)) {
      assert(p->class_id == JS_CLASS_ARRAY);
      assert(prop == JS_ATOM_length);
      return set_array_length(ctx, p, pr, val, flags);
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
      return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
      /* LEPUS_PROP_WRITABLE is always true for variable
         references, but they are write protected in module name
         spaces. */
      if (p->class_id == JS_CLASS_MODULE_NS) goto read_only_prop;
      set_value(ctx, pr->u.var_ref->pvalue, val);
      return TRUE;
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
      /* Instantiate property and retry (potentially useless) */
      if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) {
        LEPUS_FreeValue(ctx, val);
        return -1;
      }
      goto retry;
    } else {
      goto read_only_prop;
    }
  }

  p1 = p;
  for (;;) {
    if (p1->is_exotic) {
      if (p1->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx = __JS_AtomToUInt32(prop);
          if (idx < p1->u.array.count) {
            if (unlikely(p == p1))
              return JS_SetPropertyValue(ctx, this_obj,
                                         LEPUS_NewInt32(ctx, idx), val, flags);
            else
              break;
          } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&
                     p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {
            goto typed_array_oob;
          }
        } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&
                   p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {
          ret = JS_AtomIsNumericIndex(ctx, prop);
          if (ret != 0) {
            if (ret < 0) {
              LEPUS_FreeValue(ctx, val);
              return -1;
            }
          typed_array_oob:
            val = JS_ToNumberFree(ctx, val);
            LEPUS_FreeValue(ctx, val);
            if (LEPUS_IsException(val)) return -1;
            return FALSE;
          }
        }
      } else {
        const LEPUSClassExoticMethods *em =
            ctx->rt->class_array[p1->class_id].exotic;
        if (em) {
          if (em->set_property) {
            ret = em->set_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1), prop,
                                   val, this_obj, flags);
            LEPUS_FreeValue(ctx, val);
            return ret;
          }
          if (em->get_own_property) {
            ret = em->get_own_property(ctx, &desc,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1), prop);
            if (ret < 0) {
              LEPUS_FreeValue(ctx, val);
              return ret;
            }
            if (ret) {
              if (desc.flags & LEPUS_PROP_GETSET) {
                LEPUSObject *setter;
                if (LEPUS_IsUndefined(desc.setter))
                  setter = NULL;
                else
                  setter = LEPUS_VALUE_GET_OBJ(desc.setter);
                ret = call_setter(ctx, setter, this_obj, val, flags);
                LEPUS_FreeValue(ctx, desc.getter);
                LEPUS_FreeValue(ctx, desc.setter);
                return ret;
              } else {
                LEPUS_FreeValue(ctx, desc.value);
                if (!(desc.flags & LEPUS_PROP_WRITABLE)) goto read_only_prop;
                if (likely(p == p1)) {
                  ret = JS_DefineProperty_RC(ctx, this_obj, prop, val,
                                             LEPUS_UNDEFINED, LEPUS_UNDEFINED,
                                             LEPUS_PROP_HAS_VALUE);
                  LEPUS_FreeValue(ctx, val);
                  return ret;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
    }
    p1 = p1->shape->proto;
  prototype_lookup:
    if (!p1) break;

  retry2:
    prs = find_own_property(&pr, p1, prop);
    if (prs) {
      if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
        return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
      } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
        /* Instantiate property and retry (potentially useless) */
        if (JS_AutoInitProperty(ctx, p1, prop, pr, prs)) return -1;
        goto retry2;
      } else if (!(prs->flags & LEPUS_PROP_WRITABLE)) {
      read_only_prop:
        LEPUS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
      }
    }
  }

  if (unlikely(flags & LEPUS_PROP_NO_ADD)) {
    LEPUS_FreeValue(ctx, val);
    JS_ThrowReferenceErrorNotDefined(ctx, prop);
    return -1;
  }

  if (unlikely(!p)) {
    LEPUS_FreeValue(ctx, val);
    return JS_ThrowTypeErrorOrFalse(ctx, flags, "not an object");
  }

  if (unlikely(!p->extensible)) {
    LEPUS_FreeValue(ctx, val);
    return JS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
  }

  if (p->is_exotic) {
    if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&
        __JS_AtomIsTaggedInt(prop)) {
      uint32_t idx = __JS_AtomToUInt32(prop);
      if (idx == p->u.array.count) {
        /* fast case */
        return add_fast_array_element(ctx, p, val, flags);
      } else {
        goto generic_create_prop;
      }
    } else {
    generic_create_prop:
      ret = JS_CreateProperty(
          ctx, p, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
          flags | LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_ENUMERABLE |
              LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_HAS_CONFIGURABLE |
              LEPUS_PROP_C_W_E);
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
  }
  pr = add_property(ctx, p, prop, LEPUS_PROP_C_W_E);
  if (unlikely(!pr)) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  pr->u.value = val;
  return TRUE;
}

/* flags can be LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT */
int JS_SetPropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                        LEPUSValue prop, LEPUSValue val, int flags) {
  if (likely(LEPUS_VALUE_IS_OBJECT(this_obj) && LEPUS_VALUE_IS_INT(prop))) {
    LEPUSObject *p;
    uint32_t idx;
    double d;
    int32_t v;

    /* fast path for array access */
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    idx = LEPUS_VALUE_GET_INT(prop);
    switch (p->class_id) {
      case JS_CLASS_ARRAY:
        if (unlikely(idx >= (uint32_t)p->u.array.count)) {
          LEPUSObject *p1;
          JSShape *sh1;

          /* fast path to add an element to the array */
          if (idx != (uint32_t)p->u.array.count || !p->fast_array ||
              !p->extensible)
            goto slow_path;
          /* check if prototype chain has a numeric property */
          p1 = p->shape->proto;
          while (p1 != NULL) {
            sh1 = p1->shape;
            if (p1->class_id == JS_CLASS_ARRAY) {
              if (unlikely(!p1->fast_array)) goto slow_path;
            } else if (p1->class_id == JS_CLASS_OBJECT) {
              if (unlikely(sh1->has_small_array_index)) goto slow_path;
            } else {
              goto slow_path;
            }
            p1 = sh1->proto;
          }
          /* add element */
          return add_fast_array_element(ctx, p, val, flags);
        }
        set_value(ctx, &p->u.array.u.values[idx], val);
        break;
      case JS_CLASS_ARGUMENTS:
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto slow_path;
        set_value(ctx, &p->u.array.u.values[idx], val);
        break;
      case JS_CLASS_UINT8C_ARRAY:
        if (JS_ToUint8ClampFree(ctx, &v, val)) return -1;
        /* Note: the conversion can detach the typed array, so the
           array bound check must be done after */
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint8_ptr[idx] = v;
        break;
      case JS_CLASS_INT8_ARRAY:
      case JS_CLASS_UINT8_ARRAY:
        if (JS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint8_ptr[idx] = v;
        break;
      case JS_CLASS_INT16_ARRAY:
      case JS_CLASS_UINT16_ARRAY:
        if (JS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint16_ptr[idx] = v;
        break;
      case JS_CLASS_INT32_ARRAY:
      case JS_CLASS_UINT32_ARRAY:
        if (JS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint32_ptr[idx] = v;
        break;
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT64_ARRAY:
      case JS_CLASS_BIG_UINT64_ARRAY:
        /* XXX: need specific conversion function */
        {
          int64_t v;
          if (JS_ToBigInt64Free(ctx, &v, val)) return -1;
          if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
          p->u.array.u.uint64_ptr[idx] = v;
        }
        break;
#endif
      case JS_CLASS_FLOAT32_ARRAY:
        if (JS_ToFloat64Free(ctx, &d, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.float_ptr[idx] = d;
        break;
      case JS_CLASS_FLOAT64_ARRAY:
        if (JS_ToFloat64Free(ctx, &d, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) {
        ta_out_of_bound:
          return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                          "out-of-bound numeric index");
          /* Accroding to 10.4.5.11, if index is invalid, return
           * NormalCompletion(undefined) */
        }
        p->u.array.u.double_ptr[idx] = d;
        break;
      default:
        goto slow_path;
    }
    return TRUE;
  } else {
    JSAtom atom;
    int ret;
  slow_path:
    atom = js_value_to_atom(ctx, prop);
    LEPUS_FreeValue(ctx, prop);
    if (unlikely(atom == JS_ATOM_NULL)) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }
    ret = JS_SetPropertyInternal_RC(ctx, this_obj, atom, val, flags);
    LEPUS_FreeAtom(ctx, atom);
    return ret;
  }
}

int LEPUS_SetPropertyUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            uint32_t idx, LEPUSValue val) {
  CallGCFunc(JS_SetPropertyUint32_GC, ctx, this_obj, idx, val);
  return JS_SetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx), val,
                             LEPUS_PROP_THROW);
}

int LEPUS_SetPropertyInt64(LEPUSContext *ctx, LEPUSValueConst this_obj,
                           int64_t idx, LEPUSValue val) {
  CallGCFunc(JS_SetPropertyInt64_GC, ctx, this_obj, idx, val);
  JSAtom prop;
  int res;

  if ((uint64_t)idx <= INT32_MAX) {
    /* fast path for fast arrays */
    return JS_SetPropertyValue(ctx, this_obj, LEPUS_NewInt32(ctx, idx), val,
                               LEPUS_PROP_THROW);
  }
  prop = JS_NewAtomInt64(ctx, idx);
  if (prop == JS_ATOM_NULL) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  res = JS_SetPropertyInternal_RC(ctx, this_obj, prop, val, LEPUS_PROP_THROW);
  LEPUS_FreeAtom(ctx, prop);
  return res;
}

int LEPUS_SetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                         const char *prop, LEPUSValue val) {
  CallGCFunc(JS_SetPropertyStr_GC, ctx, this_obj, prop, val);
  JSAtom atom;
  int ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = JS_SetPropertyInternal_RC(ctx, this_obj, atom, val, LEPUS_PROP_THROW);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

/* compute the property flags. For each flag: (JS_PROP_HAS_x forces
   it, otherwise def_flags is used)
   Note: makes assumption about the bit pattern of the flags
*/
QJS_STATIC int get_prop_flags(int flags, int def_flags) {
  int mask;
  mask = (flags >> LEPUS_PROP_HAS_SHIFT) & LEPUS_PROP_C_W_E;
  return (flags & mask) | (def_flags & ~mask);
}

QJS_STATIC int JS_CreateProperty(LEPUSContext *ctx, LEPUSObject *p, JSAtom prop,
                                 LEPUSValueConst val, LEPUSValueConst getter,
                                 LEPUSValueConst setter, int flags) {
  JSProperty *pr;
  int ret, prop_flags;

  /* add a new property or modify an existing exotic one */
  if (p->is_exotic) {
    if (p->class_id == JS_CLASS_ARRAY) {
      uint32_t idx, len;

      if (p->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          idx = __JS_AtomToUInt32(prop);
          if (idx == p->u.array.count) {
            if (!p->extensible) goto not_extensible;
            if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET))
              goto convert_to_array;
            prop_flags = get_prop_flags(flags, 0);
            if (prop_flags != LEPUS_PROP_C_W_E) goto convert_to_array;
            return add_fast_array_element(ctx, p, LEPUS_DupValue(ctx, val),
                                          flags);
          } else {
            goto convert_to_array;
          }
        } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {
          /* convert the fast array to normal array */
        convert_to_array:
          if (convert_fast_array_to_array(ctx, p)) return -1;
          goto generic_array;
        }
      } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {
        JSProperty *plen;
        JSShapeProperty *pslen;
      generic_array:
        /* update the length field */
        plen = &p->prop[0];
        LEPUS_ToUint32(ctx, &len, plen->u.value);
        if ((idx + 1) > len) {
          pslen = get_shape_prop(p->shape);
          if (unlikely(!(pslen->flags & LEPUS_PROP_WRITABLE)))
            return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
          /* XXX: should update the length after defining
             the property */
          len = idx + 1;
          set_value(ctx, &plen->u.value, JS_NewUint32(ctx, len));
        }
      }
    } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
               p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
      ret = JS_AtomIsNumericIndex(ctx, prop);
      if (ret != 0) {
        if (ret < 0) return -1;
        /* 10.4.5.5: Always return true */
        // return JS_ThrowTypeErrorOrFalse(
        //     ctx, flags, "cannot create numeric index in typed array");
      }
    } else if (!(flags & LEPUS_PROP_NO_EXOTIC)) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em) {
        if (em->define_own_property) {
          return em->define_own_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p),
                                         prop, val, getter, setter, flags);
        }
        ret = LEPUS_IsExtensible(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
        if (ret < 0) return -1;
        if (!ret) goto not_extensible;
      }
    }
  }

  if (!p->extensible) {
  not_extensible:
    return JS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
  }

  if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    prop_flags = (flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE)) |
                 LEPUS_PROP_GETSET;
  } else {
    prop_flags = flags & LEPUS_PROP_C_W_E;
  }
  pr = add_property(ctx, p, prop, prop_flags);
  if (unlikely(!pr)) return -1;
  if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    pr->u.getset.getter = NULL;
    if ((flags & LEPUS_PROP_HAS_GET) && LEPUS_IsFunction(ctx, getter)) {
      pr->u.getset.getter = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, getter));
    }
    pr->u.getset.setter = NULL;
    if ((flags & LEPUS_PROP_HAS_SET) && LEPUS_IsFunction(ctx, setter)) {
      pr->u.getset.setter = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, setter));
    }
  } else {
    if (flags & LEPUS_PROP_HAS_VALUE) {
      pr->u.value = LEPUS_DupValue(ctx, val);
    } else {
      pr->u.value = LEPUS_UNDEFINED;
    }
  }
  return TRUE;
}

/* return FALSE if not OK */
QJS_STATIC BOOL check_define_prop_flags(int prop_flags, int flags) {
  BOOL has_accessor, is_getset;

  if (!(prop_flags & LEPUS_PROP_CONFIGURABLE)) {
    if ((flags & (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) ==
        (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) {
      return FALSE;
    }
    if ((flags & LEPUS_PROP_HAS_ENUMERABLE) &&
        (flags & LEPUS_PROP_ENUMERABLE) != (prop_flags & LEPUS_PROP_ENUMERABLE))
      return FALSE;
  }
  if (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
               LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    if (!(prop_flags & LEPUS_PROP_CONFIGURABLE)) {
      has_accessor = ((flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) != 0);
      is_getset = ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET);
      if (has_accessor != is_getset) return FALSE;
      if (!has_accessor && !is_getset && !(prop_flags & LEPUS_PROP_WRITABLE)) {
        /* not writable: cannot set the writable bit */
        if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
            (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE))
          return FALSE;
      }
    }
  }
  return TRUE;
}

/* ensure that the shape can be safely modified */
QJS_STATIC int js_shape_prepare_update(LEPUSContext *ctx, LEPUSObject *p,
                                       JSShapeProperty **pprs) {
  JSShape *sh;
  uint32_t idx = 0; /* prevent warning */

  sh = p->shape;
  if (sh->is_hashed) {
    if (sh->header.ref_count != 1) {
      if (pprs) idx = *pprs - get_shape_prop(sh);
      /* clone the shape (the resulting one is no longer hashed) */
      sh = js_clone_shape(ctx, sh);
      if (!sh) return -1;
      js_free_shape(ctx->rt, p->shape);
      p->shape = sh;
      if (pprs) *pprs = get_shape_prop(sh) + idx;
    } else {
      js_shape_hash_unlink(ctx->rt, sh);
      sh->is_hashed = FALSE;
    }
  }
  return 0;
}

QJS_STATIC int js_update_property_flags(LEPUSContext *ctx, LEPUSObject *p,
                                        JSShapeProperty **pprs, int flags) {
  if (flags != (*pprs)->flags) {
    if (js_shape_prepare_update(ctx, p, pprs)) return -1;
    (*pprs)->flags = flags;
  }
  return 0;
}

/* allowed flags:
   LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_WRITABLE, LEPUS_PROP_ENUMERABLE
   LEPUS_PROP_HAS_GET, LEPUS_PROP_HAS_SET, LEPUS_PROP_HAS_VALUE,
   LEPUS_PROP_HAS_CONFIGURABLE, LEPUS_PROP_HAS_WRITABLE,
   LEPUS_PROP_HAS_ENUMERABLE, LEPUS_PROP_THROW, LEPUS_PROP_NO_EXOTIC. If
   LEPUS_PROP_THROW is set, return an exception instead of FALSE. if
   LEPUS_PROP_NO_EXOTIC is set, do not call the exotic define_own_property
   callback. return -1 (exception), FALSE or TRUE.
*/
static int JS_DefineProperty_RC(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                JSAtom prop, LEPUSValueConst val,
                                LEPUSValueConst getter, LEPUSValueConst setter,
                                int flags) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  int mask, res;
  // <Primjs begin>
  this_obj = JSRef2Value(ctx, this_obj);
  // <Primjs end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_obj)) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p = LEPUS_VALUE_GET_OBJ(this_obj);

redo_prop_update:
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* the range of the Array length property is always tested before */
    if ((prs->flags & LEPUS_PROP_LENGTH) && (flags & LEPUS_PROP_HAS_VALUE)) {
      uint32_t array_length;
      if (JS_ToArrayLengthFree(ctx, &array_length, LEPUS_DupValue(ctx, val),
                               FALSE)) {
        return -1;
      }
      /* this code relies on the fact that Uint32 are never allocated */
      val = (LEPUSValueConst)JS_NewUint32(ctx, array_length);
      /* prs may have been modified */
      prs = find_own_property(&pr, p, prop);
      assert(prs != NULL);
    }
    /* property already exists */
    if (!check_define_prop_flags(prs->flags, flags)) {
    not_configurable:
      return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                      "property is not configurable");
    }
    if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
      /* Instantiate property and retry */
      if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) return -1;
      goto redo_prop_update;
    }

    if (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
                 LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
      if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
        LEPUSObject *new_getter, *new_setter;

        if (LEPUS_IsFunction(ctx, getter)) {
          new_getter = LEPUS_VALUE_GET_OBJ(getter);
        } else {
          new_getter = NULL;
        }
        if (LEPUS_IsFunction(ctx, setter)) {
          new_setter = LEPUS_VALUE_GET_OBJ(setter);
        } else {
          new_setter = NULL;
        }

        if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_GETSET) {
          if (js_shape_prepare_update(ctx, p, &prs)) return -1;
          /* convert to getset */
          if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
            free_var_ref(ctx->rt, pr->u.var_ref);
          } else {
            LEPUS_FreeValue(ctx, pr->u.value);
          }
          prs->flags =
              (prs->flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE)) |
              LEPUS_PROP_GETSET;
          pr->u.getset.getter = NULL;
          pr->u.getset.setter = NULL;
        } else {
          if (!(prs->flags & LEPUS_PROP_CONFIGURABLE)) {
            if ((flags & LEPUS_PROP_HAS_GET) &&
                new_getter != pr->u.getset.getter) {
              goto not_configurable;
            }
            if ((flags & LEPUS_PROP_HAS_SET) &&
                new_setter != pr->u.getset.setter) {
              goto not_configurable;
            }
          }
        }
        if (flags & LEPUS_PROP_HAS_GET) {
          if (pr->u.getset.getter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (new_getter) LEPUS_DupValue(ctx, getter);
          pr->u.getset.getter = new_getter;
        }
        if (flags & LEPUS_PROP_HAS_SET) {
          if (pr->u.getset.setter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
          if (new_setter) LEPUS_DupValue(ctx, setter);
          pr->u.getset.setter = new_setter;
        }
      } else {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          /* convert to data descriptor */
          if (js_shape_prepare_update(ctx, p, &prs)) return -1;
          if (pr->u.getset.getter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (pr->u.getset.setter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
          prs->flags &= ~(LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE);
          pr->u.value = LEPUS_UNDEFINED;
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          /* Note: LEPUS_PROP_VARREF is always writable */
        } else {
          if ((prs->flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)) ==
                  0 &&
              (flags & LEPUS_PROP_HAS_VALUE)) {
            if (!js_same_value(ctx, val, pr->u.value)) {
              goto not_configurable;
            } else {
              return TRUE;
            }
          }
        }
        if (prs->flags & LEPUS_PROP_LENGTH) {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            res = set_array_length(ctx, p, pr, LEPUS_DupValue(ctx, val), flags);
          } else {
            res = TRUE;
          }
          /* still need to reset the writable flag if needed.
             The LEPUS_PROP_LENGTH is reset to have the correct
             read-only behavior in LEPUS_SetProperty(). */
          if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
              LEPUS_PROP_HAS_WRITABLE) {
            prs = get_shape_prop(p->shape);
            if (js_update_property_flags(
                    ctx, p, &prs,
                    prs->flags & ~(LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH)))
              return -1;
          }
          return res;
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            if (p->class_id == JS_CLASS_MODULE_NS) {
              /* LEPUS_PROP_WRITABLE is always true for variable
                 references, but they are write protected in module name
                 spaces. */
              if (!js_same_value(ctx, val, *pr->u.var_ref->pvalue))
                goto not_configurable;
            }
            /* update the reference */
            set_value(ctx, pr->u.var_ref->pvalue, LEPUS_DupValue(ctx, val));
          }
          /* if writable is set to false, no longer a
             reference (for mapped arguments) */
          if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
              LEPUS_PROP_HAS_WRITABLE) {
            LEPUSValue val1;
            if (js_shape_prepare_update(ctx, p, &prs)) return -1;
            val1 = LEPUS_DupValue(ctx, *pr->u.var_ref->pvalue);
            free_var_ref(ctx->rt, pr->u.var_ref);
            pr->u.value = val1;
            prs->flags &= ~(LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE);
          }
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* XXX: should never happen, type was reset above */
          abort();
        } else {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            LEPUS_FreeValue(ctx, pr->u.value);
            pr->u.value = LEPUS_DupValue(ctx, val);
          }
          if (flags & LEPUS_PROP_HAS_WRITABLE) {
            if (js_update_property_flags(ctx, p, &prs,
                                         (prs->flags & ~LEPUS_PROP_WRITABLE) |
                                             (flags & LEPUS_PROP_WRITABLE)))
              return -1;
          }
        }
      }
    }
    mask = 0;
    if (flags & LEPUS_PROP_HAS_CONFIGURABLE) mask |= LEPUS_PROP_CONFIGURABLE;
    if (flags & LEPUS_PROP_HAS_ENUMERABLE) mask |= LEPUS_PROP_ENUMERABLE;
    if (js_update_property_flags(ctx, p, &prs,
                                 (prs->flags & ~mask) | (flags & mask)))
      return -1;
    return TRUE;
  }

  /* handle modification of fast array elements */
  if (p->fast_array) {
    uint32_t idx;
    uint32_t prop_flags;
    if (p->class_id == JS_CLASS_ARRAY) {
      if (__JS_AtomIsTaggedInt(prop)) {
        idx = __JS_AtomToUInt32(prop);
        if (idx < p->u.array.count) {
          prop_flags = get_prop_flags(flags, LEPUS_PROP_C_W_E);
          if (prop_flags != LEPUS_PROP_C_W_E) goto convert_to_slow_array;
          if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
          convert_to_slow_array:
            if (convert_fast_array_to_array(ctx, p))
              return -1;
            else
              goto redo_prop_update;
          }
          if (flags & LEPUS_PROP_HAS_VALUE) {
            set_value(ctx, &p->u.array.u.values[idx], LEPUS_DupValue(ctx, val));
          }
          return TRUE;
        }
      }
    } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
               p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
      LEPUSValue num;
      int ret;

      if (!__JS_AtomIsTaggedInt(prop)) {
        /* slow path with to handle all numeric indexes */
        num = JS_AtomIsNumericIndex1(ctx, prop);
        if (LEPUS_IsUndefined(num)) goto typed_array_done;
        if (LEPUS_IsException(num)) return -1;
        ret = JS_NumberIsInteger(ctx, num);
        if (ret < 0) {
          LEPUS_FreeValue(ctx, num);
          return -1;
        }
        if (!ret) {
          LEPUS_FreeValue(ctx, num);
          return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                          "non integer index in typed array");
        }
        ret = JS_NumberIsNegativeOrMinusZero(ctx, num);
        LEPUS_FreeValue(ctx, num);
        if (ret) {
          return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                          "negative index in typed array");
        }
        if (!__JS_AtomIsTaggedInt(prop)) goto typed_array_oob;
      }
      idx = __JS_AtomToUInt32(prop);
      /* if the typed array is detached, p->u.array.count = 0 */
      if (idx >= typed_array_get_length(ctx, p)) {
      typed_array_oob:
        return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                        "out-of-bound index in typed array");
      }
      prop_flags =
          get_prop_flags(flags, LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE);
      if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET) ||
          prop_flags != (LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE)) {
        return JS_ThrowTypeErrorOrFalse(ctx, flags, "invalid descriptor flags");
      }
      if (flags & LEPUS_PROP_HAS_VALUE) {
        return JS_SetPropertyValue(ctx, this_obj, LEPUS_NewInt32(ctx, idx),
                                   LEPUS_DupValue(ctx, val), flags);
      }
      return TRUE;
    typed_array_done:;
    }
  }

  return JS_CreateProperty(ctx, p, prop, val, getter, setter, flags);
}

int LEPUS_DefineProperty(LEPUSContext *ctx, LEPUSValueConst this_obj,
                         JSAtom prop, LEPUSValueConst val,
                         LEPUSValueConst getter, LEPUSValueConst setter,
                         int flags) {
  CallGCFunc(JS_DefineProperty_GC, ctx, this_obj, prop, val, getter, setter,
             flags);
  return JS_DefineProperty_RC(ctx, this_obj, prop, val, getter, setter, flags);
}

QJS_STATIC int JS_DefineAutoInitProperty(
    LEPUSContext *ctx, LEPUSValueConst this_obj, JSAtom prop,
    LEPUSValue (*init_func)(LEPUSContext *ctx, LEPUSObject *obj, JSAtom prop,
                            void *opaque),
    void *opaque, int flags) {
  LEPUSObject *p;
  JSProperty *pr;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_obj)) return FALSE;

  p = LEPUS_VALUE_GET_OBJ(this_obj);

  if (find_own_property(&pr, p, prop)) {
    /* property already exists */
    abort();
    return FALSE;
  }

  /* Specialized CreateProperty */
  pr = add_property(ctx, p, prop,
                    (flags & LEPUS_PROP_C_W_E) | LEPUS_PROP_AUTOINIT);
  if (unlikely(!pr)) return -1;
  pr->u.init.init_func = init_func;
  pr->u.init.opaque = opaque;
  return TRUE;
}

/* shortcut to add or redefine a new property value */
static int JS_DefinePropertyValue_RC(LEPUSContext *ctx,
                                     LEPUSValueConst this_obj, JSAtom prop,
                                     LEPUSValue val, int flags) {
  int ret;
  ret = JS_DefineProperty_RC(
      ctx, this_obj, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
      flags | LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_CONFIGURABLE |
          LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_HAS_ENUMERABLE);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

int LEPUS_DefinePropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                              JSAtom prop, LEPUSValue val, int flags) {
  CallGCFunc(JS_DefinePropertyValue_GC, ctx, this_obj, prop, val, flags);
  return JS_DefinePropertyValue_RC(ctx, this_obj, prop, val, flags);
}

int JS_DefinePropertyValueValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                LEPUSValue prop, LEPUSValue val, int flags) {
  JSAtom atom;
  int ret;
  atom = js_value_to_atom(ctx, prop);
  LEPUS_FreeValue(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  ret = JS_DefinePropertyValue_RC(ctx, this_obj, atom, val, flags);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

static int JS_DefinePropertyValueUint32_RC(LEPUSContext *ctx,
                                           LEPUSValueConst this_obj,
                                           uint32_t idx, LEPUSValue val,
                                           int flags) {
  return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewUint32(ctx, idx), val,
                                     flags);
}

int LEPUS_DefinePropertyValueUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                    uint32_t idx, LEPUSValue val, int flags) {
  CallGCFunc(JS_DefinePropertyValueUint32_GC, ctx, this_obj, idx, val, flags);
  return JS_DefinePropertyValueUint32_RC(ctx, this_obj, idx, val, flags);
}

QJS_STATIC int JS_DefinePropertyValueInt64(LEPUSContext *ctx,
                                           LEPUSValueConst this_obj,
                                           int64_t idx, LEPUSValue val,
                                           int flags) {
  CallGCFunc(JS_DefinePropertyValueInt64_GC, ctx, this_obj, idx, val, flags);
  return JS_DefinePropertyValueValue(ctx, this_obj, LEPUS_NewInt64(ctx, idx),
                                     val, flags);
}

static int JS_DefinePropertyValueStr_RC(LEPUSContext *ctx,
                                        LEPUSValueConst this_obj,
                                        const char *prop, LEPUSValue val,
                                        int flags) {
  JSAtom atom;
  int ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = JS_DefinePropertyValue_RC(ctx, this_obj, atom, val, flags);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

int LEPUS_DefinePropertyValueStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                 const char *prop, LEPUSValue val, int flags) {
  CallGCFunc(JS_DefinePropertyValueStr_GC, ctx, this_obj, prop, val, flags);
  return JS_DefinePropertyValueStr_RC(ctx, this_obj, prop, val, flags);
}

/* shortcut to add getter & setter */
int LEPUS_DefinePropertyGetSet(LEPUSContext *ctx, LEPUSValueConst this_obj,
                               JSAtom prop, LEPUSValue getter,
                               LEPUSValue setter, int flags) {
  CallGCFunc(JS_DefinePropertyGetSet_GC, ctx, this_obj, prop, getter, setter,
             flags);
  int ret;
  ret = JS_DefineProperty_RC(
      ctx, this_obj, prop, LEPUS_UNDEFINED, getter, setter,
      flags | LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET |
          LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_ENUMERABLE);
  LEPUS_FreeValue(ctx, getter);
  LEPUS_FreeValue(ctx, setter);
  return ret;
}

QJS_STATIC int JS_CreateDataPropertyUint32(LEPUSContext *ctx,
                                           LEPUSValueConst this_obj,
                                           int64_t idx, LEPUSValue val,
                                           int flags) {
  return JS_DefinePropertyValueValue(
      ctx, this_obj, LEPUS_NewInt64(ctx, idx), val,
      flags | LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE |
          LEPUS_PROP_WRITABLE);
}

QJS_STATIC BOOL js_object_has_name(LEPUSContext *ctx, LEPUSValueConst obj) {
  JSProperty *pr;
  JSShapeProperty *prs;
  LEPUSValueConst val;
  JSString *p;

  prs = find_own_property(&pr, LEPUS_VALUE_GET_OBJ(obj), JS_ATOM_name);
  if (!prs) return FALSE;
  if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_NORMAL) return TRUE;
  val = pr->u.value;
  if (!LEPUS_IsString(val)) return TRUE;
  if (JS_IsSeparableString(val)) {
    return JS_GetSeparableString(val)->len != 0;
  }

  p = LEPUS_VALUE_GET_STRING(val);
  return (p->len != 0);
}

int JS_DefineObjectName(LEPUSContext *ctx, LEPUSValueConst obj, JSAtom name,
                        int flags) {
  CallGCFunc(JS_DefineObjectName_GC, ctx, obj, name, flags);
  // <Primjs begin>
  obj = JSRef2Value(ctx, obj);
  // <Primjs end>
  if (name != JS_ATOM_NULL && LEPUS_IsObject(obj) &&
      !js_object_has_name(ctx, obj) &&
      JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_name,
                                LEPUS_AtomToString(ctx, name), flags) < 0) {
    return -1;
  }
  return 0;
}

int JS_DefineObjectNameComputed(LEPUSContext *ctx, LEPUSValueConst obj,
                                LEPUSValueConst str, int flags) {
  // <Primjs begin>
  obj = JSRef2Value(ctx, obj);
  // <Primjs end>
  if (LEPUS_IsObject(obj) && !js_object_has_name(ctx, obj)) {
    JSAtom prop;
    LEPUSValue name_str;
    prop = js_value_to_atom(ctx, str);
    if (prop == JS_ATOM_NULL) return -1;
    name_str = js_get_function_name(ctx, prop);
    LEPUS_FreeAtom(ctx, prop);
    if (LEPUS_IsException(name_str)) return -1;
    if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_name, name_str, flags) < 0)
      return -1;
  }
  return 0;
}

#define DEFINE_GLOBAL_LEX_VAR (1 << 7)
#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)

LEPUSValue JS_ThrowSyntaxErrorVarRedeclaration(LEPUSContext *ctx, JSAtom prop) {
  return JS_ThrowSyntaxErrorAtom(ctx, "redeclaration of '%s'", prop);
}

/* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */
/* XXX: could support exotic global object. */
int JS_CheckDefineGlobalVar(LEPUSContext *ctx, JSAtom prop, int flags) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  char buf[ATOM_GET_STR_BUF_SIZE];

  p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
  prs = find_own_property1(p, prop);
  /* XXX: should handle LEPUS_PROP_AUTOINIT */
  if (flags & DEFINE_GLOBAL_LEX_VAR) {
    if (prs && !(prs->flags & LEPUS_PROP_CONFIGURABLE)) goto fail_redeclaration;
  } else {
    if (!prs && !p->extensible) goto define_error;
    if (flags & DEFINE_GLOBAL_FUNC_VAR) {
      if (prs) {
        if (!(prs->flags & LEPUS_PROP_CONFIGURABLE) &&
            ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET ||
             ((prs->flags & (LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE)) !=
              (LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE)))) {
        define_error:
          JS_ThrowTypeErrorAtom(ctx, "cannot define variable '%s'", prop);
          return -1;
        }
      }
    }
  }
  /* check if there already is a lexical declaration */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property1(p, prop);
  if (prs) {
  fail_redeclaration:
    JS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);
    return -1;
  }
  return 0;
}

/* def_flags is (0, DEFINE_GLOBAL_LEX_VAR) |
   LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE */
/* XXX: could support exotic global object. */
int JS_DefineGlobalVar(LEPUSContext *ctx, JSAtom prop, int def_flags) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  LEPUSValue val;
  int flags;

  if (def_flags & DEFINE_GLOBAL_LEX_VAR) {
    p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
    flags = LEPUS_PROP_ENUMERABLE | (def_flags & LEPUS_PROP_WRITABLE) |
            LEPUS_PROP_CONFIGURABLE;
    val = LEPUS_UNINITIALIZED;
  } else {
    p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
    flags = LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE |
            (def_flags & LEPUS_PROP_CONFIGURABLE);
    val = LEPUS_UNDEFINED;
  }
  prs = find_own_property1(p, prop);
  if (prs) return 0;
  if (!p->extensible) return 0;
  pr = add_property(ctx, p, prop, flags);
  if (unlikely(!pr)) return -1;
  pr->u.value = val;
  return 0;
}

/* 'def_flags' is 0 or LEPUS_PROP_CONFIGURABLE. */
/* XXX: could support exotic global object. */
int JS_DefineGlobalFunction(LEPUSContext *ctx, JSAtom prop,
                            LEPUSValueConst func, int def_flags) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  int flags;

  p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
  prs = find_own_property1(p, prop);
  flags = LEPUS_PROP_HAS_VALUE | LEPUS_PROP_THROW;
  if (!prs || (prs->flags & LEPUS_PROP_CONFIGURABLE)) {
    flags |= LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE | def_flags |
             LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_WRITABLE |
             LEPUS_PROP_HAS_ENUMERABLE;
  }
  if (JS_DefineProperty_RC(ctx, ctx->global_obj, prop, func, LEPUS_UNDEFINED,
                           LEPUS_UNDEFINED, flags) < 0)
    return -1;
  return 0;
}

void LEPUS_VisitLEPUSValue(LEPUSRuntime *rt, LEPUSValue *val, int local_idx) {
  CallGCFunc(JS_VisitLEPUSValue_GC, rt, val, local_idx);
}

void DisposeGlobal(LEPUSRuntime *runtime, LEPUSValue *global_handle) {
  CallGCFunc(DisposeGlobal_GC, runtime, global_handle);
}

LEPUSValue *GlobalizeReference(LEPUSRuntime *runtime, LEPUSValue val,
                               bool is_weak) {
#ifdef ENABLE_COMPATIBLE_MM
  if (runtime->gc_enable) {
    return GlobalizeReference_GC(runtime, val, is_weak);
  }
#endif
  return nullptr;
}

static LEPUSValue JS_GetGlobalVar_RC(LEPUSContext *ctx, JSAtom prop,
                                     BOOL throw_ref_error) {
  return JS_GetGlobalVarImpl(ctx, prop, throw_ref_error);
}

LEPUSValue LEPUS_GetGlobalVar(LEPUSContext *ctx, JSAtom prop,
                              BOOL throw_ref_error) {
  CallGCFunc(JS_GetGlobalVar_GC, ctx, prop, throw_ref_error);
  return JS_GetGlobalVar_RC(ctx, prop, throw_ref_error);
}

LEPUSValue JS_GetGlobalVarImpl(LEPUSContext *ctx, JSAtom prop,
                               BOOL throw_ref_error) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_TMASK properties */
    if (unlikely(LEPUS_IsUninitialized(pr->u.value)))
      return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
    return LEPUS_DupValue(ctx, pr->u.value);
  }
  return JS_GetPropertyInternalImpl(ctx, ctx->global_obj, prop, ctx->global_obj,
                                    throw_ref_error);
}

/* construct a reference to a global variable */
int JS_GetGlobalVarRef(LEPUSContext *ctx, JSAtom prop, LEPUSValue *sp) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_AUTOINIT properties? */
    /* XXX: conformance: do these tests in
       OP_put_var_ref/OP_get_var_ref ? */
    if (unlikely(LEPUS_IsUninitialized(pr->u.value))) {
      JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
      return -1;
    }
    if (unlikely(!(prs->flags & LEPUS_PROP_WRITABLE))) {
      return JS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, prop);
    }
    sp[0] = LEPUS_DupValue(ctx, ctx->global_var_obj);
  } else {
    int ret;
    ret = LEPUS_HasProperty(ctx, ctx->global_obj, prop);
    if (ret < 0) return -1;
    if (ret) {
      sp[0] = LEPUS_DupValue(ctx, ctx->global_obj);
    } else {
      sp[0] = LEPUS_UNDEFINED;
    }
  }
  sp[1] = JS_AtomToValue_RC(ctx, prop);
  return 0;
}

/* use for strict variable access: test if the variable exists */
int JS_CheckGlobalVar(LEPUSContext *ctx, JSAtom prop) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  int ret;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property1(p, prop);
  if (prs) {
    ret = TRUE;
  } else {
    ret = LEPUS_HasProperty(ctx, ctx->global_obj, prop);
    if (ret < 0) return -1;
  }
  return ret;
}

/* flag = 0: normal variable write
   flag = 1: initialize lexical variable
   flag = 2: normal variable write, strict check was done before
   flag = 3: add property in global var obj
*/
static int JS_SetGlobalVar_RC(LEPUSContext *ctx, JSAtom prop, LEPUSValue val,
                              int flag) {
  LEPUSObject *p;
  JSShapeProperty *prs;
  JSProperty *pr;
  int flags;

  if (flag == 3) {
    flags = LEPUS_PROP_THROW_STRICT;
    return JS_SetPropertyInternal_RC(ctx, ctx->global_var_obj, prop, val,
                                     flags);
  }
  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_AUTOINIT properties? */
    if (flag != 1) {
      if (unlikely(LEPUS_IsUninitialized(pr->u.value))) {
        LEPUS_FreeValue(ctx, val);
        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
        return -1;
      }
      if (unlikely(!(prs->flags & LEPUS_PROP_WRITABLE))) {
        LEPUS_FreeValue(ctx, val);
        return JS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, prop);
      }
    }
    set_value(ctx, &pr->u.value, val);
    return 0;
  }

  flags = LEPUS_PROP_THROW_STRICT;
  if (flag != 2 && is_strict_mode(ctx)) flags |= LEPUS_PROP_NO_ADD;
  return JS_SetPropertyInternal_RC(ctx, ctx->global_obj, prop, val, flags);
}

int LEPUS_SetGlobalVar(LEPUSContext *ctx, JSAtom prop, LEPUSValue val,
                       int flag) {
  CallGCFunc(JS_SetGlobalVar_GC, ctx, prop, val, flag);
  return JS_SetGlobalVar_RC(ctx, prop, val, flag);
}

/* return -1, FALSE or TRUE. return FALSE if not configurable or
   invalid object. return -1 in case of exception.
   flags can be 0, LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT */
int LEPUS_DeleteProperty(LEPUSContext *ctx, LEPUSValueConst obj, JSAtom prop,
                         int flags) {
  CallGCFunc(JS_DeleteProperty_GC, ctx, obj, prop, flags);
#ifdef ENABLE_LEPUSNG
  if (LEPUS_VALUE_IS_LEPUS_REF(obj)) {
    return JSRefDeleteProperty(ctx, obj, prop);
  }
#endif

  obj = LEPUS_ToObject(ctx, obj);
  if (LEPUS_IsException(obj)) return -1;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  int res = delete_property(ctx, p, prop);
  LEPUS_FreeValue(ctx, obj);
  if (res != FALSE) return res;
  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
    LEPUS_ThrowTypeError(ctx, "could not delete property");
    return -1;
  }
  return FALSE;
}

QJS_STATIC int JS_DeletePropertyInt64(LEPUSContext *ctx, LEPUSValueConst obj,
                                      int64_t idx, int flags) {
  JSAtom prop;
  int res;

  if ((uint64_t)idx <= JS_ATOM_MAX_INT) {
    /* fast path for fast arrays */
    return LEPUS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx), flags);
  }
  prop = JS_NewAtomInt64(ctx, idx);
  if (prop == JS_ATOM_NULL) return -1;
  res = LEPUS_DeleteProperty(ctx, obj, prop, flags);
  LEPUS_FreeAtom(ctx, prop);
  return res;
}

BOOL LEPUS_IsFunction(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  switch (p->class_id) {
    case JS_CLASS_BYTECODE_FUNCTION:
      return TRUE;
    case JS_CLASS_PROXY:
      return p->u.proxy_data->is_func;
    default:
      return (ctx->rt->class_array[p->class_id].call != NULL);
  }
}

QJS_STATIC BOOL JS_IsCFunction(LEPUSContext *ctx, LEPUSValueConst val,
                               LEPUSCFunction *func, int magic) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == JS_CLASS_C_FUNCTION)
    return (p->u.cfunc.c_function.generic == func && p->u.cfunc.magic == magic);
  else
    return FALSE;
}

BOOL LEPUS_IsConstructor(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return p->is_constructor;
}

BOOL LEPUS_SetConstructorBit(LEPUSContext *ctx, LEPUSValueConst func_obj,
                             BOOL val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(func_obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->is_constructor = val;
  return TRUE;
}

BOOL LEPUS_IsError(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == JS_CLASS_ERROR) return TRUE;
#ifdef QJS_UNITTEST
  if (ctx->is_error_property_enabled) {
    /* check for a special property for test262 test suites */
    LEPUSValue isError;
    isError = LEPUS_GetPropertyStr(ctx, val, "isError");
    HandleScope block_scope(ctx, &isError, HANDLE_TYPE_LEPUS_VALUE);
    return JS_ToBoolFree(ctx, isError);
  }
#endif
  return FALSE;
}

#ifdef QJS_UNITTEST
/* only used for test262 test suites */
void LEPUS_EnableIsErrorProperty(LEPUSContext *ctx, BOOL enable) {
  ctx->is_error_property_enabled = enable;
}
#endif

/* used to avoid catching interrupt exceptions */
BOOL JS_IsUncatchableError(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return p->class_id == JS_CLASS_ERROR && p->is_uncatchable_error;
}

QJS_STATIC void JS_SetUncatchableError(LEPUSContext *ctx, LEPUSValueConst val,
                                       BOOL flag) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == JS_CLASS_ERROR) p->is_uncatchable_error = flag;
}

void LEPUS_ResetUncatchableError(LEPUSContext *ctx) {
  JS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);
}

void LEPUS_SetOpaque(LEPUSValue obj, void *opaque) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->u.opaque = opaque;
  }
}

/* return NULL if not an object of class class_id */
void *LEPUS_GetOpaque(LEPUSValueConst obj, LEPUSClassID class_id) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return NULL;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id != class_id) return NULL;
  return p->u.opaque;
}

void *LEPUS_GetOpaque2(LEPUSContext *ctx, LEPUSValueConst obj,
                       LEPUSClassID class_id) {
  void *p = LEPUS_GetOpaque(obj, class_id);
  if (unlikely(!p)) {
    JS_ThrowTypeErrorInvalidClass(ctx, class_id);
  }
  return p;
}

static LEPUSValue JS_ToPrimitiveFree_RC(LEPUSContext *ctx, LEPUSValue val,
                                        int hint) {
  int i;
  BOOL force_ordinary;

  JSAtom method_name;
  LEPUSValue method, ret;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return val;
  force_ordinary = hint & HINT_FORCE_ORDINARY;
  hint &= ~HINT_FORCE_ORDINARY;
  if (!force_ordinary) {
    method =
        JS_GetPropertyInternal_RC(ctx, val, JS_ATOM_Symbol_toPrimitive, val, 0);
    if (LEPUS_IsException(method)) goto exception;
    /* ECMA says *If exoticToPrim is not undefined* but tests in
       test262 use null as a non callable converter */
    if (!LEPUS_IsUndefined(method) && !LEPUS_IsNull(method)) {
      JSAtom atom;
      LEPUSValue arg;
      switch (hint) {
        case HINT_STRING:
          atom = JS_ATOM_string;
          break;
        case HINT_NUMBER:
          atom = JS_ATOM_number;
          break;
        default:
        case HINT_NONE:
          atom = JS_ATOM_default;
          break;
#ifdef CONFIG_BIGNUM
        case HINT_INTEGER:
          atom = JS_ATOM_integer;
          break;
#endif
      }
      arg = LEPUS_AtomToString(ctx, atom);
      ret = JS_CallFree(ctx, method, val, 1, (LEPUSValueConst *)&arg);
      LEPUS_FreeValue(ctx, arg);
      if (LEPUS_IsException(ret)) goto exception;
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_VALUE_IS_NOT_OBJECT(ret)) return ret;
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(ctx, "toPrimitive");
    }
  }
  if (hint != HINT_STRING) hint = HINT_NUMBER;
  for (i = 0; i < 2; i++) {
    if ((i ^ hint) == 0) {
      method_name = JS_ATOM_toString;
    } else {
      method_name = JS_ATOM_valueOf;
    }
    method = JS_GetPropertyInternal_RC(ctx, val, method_name, val, 0);
    if (LEPUS_IsException(method)) goto exception;
    if (LEPUS_IsFunction(ctx, method)) {
      ret = JS_CallFree(ctx, method, val, 0, NULL);
      if (LEPUS_IsException(ret)) goto exception;
      if (LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
      LEPUS_FreeValue(ctx, ret);
    } else {
      LEPUS_FreeValue(ctx, method);
    }
  }
  LEPUS_ThrowTypeError(ctx, "toPrimitive");
exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

LEPUSValue JS_ToPrimitiveFree(LEPUSContext *ctx, LEPUSValue val, int hint) {
  CallGCFunc(JS_ToPrimitiveFree_GC, ctx, val, hint);
  return JS_ToPrimitiveFree_RC(ctx, val, hint);
}

QJS_STATIC LEPUSValue JS_ToPrimitive(LEPUSContext *ctx, LEPUSValueConst val,
                                     int hint) {
  return JS_ToPrimitiveFree_RC(ctx, LEPUS_DupValue(ctx, val), hint);
}

static int JS_ToBoolFree_RC(LEPUSContext *ctx, LEPUSValue val) {
  int64_t tag = LEPUS_VALUE_GET_TAG(val);
  switch (tag) {
    case LEPUS_TAG_BOOL:
      return LEPUS_VALUE_GET_BOOL(val);
    case LEPUS_TAG_INT:
      return LEPUS_VALUE_GET_INT(val) != 0;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      return FALSE;
    case LEPUS_TAG_EXCEPTION:
      return -1;
    case LEPUS_TAG_STRING: {
      BOOL ret = LEPUS_VALUE_GET_STRING(val)->len != 0;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
    case LEPUS_TAG_SEPARABLE_STRING: {
      BOOL ret = JS_GetSeparableString(val)->len != 0;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      BOOL ret;
      ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#endif
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      BOOL ret = p->num == 0 ? FALSE : TRUE;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#endif
      // <Primjs end>
    default:
      if (LEPUS_TAG_IS_FLOAT64(tag)) {
        double d = LEPUS_VALUE_GET_FLOAT64(val);
        return !isnan(d) && d != 0;
      } else {
        LEPUS_FreeValue(ctx, val);
        return TRUE;
      }
  }
}

int JS_ToBoolFree(LEPUSContext *ctx, LEPUSValue val) {
  CallGCFunc(JS_ToBoolFree_GC, ctx, val);
  return JS_ToBoolFree_RC(ctx, val);
}

int LEPUS_ToBool(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_ToBool_GC, ctx, val);
  return JS_ToBoolFree_RC(ctx, LEPUS_DupValue(ctx, val));
}

int skip_spaces(const char *pc) {
  const uint8_t *p, *p_next, *p_start;
  uint32_t c;

  p = p_start = (const uint8_t *)pc;
  for (;;) {
    c = *p;
    if (c < 128) {
      if (!((c >= 0x09 && c <= 0x0d) || (c == 0x20))) break;
      p++;
    } else {
      c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
      if (!lre_is_space(c)) break;
      p = p_next;
    }
  }
  return p - p_start;
}

#ifdef CONFIG_BIGNUM

/* force big int type if integer result */
#define BF_ATOF_BIG_INT (1 << 30)
/* return LEPUS_EXCEPTION if invalid syntax. Otherwise return NaN */
#define BF_ATOF_THROW (1 << 29)
#define BF_ATOF_FLOAT64 (1 << 28)

static LEPUSValue js_atof(LEPUSContext *ctx, const char *p, const char **pp,
                          int radix, int flags) {
  bf_t a_s, *a = &a_s;
  int res;
  slimb_t prec;
  LEPUSValue val;

  bf_init(ctx->bf_ctx, a);
  if (flags & BF_ATOF_FLOAT64) {
    prec = 53;
    flags |= bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
  } else {
    /* use the current precision */
    prec = ctx->fp_env.prec;
    flags |= ctx->fp_env.flags;
  }
  p += skip_spaces(p);
  res = bf_atof(a, p, &p, radix, prec, flags);
  if ((flags & BF_ATOF_THROW) && bf_is_nan(a)) {
    bf_delete(a);
    return LEPUS_EXCEPTION;
  }
  if (res & BF_ATOF_ST_INTEGER) {
    val = JS_NewBigInt2(ctx, a, (flags & BF_ATOF_BIG_INT) != 0);
  } else if (flags & BF_ATOF_FLOAT64) {
    double d;
    bf_get_float64(a, &d, BF_RNDN);
    bf_delete(a);
    /* return int or float64 */
    val = LEPUS_NewFloat64(ctx, d);
  } else {
    val = JS_NewBigFloat(ctx, a);
  }
  if (pp) *pp = p;
  return val;
}

#else

QJS_STATIC inline int to_digit(int c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  else if (c >= 'A' && c <= 'Z')
    return c - 'A' + 10;
  else if (c >= 'a' && c <= 'z')
    return c - 'a' + 10;
  else
    return 36;
}

#define ATOD_INT_ONLY (1 << 0)
/* return LEPUS_EXCEPTION if invalid syntax. Otherwise return NaN */
#define ATOD_THROW (1 << 1)
/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */
#define ATOD_ACCEPT_BIN_OCT (1 << 2)
/* if set return NaN if empty number string */
#define ATOD_NAN_IF_EMPTY (1 << 3)
/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */
#define ATOD_ACCEPT_LEGACY_OCTAL (1 << 4)
/* accept _ between digits as a digit separator */
#define ATOD_ACCEPT_UNDERSCORES (1 << 5)

/* radix = 0 accepts prefixes. radix = 16 also
   accepts 0x prefix. radix must be 0 or between 2 and 36 */
LEPUSValue js_atod(LEPUSContext *ctx, const char *str, const char **pp,
                   int radix, int flags) {
  const char *p;
  const char *p_start;
  int is_neg, c, sep, has_sign = 0;
  double d;

  /* optional separator between digits */
  sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;

  p = str + skip_spaces(str);
  p_start = p;
  is_neg = 0;
  if (p[0] == '+') {
    p++;
    p_start++;
    has_sign = 1;
    if (!(flags & ATOD_INT_ONLY)) goto no_radix_prefix;
  } else if (p[0] == '-') {
    is_neg = 1;
    p++;
    p_start++;
    has_sign = 1;
    if (!(flags & ATOD_INT_ONLY)) goto no_radix_prefix;
  }
  if (p[0] == '0') {
    if ((p[1] == 'x' || p[1] == 'X') && (radix == 0 || radix == 16)) {
      p += 2;
      radix = 16;
    } else if ((p[1] == 'o' || p[1] == 'O') && radix == 0 &&
               (flags & ATOD_ACCEPT_BIN_OCT)) {
      p += 2;
      radix = 8;
    } else if ((p[1] == 'b' || p[1] == 'B') && radix == 0 &&
               (flags & ATOD_ACCEPT_BIN_OCT)) {
      p += 2;
      radix = 2;
    } else if ((p[1] >= '0' && p[1] <= '9') && radix == 0 &&
               (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {
      int i;
      sep = 256;
      for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++) continue;
      if (p[i] == '8' || p[i] == '9') goto no_prefix;
      p += 1;
      radix = 8;
    } else {
      goto no_prefix;
    }
    /* there must be a digit after the prefix */
    if (to_digit((uint8_t)*p) >= radix) goto fail;
  no_prefix:;
  } else {
  no_radix_prefix:
    if (!(flags & ATOD_INT_ONLY) && strstart(p, "Infinity", &p)) {
      d = 1.0 / 0.0;
      goto done;
    }
  }
  if (radix == 0) radix = 10;
  if ((flags & ATOD_INT_ONLY) || radix != 10) {
    uint64_t n_max, n;
    int int_exp;

    /* skip leading zeros */
    while (*p == '0') p++;
    n = 0;
    if (radix == 10)
      n_max = ((uint64_t)-1 - 9) / 10; /* most common case */
    else
      n_max = ((uint64_t)-1 - (radix - 1)) / radix;
    /* XXX: could be more precise */
    int_exp = 0;
    while (*p != '\0') {
      if (*p == sep && to_digit(p[1]) < radix) p++;
      c = to_digit((uint8_t)*p);
      if (c >= radix) break;
      if (n <= n_max) {
        n = n * radix + c;
      } else {
        int_exp++;
      }
      p++;
    }
    d = n;
    if (int_exp != 0) {
      d *= pow(radix, int_exp);
    }
  } else {
    p_start = p;
    while (is_digit((uint8_t)*p) ||
           (*p == sep && (p != p_start + 1 || p[-1] != '0') &&
            is_digit((uint8_t)p[1]))) {
      p++;
    }
    if (*p == '.' && (p > p_start || is_digit((uint8_t)p[1]))) {
      p++;
      if (*p == sep) goto fail;
      while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
        p++;
    }
    if (p > p_start && (*p == 'e' || *p == 'E')) {
      const char *p1 = p + 1;
      if (*p1 == '+') {
        p1++;
      } else if (*p1 == '-') {
        p1++;
      }
      if (is_digit((uint8_t)*p1)) {
        p = p1 + 1;
        while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
          p++;
      }
    }
    if (*p == '\0' && sep != '_') {
      d = strtod(p_start, NULL);
    } else {
      char buf1[64], *buf;
      int i, j, len;
      BOOL buf_allocated;

      buf = buf1;
      buf_allocated = FALSE;
      len = p - p_start;
      if (len >= sizeof(buf1)) {
        buf = static_cast<char *>(
            lepus_malloc(ctx, len + 1, ALLOC_TAG_WITHOUT_PTR));
        if (!buf) return LEPUS_EXCEPTION;
        buf_allocated = TRUE;
      }
      for (i = j = 0; i < len; i++) {
        if (p_start[i] != '_') buf[j++] = p_start[i];
      }
      buf[j] = '\0';
      d = strtod(buf, NULL);
      if (buf_allocated && !ctx->gc_enable) lepus_free(ctx, buf);
    }
  }
done:
  if (is_neg) d = -d;
  if (p == p_start && (flags & ATOD_NAN_IF_EMPTY || has_sign)) {
    d = LEPUS_FLOAT64_NAN;
  }
  if (pp) *pp = p;
  return LEPUS_NewFloat64(ctx, d);
fail:
  if (pp) *pp = p;
  if (flags & ATOD_THROW)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NAN;
}
#endif

typedef enum JSToNumberHintEnum {
  TON_FLAG_NUMBER,
  TON_FLAG_INTEGER,
  TON_FLAG_NUMERIC,
} JSToNumberHintEnum;

QJS_STATIC LEPUSValue JS_ToNumberHintFree(LEPUSContext *ctx, LEPUSValue val,
                                          JSToNumberHintEnum flag) {
  int64_t tag;
  LEPUSValue ret;
  int hint;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      if (flag == TON_FLAG_NUMBER && !is_bignum_mode(ctx)) {
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeError(ctx, "cannot convert bigint to number");
      }
      /* fall thru */
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_EXCEPTION:
      ret = val;
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(val));
      break;
    case LEPUS_TAG_NULL:
      ret = LEPUS_NewInt32(ctx, 0);
      break;
    case LEPUS_TAG_UNDEFINED:
      ret = LEPUS_NAN;
      break;
    case LEPUS_TAG_OBJECT:
#ifdef CONFIG_BIGNUM
      hint = flag == TON_FLAG_INTEGER ? HINT_INTEGER : HINT_NUMBER;
#else
      hint = HINT_NUMBER;
#endif
      val = JS_ToPrimitiveFree_RC(ctx, val, hint);
      if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
      goto redo;
    case LEPUS_TAG_STRING: {
      const char *str;
      const char *p;

      str = JS_ToCStringLen2_RC(ctx, NULL, val, 0);
      LEPUS_FreeValue(ctx, val);
      if (!str) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
      {
        int flags;
        flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN |
                BF_ATOF_JS_QUIRKS | BF_ATOF_FLOAT64;
        if (is_bignum_mode(ctx))
          flags |= BF_ATOF_INT_PREC_INF;
        else
          flags |= BF_ATOF_ONLY_DEC_FLOAT;
        ret = js_atof(ctx, str, &p, 0, flags);
      }
#else
      ret = js_atod(ctx, str, &p, 0, ATOD_ACCEPT_BIN_OCT);
#endif
      p += skip_spaces(p);
      if (*p != '\0') {
        LEPUS_FreeValue(ctx, ret);
        ret = LEPUS_NAN;
      }
      LEPUS_FreeCString(ctx, str);
    } break;
    case LEPUS_TAG_SEPARABLE_STRING: {
      auto content = JS_GetSeparableStringContent(ctx, val);
      ret = JS_ToNumberHintFree(ctx, content, flag);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_SYMBOL:
      LEPUS_FreeValue(ctx, val);
      return LEPUS_ThrowTypeError(ctx, "cannot convert symbol to number");
    default:
      LEPUS_FreeValue(ctx, val);
      ret = LEPUS_NAN;
      break;
  }
  return ret;
}

QJS_STATIC LEPUSValue JS_ToNumberFree(LEPUSContext *ctx, LEPUSValue val) {
  return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);
}

#ifdef CONFIG_BIGNUM
static LEPUSValue JS_ToNumericFree(LEPUSContext *ctx, LEPUSValue val) {
  return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);
}

static LEPUSValue JS_ToNumeric(LEPUSContext *ctx, LEPUSValueConst val) {
  return JS_ToNumericFree(ctx, LEPUS_DupValue(ctx, val));
}
#endif

QJS_STATIC __exception int __JS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                              LEPUSValue val) {
  double d;
  int64_t tag;

  val = JS_ToNumberFree(ctx, val);
  if (LEPUS_IsException(val)) {
    *pres = LEPUS_FLOAT64_NAN;
    return -1;
  }
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      d = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_FLOAT64:
      d = LEPUS_VALUE_GET_FLOAT64(val);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      /* XXX: there can be a double rounding issue with some
         primitives (such as JS_ToUint8ClampFree()), but it is
         not critical to fix it. */
      bf_get_float64(&p->num, &d, BF_RNDN);
      LEPUS_FreeValue(ctx, val);
    } break;
#endif
    default:
      abort();
  }
  *pres = d;
  return 0;
}

QJS_STATIC inline int JS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                       LEPUSValue val) {
  if (LEPUS_VALUE_IS_FLOAT64(val)) {
    *pres = LEPUS_VALUE_GET_FLOAT64(val);
    return 0;
  } else if (LEPUS_VALUE_IS_INT(val)) {
    *pres = LEPUS_VALUE_GET_INT(val);
    return 0;
  } else if (LEPUS_VALUE_IS_BOOL(val)) {
    *pres = LEPUS_VALUE_GET_BOOL(val);
    return 0;
  } else if (LEPUS_VALUE_IS_NULL(val)) {
    *pres = 0;
    return 0;
  } else {
    return __JS_ToFloat64Free(ctx, pres, val);
  }
}

int LEPUS_ToFloat64(LEPUSContext *ctx, double *pres, LEPUSValueConst val) {
  CallGCFunc(JS_ToFloat64_GC, ctx, pres, val);
  return JS_ToFloat64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC LEPUSValue JS_ToNumber(LEPUSContext *ctx, LEPUSValueConst val) {
  return JS_ToNumberFree(ctx, LEPUS_DupValue(ctx, val));
}

QJS_STATIC __attribute__((unused)) LEPUSValue JS_ToIntegerFree(
    LEPUSContext *ctx, LEPUSValue val) {
  int64_t tag;
  LEPUSValue ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(val));
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = LEPUS_NewInt32(ctx, 0);
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        ret = LEPUS_NewInt32(ctx, 0);
      } else {
        /* convert -0 to +0 */
        /* XXX: should not be done here ? */
        d = trunc(d) + 0.0;
        ret = LEPUS_NewFloat64(ctx, d);
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      if (!is_bignum_mode(ctx)) goto to_number;
      ret = val;
      break;
    case LEPUS_TAG_BIG_FLOAT: {
      bf_t a_s, *a, r_s, *r = &r_s;
      BOOL is_float, is_nan;

      a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
      if (!bf_is_finite(a)) {
        is_nan = bf_is_nan(a);
        if (is_nan)
          ret = LEPUS_NewInt32(ctx, 0);
        else
          ret = LEPUS_DupValue(ctx, val);
      } else {
        bf_init(ctx->bf_ctx, r);
        bf_set(r, a);
        bf_rint(r, BF_PREC_INF, BF_RNDZ);
        ret = JS_NewBigInt(ctx, r);
      }
      if (a == &a_s) bf_delete(a);
      LEPUS_FreeValue(ctx, val);
    } break;
#endif
    default:
#ifdef CONFIG_BIGNUM
    to_number:
#endif
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) return val;
      goto redo;
  }
  return ret;
}

/* Note: the integer value is satured to 32 bits */
QJS_STATIC int JS_ToInt32SatFree(LEPUSContext *ctx, int *pres, LEPUSValue val) {
  int64_t tag;
  int ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_EXCEPTION:
      *pres = 0;
      return -1;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        ret = 0;
      } else {
        if (d < INT32_MIN)
          ret = INT32_MIN;
        else if (d > INT32_MAX)
          ret = INT32_MAX;
        else
          ret = (int)d;
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int32(&ret, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

QJS_STATIC int JS_ToInt32Sat(LEPUSContext *ctx, int *pres,
                             LEPUSValueConst val) {
  return JS_ToInt32SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC int JS_ToInt32Clamp(LEPUSContext *ctx, int *pres,
                               LEPUSValueConst val, int min, int max,
                               int min_offset) {
  int res = JS_ToInt32SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
  if (res == 0) {
    if (*pres < min) {
      *pres += min_offset;
      if (*pres < min) *pres = min;
    } else {
      if (*pres > max) *pres = max;
    }
  }
  return res;
}

QJS_STATIC int JS_ToInt64SatFree(LEPUSContext *ctx, int64_t *pres,
                                 LEPUSValue val) {
  int64_t tag;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      *pres = LEPUS_VALUE_GET_INT(val);
      return 0;
    case LEPUS_TAG_BOOL:
      *pres = LEPUS_VALUE_GET_BOOL(val);
      return 0;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      *pres = 0;
      return 0;
    case LEPUS_TAG_EXCEPTION:
      *pres = 0;
      return -1;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        *pres = 0;
      } else {
        if (d < INT64_MIN)
          *pres = INT64_MIN;
        else if (d > INT64_MAX)
          *pres = INT64_MAX;
        else
          *pres = (int64_t)d;
      }
    }
      return 0;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int64(pres, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    }
      return 0;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
}

QJS_STATIC int JS_ToInt64Sat(LEPUSContext *ctx, int64_t *pres,
                             LEPUSValueConst val) {
  return JS_ToInt64SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC int JS_ToInt64Clamp(LEPUSContext *ctx, int64_t *pres,
                               LEPUSValueConst val, int64_t min, int64_t max,
                               int64_t neg_offset) {
  int res = JS_ToInt64SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
  if (res == 0) {
    if (*pres < 0) *pres += neg_offset;
    if (*pres < min)
      *pres = min;
    else if (*pres > max)
      *pres = max;
  }
  return res;
}

/* Same as JS_ToInt32Free() but with a 64 bit result. Return (<0, 0)
   in case of exception */
QJS_STATIC int JS_ToInt64Free(LEPUSContext *ctx, int64_t *pres,
                              LEPUSValue val) {
  int64_t tag;
  int64_t ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_FLOAT64: {
      JSFloat64Union u;
      double d;
      int e;
      d = LEPUS_VALUE_GET_FLOAT64(val);
      u.d = d;
      /* we avoid doing fmod(x, 2^64) */
      e = (u.u64 >> 52) & 0x7ff;
      if (likely(e <= (1023 + 62))) {
        /* fast case */
        ret = (int64_t)d;
      } else if (e <= (1023 + 62 + 53)) {
        uint64_t v;
        /* remainder modulo 2^64 */
        v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
        ret = v << ((e - 1023) - 52);
        /* take the sign into account */
        if (u.u64 >> 63) ret = -ret;
      } else {
        ret = 0; /* also handles NaN and +inf */
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int64(&ret, &p->num, BF_GET_INT_MOD);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#else
#ifdef ENABLE_LEPUSNG
    // <Primjs change>
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      ret = p->num;
      LEPUS_FreeValue(ctx, val);
      break;
    }
#endif
#endif
    default:
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

// <Primjs begin>
void LEPUS_SetNoStrictMode(LEPUSContext *ctx) {
  ctx->no_lepus_strict_mode = TRUE;
}
// <Primjs end>

int LEPUS_ToInt64(LEPUSContext *ctx, int64_t *pres, LEPUSValueConst val) {
  CallGCFunc(JS_ToInt64_GC, ctx, pres, val);
  return JS_ToInt64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

/* return (<0, 0) in case of exception */
QJS_STATIC int JS_ToInt32Free(LEPUSContext *ctx, int32_t *pres,
                              LEPUSValue val) {
  int64_t tag;
  int32_t ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_FLOAT64: {
      JSFloat64Union u;
      double d;
      int e;
      d = LEPUS_VALUE_GET_FLOAT64(val);
      u.d = d;
      /* we avoid doing fmod(x, 2^32) */
      e = (u.u64 >> 52) & 0x7ff;
      if (likely(e <= (1023 + 30))) {
        /* fast case */
        ret = (int32_t)d;
      } else if (e <= (1023 + 30 + 53)) {
        uint64_t v;
        /* remainder modulo 2^32 */
        v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
        v = v << ((e - 1023) - 52 + 32);
        ret = v >> 32;
        /* take the sign into account */
        if (u.u64 >> 63) ret = -ret;
      } else {
        ret = 0; /* also handles NaN and +inf */
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int32(&ret, &p->num, BF_GET_INT_MOD);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

int LEPUS_ToInt32(LEPUSContext *ctx, int32_t *pres, LEPUSValueConst val) {
  CallGCFunc(JS_ToInt32_GC, ctx, pres, val);
  return JS_ToInt32Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC inline int JS_ToUint32Free(LEPUSContext *ctx, uint32_t *pres,
                                      LEPUSValue val) {
  return JS_ToInt32Free(ctx, (int32_t *)pres, val);
}

QJS_STATIC int JS_ToUint8ClampFree(LEPUSContext *ctx, int32_t *pres,
                                   LEPUSValue val) {
  int64_t tag;
  int res;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      res = LEPUS_VALUE_GET_INT(val);
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_BOOL:
      res = LEPUS_VALUE_GET_BOOL(val);
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      res = 0;
#ifdef CONFIG_BIGNUM
    int_clamp:
#endif
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        res = 0;
      } else {
        if (d < 0)
          res = 0;
        else if (d > 255)
          res = 255;
        else
          res = lrint(d);
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      if (!is_bignum_mode(ctx)) goto to_number;
      bf_get_int32(&res, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    }
      goto int_clamp;
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t r_s, *r = &r_s;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      bf_rint(r, BF_PREC_INF, BF_RNDN);
      bf_get_int32(&res, r, 0);
      bf_delete(r);
      LEPUS_FreeValue(ctx, val);
    }
      goto int_clamp;
#endif
    default:
#ifdef CONFIG_BIGNUM
    to_number:
#endif
      val = JS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = res;
  return 0;
}

QJS_STATIC __exception int JS_ToArrayLengthFree(LEPUSContext *ctx,
                                                uint32_t *plen, LEPUSValue val,
                                                BOOL is_array_ctor) {
  int64_t tag;
  uint32_t len;

  tag = LEPUS_VALUE_GET_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT: {
      int v;
      v = LEPUS_VALUE_GET_INT(val);
      if (v < 0) goto fail;
      len = v;
    } break;
    case LEPUS_TAG_BOOL: {
      int v;
      v = LEPUS_VALUE_GET_BOOL(val);
      len = v;
    } break;
    case LEPUS_TAG_NULL: {
      int v;
      v = 0;
      len = v;
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t a;
      BOOL res;
      bf_get_int32((int32_t *)&len, &p->num, BF_GET_INT_MOD);
      bf_init(ctx->bf_ctx, &a);
      bf_set_ui(&a, len);
      res = bf_cmp_eq(&a, &p->num);
      bf_delete(&a);
      LEPUS_FreeValue(ctx, val);
      if (!res) goto fail;
    } break;
#endif
    default:
      if (LEPUS_TAG_IS_FLOAT64(tag)) {
        double d;
        d = LEPUS_VALUE_GET_FLOAT64(val);
        len = (uint32_t)d;
        if (len != d) goto fail;
      } else {
        uint32_t len1;
        if (is_array_ctor) {
          val = JS_ToNumberFree(ctx, val);
          if (LEPUS_IsException(val)) return -1;
          /* cannot recurse because val is a number */
          if (JS_ToArrayLengthFree(ctx, &len, val, TRUE)) return -1;
        } else {
          /* legacy behavior: must do the conversion twice and compare */
          if (LEPUS_ToUint32(ctx, &len, val)) {
            LEPUS_FreeValue(ctx, val);
            return -1;
          }
          val = JS_ToNumberFree(ctx, val);
          if (LEPUS_IsException(val)) return -1;
          /* cannot recurse because val is a number */
          if (JS_ToArrayLengthFree(ctx, &len1, val, FALSE)) return -1;
          if (len1 != len) {
          fail:
            LEPUS_ThrowRangeError(ctx, "invalid array length");
            return -1;
          }
        }
      }
      break;
  }
  *plen = len;
  return 0;
}

#define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)

int LEPUS_ToIndex(LEPUSContext *ctx, uint64_t *plen, LEPUSValueConst val) {
  CallGCFunc(JS_ToIndex_GC, ctx, plen, val);
  int64_t v;
  if (JS_ToInt64Sat(ctx, &v, val)) return -1;
  if (v < 0 || v > MAX_SAFE_INTEGER) {
    LEPUS_ThrowRangeError(ctx, "invalid array index");
    *plen = 0;
    return -1;
  }
  *plen = v;
  return 0;
}

/* convert a value to a length between 0 and MAX_SAFE_INTEGER.
   return -1 for exception */
QJS_STATIC __exception int JS_ToLengthFree(LEPUSContext *ctx, int64_t *plen,
                                           LEPUSValue val) {
  int res = JS_ToInt64Clamp(ctx, plen, val, 0, MAX_SAFE_INTEGER, 0);
  LEPUS_FreeValue(ctx, val);
  return res;
}

/* Note: can return an exception */
/* XXX: bignum case */
QJS_STATIC int JS_NumberIsInteger(LEPUSContext *ctx, LEPUSValueConst val) {
  double d;
  if (!LEPUS_IsNumber(val)) return FALSE;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, val))) return -1;
  return isfinite(d) && floor(d) == d;
}

QJS_STATIC BOOL JS_NumberIsNegativeOrMinusZero(LEPUSContext *ctx,
                                               LEPUSValueConst val) {
  int64_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT: {
      int v;
      v = LEPUS_VALUE_GET_INT(val);
      return (v < 0);
    }
    case LEPUS_TAG_FLOAT64: {
      JSFloat64Union u;
      u.d = LEPUS_VALUE_GET_FLOAT64(val);
      return (u.u64 >> 63);
    }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      /* Note: integer zeros are not necessarily positive */
      return p->num.sign && !bf_is_zero(&p->num);
    }
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      return p->num.sign;
    } break;
#endif
    default:
      return FALSE;
  }
}

#ifdef CONFIG_BIGNUM
static inline char *js_ftoa1(LEPUSContext *ctx, LEPUSValueConst val1, int radix,
                             limb_t prec, bf_flags_t flags) {
  LEPUSValue val;
  bf_t a_s, *a;
  BOOL is_float;
  char *str;
  int saved_sign;

  val = JS_ToNumeric(ctx, val1);
  if (LEPUS_IsException(val)) return nullptr;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
  saved_sign = a->sign;
  if (a->expn == BF_EXP_ZERO) a->sign = 0;
  flags |= BF_FTOA_JS_QUIRKS;
  if ((flags & BF_FTOA_FORMAT_MASK) == BF_FTOA_FORMAT_FREE_MIN) {
    /* Note: for floating point numbers with a radix which is not
       a power of two, the current precision is used to compute
       the number of digits. For integers, the full precision is
       always returned. */
    if (is_float || (flags & BF_FTOA_FORCE_EXP)) {
      if ((radix & (radix - 1)) != 0) {
        bf_t r_s, *r = &r_s;
        int prec, flags1;
        /* must round first */
        if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
          prec = ctx->fp_env.prec;
          flags1 =
              ctx->fp_env.flags &
              (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));
        } else {
          prec = 53;
          flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;
        }
        bf_init(ctx->bf_ctx, r);
        bf_set(r, a);
        bf_round(r, prec, flags1 | BF_RNDN);
        bf_ftoa(&str, r, radix, prec, flags1 | flags);
        bf_delete(r);
      } else {
        bf_ftoa(&str, a, radix, BF_PREC_INF, flags);
      }
    } else {
      bf_ftoa(&str, a, radix, 0,
              BF_RNDZ | BF_FTOA_FORMAT_FRAC | BF_FTOA_JS_QUIRKS);
    }
  } else {
    bf_ftoa(&str, a, radix, prec, flags);
  }
  a->sign = saved_sign;
  if (a == &a_s) bf_delete(a);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, val);
  return str;
}

static LEPUSValue js_ftoa(LEPUSContext *ctx, LEPUSValueConst val1, int radix,
                          limb_t prec, bf_flags_t flags) {
  char *str = js_ftoa1(ctx, val1, radix, prec, flags);
  if (!str) return LEPUS_EXCEPTION;
  LEPUSValue ret = LEPUS_NewString(ctx, str);
  bf_realloc(ctx->bf_ctx, str, 0);
  return ret;
}

#else /* !CONFIG_BIGNUM */

/* 2 <= base <= 36 */
QJS_STATIC char *i64toa(char *buf_end, int64_t n, unsigned int base) {
  char *q = buf_end;
  int digit, is_neg;

  is_neg = 0;
  if (n < 0) {
    is_neg = 1;
    n = -n;
  }
  *--q = '\0';
  do {
    digit = (uint64_t)n % base;
    n = (uint64_t)n / base;
    if (digit < 10)
      digit += '0';
    else
      digit += 'a' - 10;
    *--q = digit;
  } while (n != 0);
  if (is_neg) *--q = '-';
  return q;
}

/* buf1 contains the printf result */
QJS_STATIC void js_ecvt1(double d, int n_digits, int *decpt, int *sign,
                         char *buf, int rounding_mode, char *buf1,
                         int buf1_size) {
  if (rounding_mode != FE_TONEAREST) {
#ifndef LYNX_ARMEABI
    fesetround(rounding_mode);
#endif
  }
  snprintf(buf1, buf1_size, "%+.*e", n_digits - 1, d);
  if (rounding_mode != FE_TONEAREST) {
#ifndef LYNX_ARMEABI
    fesetround(FE_TONEAREST);
#endif
  }
  *sign = (buf1[0] == '-');
  /* mantissa */
  buf[0] = buf1[1];
  if (n_digits > 1) memcpy(buf + 1, buf1 + 3, n_digits - 1);
  buf[n_digits] = '\0';
  /* exponent */
  *decpt = atoi(buf1 + n_digits + 2 + (n_digits > 1)) + 1;
}

/* maximum buffer size for js_dtoa */
#define JS_DTOA_BUF_SIZE 128

/* needed because ecvt usually limits the number of digits to
   17. Return the number of digits. */
QJS_STATIC int js_ecvt(double d, int n_digits, int *decpt, int *sign, char *buf,
                       BOOL is_fixed) {
  int rounding_mode;
  char buf_tmp[JS_DTOA_BUF_SIZE];

  if (!is_fixed) {
    unsigned int n_digits_min, n_digits_max;
    /* find the minimum amount of digits (XXX: inefficient but simple) */
    n_digits_min = 1;
    n_digits_max = 17;
    while (n_digits_min < n_digits_max) {
      n_digits = (n_digits_min + n_digits_max) / 2;
      js_ecvt1(d, n_digits, decpt, sign, buf, FE_TONEAREST, buf_tmp,
               sizeof(buf_tmp));
      if (strtod(buf_tmp, NULL) == d) {
        /* no need to keep the trailing zeros */
        while (n_digits >= 2 && buf[n_digits - 1] == '0') n_digits--;
        n_digits_max = n_digits;
      } else {
        n_digits_min = n_digits + 1;
      }
    }
    n_digits = n_digits_max;
    rounding_mode = FE_TONEAREST;
  } else {
    rounding_mode = FE_TONEAREST;
#ifdef CONFIG_PRINTF_RNDN
    {
      char buf1[JS_DTOA_BUF_SIZE], buf2[JS_DTOA_BUF_SIZE];
      int decpt1, sign1, decpt2, sign2;
      /* The LEPUS rounding is specified as round to nearest ties away
         from zero (RNDNA), but in printf the "ties" case is not
         specified (for example it is RNDN for glibc, RNDNA for
         Windows), so we must round manually. */
      js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_TONEAREST, buf_tmp,
               sizeof(buf_tmp));
      /* XXX: could use 2 digits to reduce the average running time */
      if (buf1[n_digits] == '5') {
        js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_DOWNWARD, buf_tmp,
                 sizeof(buf_tmp));
        js_ecvt1(d, n_digits + 1, &decpt2, &sign2, buf2, FE_UPWARD, buf_tmp,
                 sizeof(buf_tmp));
        if (memcmp(buf1, buf2, n_digits + 1) == 0 && decpt1 == decpt2) {
          /* exact result: round away from zero */
          if (sign1)
            rounding_mode = FE_DOWNWARD;
          else
            rounding_mode = FE_UPWARD;
        }
      }
    }
#endif /* CONFIG_PRINTF_RNDN */
  }
  js_ecvt1(d, n_digits, decpt, sign, buf, rounding_mode, buf_tmp,
           sizeof(buf_tmp));
  return n_digits;
}

QJS_STATIC int js_fcvt1(char *buf, int buf_size, double d, int n_digits,
                        int rounding_mode) {
  int n;
  if (rounding_mode != FE_TONEAREST) {
#ifndef LYNX_ARMEABI
    fesetround(rounding_mode);
#endif
  }
  n = snprintf(buf, buf_size, "%.*f", n_digits, d);
  if (rounding_mode != FE_TONEAREST) {
#ifndef LYNX_ARMEABI
    fesetround(FE_TONEAREST);
#endif
  }
  assert(n < buf_size);
  return n;
}

QJS_STATIC void js_fcvt(char *buf, int buf_size, double d, int n_digits) {
  int rounding_mode;
  rounding_mode = FE_TONEAREST;
#ifdef CONFIG_PRINTF_RNDN
  {
    int n1, n2;
    char buf1[JS_DTOA_BUF_SIZE];
    char buf2[JS_DTOA_BUF_SIZE];

    /* The LEPUS rounding is specified as round to nearest ties away from
       zero (RNDNA), but in printf the "ties" case is not specified
       (for example it is RNDN for glibc, RNDNA for Windows), so we
       must round manually. */
    n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_TONEAREST);
    rounding_mode = FE_TONEAREST;
    /* XXX: could use 2 digits to reduce the average running time */
    if (buf1[n1 - 1] == '5') {
      n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_DOWNWARD);
      n2 = js_fcvt1(buf2, sizeof(buf2), d, n_digits + 1, FE_UPWARD);
      if (n1 == n2 && memcmp(buf1, buf2, n1) == 0) {
        /* exact result: round away from zero */
        if (buf1[0] == '-')
          rounding_mode = FE_DOWNWARD;
        else
          rounding_mode = FE_UPWARD;
      }
    }
  }
#endif /* CONFIG_PRINTF_RNDN */
  js_fcvt1(buf, buf_size, d, n_digits, rounding_mode);
}

/* radix != 10 is only supported with flags = JS_DTOA_VAR_FORMAT */
/* use as many digits as necessary */
#define JS_DTOA_VAR_FORMAT (0 << 0)
/* use n_digits significant digits (1 <= n_digits <= 101) */
#define JS_DTOA_FIXED_FORMAT (1 << 0)
/* force fractional format: [-]dd.dd with n_digits fractional digits */
#define JS_DTOA_FRAC_FORMAT (2 << 0)
/* force exponential notation either in fixed or variable format */
#define JS_DTOA_FORCE_EXP (1 << 2)

/* XXX: slow and maybe not fully correct
   XXX: radix != 10 is only supported for small integers
*/
void js_dtoa1(char *buf, double d, int radix, int n_digits, int flags) {
  char *q;

  if (!isfinite(d)) {
    if (isnan(d)) {
      strcpy(buf, "NaN");
    } else {
      q = buf;
      if (d < 0) *q++ = '-';
      strcpy(q, "Infinity");
    }
  } else if (flags == JS_DTOA_VAR_FORMAT) {
    int64_t i64;
    char buf1[70], *ptr;
    i64 = (int64_t)d;
    if (d != i64 || i64 > MAX_SAFE_INTEGER || i64 < -MAX_SAFE_INTEGER)
      goto generic_conv;
    /* fast path for integers */
    ptr = i64toa(buf1 + sizeof(buf1), i64, radix);
    strcpy(buf, ptr);
  } else {
    if (d == 0.0) d = 0.0; /* convert -0 to 0 */
    if (flags == JS_DTOA_FRAC_FORMAT) {
      js_fcvt(buf, JS_DTOA_BUF_SIZE, d, n_digits);
    } else {
      char buf1[JS_DTOA_BUF_SIZE];
      int sign, decpt, k, n, i, p, n_max;
      BOOL is_fixed;
    generic_conv:
      is_fixed = ((flags & 3) == JS_DTOA_FIXED_FORMAT);
      if (is_fixed) {
        n_max = n_digits;
      } else {
        n_max = 21;
      }
      /* the number has k digits (k >= 1) */
      k = js_ecvt(d, n_digits, &decpt, &sign, buf1, is_fixed);
      n = decpt; /* d=10^(n-k)*(buf1) i.e. d= < x.yyyy 10^(n-1) */
      q = buf;
      if (sign) *q++ = '-';
      if (flags & JS_DTOA_FORCE_EXP) goto force_exp;
      if (n >= 1 && n <= n_max) {
        if (k <= n) {
          memcpy(q, buf1, k);
          q += k;
          for (i = 0; i < (n - k); i++) *q++ = '0';
          *q = '\0';
        } else {
          /* k > n */
          memcpy(q, buf1, n);
          q += n;
          *q++ = '.';
          for (i = 0; i < (k - n); i++) *q++ = buf1[n + i];
          *q = '\0';
        }
      } else if (n >= -5 && n <= 0) {
        *q++ = '0';
        *q++ = '.';
        for (i = 0; i < -n; i++) *q++ = '0';
        memcpy(q, buf1, k);
        q += k;
        *q = '\0';
      } else {
      force_exp:
        /* exponential notation */
        *q++ = buf1[0];
        if (k > 1) {
          *q++ = '.';
          for (i = 1; i < k; i++) *q++ = buf1[i];
        }
        *q++ = 'e';
        p = n - 1;
        if (p >= 0) *q++ = '+';
        char pbuf[16];
        snprintf(pbuf, sizeof(pbuf), "%d", p);
        strcpy(q, pbuf);
      }
    }
  }
}

QJS_STATIC LEPUSValue js_dtoa(LEPUSContext *ctx, double d, int radix,
                              int n_digits, int flags) {
  char buf[JS_DTOA_BUF_SIZE];
  js_dtoa1(buf, d, radix, n_digits, flags);
  return LEPUS_NewString(ctx, buf);
}

#endif /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue JS_ToStringInternal(LEPUSContext *ctx,
                                          LEPUSValueConst val,
                                          BOOL is_ToPropertyKey) {
  int64_t tag;
  const char *str;
  char buf[32];

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_SEPARABLE_STRING:
      return JS_GetSeparableStringContent(ctx, val);
    case LEPUS_TAG_STRING:
      return LEPUS_DupValue(ctx, val);
    case LEPUS_TAG_INT:
      snprintf(buf, sizeof(buf), "%d", LEPUS_VALUE_GET_INT(val));
      str = buf;
      goto new_string;
    case LEPUS_TAG_BOOL:
      return LEPUS_AtomToString(
          ctx, LEPUS_VALUE_GET_BOOL(val) ? JS_ATOM_true : JS_ATOM_false);
    case LEPUS_TAG_NULL:
      return LEPUS_AtomToString(ctx, JS_ATOM_null);
    case LEPUS_TAG_UNDEFINED:
      return LEPUS_AtomToString(ctx, JS_ATOM_undefined);
    case LEPUS_TAG_EXCEPTION:
      return LEPUS_EXCEPTION;
    case LEPUS_TAG_OBJECT: {
      LEPUSValue val1, ret;
      val1 = JS_ToPrimitive(ctx, val, HINT_STRING);
      if (LEPUS_IsException(val1)) return val1;
      ret = JS_ToStringInternal(ctx, val1, is_ToPropertyKey);
      LEPUS_FreeValue(ctx, val1);
      return ret;
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      str = "[function bytecode]";
      goto new_string;
    case LEPUS_TAG_SYMBOL:
      if (is_ToPropertyKey) {
        return LEPUS_DupValue(ctx, val);
      } else {
        return LEPUS_ThrowTypeError(ctx, "cannot convert symbol to string");
      }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT:
      return js_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
#else
    case LEPUS_TAG_FLOAT64:
      return js_dtoa(ctx, LEPUS_VALUE_GET_FLOAT64(val), 10, 0,
                     JS_DTOA_VAR_FORMAT);
#endif
#ifdef ENABLE_LEPUSNG
      // <Primjs begin>
    case LEPUS_TAG_LEPUS_REF:
      if (ctx->rt->js_callbacks_.lepus_ref_tostring) {
        return ctx->rt->js_callbacks_.lepus_ref_tostring(ctx, val);
      }
      // <Primjs end>
#endif
    default:
      str = "[unsupported type]";
    new_string:
      return LEPUS_NewString(ctx, str);
  }
}

static LEPUSValue JS_ToString_RC(LEPUSContext *ctx, LEPUSValueConst val) {
  return JS_ToStringInternal(ctx, val, FALSE);
}

LEPUSValue LEPUS_ToString(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_ToString_GC, ctx, val);
  return JS_ToString_RC(ctx, val);
}

QJS_STATIC LEPUSValue JS_ToStringFree(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSValue ret;
  ret = JS_ToString_RC(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue JS_ToLocaleStringFree(LEPUSContext *ctx, LEPUSValue val) {
  if (LEPUS_IsUndefined(val) || LEPUS_IsNull(val))
    return JS_ToStringFree(ctx, val);
  return JS_InvokeFree(ctx, val, JS_ATOM_toLocaleString, 0, NULL);
}

LEPUSValue LEPUS_ToPropertyKey(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_ToPropertyKey_GC, ctx, val);
  return JS_ToStringInternal(ctx, val, TRUE);
}

QJS_STATIC LEPUSValue JS_ToStringCheckObject(LEPUSContext *ctx,
                                             LEPUSValueConst val) {
  if (LEPUS_VALUE_IS_NULL(val) || LEPUS_VALUE_IS_UNDEFINED(val))
    return LEPUS_ThrowTypeError(ctx, "null or undefined are forbidden");
  return JS_ToString_RC(ctx, val);
}

QJS_STATIC LEPUSValue JS_ToQuotedString(LEPUSContext *ctx,
                                        LEPUSValueConst val1) {
  LEPUSValue val;
  JSString *p;
  int i;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;
  char buf[16];

  val = JS_ToStringCheckObject(ctx, val1);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);

  if (string_buffer_init(ctx, b, p->len + 2)) goto fail;

  if (string_buffer_putc8(b, '\"')) goto fail;
  for (i = 0; i < p->len;) {
    c = string_getc(p, &i);
    switch (c) {
      case '\t':
        c = 't';
        goto quote;
      case '\r':
        c = 'r';
        goto quote;
      case '\n':
        c = 'n';
        goto quote;
      case '\b':
        c = 'b';
        goto quote;
      case '\f':
        c = 'f';
        goto quote;
      case '\"':
      case '\\':
      quote:
        if (string_buffer_putc8(b, '\\')) goto fail;
        if (string_buffer_putc8(b, c)) goto fail;
        break;
      default:
        if (c < 32 || (c >= 0xd800 && c < 0xe000)) {
          snprintf(buf, sizeof(buf), "\\u%04x", c);
          if (string_buffer_puts8(b, buf)) goto fail;
        } else {
          if (string_buffer_putc(b, c)) goto fail;
        }
        break;
    }
  }
  if (string_buffer_putc8(b, '\"')) goto fail;
  LEPUS_FreeValue(ctx, val);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, val);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

// <Primjs begin>
#if defined(DUMP_QJS_VALUE)

#ifdef DEBUG_MEMORY
static __attribute__((unused)) void JS_DumpObjectHeader(LEPUSRuntime *rt) {
  printf("DUMP_LEAKS: %14s %4s %4s %14s %10s %s\n", "ADDRESS", "REFS", "SHRF",
         "PROTO", "CLASS", "PROPS");
}
#else
static __attribute__((unused)) void JS_DumpObjectHeader(LEPUSRuntime *rt) {
  printf("%14s %4s %4s %14s %10s %s\n", "ADDRESS", "REFS", "SHRF", "PROTO",
         "CLASS", "PROPS");
}
#endif

/* for debug only: dump an object without side effect */
static __attribute__((unused)) void JS_DumpObject(LEPUSRuntime *rt,
                                                  LEPUSObject *p) {
  uint32_t i;
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  JSShape *sh;
  JSShapeProperty *prs;
  JSProperty *pr;
  BOOL is_first = TRUE;
  char dump_buf[4096], fmt_buf[1024];
  dump_buf[0] = '\0';

#define write(...)                                   \
  if (strlen(dump_buf) + strlen(fmt_buf) < 4090) {   \
    snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), \
        strcat(dump_buf, fmt_buf);                   \
  } else {                                           \
    printf("DUMP_LEAKS: %s", dump_buf);              \
    return;                                          \
  }

  /* XXX: should encode atoms with special characters */
  sh = p->shape; /* the shape can be NULL while freeing an object */
  write("%14p %4d ", (void *)p, p->header.ref_count);
  if (sh) {
    write("%3d%c %14p ", sh->header.ref_count, " *"[sh->is_hashed],
          (void *)sh -> proto);
  } else {
    write("%3s  %14s ", "-", "-");
  }
  write("%10s ", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
                                 rt->class_array[p->class_id].class_name));
  if (p->is_exotic && p->fast_array) {
    write("[ ");
    for (i = 0; i < p->u.array.count; i++) {
      if (i != 0) {
        write(", ");
      }
      switch (p->class_id) {
        case JS_CLASS_ARRAY:
        case JS_CLASS_ARGUMENTS:
          JS_DumpValueShortNoPrint(rt, p->u.array.u.values[i], dump_buf);
          break;
        case JS_CLASS_UINT8C_ARRAY ... JS_CLASS_FLOAT64_ARRAY: {
          int size = 1 << typed_array_size_log2(p->class_id);
          const uint8_t *b = p->u.array.u.uint8_ptr + i * size;
          while (size-- > 0) write("%02X", *b++);
        } break;
      }
    }
    write(" ] ");
  }

  if (sh) {
    write("{ ");
    for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
      if (prs->atom != JS_ATOM_NULL) {
        pr = &p->prop[i];
        if (!is_first) {
          write(", ");
        }
        write("%s: ",
              JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), prs->atom));
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          write("[getset %p %p]", (void *)pr->u.getset.getter,
                (void *)pr->u.getset.setter);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          write("[varref %p]", (void *)pr->u.var_ref);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          write("[autoinit %p %p]", (void *)pr->u.init.init_func,
                (void *)pr->u.init.opaque);
        } else {
          JS_DumpValueShortNoPrint(rt, pr->u.value, dump_buf);
        }
        is_first = FALSE;
      }
    }
    write(" }");
  }

  if (lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    JSVarRef **var_refs;
    if (b->closure_var_count) {
      var_refs = p->u.func.var_refs;
      write(" Closure:");
      for (i = 0; i < b->closure_var_count; i++) {
        write(" ");
        JS_DumpValueShortNoPrint(rt, var_refs[i]->value, dump_buf);
      }
      if (p->u.func.home_object) {
        write(" HomeObject: ");
        JS_DumpValueShortNoPrint(
            rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object), dump_buf);
      }
    }
  }
  write("\n");
#undef write

#ifdef DEBUG_MEMORY
  printf("DUMP_LEAKS: %s", dump_buf);
#else
  printf("%s", dump_buf);
#endif
}

static __attribute__((unused)) void JS_DumpValueShortNoPrint(
    LEPUSRuntime *rt, LEPUSValueConst val, char dump_buf[]) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  const char *str;

  char fmt_buf[1024];

#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
  switch (tag) {
    case LEPUS_TAG_INT:
      write("%d", LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_BOOL:
      if (LEPUS_VALUE_GET_BOOL(val))
        str = "true";
      else
        str = "false";
      goto print_str;
    case LEPUS_TAG_NULL:
      str = "null";
      goto print_str;
    case LEPUS_TAG_EXCEPTION:
      str = "exception";
      goto print_str;
    case LEPUS_TAG_UNINITIALIZED:
      str = "uninitialized";
      goto print_str;
    case LEPUS_TAG_UNDEFINED:
      str = "undefined";
    print_str:
      write("%s", str);
      break;
    case LEPUS_TAG_FLOAT64:
      write("%.14g", LEPUS_VALUE_GET_FLOAT64(val));
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = (JSBigFloat *)LEPUS_VALUE_GET_PTR(val);
      char *str;
      bf_ftoa(&str, &p->num, 10, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC);
      write("%sn", str);
      bf_realloc(&rt->bf_ctx, str, 0);
    } break;
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = (JSBigFloat *)LEPUS_VALUE_GET_PTR(val);
      char *str;
      bf_ftoa(&str, &p->num, 16, BF_PREC_INF,
              BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);
      write("%sl", str);
      bf_realloc(&rt->bf_ctx, str, 0);
    } break;
#endif
    case LEPUS_TAG_SEPARABLE_STRING: {
      write("[SeparableString(%p)]", LEPUS_VALUE_GET_PTR(val));
    } break;
    case LEPUS_TAG_STRING: {
      JSString *p;
      p = LEPUS_VALUE_GET_STRING(val);
      JS_DumpStringNoPrint(rt, p, dump_buf);
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      LEPUSFunctionBytecode *b =
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
      char buf[ATOM_GET_STR_BUF_SIZE];
      write("[bytecode %s]",
            JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
    } break;
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
      JSAtom atom = rt->class_array[p->class_id].class_name;
      char atom_buf[ATOM_GET_STR_BUF_SIZE];
      write("[%s %p]", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), atom),
            (void *)p);
    } break;
    case LEPUS_TAG_SYMBOL: {
      JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
      char atom_buf[ATOM_GET_STR_BUF_SIZE];
      write("Symbol(%s)", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
                                          js_get_atom_index(rt, p)));
    } break;
    case LEPUS_TAG_MODULE:
      write("[module]");
      break;
    case LEPUS_TAG_VAR_REF:
      write("[var_ref]");
      break;
    case LEPUS_TAG_LEPUS_REF: {
      auto *ref = static_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(val));
      write("[js_ref: %p -> %p]", ref, ref->p);
      break;
    }
    default:
#if defined(__aarch64__) && !defined(OS_WIN) && !defined(CONFIG_BIGNUM) && \
    !DISABLE_NANBOX
      write("[unknown tag %p]", (void *)tag);
#else
      write("[unknown tag %" PRId64 "]", tag);
#endif
      break;
  }
#undef write
}

static __attribute__((unused)) void JS_DumpValueShort(LEPUSRuntime *rt,
                                                      LEPUSValueConst val) {
  char dump_buf[4096];
  dump_buf[0] = '\0';
  JS_DumpValueShortNoPrint(rt, val, dump_buf);
  printf("%s", dump_buf);
}

static __attribute__((unused)) void JS_DumpValue(LEPUSContext *ctx,
                                                 LEPUSValueConst val) {
  JS_DumpValueShort(ctx->rt, val);
}

static __attribute__((unused)) void JS_PrintValue(LEPUSContext *ctx,
                                                  const char *str,
                                                  LEPUSValueConst val) {
  printf("%s=", str);
  JS_DumpValueShort(ctx->rt, val);
  printf("\n");
}
#endif  // DUMP_QJS_VALUE
// <Primjs end>

/* return -1 if exception (proxy case) or TRUE/FALSE */
int LEPUS_IsArray(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_IsArray_GC, ctx, val);
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_OBJECT(val)) {
    p = LEPUS_VALUE_GET_OBJ(val);
    if (unlikely(p->class_id == JS_CLASS_PROXY))
      return js_proxy_isArray(ctx, val);
    else
      return p->class_id == JS_CLASS_ARRAY;
  } else {
    return FALSE;
  }
}

QJS_STATIC double js_pow(double a, double b) {
  if (unlikely(!isfinite(b)) && fabs(a) == 1) {
    /* not compatible with IEEE 754 */
    return LEPUS_FLOAT64_NAN;
  } else {
    return pow(a, b);
  }
}

#ifdef CONFIG_BIGNUM

LEPUSValue LEPUS_NewBigInt64(LEPUSContext *ctx, int64_t v) {
  BOOL is_bignum = is_bignum_mode(ctx);
  if (is_bignum && v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
    bf_t a_s, *a = &a_s;
    bf_init(ctx->bf_ctx, a);
    bf_set_si(a, v);
    return JS_NewBigInt2(ctx, a, TRUE);
  }
}

LEPUSValue LEPUS_NewBigUint64(LEPUSContext *ctx, uint64_t v) {
  CallGCFunc(JS_NewBigUint64_GC, ctx, v);
  BOOL is_bignum = is_bignum_mode(ctx);
  if (is_bignum && v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
    bf_t a_s, *a = &a_s;
    bf_init(ctx->bf_ctx, a);
    bf_set_ui(a, v);
    return JS_NewBigInt2(ctx, a, TRUE);
  }
}

/* if the returned bigfloat is allocated it is equal to
   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */
static bf_t *JS_ToBigFloat(LEPUSContext *ctx, BOOL *pis_float, bf_t *buf,
                           LEPUSValueConst val) {
  int32_t tag;
  bf_t *r;
  BOOL is_float;
  JSBigFloat *p;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_si(r, LEPUS_VALUE_GET_INT(val));
      is_float = FALSE;
      break;
    case LEPUS_TAG_FLOAT64:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_float64(r, LEPUS_VALUE_GET_FLOAT64(val));
      is_float = TRUE;
      break;
    case LEPUS_TAG_BIG_INT:
      is_float = FALSE;
      goto get_ptr;
    case LEPUS_TAG_BIG_FLOAT:
      is_float = TRUE;
    get_ptr:
      p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      r = &p->num;
      break;
    case LEPUS_TAG_UNDEFINED:
    default:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_nan(r);
      is_float = TRUE;
      break;
  }
  *pis_float = is_float;
  return r;
}

/* return NaN if bad bigint literal */
static LEPUSValue JS_StringToBigInt(LEPUSContext *ctx, LEPUSValue val) {
  const char *str;
  const char *p;
  int flags, err;

  str = JS_ToCStringLen2_RC(ctx, NULL, val, 0);
  LEPUS_FreeValue(ctx, val);
  if (!str) return LEPUS_EXCEPTION;
  flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN | BF_ATOF_JS_QUIRKS |
          BF_ATOF_INT_ONLY | BF_ATOF_INT_PREC_INF;
  if (!is_bignum_mode(ctx)) flags |= BF_ATOF_BIG_INT;
  val = js_atof(ctx, str, &p, 0, flags);
  p += skip_spaces(p);
  err = (*p != '\0');
  LEPUS_FreeCString(ctx, str);
  if (err) {
    LEPUS_FreeValue(ctx, val);
    val = LEPUS_NAN;
  }
  return val;
}

static LEPUSValue JS_StringToBigIntErr(LEPUSContext *ctx, LEPUSValue val) {
  val = JS_StringToBigInt(ctx, val);
  if (LEPUS_VALUE_GET_TAG(val) != LEPUS_TAG_BIG_INT) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_ThrowSyntaxError(ctx, "invalid bigint literal");
  }
  return val;
}

/* if the returned bigfloat is allocated it is equal to
   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */
static bf_t *JS_ToBigIntFree(LEPUSContext *ctx, bf_t *buf, LEPUSValue val) {
  int32_t tag;
  bf_t *r;
  JSBigFloat *p;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      if (!is_bignum_mode(ctx)) goto fail;
      /* fall tru */
    case LEPUS_TAG_BOOL:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_si(r, LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (!is_bignum_mode(ctx)) goto fail;
      if (!isfinite(d)) goto fail;
      r = buf;
      bf_init(ctx->bf_ctx, r);
      d = trunc(d);
      bf_set_float64(r, d);
    } break;
    case LEPUS_TAG_BIG_INT:
      p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      r = &p->num;
      break;
    case LEPUS_TAG_BIG_FLOAT:
      if (!is_bignum_mode(ctx)) goto fail;
      p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      if (!bf_is_finite(&p->num)) goto fail;
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      bf_rint(r, BF_PREC_INF, BF_RNDZ);
      LEPUS_FreeValue(ctx, val);
      break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING:
      val = JS_StringToBigIntErr(ctx, val);
      if (LEPUS_IsException(val)) return NULL;
      goto redo;
    case LEPUS_TAG_OBJECT:
      val = JS_ToPrimitiveFree_RC(
          ctx, val, is_bignum_mode(ctx) ? HINT_INTEGER : HINT_NUMBER);
      if (LEPUS_IsException(val)) return NULL;
      goto redo;
    default:
    fail:
      LEPUS_FreeValue(ctx, val);
      LEPUS_ThrowTypeError(ctx, "cannot convert to bigint");
      return NULL;
  }
  return r;
}

static bf_t *JS_ToBigInt(LEPUSContext *ctx, bf_t *buf, LEPUSValueConst val) {
  return JS_ToBigIntFree(ctx, buf, LEPUS_DupValue(ctx, val));
}

static __attribute__((unused)) LEPUSValue JS_ToBigIntValueFree(
    LEPUSContext *ctx, LEPUSValue val) {
  if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_INT) {
    return val;
  } else {
    bf_t a_s, *a;
    a = JS_ToBigIntFree(ctx, &a_s, val);
    if (!a) return LEPUS_EXCEPTION;
    return JS_NewBigInt2(ctx, a, TRUE);
  }
}

/* free the bf_t allocated by JS_ToBigInt */
static void JS_FreeBigInt(LEPUSContext *ctx, bf_t *a, bf_t *buf) {
  if (a == buf) {
    bf_delete(a);
  } else {
    JSBigFloat *p = (JSBigFloat *)((uint8_t *)a - offsetof(JSBigFloat, num));
    LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p));
  }
}

/* XXX: merge with JS_ToInt64Free with a specific flag */
static int JS_ToBigInt64Free(LEPUSContext *ctx, int64_t *pres, LEPUSValue val) {
  bf_t a_s, *a;

  a = JS_ToBigIntFree(ctx, &a_s, val);
  if (!a) {
    *pres = 0;
    return -1;
  }
  bf_get_int64(pres, a, BF_GET_INT_MOD);
  JS_FreeBigInt(ctx, a, &a_s);
  return 0;
}

int LEPUS_ToBigInt64(LEPUSContext *ctx, int64_t *pres, LEPUSValueConst val) {
  CallGCFunc(JS_ToBigInt64_GC, ctx, pres, val);
  return JS_ToBigInt64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

static JSBigFloat *js_new_bf(LEPUSContext *ctx) {
  JSBigFloat *p;
  p = static_cast<JSBigFloat *>(
      lepus_mallocz(ctx, sizeof(*p), ALLOC_TAG_JSBigFloat));
  if (!p) return NULL;
  if (!ctx->rt->gc_enable) p->header.ref_count = 1;
  bf_init(ctx->bf_ctx, &p->num);
  return p;
}

/* WARNING: 'a' is freed */
static LEPUSValue JS_NewBigFloat(LEPUSContext *ctx, bf_t *a) {
  LEPUSValue ret;
  JSBigFloat *p;

  p = js_new_bf(ctx);
  p->num = *a;
  ret = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
  return ret;
}

/* WARNING: 'a' is freed */
static LEPUSValue JS_NewBigInt2(LEPUSContext *ctx, bf_t *a, BOOL force_bigint) {
  LEPUSValue ret;
  JSBigFloat *p;
  int32_t v;

  if (!force_bigint && bf_get_int32(&v, a, 0) == 0) {
    /* can fit in an int32 */
    ret = LEPUS_NewInt32(ctx, v);
    bf_delete(a);
  } else {
    p = js_new_bf(ctx);
    p->num = *a;
    /* normalize the zero representation */
    if (bf_is_zero(&p->num)) p->num.sign = 0;
    ret = LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
  }
  return ret;
}

static LEPUSValue JS_NewBigInt(LEPUSContext *ctx, bf_t *a) {
  return JS_NewBigInt2(ctx, a, FALSE);
}

/* return < 0 if exception, 0 if overloading method, 1 if overloading
   operator called */
static __exception int js_call_binary_op_fallback(LEPUSContext *ctx,
                                                  LEPUSValue *pret,
                                                  LEPUSValueConst op1,
                                                  LEPUSValueConst op2,
                                                  OPCodeEnum op) {
  JSAtom op_name;
  LEPUSValue method, ret, c1, c2;
  BOOL bool_result, swap_op;
  LEPUSValueConst args[2];

  bool_result = FALSE;
  swap_op = FALSE;
  c1 = LEPUS_UNDEFINED;
  c2 = LEPUS_UNDEFINED;
  switch (op) {
    case OP_add:
      op_name = JS_ATOM_Symbol_operatorAdd;
      break;
    case OP_sub:
      op_name = JS_ATOM_Symbol_operatorSub;
      break;
    case OP_mul:
      op_name = JS_ATOM_Symbol_operatorMul;
      break;
    case OP_div:
    case OP_math_div:
      op_name = JS_ATOM_Symbol_operatorDiv;
      break;
    case OP_mod:
      op_name = JS_ATOM_Symbol_operatorMod;
      break;
    case OP_pow:
    case OP_math_pow:
      op_name = JS_ATOM_Symbol_operatorPow;
      break;
    case OP_math_mod:
      op_name = JS_ATOM_Symbol_operatorMathMod;
      break;
    case OP_shl:
      op_name = JS_ATOM_Symbol_operatorShl;
      break;
    case OP_sar:
      op_name = JS_ATOM_Symbol_operatorShr;
      break;
    case OP_and:
      op_name = JS_ATOM_Symbol_operatorAnd;
      break;
    case OP_or:
      op_name = JS_ATOM_Symbol_operatorOr;
      break;
    case OP_xor:
      op_name = JS_ATOM_Symbol_operatorXor;
      break;
    case OP_lt:
      op_name = JS_ATOM_Symbol_operatorCmpLT;
      bool_result = TRUE;
      break;
    case OP_lte:
      op_name = JS_ATOM_Symbol_operatorCmpLE;
      bool_result = TRUE;
      break;
    case OP_gt:
      op_name = JS_ATOM_Symbol_operatorCmpLT;
      bool_result = TRUE;
      swap_op = TRUE;
      break;
    case OP_gte:
      op_name = JS_ATOM_Symbol_operatorCmpLE;
      bool_result = TRUE;
      swap_op = TRUE;
      break;
    case OP_eq:
    case OP_neq:
      op_name = JS_ATOM_Symbol_operatorCmpEQ;
      bool_result = TRUE;
      break;
    default:
      goto fail;
  }
  c1 = JS_GetPropertyInternal_RC(ctx, op1, JS_ATOM_constructor, op1, 0);
  if (LEPUS_IsException(c1)) goto exception;
  c2 = JS_GetPropertyInternal_RC(ctx, op2, JS_ATOM_constructor, op2, 0);
  if (LEPUS_IsException(c2)) goto exception;
  if (LEPUS_VALUE_IS_NOT_OBJECT(c1) || LEPUS_VALUE_IS_NOT_OBJECT(c2)) goto fail;
  if (LEPUS_VALUE_GET_OBJ(c1) == LEPUS_VALUE_GET_OBJ(c2)) {
    /* if same constructor, there is no ambiguity */
    method = JS_GetPropertyInternal_RC(ctx, c1, op_name, c1, 0);
  } else {
    LEPUSValue val;
    int order1, order2;

    /* different constructors: we use a user-defined ordering */
    val =
        JS_GetPropertyInternal_RC(ctx, c1, JS_ATOM_Symbol_operatorOrder, c1, 0);
    if (LEPUS_IsException(val)) goto exception;
    if (LEPUS_IsUndefined(val)) goto undef_order;
    if (JS_ToInt32Free(ctx, &order1, val)) goto exception;
    val =
        JS_GetPropertyInternal_RC(ctx, c2, JS_ATOM_Symbol_operatorOrder, c2, 0);
    if (LEPUS_IsException(val)) goto exception;
    if (LEPUS_IsUndefined(val)) {
    undef_order:
      LEPUS_FreeValue(ctx, c1);
      LEPUS_FreeValue(ctx, c2);
      *pret = LEPUS_UNDEFINED;
      return 0;
    }
    if (JS_ToInt32Free(ctx, &order2, val)) goto exception;
    /* ambiguous priority: error */
    if (order1 == order2) {
      LEPUS_ThrowTypeError(ctx,
                           "operator_order is identical in both constructors");
      goto exception;
    }
    if (order1 > order2) {
      val = c1;
    } else {
      val = c2;
    }
    method = JS_GetPropertyInternal_RC(ctx, val, op_name, val, 0);
  }
  LEPUS_FreeValue(ctx, c1);
  LEPUS_FreeValue(ctx, c2);
  c1 = LEPUS_UNDEFINED;
  c2 = LEPUS_UNDEFINED;
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    *pret = LEPUS_UNDEFINED;
    return 0;
  }
  if (swap_op) {
    args[0] = op2;
    args[1] = op1;
  } else {
    args[0] = op1;
    args[1] = op2;
  }
  ret = JS_CallFree(ctx, method, LEPUS_UNDEFINED, 2, args);
  if (LEPUS_IsException(ret)) goto exception;
  if (bool_result) {
    BOOL res = JS_ToBoolFree_RC(ctx, ret);
    if (op == OP_neq) res ^= 1;
    ret = LEPUS_NewBool(ctx, res);
  }
  *pret = ret;
  return 1;
fail:
  LEPUS_ThrowTypeError(ctx, "invalid types for binary operator");
exception:
  LEPUS_FreeValue(ctx, c1);
  LEPUS_FreeValue(ctx, c2);
  *pret = LEPUS_UNDEFINED;
  return -1;
}

static LEPUSValue throw_bf_exception(LEPUSContext *ctx, int status) {
  const char *str;
  if (status & BF_ST_DIVIDE_ZERO) {
    str = "division by zero";
  } else if (status & BF_ST_INVALID_OP) {
    str = "invalid operation";
  } else {
    str = "integer overflow";
  }
  return LEPUS_ThrowRangeError(ctx, "%s", str);
}

static no_inline __exception int js_unary_arith_slow(LEPUSContext *ctx,
                                                     LEPUSValue *sp,
                                                     OPCodeEnum op) {
  LEPUSValue op1, val, method;
  bf_t a_s, r_s, *r = &r_s, *a;
  BOOL is_float, is_legacy;
  JSAtom op_name;
  int ret, v;
  int32_t tag;

  op1 = sp[-1];
  /* fast path for float64 */
  if (LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(op1))) goto handle_float64;
  if (LEPUS_IsObject(op1)) {
    switch (op) {
      case OP_plus:
        op_name = JS_ATOM_Symbol_operatorPlus;
        break;
      case OP_neg:
        op_name = JS_ATOM_Symbol_operatorNeg;
        break;
      case OP_inc:
        op_name = JS_ATOM_Symbol_operatorInc;
        break;
      case OP_dec:
        op_name = JS_ATOM_Symbol_operatorDec;
        break;
      default:
        abort();
    }
    method = JS_GetPropertyInternal_RC(ctx, op1, op_name, op1, 0);
    if (LEPUS_IsException(method)) return -1;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) goto to_number;
    val = JS_CallFree(ctx, method, op1, 0, NULL);
    if (LEPUS_IsException(val)) return -1;
    LEPUS_FreeValue(ctx, op1);
    sp[-1] = val;
  } else {
  to_number:
    op1 = JS_ToNumericFree(ctx, op1);
    if (LEPUS_IsException(op1)) goto exception;
    is_legacy = is_bignum_mode(ctx) ^ 1;
    tag = LEPUS_VALUE_GET_TAG(op1);
    switch (tag) {
      case LEPUS_TAG_INT: {
        int64_t v64;
        v64 = LEPUS_VALUE_GET_INT(op1);
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            v64 += v;
            break;
          case OP_plus:
            break;
          case OP_neg:
            if (v64 == 0 && is_legacy) {
              sp[-1] = __JS_NewFloat64(ctx, -0.0);
              return 0;
            } else {
              v64 = -v64;
            }
            break;
          default:
            abort();
        }
        sp[-1] = LEPUS_NewInt64(ctx, v64);
      } break;
      case LEPUS_TAG_BIG_INT:
        if (is_legacy && op == OP_plus) {
          LEPUS_ThrowTypeError(ctx, "bigint argument with unary +");
          LEPUS_FreeValue(ctx, op1);
          goto exception;
        }
        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
        bf_init(ctx->bf_ctx, r);
        ret = 0;
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
            break;
          case OP_plus:
            bf_set(r, a);
            break;
          case OP_neg:
            bf_set(r, a);
            bf_neg(r);
            break;
          default:
            abort();
        }
        if (a == &a_s) bf_delete(a);
        LEPUS_FreeValue(ctx, op1);
        if (unlikely(ret)) {
          bf_delete(r);
          throw_bf_exception(ctx, ret);
          goto exception;
        }
        sp[-1] = JS_NewBigInt2(ctx, r, is_legacy);
        break;
      case LEPUS_TAG_BIG_FLOAT:
        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
        bf_init(ctx->bf_ctx, r);
        ret = 0;
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
            break;
          case OP_plus:
            bf_set(r, a);
            break;
          case OP_neg:
            bf_set(r, a);
            bf_neg(r);
            break;
          default:
            abort();
        }
        if (a == &a_s) bf_delete(a);
        LEPUS_FreeValue(ctx, op1);
        if (unlikely(ret)) {
          bf_delete(r);
          throw_bf_exception(ctx, ret);
          goto exception;
        }
        sp[-1] = JS_NewBigFloat(ctx, r);
        break;
      default:
      handle_float64: {
        double d;
        d = LEPUS_VALUE_GET_FLOAT64(op1);
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            d += v;
            break;
          case OP_plus:
            break;
          case OP_neg:
            d = -d;
            break;
          default:
            abort();
        }
        sp[-1] = __JS_NewFloat64(ctx, d);
      } break;
    }
  }
  return 0;
exception:
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

__exception int js_post_inc_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                 OPCodeEnum op) {
  LEPUSValue op1;

  /* XXX: allow custom operators */
  op1 = sp[-1];
  op1 = JS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  sp[-1] = op1;
  sp[0] = LEPUS_DupValue(ctx, op1);
  return js_unary_arith_slow(
      ctx, sp + 1, static_cast<OPCodeEnum>(op - OP_post_dec + OP_dec));
}

static no_inline int js_not_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, method, val;
  bf_t a_s, r_s, *r = &r_s, *a;
  int ret;
  BOOL is_legacy;

  op1 = sp[-1];
  if (LEPUS_IsObject(op1)) {
    method =
        JS_GetPropertyInternal_RC(ctx, op1, JS_ATOM_Symbol_operatorNot, op1, 0);
    if (LEPUS_IsException(method)) return -1;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) goto to_number;
    val = JS_CallFree(ctx, method, op1, 0, NULL);
    if (LEPUS_IsException(val)) return -1;
    LEPUS_FreeValue(ctx, op1);
    sp[-1] = val;
  } else {
    if (LEPUS_IsString(op1)) {
    to_number:
      op1 = JS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
      if (LEPUS_IsException(op1)) goto exception;
    }
    is_legacy = is_bignum_mode(ctx) ^ 1;
    if (!is_legacy || LEPUS_VALUE_GET_TAG(op1) == LEPUS_TAG_BIG_INT) {
      a = JS_ToBigIntFree(ctx, &a_s, op1);
      bf_init(ctx->bf_ctx, r);
      ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
      bf_neg(r);
      JS_FreeBigInt(ctx, a, &a_s);
      if (unlikely(ret)) {
        bf_delete(r);
        throw_bf_exception(ctx, ret);
        goto exception;
      }
      sp[-1] = JS_NewBigInt2(ctx, r, is_legacy);
    } else {
      int32_t v1;
      if (unlikely(JS_ToInt32Free(ctx, &v1, op1))) goto exception;
      sp[-1] = LEPUS_NewInt32(ctx, ~v1);
    }
  }
  return 0;
exception:
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int js_binary_arith_slow(LEPUSContext *ctx,
                                                      LEPUSValue *sp,
                                                      OPCodeEnum op) {
  LEPUSValue op1, op2, res;
  BOOL is_float, is_legacy;
  uint32_t tag1, tag2;
  int ret, rnd_mode;
  double d1, d2;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* fast path for float operations */
  if (tag1 == LEPUS_TAG_FLOAT64 && tag2 == LEPUS_TAG_FLOAT64) {
    d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    goto handle_float64;
  }

  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
    if (ret != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (ret < 0) {
        goto exception;
      } else {
        sp[-2] = res;
        return 0;
      }
    }
  }

  op1 = JS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy && (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
      tag1 != tag2) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
    goto exception;
  }

  if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
    int32_t v1, v2;
    int64_t v;
    v1 = LEPUS_VALUE_GET_INT(op1);
    v2 = LEPUS_VALUE_GET_INT(op2);
    switch (op) {
      case OP_sub:
        v = (int64_t)v1 - (int64_t)v2;
        break;
      case OP_mul:
        v = (int64_t)v1 * (int64_t)v2;
        if (is_legacy && v == 0 && (v1 | v2) < 0) {
          sp[-2] = __JS_NewFloat64(ctx, -0.0);
          return 0;
        }
        break;
      case OP_math_div:
        goto op_fallback2;
      case OP_div:
        sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);
        return 0;
      case OP_math_mod:
        if (unlikely(v2 == 0)) {
          throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
          goto exception;
        }
        v = (int64_t)v1 % (int64_t)v2;
        if (v < 0) {
          if (v2 < 0)
            v -= v2;
          else
            v += v2;
        }
        break;
      case OP_mod:
        if (is_legacy && (v1 < 0 || v2 <= 0)) {
          sp[-2] = LEPUS_NewFloat64(ctx, fmod(v1, v2));
          return 0;
        } else {
          if (unlikely(v2 == 0)) {
            throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
            goto exception;
          }
          v = (int64_t)v1 % (int64_t)v2;
        }
        break;
      case OP_pow:
      case OP_math_pow:
        if (is_legacy) {
          sp[-2] = LEPUS_NewFloat64(ctx, js_pow(v1, v2));
          return 0;
        } else {
          goto handle_bigint;
        }
        break;
      default:
        abort();
    }
    sp[-2] = LEPUS_NewInt64(ctx, v);
  } else if ((tag1 == LEPUS_TAG_BIG_INT &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_INT)) {
    /* big int result */
    bf_t a_s, b_s, r_s, *r, *a, *b;
  handle_bigint:
    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = 0;
    switch (op) {
      case OP_sub:
        ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
        break;
      case OP_mul:
        ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
        break;
      case OP_math_div:
        goto op_fallback;
      case OP_div:
        if (is_legacy) {
          bf_t rem_s, *rem = &rem_s;
          bf_init(ctx->bf_ctx, rem);
          ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ, BF_RNDZ) &
                BF_ST_INVALID_OP;
          bf_delete(rem);
        } else {
          bf_div(r, a, b, 53,
                 bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
          goto float64_result;
        }
        break;
      case OP_math_mod:
        /* Euclidian remainder */
        rnd_mode = BF_DIVREM_EUCLIDIAN;
        goto do_int_mod;
      case OP_mod:
        rnd_mode = BF_RNDZ;
      do_int_mod: {
        bf_t q_s, *q = &q_s;
        bf_init(ctx->bf_ctx, q);
        ret = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, rnd_mode) &
              BF_ST_INVALID_OP;
        bf_delete(q);
      } break;
      case OP_pow:
      case OP_math_pow:
        if (b->sign) {
          if (is_legacy) {
            ret = BF_ST_INVALID_OP;
          } else if (op == OP_math_pow) {
          op_fallback:
            bf_delete(r);
            if (a == &a_s) bf_delete(a);
            if (b == &b_s) bf_delete(b);
          op_fallback2:
            ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
            LEPUS_FreeValue(ctx, op1);
            LEPUS_FreeValue(ctx, op2);
            if (ret < 0) {
              goto exception;
            } else if (ret == 0) {
              LEPUS_ThrowTypeError(
                  ctx, "operator must be defined for exact division or power");
              goto exception;
            }
            sp[-2] = res;
            return 0;
          } else {
            double dr;
            bf_pow(r, a, b, 53,
                   bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
          float64_result:
            bf_get_float64(r, &dr, BF_RNDN);
            bf_delete(r);
            if (a == &a_s) bf_delete(a);
            if (b == &b_s) bf_delete(b);
            LEPUS_FreeValue(ctx, op1);
            LEPUS_FreeValue(ctx, op2);
            sp[-2] = __JS_NewFloat64(ctx, dr);
            return 0;
          }
        } else {
          ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUICKS) &
                BF_ST_OVERFLOW;
        }
        break;
      default:
        abort();
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
  } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
              (tag2 == LEPUS_TAG_FLOAT64 || tag2 == LEPUS_TAG_INT ||
               tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_FLOAT64 &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_BIG_INT))) {
    double dr;
    /* float64 result */
    JS_ToFloat64Free(ctx, &d1, op1);
    JS_ToFloat64Free(ctx, &d2, op2);
  handle_float64:
    switch (op) {
      case OP_sub:
        dr = d1 - d2;
        break;
      case OP_mul:
        dr = d1 * d2;
        break;
      case OP_div:
      case OP_math_div:
        dr = d1 / d2;
        break;
      case OP_mod:
        dr = fmod(d1, d2);
        break;
      case OP_math_mod:
        if (d1 >= 0 && d2 >= 0) {
          dr = fmod(d1, d2);
        } else {
          /* XXX: slow */
          bf_t a, b, r, q;
          bf_init(ctx->bf_ctx, &a);
          bf_init(ctx->bf_ctx, &b);
          bf_init(ctx->bf_ctx, &r);
          bf_set_float64(&a, d1);
          bf_set_float64(&b, d2);
          bf_divrem(&q, &r, &a, &b, 53,
                    bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL,
                    BF_DIVREM_EUCLIDIAN);
          bf_get_float64(&q, &dr, BF_RNDN);
          bf_delete(&a);
          bf_delete(&b);
          bf_delete(&q);
          bf_delete(&r);
        }
        break;
      case OP_pow:
      case OP_math_pow:
        dr = js_pow(d1, d2);
        break;
      default:
        abort();
    }
    sp[-2] = __JS_NewFloat64(ctx, dr);
  } else {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big float result */
    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = 0;
    switch (op) {
      case OP_sub:
        bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_mul:
        bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_math_div:
      case OP_div:
        bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_math_mod:
        /* Euclidian remainder */
        rnd_mode = BF_DIVREM_EUCLIDIAN;
        goto do_mod;
      case OP_mod:
        rnd_mode = BF_RNDZ;
      do_mod: {
        bf_t q_s, *q = &q_s;
        bf_init(ctx->bf_ctx, q);
        bf_divrem(q, r, a, b, ctx->fp_env.prec, ctx->fp_env.flags, rnd_mode);
        bf_delete(q);
      } break;
      case OP_pow:
      case OP_math_pow:
        bf_pow(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags | BF_POW_JS_QUICKS);
        break;
      default:
        abort();
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = JS_NewBigFloat(ctx, r);
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int js_add_slow(LEPUSContext *ctx,
                                             LEPUSValue *sp) {
  LEPUSValue op1, op2, res;
  uint32_t tag1, tag2;
  BOOL is_float, is_legacy;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];

  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* fast path for float64 */
  if (tag1 == LEPUS_TAG_FLOAT64 && tag2 == LEPUS_TAG_FLOAT64) {
    double d1, d2;
    d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
    return 0;
  }

  if (tag1 == LEPUS_TAG_OBJECT || tag2 == LEPUS_TAG_OBJECT) {
    /* try to call an overloaded operator */
    if ((tag1 == LEPUS_TAG_OBJECT &&
         (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
        (tag2 == LEPUS_TAG_OBJECT &&
         (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
      ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add);
      if (ret != 0) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        if (ret < 0) {
          goto exception;
        } else {
          sp[-2] = res;
          return 0;
        }
      }
    }

    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }

    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
    tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  }

  if (LEPUS_IsString(op1) || LEPUS_IsString(op2)) {
    sp[-2] = JS_ConcatString(ctx, op1, op2);
    if (LEPUS_IsException(sp[-2])) goto exception;
    return 0;
  }

  op1 = JS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy && (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
      tag1 != tag2) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
    goto exception;
  }

  if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
    int32_t v1, v2;
    int64_t v;
    v1 = LEPUS_VALUE_GET_INT(op1);
    v2 = LEPUS_VALUE_GET_INT(op2);
    v = (int64_t)v1 + (int64_t)v2;
    sp[-2] = LEPUS_NewInt64(ctx, v);
  } else if ((tag1 == LEPUS_TAG_BIG_INT &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_INT)) {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big int result */
    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
  } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
              (tag2 == LEPUS_TAG_FLOAT64 || tag2 == LEPUS_TAG_INT ||
               tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_FLOAT64 &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_BIG_INT))) {
    double d1, d2;
    /* float64 result */
    JS_ToFloat64Free(ctx, &d1, op1);
    JS_ToFloat64Free(ctx, &d2, op2);
    sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
  } else {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big float result */
    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);

    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = JS_NewBigFloat(ctx, r);
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int js_binary_logic_slow(LEPUSContext *ctx,
                                                      LEPUSValue *sp,
                                                      OPCodeEnum op) {
  LEPUSValue op1, op2, res;
  bf_t a_s, b_s, r_s, *r, *a, *b;
  int ret;
  uint32_t tag1, tag2;
  BOOL is_legacy;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
    if (ret != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (ret < 0) {
        goto exception;
      } else {
        sp[-2] = res;
        return 0;
      }
    }
  }

  op1 = JS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToNumberHintFree(ctx, op2, TON_FLAG_INTEGER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy) {
    uint32_t v1, v2, r;

    tag1 = LEPUS_VALUE_GET_TAG(op1);
    tag2 = LEPUS_VALUE_GET_TAG(op2);
    if (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) {
      if (tag1 != tag2) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
        goto exception;
      }
    } else {
      if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
      switch (op) {
        case OP_shl:
          r = v1 << (v2 & 0x1f);
          break;
        case OP_sar:
          r = (int)v1 >> (v2 & 0x1f);
          break;
        case OP_and:
          r = v1 & v2;
          break;
        case OP_or:
          r = v1 | v2;
          break;
        case OP_xor:
          r = v1 ^ v2;
          break;
        default:
          abort();
      }
      sp[-2] = LEPUS_NewInt32(ctx, r);
      return 0;
    }
  }

  a = JS_ToBigIntFree(ctx, &a_s, op1);
  b = JS_ToBigIntFree(ctx, &b_s, op2);

  r = &r_s;
  bf_init(ctx->bf_ctx, r);
  ret = 0;
  switch (op) {
    case OP_shl:
    case OP_sar: {
      slimb_t v2;
#if LIMB_BITS == 32
      bf_get_int32(&v2, b, 0);
      if (v2 == INT32_MIN) v2 = INT32_MIN + 1;
#else
      bf_get_int64(&v2, b, 0);
      if (v2 == INT64_MIN) v2 = INT64_MIN + 1;
#endif
      if (op == OP_sar) v2 = -v2;
      bf_set(r, a);
      ret = bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);
      if (v2 < 0) {
        ret |= bf_rint(r, BF_PREC_INF, BF_RNDD);
      }
      ret &= BF_ST_OVERFLOW;
    } break;
    case OP_and:
      bf_logic_and(r, a, b);
      break;
    case OP_or:
      bf_logic_or(r, a, b);
      break;
    case OP_xor:
      bf_logic_xor(r, a, b);
      break;
    default:
      abort();
  }
  JS_FreeBigInt(ctx, a, &a_s);
  JS_FreeBigInt(ctx, b, &b_s);
  if (unlikely(ret)) {
    bf_delete(r);
    throw_bf_exception(ctx, ret);
    goto exception;
  }
  sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline int js_relational_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                        OPCodeEnum op) {
  LEPUSValue op1, op2, ret;
  int res;
  uint32_t tag1, tag2;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op);
    if (res != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (res < 0) {
        goto exception;
      } else {
        sp[-2] = ret;
        return 0;
      }
    }
  }
  op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }

  if (JS_IsSeparableString(op1)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op1);
    LEPUS_FreeValue(ctx, op1);
    op1 = tmp;
  }

  if (JS_IsSeparableString(op2)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op2);
    LEPUS_FreeValue(ctx, op2);
    op2 = tmp;
  }

  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  if (tag1 == LEPUS_TAG_STRING && tag2 == LEPUS_TAG_STRING) {
    JSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = js_string_compare(ctx, p1, p2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  } else if ((tag1 <= LEPUS_TAG_NULL || tag1 == LEPUS_TAG_FLOAT64) &&
             (tag2 <= LEPUS_TAG_NULL || tag2 == LEPUS_TAG_FLOAT64)) {
    /* can use floating point comparison */
    double d1, d2;
    if (tag1 == LEPUS_TAG_FLOAT64) {
      d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    } else {
      d1 = LEPUS_VALUE_GET_INT(op1);
    }
    if (tag2 == LEPUS_TAG_FLOAT64) {
      d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    } else {
      d2 = LEPUS_VALUE_GET_INT(op2);
    }
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  } else {
    bf_t a_s, b_s, *a, *b;
    BOOL is_float;

    if (((tag1 == LEPUS_TAG_BIG_INT && tag2 == LEPUS_TAG_STRING) ||
         (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_STRING)) &&
        !is_bignum_mode(ctx)) {
      if (tag1 == LEPUS_TAG_STRING) {
        op1 = JS_StringToBigInt(ctx, op1);
        if (LEPUS_VALUE_GET_TAG(op1) != LEPUS_TAG_BIG_INT)
          goto invalid_bigint_string;
      }
      if (tag2 == LEPUS_TAG_STRING) {
        op2 = JS_StringToBigInt(ctx, op2);
        if (LEPUS_VALUE_GET_TAG(op2) != LEPUS_TAG_BIG_INT) {
        invalid_bigint_string:
          LEPUS_FreeValue(ctx, op1);
          LEPUS_FreeValue(ctx, op2);
          res = FALSE;
          goto done;
        }
      }
    } else {
      op1 = JS_ToNumericFree(ctx, op1);
      if (LEPUS_IsException(op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      op2 = JS_ToNumericFree(ctx, op2);
      if (LEPUS_IsException(op2)) {
        LEPUS_FreeValue(ctx, op1);
        goto exception;
      }
    }

    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);

    switch (op) {
      case OP_lt:
        res = bf_cmp_lt(a, b); /* if NaN return false */
        break;
      case OP_lte:
        res = bf_cmp_le(a, b); /* if NaN return false */
        break;
      case OP_gt:
        res = bf_cmp_lt(b, a); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = bf_cmp_le(b, a); /* if NaN return false */
        break;
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  }
done:
  sp[-2] = LEPUS_NewBool(ctx, res);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static BOOL tag_is_number(uint32_t tag) {
  return (tag == LEPUS_TAG_INT || tag == LEPUS_TAG_BIG_INT ||
          tag == LEPUS_TAG_FLOAT64 || tag == LEPUS_TAG_BIG_FLOAT);
}

static no_inline __exception int js_eq_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                            BOOL is_neq) {
  LEPUSValue op1, op2, ret;
  int res;
  uint32_t tag1, tag2;

  op1 = sp[-2];
  op2 = sp[-1];
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag_is_number(tag1) && tag_is_number(tag2)) {
    if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
      res = LEPUS_VALUE_GET_INT(op1) == LEPUS_VALUE_GET_INT(op2);
    } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
                (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
               (tag2 == LEPUS_TAG_FLOAT64 &&
                (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
      double d1, d2;
      if (tag1 == LEPUS_TAG_FLOAT64) {
        d1 = LEPUS_VALUE_GET_FLOAT64(op1);
      } else {
        d1 = LEPUS_VALUE_GET_INT(op1);
      }
      if (tag2 == LEPUS_TAG_FLOAT64) {
        d2 = LEPUS_VALUE_GET_FLOAT64(op2);
      } else {
        d2 = LEPUS_VALUE_GET_INT(op2);
      }
      res = (d1 == d2);
    } else {
      bf_t a_s, b_s, *a, *b;
      BOOL is_float;
      a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
      b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
      res = bf_cmp_eq(a, b);
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(b);
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
    }
  } else if (tag1 == tag2 || (LEPUS_IsString(op1) && LEPUS_IsString(op2))) {
    if (tag1 == LEPUS_TAG_OBJECT) {
      /* try the fallback operator */
      res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
                                       is_neq ? OP_neq : OP_eq);
      if (res != 0) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        if (res < 0) {
          goto exception;
        } else {
          sp[-2] = ret;
          return 0;
        }
      }
    }
    res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((LEPUS_IsString(op1) && tag_is_number(tag2)) ||
             (LEPUS_IsString(op2) && tag_is_number(tag1))) {
    if ((tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
        !is_bignum_mode(ctx)) {
      if (LEPUS_IsString(op1)) {
        op1 = JS_StringToBigInt(ctx, op1);
        if (LEPUS_VALUE_GET_TAG(op1) != LEPUS_TAG_BIG_INT)
          goto invalid_bigint_string;
      }
      if (LEPUS_IsString(op2)) {
        op2 = JS_StringToBigInt(ctx, op2);
        if (LEPUS_VALUE_GET_TAG(op2) != LEPUS_TAG_BIG_INT) {
        invalid_bigint_string:
          LEPUS_FreeValue(ctx, op1);
          LEPUS_FreeValue(ctx, op2);
          res = FALSE;
          goto done;
        }
      }
    } else {
      op1 = JS_ToNumericFree(ctx, op1);
      if (LEPUS_IsException(op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      op2 = JS_ToNumericFree(ctx, op2);
      if (LEPUS_IsException(op2)) {
        LEPUS_FreeValue(ctx, op1);
        goto exception;
      }
    }
    res = js_strict_eq(ctx, op1, op2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(op2));
    goto redo;
  } else if ((tag1 == LEPUS_TAG_OBJECT &&
              (tag_is_number(tag2) || tag2 == LEPUS_TAG_STRING ||
               tag2 == LEPUS_TAG_SYMBOL ||
               tag2 == LEPUS_TAG_SEPARABLE_STRING)) ||
             (tag2 == LEPUS_TAG_OBJECT &&
              (tag_is_number(tag1) || tag1 == LEPUS_TAG_STRING ||
               tag1 == LEPUS_TAG_SYMBOL ||
               tag1 == LEPUS_TAG_SEPARABLE_STRING))) {
    /* try the fallback operator */
    res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
                                     is_neq ? OP_neq : OP_eq);
    if (res != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (res < 0) {
        goto exception;
      } else {
        sp[-2] = ret;
        return 0;
      }
    }

    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    res = FALSE;
  }
done:
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline int js_shr_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  op1 = JS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  /* XXX: could forbid >>> in bignum mode */
  if (!is_bignum_mode(ctx) && (LEPUS_VALUE_GET_TAG(op1) == LEPUS_TAG_BIG_INT ||
                               LEPUS_VALUE_GET_TAG(op2) == LEPUS_TAG_BIG_INT)) {
    LEPUS_ThrowTypeError(ctx, "bigint operands are forbidden for >>>");
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  /* cannot give an exception */
  JS_ToUint32Free(ctx, &v1, op1);
  JS_ToUint32Free(ctx, &v2, op2);
  r = v1 >> (v2 & 0x1f);
  sp[-2] = JS_NewUint32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static double bf_mul_pow10_to_float64(LEPUSContext *ctx, const bf_t *a,
                                      int64_t exponent) {
  bf_t r_s, *r = &r_s;
  double d;
  /* always convert to Float64 */
  bf_init(ctx->bf_ctx, r);
  bf_mul_pow_radix(r, a, 10, exponent, 53,
                   bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
  bf_get_float64(r, &d, BF_RNDN);
  bf_delete(r);
  return d;
}

static no_inline int js_mul_pow10(LEPUSContext *ctx, LEPUSValue *sp) {
  bf_t a_s, *a, r_s, *r = &r_s;
  BOOL is_float;
  LEPUSValue op1, op2;
  slimb_t e;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];
  a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
  if (!a) return -1;
#if LIMB_BITS == 32
  ret = LEPUS_ToInt32(ctx, &e, op2);
#else
  ret = LEPUS_ToInt64(ctx, &e, op2);
#endif
  if (ret) {
    if (a == &a_s) bf_delete(a);
    return -1;
  }

  bf_init(ctx->bf_ctx, r);
  bf_mul_pow_radix(r, a, 10, e, ctx->fp_env.prec, ctx->fp_env.flags);
  if (a == &a_s) bf_delete(a);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = JS_NewBigFloat(ctx, r);
  return 0;
}

#else /* !CONFIG_BIGNUM */

QJS_STATIC no_inline __exception int js_unary_arith_slow(LEPUSContext *ctx,
                                                         LEPUSValue *sp,
                                                         OPCodeEnum op) {
  LEPUSValue op1;
  double d;

  op1 = sp[-1];
  if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  switch (op) {
    case OP_inc:
      d++;
      break;
    case OP_dec:
      d--;
      break;
    case OP_plus:
      break;
    case OP_neg:
      d = -d;
      break;
    default:
      abort();
  }
  sp[-1] = LEPUS_NewFloat64(ctx, d);
  return 0;
}

/* specific case necessary for correct return value semantics */
__exception int js_post_inc_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                 OPCodeEnum op) {
  LEPUSValue op1;
  double d, r;

  op1 = sp[-1];
  if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  r = d + 2 * (op - OP_post_dec) - 1;
  sp[0] = LEPUS_NewFloat64(ctx, r);
  sp[-1] = LEPUS_NewFloat64(ctx, d);
  return 0;
}

QJS_STATIC no_inline __exception int js_binary_arith_slow(LEPUSContext *ctx,
                                                          LEPUSValue *sp,
                                                          OPCodeEnum op) {
  LEPUSValue op1, op2;
  double d1, d2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(JS_ToFloat64Free(ctx, &d1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(JS_ToFloat64Free(ctx, &d2, op2))) {
    goto exception;
  }
  switch (op) {
    case OP_sub:
      r = d1 - d2;
      break;
    case OP_mul:
      r = d1 * d2;
      break;
    case OP_div:
      r = d1 / d2;
      break;
    case OP_mod:
      r = fmod(d1, d2);
      break;
    case OP_pow:
      r = js_pow(d1, d2);
      break;
    default:
      abort();
  }
  sp[-2] = LEPUS_NewFloat64(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int js_add_slow(LEPUSContext *ctx,
                                                 LEPUSValue *sp) {
  LEPUSValue op1, op2;

  op1 = sp[-2];
  op2 = sp[-1];
  if ((LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) &&
      (LEPUS_VALUE_IS_INT(op2) || LEPUS_VALUE_IS_FLOAT64(op2))) {
    goto add_numbers;
  } else {
    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    if (LEPUS_IsString(op1) || LEPUS_IsString(op2)) {
      sp[-2] = JS_ConcatString(ctx, op1, op2);
      if (LEPUS_IsException(sp[-2])) goto exception;
    } else {
      double d1, d2;
    add_numbers:
      if (JS_ToFloat64Free(ctx, &d1, op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
      sp[-2] = LEPUS_NewFloat64(ctx, d1 + d2);
    }
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int js_binary_logic_slow(LEPUSContext *ctx,
                                                          LEPUSValue *sp,
                                                          OPCodeEnum op) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
  switch (op) {
    case OP_shl:
      r = v1 << (v2 & 0x1f);
      break;
    case OP_sar:
      r = (int)v1 >> (v2 & 0x1f);
      break;
    case OP_and:
      r = v1 & v2;
      break;
    case OP_or:
      r = v1 | v2;
      break;
    case OP_xor:
      r = v1 ^ v2;
      break;
    default:
      abort();
  }
  sp[-2] = LEPUS_NewInt32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline int js_not_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  int32_t v1;

  if (unlikely(JS_ToInt32Free(ctx, &v1, sp[-1]))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  sp[-1] = LEPUS_NewInt32(ctx, ~v1);
  return 0;
}

QJS_STATIC no_inline int js_relational_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                            OPCodeEnum op) {
  LEPUSValue op1, op2;
  int res;

  op1 = sp[-2];
  op2 = sp[-1];
  op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }

  if (JS_IsSeparableString(op1)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op1);
    LEPUS_FreeValue(ctx, op1);
    op1 = tmp;
  }

  if (JS_IsSeparableString(op2)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op2);
    LEPUS_FreeValue(ctx, op2);
    op2 = tmp;
  }

  if (LEPUS_VALUE_IS_STRING(op1) && LEPUS_VALUE_IS_STRING(op2)) {
    JSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = js_string_compare(ctx, p1, p2);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
  } else {
    double d1, d2;
    if (JS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  }
  sp[-2] = LEPUS_NewBool(ctx, res);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int js_eq_slow(LEPUSContext *ctx,
                                                LEPUSValue *sp, BOOL is_neq) {
  LEPUSValue op1, op2;
  int64_t tag1, tag2;
  BOOL res;

  op1 = sp[-2];
  op2 = sp[-1];
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag1 == tag2 || (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_FLOAT64) ||
      (tag2 == LEPUS_TAG_INT && tag1 == LEPUS_TAG_FLOAT64) ||
      (LEPUS_IsString(op1) && LEPUS_IsString(op2))) {
    res = js_strict_eq(ctx, op1, op2);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((LEPUS_IsString(op1) &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
             (LEPUS_IsString(op2) &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
    double d1;
    double d2;
    if (JS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    res = (d1 == d2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op2));
    goto redo;
  } else if (tag1 == LEPUS_TAG_OBJECT &&
             (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64 ||
              tag2 == LEPUS_TAG_STRING || tag2 == LEPUS_TAG_SYMBOL ||
              tag2 == LEPUS_TAG_SEPARABLE_STRING)) {
    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    goto redo;
  } else if (tag2 == LEPUS_TAG_OBJECT &&
             (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64 ||
              tag1 == LEPUS_TAG_STRING || tag1 == LEPUS_TAG_SEPARABLE_STRING ||
              tag1 == LEPUS_TAG_SYMBOL)) {
    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    res = FALSE;
  }
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline int js_shr_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(JS_ToUint32Free(ctx, &v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(JS_ToUint32Free(ctx, &v2, op2))) goto exception;
  r = v1 >> (v2 & 0x1f);
  sp[-2] = JS_NewUint32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

// <Primjs begin>
#ifdef ENABLE_LEPUSNG
QJS_STATIC JSBigFloat *js_new_bf(LEPUSContext *ctx) {
  JSBigFloat *p;
  p = static_cast<JSBigFloat *>(lepus_mallocz(ctx, sizeof(*p)));
  if (!p) return NULL;
  p->header.ref_count = 1;
  return p;
}

LEPUSValue LEPUS_NewBigUint64(LEPUSContext *ctx, uint64_t v) {
  CallGCFunc(JS_NewBigUint64_GC, ctx, v);
  JSBigFloat *p = js_new_bf(ctx);
  p->num = v;
  return LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
}

LEPUSValue LEPUS_NewLepusWrap(LEPUSContext *ctx, void *p, int tag) {
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable) AddLepusRefCount(ctx);
#endif
  LEPUSLepusRef *pref;
  pref = static_cast<LEPUSLepusRef *>(
      lepus_mallocz(ctx, sizeof(*pref), ALLOC_TAG_LEPUSLepusRef));
  if (!pref) return LEPUS_UNDEFINED;
  pref->header.ref_count = 1;

  pref->tag = tag;
  pref->p = p;
  pref->lepus_val = LEPUS_UNDEFINED;

  return LEPUS_MKPTR(LEPUS_TAG_LEPUS_REF, pref);
}

void RegisterGCInfoCallback(LEPUSRuntime *rt, void (*func)(const char *, int)) {
  if (!rt) return;
  rt->update_gc_info = func;
}

void RegisterLepusRefCallbacks(LEPUSRuntime *rt,
                               LEPUSLepusRefCallbacks *funcs) {
  if (!rt) return;
  rt->js_callbacks_.free_value = funcs->free_value;
  rt->js_callbacks_.get_property = funcs->get_property;
  rt->js_callbacks_.get_length = funcs->get_length;
  rt->js_callbacks_.convert_to_object = funcs->convert_to_object;
  rt->js_callbacks_.set_property = funcs->set_property;
  rt->js_callbacks_.free_str_cache = funcs->free_str_cache;
  rt->js_callbacks_.lepus_ref_equal = funcs->lepus_ref_equal;
  rt->js_callbacks_.lepus_ref_tostring = funcs->lepus_ref_tostring;
  return;
}

void RegisterPrimJSCallbacks(LEPUSRuntime *rt, void **funcs,
                             int32_t callback_size) {
  if (!rt || !funcs) return;
  int32_t num = 0;
#define Name(name)                                                            \
  if (num < callback_size) {                                                  \
    rt->primjs_callbacks_.name =                                              \
        reinterpret_cast<decltype(rt->primjs_callbacks_.name)>(funcs[num++]); \
  } else {                                                                    \
    rt->primjs_callbacks_.name = NULL;                                        \
  }
  PRIMJSCallBackName(Name)
#undef Name
}

void LEPUS_SetStringCache(LEPUSContext *ctx, LEPUSValue val, void *p) {
  CallGCFunc(JS_SetStringCache_GC, ctx, val, p);
  if (JS_IsSeparableString(val)) {
    auto content = JS_GetSeparableString(val)->flat_content;
    if (LEPUS_IsUndefined(content)) {
      return;
    }
    val = content;
  } else if (!LEPUS_VALUE_IS_STRING(val)) {
    return;
  }
  JSString *str = LEPUS_VALUE_GET_STRING(val);
  void *old_ptr = str->cache_;
  str->cache_ = p;
  ctx->rt->js_callbacks_.free_str_cache(old_ptr, p);
  return;
}

void JS_FreeStringCache(LEPUSRuntime *rt, JSString *p) {
  if (p->cache_ && (rt->js_callbacks_.free_str_cache)) {
    rt->js_callbacks_.free_str_cache(p->cache_, NULL);
    p->cache_ = NULL;
  }
}

void *LEPUS_GetStringCache(LEPUSValue val) {
  if (JS_IsSeparableString(val)) {
    auto content = JS_GetSeparableString(val)->flat_content;
    if (LEPUS_IsUndefined(content)) {
      return nullptr;
    }
    val = content;
  } else if (!LEPUS_VALUE_IS_STRING(val)) {
    return nullptr;
  }
  JSString *str = LEPUS_VALUE_GET_STRING(val);
  return str->cache_;
}

#ifndef ENABLE_COMPATIBLE_MM
void *LEPUS_GetStringCache_GC(LEPUSValue val) { return nullptr; }
#endif

#endif
// <Primjs end>

#endif /* !CONFIG_BIGNUM */

/* XXX: Should take LEPUSValueConst arguments */
QJS_STATIC BOOL js_strict_eq2(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2,
                              JSStrictEqModeEnum eq_mode) {
  BOOL res;
  int64_t tag1, tag2;
  double d1, d2;

  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  switch (tag1) {
    case LEPUS_TAG_BOOL:
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        res = LEPUS_VALUE_GET_BOOL(op1) == LEPUS_VALUE_GET_BOOL(op2);
        goto done_no_free;
      }
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      res = (tag1 == tag2);
      break;
    case LEPUS_TAG_STRING: {
      JSString *p1, *p2;
      if (tag2 == LEPUS_TAG_SEPARABLE_STRING) {
        p1 = LEPUS_VALUE_GET_STRING(op1);
        auto *separable_string = JS_GetSeparableString(op2);
        if (p1->len != separable_string->len) {
          res = FALSE;
        } else {
          auto content = JS_GetSeparableStringContent(ctx, op2);
          res = js_strict_eq2(ctx, LEPUS_DupValue(ctx, op1), content, eq_mode);
        }
      } else if (tag1 != tag2) {
        res = FALSE;
      } else {
        p1 = LEPUS_VALUE_GET_STRING(op1);
        p2 = LEPUS_VALUE_GET_STRING(op2);
        // <Primjs change>
        if (p1 == p2) {
          res = TRUE;
        } else if (p1->atom_type == JS_ATOM_TYPE_STRING &&
                   p2->atom_type == JS_ATOM_TYPE_STRING) {
          res = FALSE;
        } else {
          res = (js_string_compare(ctx, p1, p2) == 0);
        }
      }
    } break;
    case LEPUS_TAG_SEPARABLE_STRING: {
      if (tag2 == LEPUS_TAG_SEPARABLE_STRING) {
        auto *separable_string_1 = JS_GetSeparableString(op1);
        auto *separable_string_2 = JS_GetSeparableString(op2);
        if (separable_string_1->len != separable_string_2->len) {
          res = FALSE;
        } else {
          auto content_1 = JS_GetSeparableStringContent(ctx, op1);
          auto content_2 = JS_GetSeparableStringContent(ctx, op2);
          res = js_strict_eq2(ctx, content_1, content_2, eq_mode);
        }
      } else if (tag2 == LEPUS_TAG_STRING) {
        res = js_strict_eq2(ctx, LEPUS_DupValue(ctx, op2),
                            LEPUS_DupValue(ctx, op1), eq_mode);
      } else {
        res = FALSE;
      }
    } break;
    case LEPUS_TAG_SYMBOL: {
      JSAtomStruct *p1, *p2;
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        p1 = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(op1));
        p2 = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(op2));
        res = (p1 == p2);
      }
    } break;
    case LEPUS_TAG_OBJECT:
      if (tag1 != tag2)
        res = FALSE;
      else
        res = LEPUS_VALUE_GET_OBJ(op1) == LEPUS_VALUE_GET_OBJ(op2);
      break;
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      if (tag1 != tag2)
        res = FALSE;
      else
        res = (LEPUS_GetLepusRefPoint(op1) == LEPUS_GetLepusRefPoint(op2));
    } break;
    case LEPUS_TAG_LEPUS_CPOINTER: {
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        res = (LEPUS_VALUE_GET_PTR(op1) == LEPUS_VALUE_GET_PTR(op2));
      }
    } break;
#endif
    case LEPUS_TAG_INT:
      d1 = LEPUS_VALUE_GET_INT(op1);
      if (tag2 == LEPUS_TAG_INT) {
        d2 = LEPUS_VALUE_GET_INT(op2);
        goto number_test;
      } else if (tag2 == LEPUS_TAG_FLOAT64) {
#ifdef CONFIG_BIGNUM
        if (is_bignum_mode(ctx)) {
          res = FALSE;
        } else
#endif
        {
          d2 = LEPUS_VALUE_GET_FLOAT64(op2);
          goto number_test;
        }
      } else
#ifdef CONFIG_BIGNUM
          if (tag2 == LEPUS_TAG_BIG_INT && is_bignum_mode(ctx)) {
        goto bigint_test;
      } else
#endif
      {
        res = FALSE;
      }
      break;
    case LEPUS_TAG_FLOAT64:
      d1 = LEPUS_VALUE_GET_FLOAT64(op1);
      if (tag2 == LEPUS_TAG_FLOAT64) {
        d2 = LEPUS_VALUE_GET_FLOAT64(op2);
      } else if (tag2 == LEPUS_TAG_INT
#ifdef CONFIG_BIGNUM
                 && !is_bignum_mode(ctx)
#endif
      ) {
        d2 = LEPUS_VALUE_GET_INT(op2);
      } else {
        res = FALSE;
        break;
      }
    number_test:
      if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {
        JSFloat64Union u1, u2;
        /* NaN is not always normalized, so this test is necessary */
        if (isnan(d1) || isnan(d2)) {
          res = isnan(d1) == isnan(d2);
        } else if (eq_mode == JS_EQ_SAME_VALUE_ZERO) {
          res = (d1 == d2); /* +0 == -0 */
        } else {
          u1.d = d1;
          u2.d = d2;
          res = (u1.u64 == u2.u64); /* +0 != -0 */
        }
      } else {
        res = (d1 == d2); /* if NaN return false and +0 == -0 */
      }
      goto done_no_free;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      bf_t a_s, *a, b_s, *b;
      BOOL is_float;
      if (tag1 == tag2) {
        /* OK */
      } else if (tag2 == LEPUS_TAG_INT && is_bignum_mode(ctx)) {
        /* OK */
      } else {
        res = FALSE;
        break;
      }
    bigint_test:
      a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
      b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
      res = bf_cmp_eq(a, b);
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(a);
    } break;
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p1, *p2;
      const bf_t *a, *b;
      if (tag1 != tag2) {
        res = FALSE;
        break;
      }
      p1 = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(op1));
      p2 = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(op2));
      a = &p1->num;
      b = &p2->num;
      if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {
        if (eq_mode == JS_EQ_SAME_VALUE_ZERO && a->expn == BF_EXP_ZERO &&
            b->expn == BF_EXP_ZERO) {
          res = TRUE;
        } else {
          res = (bf_cmp_full(a, b) == 0);
        }
      } else {
        res = bf_cmp_eq(a, b);
      }
    } break;
#endif
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p1 = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(op1));
      if (tag2 == LEPUS_TAG_BIG_INT) {
        JSBigFloat *p2 = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(op2));
        if (p2->num == p1->num) {
          res = TRUE;
        } else {
          res = FALSE;
        }
      } else {
        res = FALSE;
      }
    } break;
#endif
      // <Primjs end>
    default:
      res = FALSE;
      break;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
done_no_free:
  return res;
}

QJS_STATIC BOOL js_strict_eq(LEPUSContext *ctx, LEPUSValue op1,
                             LEPUSValue op2) {
  return js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
}

QJS_STATIC BOOL js_same_value(LEPUSContext *ctx, LEPUSValueConst op1,
                              LEPUSValueConst op2) {
  return js_strict_eq2(ctx, LEPUS_DupValue(ctx, op1), LEPUS_DupValue(ctx, op2),
                       JS_EQ_SAME_VALUE);
}

QJS_STATIC BOOL js_same_value_zero(LEPUSContext *ctx, LEPUSValueConst op1,
                                   LEPUSValueConst op2) {
  return js_strict_eq2(ctx, LEPUS_DupValue(ctx, op1), LEPUS_DupValue(ctx, op2),
                       JS_EQ_SAME_VALUE_ZERO);
}

QJS_STATIC no_inline int js_strict_eq_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                           BOOL is_neq) {
  BOOL res;
  res = js_strict_eq(ctx, sp[-2], sp[-1]);
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
}

QJS_STATIC __exception int js_operator_in(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, op2;
  JSAtom atom;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];

  if (LEPUS_VALUE_IS_NOT_OBJECT(op2) && !LEPUS_VALUE_IS_LEPUS_REF(op2)) {
    atom = js_value_to_atom(ctx, op1);
    if (unlikely(atom == JS_ATOM_NULL)) {
      LEPUS_ThrowTypeError(ctx, "invalid 'in' operand search for null");
      return -1;
    }
    const char *msg = LEPUS_AtomToCString(ctx, atom);
    char buffer[200];
    if (msg) {
      snprintf(buffer, 199, "invalid 'in' operand search for '%s'", msg);
      LEPUS_FreeCString(ctx, msg);
    } else {
      snprintf(buffer, 199, "invalid 'in' operand search for null");
    }
    LEPUS_ThrowTypeError(ctx, "%s", buffer);
    LEPUS_FreeAtom(ctx, atom);
    return -1;
  }

  atom = js_value_to_atom(ctx, op1);
  if (unlikely(atom == JS_ATOM_NULL)) return -1;
  ret = LEPUS_HasProperty(ctx, op2, atom);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) return -1;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

QJS_STATIC __exception int js_has_unscopable(LEPUSContext *ctx,
                                             LEPUSValueConst obj, JSAtom atom) {
  LEPUSValue arr, val;
  int ret;

  arr = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_Symbol_unscopables, obj, 0);
  if (LEPUS_IsException(arr)) return -1;
  ret = 0;
  if (LEPUS_IsObject(arr)) {
    val = JS_GetPropertyInternal_RC(ctx, arr, atom, arr, 0);
    ret = JS_ToBoolFree_RC(ctx, val);
  }
  LEPUS_FreeValue(ctx, arr);
  return ret;
}

QJS_STATIC __exception int js_operator_instanceof(LEPUSContext *ctx,
                                                  LEPUSValue *sp) {
  LEPUSValue op1, op2;
  BOOL ret;

  op1 = sp[-2];
  op2 = sp[-1];
  ret = JS_IsInstanceOf_RC(ctx, op1, op2);
  if (ret < 0) return ret;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

__exception int js_operator_typeof(LEPUSContext *ctx, LEPUSValue op1) {
  JSAtom atom;
  int64_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(op1);
  switch (tag) {
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF:
      if (ctx && (JS_LepusRefIsArray(ctx->rt, op1) ||
                  JS_LepusRefIsTable(ctx->rt, op1))) {
        atom = JS_ATOM_object;
      } else {
        atom = JS_ATOM_unknown;
      }
      break;
#endif
      // <Primjs end>

#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx))
        atom = JS_ATOM_bigint;
      else
        atom = JS_ATOM_number;
      break;
    case LEPUS_TAG_BIG_INT:
      atom = JS_ATOM_bigint;
      break;
    case LEPUS_TAG_FLOAT64:
      atom = JS_ATOM_number;
      break;
    case LEPUS_TAG_BIG_FLOAT:
      atom = JS_ATOM_bigfloat;
      break;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT:
#endif
      // <Primjs end>
      atom = JS_ATOM_number;
      break;
#endif
    case LEPUS_TAG_UNDEFINED:
      atom = JS_ATOM_undefined;
      break;
    case LEPUS_TAG_BOOL:
      atom = JS_ATOM_boolean;
      break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING:
      atom = JS_ATOM_string;
      break;
    case LEPUS_TAG_OBJECT:
      if (LEPUS_IsFunction(ctx, op1))
        atom = JS_ATOM_function;
      else
        goto obj_type;
      break;
    case LEPUS_TAG_NULL:
    obj_type:
      atom = JS_ATOM_object;
      break;
    case LEPUS_TAG_SYMBOL:
      atom = JS_ATOM_symbol;
      break;
    default:
      atom = JS_ATOM_unknown;
      break;
  }
  return atom;
}

QJS_STATIC __exception int js_operator_delete(LEPUSContext *ctx,
                                              LEPUSValue *sp) {
  LEPUSValue op1, op2;
  JSAtom atom;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];
  atom = js_value_to_atom(ctx, op2);
  if (unlikely(atom == JS_ATOM_NULL)) return -1;
  ret = LEPUS_DeleteProperty(ctx, op1, atom, LEPUS_PROP_THROW_STRICT);
  LEPUS_FreeAtom(ctx, atom);
  if (unlikely(ret < 0)) return -1;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

QJS_STATIC LEPUSValue js_throw_type_error(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  return LEPUS_ThrowTypeError(ctx, "invalid property access");
}

/* XXX: not 100% compatible, but mozilla seems to use a similar
   implementation to ensure that caller in non strict mode does not
   throw (ES5 compatibility) */
QJS_STATIC LEPUSValue js_function_proto_caller(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
  if (!b || (b->js_mode & JS_MODE_STRICT) || !b->has_prototype) {
    return js_throw_type_error(ctx, this_val, 0, NULL);
  }
  return LEPUS_UNDEFINED;
}

QJS_HIDE LEPUSValue js_function_proto_fileName(LEPUSContext *ctx,
                                               LEPUSValueConst this_val) {
  LEPUSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
  if (b && b->has_debug) {
    return LEPUS_AtomToString(ctx, b->debug.filename);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_function_proto_lineNumber(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val) {
  LEPUSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);
  if (b && b->has_debug) {
    return LEPUS_NewInt32(ctx, b->debug.line_num);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC int js_arguments_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, JSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags) {
  LEPUSObject *p;
  uint32_t idx;
  p = LEPUS_VALUE_GET_OBJ(this_obj);
  /* convert to normal array when redefining an existing numeric field */
  if (p->fast_array && JS_AtomIsArrayIndex(ctx, &idx, prop) &&
      idx < p->u.array.count) {
    if (convert_fast_array_to_array(ctx, p)) return -1;
  }
  /* run the default define own property */
  return JS_DefineProperty_RC(ctx, this_obj, prop, val, getter, setter,
                              flags | LEPUS_PROP_NO_EXOTIC);
}

LEPUSValue js_build_arguments(LEPUSContext *ctx, int argc,
                              LEPUSValueConst *argv) {
  LEPUSValue val, *tab;
  JSProperty *pr;
  LEPUSObject *p;
  int i;

  val = JS_NewObjectProtoClass_RC(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                  JS_CLASS_ARGUMENTS);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_OBJ(val);

  /* add the length field (cannot fail) */
  pr = add_property(ctx, p, JS_ATOM_length,
                    LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  pr->u.value = LEPUS_NewInt32(ctx, argc);

  /* initialize the fast array part */
  tab = NULL;
  if (argc > 0) {
    tab = static_cast<LEPUSValue *>(lepus_malloc(ctx, sizeof(tab[0]) * argc));
    if (!tab) {
      LEPUS_FreeValue(ctx, val);
      return LEPUS_EXCEPTION;
    }
    for (i = 0; i < argc; i++) {
      tab[i] = LEPUS_DupValue(ctx, argv[i]);
    }
  }
  p->u.array.u.values = tab;
  p->u.array.count = argc;

  JS_DefinePropertyValue_RC(ctx, val, JS_ATOM_Symbol_iterator,
                            LEPUS_DupValue(ctx, ctx->array_proto_values),
                            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  /* add callee property to throw a TypeError in strict mode */
  JS_DefineProperty_RC(ctx, val, JS_ATOM_callee, LEPUS_UNDEFINED,
                       ctx->throw_type_error, ctx->throw_type_error,
                       LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET);
  return val;
}

#define GLOBAL_VAR_OFFSET 0x40000000
#define ARGUMENT_VAR_OFFSET 0x20000000

/* legacy arguments object: add references to the function arguments */
LEPUSValue js_build_mapped_arguments(LEPUSContext *ctx, int argc,
                                     LEPUSValueConst *argv, LEPUSStackFrame *sf,
                                     int arg_count) {
  LEPUSValue val;
  JSProperty *pr;
  LEPUSObject *p;
  int i;

  val = JS_NewObjectProtoClass_RC(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                  JS_CLASS_MAPPED_ARGUMENTS);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_OBJ(val);

  /* add the length field (cannot fail) */
  pr = add_property(ctx, p, JS_ATOM_length,
                    LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  pr->u.value = LEPUS_NewInt32(ctx, argc);

  for (i = 0; i < arg_count; i++) {
    JSVarRef *var_ref;
    var_ref = get_var_ref(ctx, sf, i, TRUE);
    if (!var_ref) goto fail;
    pr = add_property(ctx, p, __JS_AtomFromUInt32(i),
                      LEPUS_PROP_C_W_E | LEPUS_PROP_VARREF);
    if (!pr) {
      free_var_ref(ctx->rt, var_ref);
      goto fail;
    }
    pr->u.var_ref = var_ref;
  }

  /* the arguments not mapped to the arguments of the function can
     be normal properties */
  for (i = arg_count; i < argc; i++) {
    if (JS_DefinePropertyValueUint32_RC(
            ctx, val, i, LEPUS_DupValue(ctx, argv[i]), LEPUS_PROP_C_W_E) < 0)
      goto fail;
  }

  JS_DefinePropertyValue_RC(ctx, val, JS_ATOM_Symbol_iterator,
                            LEPUS_DupValue(ctx, ctx->array_proto_values),
                            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  /* callee returns this function in non strict mode */
  JS_DefinePropertyValue_RC(
      ctx, val, JS_ATOM_callee,
      LEPUS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),
      LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  return val;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

LEPUSValue js_build_rest(LEPUSContext *ctx, int first, int argc,
                         LEPUSValueConst *argv) {
  LEPUSValue val;
  int i, ret;

  val = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(val)) return val;
  for (i = first; i < argc; i++) {
    ret = JS_DefinePropertyValueUint32_RC(
        ctx, val, i - first, LEPUS_DupValue(ctx, argv[i]), LEPUS_PROP_C_W_E);
    if (ret < 0) {
      LEPUS_FreeValue(ctx, val);
      return LEPUS_EXCEPTION;
    }
  }
  return val;
}

QJS_STATIC LEPUSValue build_for_in_iterator(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUSObject *p, *p1;
  LEPUSPropertyEnum *tab_atom;
  int i;
  LEPUSValue enum_obj;
  JSForInIterator *it;
  int64_t tag;
  uint32_t tab_atom_count;

  tag = LEPUS_VALUE_GET_TAG(obj);
  if (tag != LEPUS_TAG_OBJECT && tag != LEPUS_TAG_NULL &&
      tag != LEPUS_TAG_UNDEFINED) {
    obj = JS_ToObjectFree(ctx, obj);
  }

  it = static_cast<JSForInIterator *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  enum_obj =
      JS_NewObjectProtoClass_RC(ctx, LEPUS_NULL, JS_CLASS_FOR_IN_ITERATOR);
  if (LEPUS_IsException(enum_obj)) {
    lepus_free(ctx, it);
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  it->is_array = FALSE;
  it->obj = obj;
  it->idx = 0;
  p = LEPUS_VALUE_GET_OBJ(enum_obj);
  p->u.for_in_iterator = it;

  if (tag == LEPUS_TAG_NULL || tag == LEPUS_TAG_UNDEFINED) return enum_obj;

  p = LEPUS_VALUE_GET_OBJ(obj);

  /* fast path: assume no enumerable properties in the prototype chain */
  p1 = p->shape->proto;
  while (p1 != NULL) {
    if (JS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p1,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_ENUM_ONLY))
      goto fail;
    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
    if (tab_atom_count != 0) {
      goto slow_path;
    }
    p1 = p1->shape->proto;
  }
  if (p->fast_array) {
    JSShape *sh;
    JSShapeProperty *prs;
    /* check that there are no enumerable normal fields */
    sh = p->shape;
    for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
      if (prs->flags & LEPUS_PROP_ENUMERABLE) goto normal_case;
    }
    /* 10.4.5.1 + 10.4.5.10 + 10.4.5.11, if detached, return undefined */
    /* for fast arrays, we only store the number of elements */
    it->is_array = TRUE;
    it->array_length = p->u.array.count;
  } else {
  normal_case:
    if (JS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_ENUM_ONLY))
      goto fail;
    for (i = 0; i < tab_atom_count; i++) {
      JS_SetPropertyInternal_RC(ctx, enum_obj, tab_atom[i].atom, LEPUS_NULL, 0);
    }
    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
  }
  return enum_obj;

slow_path:
  /* non enumerable properties hide the enumerables ones in the
     prototype chain */
  while (p != NULL) {
    if (JS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_SET_ENUM))
      goto fail;
    for (i = 0; i < tab_atom_count; i++) {
      JS_DefinePropertyValue_RC(
          ctx, enum_obj, tab_atom[i].atom, LEPUS_NULL,
          (tab_atom[i].is_enumerable ? LEPUS_PROP_ENUMERABLE : 0));
    }
    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
    p = p->shape->proto;
  }
  return enum_obj;

fail:
  LEPUS_FreeValue(ctx, enum_obj);
  return LEPUS_EXCEPTION;
}

/* obj -> enum_obj */
QJS_STATIC __exception int js_for_in_start(LEPUSContext *ctx, LEPUSValue *sp) {
  sp[-1] = build_for_in_iterator(ctx, sp[-1]);
  if (LEPUS_IsException(sp[-1])) return -1;
  return 0;
}

/* enum_obj -> enum_obj value done */
__exception int js_for_in_next(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValueConst enum_obj;
  LEPUSObject *p;
  JSAtom prop;
  JSForInIterator *it;
  int ret;

  enum_obj = sp[-1];
  /* fail safe */
  if (LEPUS_VALUE_IS_NOT_OBJECT(enum_obj)) goto done;
  p = LEPUS_VALUE_GET_OBJ(enum_obj);
  if (p->class_id != JS_CLASS_FOR_IN_ITERATOR) goto done;
  it = p->u.for_in_iterator;

  for (;;) {
    if (it->is_array) {
      if (it->idx >= it->array_length) goto done;
      prop = __JS_AtomFromUInt32(it->idx);
      it->idx++;
    } else {
      JSShape *sh = p->shape;
      JSShapeProperty *prs;
      if (it->idx >= sh->prop_count) goto done;
      prs = get_shape_prop(sh) + it->idx;
      prop = prs->atom;
      it->idx++;
      if (prop == JS_ATOM_NULL || !(prs->flags & LEPUS_PROP_ENUMERABLE))
        continue;
    }
    /* check if the property was deleted */
    ret = LEPUS_HasProperty(ctx, it->obj, prop);
    if (ret < 0) return ret;
    if (ret) break;
  }
  /* return the property */
  sp[0] = JS_AtomToValue_RC(ctx, prop);
  sp[1] = LEPUS_FALSE;
  return 0;
done:
  /* return the end */
  sp[0] = LEPUS_UNDEFINED;
  sp[1] = LEPUS_TRUE;
  return 0;
}

static LEPUSValue JS_Call_RC(LEPUSContext *ctx, LEPUSValueConst func_obj,
                             LEPUSValueConst this_obj, int argc,
                             LEPUSValueConst *argv);

LEPUSValue JS_GetIterator2(LEPUSContext *ctx, LEPUSValueConst obj,
                           LEPUSValueConst method) {
  LEPUSValue enum_obj;

  enum_obj = LEPUS_Call(ctx, method, obj, 0, NULL);
  if (LEPUS_IsException(enum_obj)) return enum_obj;
  if (!LEPUS_IsObject(enum_obj)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, enum_obj);
    return JS_ThrowTypeErrorNotAnObject(ctx);
  }
  return enum_obj;
}

LEPUSValue JS_GetIterator(LEPUSContext *ctx, LEPUSValueConst obj,
                          BOOL is_async) {
  LEPUSValue method = LEPUS_UNDEFINED, ret, sync_iter;
  HandleScope func_scope(ctx, &method, HANDLE_TYPE_LEPUS_VALUE);

  if (is_async) {
    method = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_Symbol_asyncIterator,
                                       obj, 0);
    if (LEPUS_IsException(method)) return method;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
      method =
          LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_Symbol_iterator, obj, 0);
      if (LEPUS_IsException(method)) return method;
      sync_iter = JS_GetIterator2(ctx, obj, method);
      if (!ctx->gc_enable) LEPUS_FreeValue(ctx, method);
      if (LEPUS_IsException(sync_iter)) return sync_iter;
      func_scope.PushHandle(&sync_iter, HANDLE_TYPE_LEPUS_VALUE);
      ret = JS_CreateAsyncFromSyncIterator(ctx, sync_iter);
      if (!ctx->gc_enable) LEPUS_FreeValue(ctx, sync_iter);
      return ret;
    }
  } else {
    method =
        LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_Symbol_iterator, obj, 0);
    if (LEPUS_IsException(method)) return method;
  }
  if (!LEPUS_IsFunction(ctx, method)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, method);
    return LEPUS_ThrowTypeError(ctx, "value is not iterable");
  }
  ret = JS_GetIterator2(ctx, obj, method);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, method);
  return ret;
}

/* return *pdone = 2 if the iterator object is not parsed */
LEPUSValue JS_IteratorNext2(LEPUSContext *ctx, LEPUSValueConst enum_obj,
                            LEPUSValueConst method, int argc,
                            LEPUSValueConst *argv, int *pdone) {
  LEPUSValue obj = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &obj, HANDLE_TYPE_LEPUS_VALUE);

  /* fast path for the built-in iterators (avoid creating the
     intermediate result object) */
  if (LEPUS_IsObject(method)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(method);
    if (p->class_id == JS_CLASS_C_FUNCTION &&
        p->u.cfunc.cproto == LEPUS_CFUNC_iterator_next) {
      HandleScope block_scope(ctx->rt);
      LEPUSCFunctionType func;
      LEPUSValueConst args[1];
      args[0] = LEPUS_UNDEFINED;
      func_scope.PushHandle(&args[0], HANDLE_TYPE_LEPUS_VALUE);

      /* in case the function expects one argument */
      if (argc == 0) {
        args[0] = LEPUS_UNDEFINED;
        argv = args;
      }
      func = p->u.cfunc.c_function;
      return func.iterator_next(ctx, enum_obj, argc, argv, pdone,
                                p->u.cfunc.magic);
    }
  }
  obj = LEPUS_Call(ctx, method, enum_obj, argc, argv);
  if (LEPUS_IsException(obj)) goto fail;
  if (!LEPUS_IsObject(obj)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
    LEPUS_ThrowTypeError(ctx, "iterator must return an object");
    goto fail;
  }
  *pdone = 2;
  return obj;
fail:
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

LEPUSValue JS_IteratorNext(LEPUSContext *ctx, LEPUSValueConst enum_obj,
                           LEPUSValueConst method, int argc,
                           LEPUSValueConst *argv, BOOL *pdone) {
  LEPUSValue obj = LEPUS_UNDEFINED, value = LEPUS_UNDEFINED,
             done_val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &obj, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&value, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&done_val, HANDLE_TYPE_LEPUS_VALUE);
  int done;

  obj = JS_IteratorNext2(ctx, enum_obj, method, argc, argv, &done);
  if (LEPUS_IsException(obj)) goto fail;
  if (done != 2) {
    *pdone = done;
    return obj;
  } else {
    done_val = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_done, obj, 0);
    if (LEPUS_IsException(done_val)) goto fail;
    *pdone = JS_ToBoolFree(ctx, done_val);
    value = LEPUS_UNDEFINED;
    if (!*pdone) {
      value = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_value, obj, 0);
    }
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
    return value;
  }
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

/* return < 0 in case of exception */
int JS_IteratorClose(LEPUSContext *ctx, LEPUSValueConst enum_obj,
                     BOOL is_exception_pending) {
  LEPUSValue method = LEPUS_UNDEFINED, ret, ex_obj;
  HandleScope func_scope(ctx, &method, HANDLE_TYPE_LEPUS_VALUE);
  int res;

  if (is_exception_pending) {
    ex_obj = ctx->rt->current_exception;
    ctx->rt->current_exception = LEPUS_NULL;
    res = -1;
  } else {
    ex_obj = LEPUS_UNDEFINED;
    res = 0;
  }
  func_scope.PushHandle(&ex_obj, HANDLE_TYPE_LEPUS_VALUE);
  method =
      LEPUS_GetPropertyInternal(ctx, enum_obj, JS_ATOM_return, enum_obj, 0);
  if (LEPUS_IsException(method)) {
    res = -1;
    goto done;
  }
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    goto done;
  }
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable)
    ret = JS_CallFree_GC(ctx, method, enum_obj, 0, NULL);
  else
#endif
    ret = JS_CallFree(ctx, method, enum_obj, 0, NULL);
  func_scope.PushHandle(&ret, HANDLE_TYPE_LEPUS_VALUE);
  if (!is_exception_pending) {
    if (LEPUS_IsException(ret)) {
      res = -1;
    } else if (!LEPUS_IsObject(ret)) {
      JS_ThrowTypeErrorNotAnObject(ctx);
      res = -1;
    }
  }
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, ret);
done:
  if (is_exception_pending) {
    LEPUS_Throw(ctx, ex_obj);
  }
  return res;
}

/* obj -> enum_rec (3 slots) */
__exception int js_for_of_start(LEPUSContext *ctx, LEPUSValue *sp,
                                BOOL is_async) {
  LEPUSValue op1, obj, method;
  op1 = sp[-1];
  obj = JS_GetIterator(ctx, op1, is_async);
  if (LEPUS_IsException(obj)) return -1;
  LEPUS_FreeValue(ctx, op1);
  sp[-1] = obj;
  method = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_next, obj, 0);
  if (LEPUS_IsException(method)) return -1;
  sp[0] = method;
  return 0;
}

/* enum_rec -> enum_rec value done */
__exception int js_for_of_next(LEPUSContext *ctx, LEPUSValue *sp, int offset) {
  LEPUSValue value = LEPUS_UNDEFINED;
  int done = 1;

  if (likely(!LEPUS_IsUndefined(sp[offset]))) {
    value = JS_IteratorNext(ctx, sp[offset], sp[offset + 1], 0, NULL, &done);
    if (LEPUS_IsException(value)) done = -1;
    if (done) {
      /* value is LEPUS_UNDEFINED or LEPUS_EXCEPTION */
      /* replace the iteration object with undefined */
      LEPUS_FreeValue(ctx, sp[offset]);
      sp[offset] = LEPUS_UNDEFINED;
      if (done < 0)
        return -1;
      else {
        LEPUS_FreeValue(ctx, value);
        value = LEPUS_UNDEFINED;
      }
    }
  }
  sp[0] = value;
  sp[1] = LEPUS_NewBool(ctx, done);
  return 0;
}

__exception int js_for_await_of_next(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue result;
  result = JS_Call_RC(ctx, sp[-2], sp[-3], 0, NULL);
  if (LEPUS_IsException(result)) return -1;
  sp[0] = result;
  return 0;
}

QJS_STATIC LEPUSValue JS_IteratorGetCompleteValue(LEPUSContext *ctx,
                                                  LEPUSValueConst obj,
                                                  BOOL *pdone) {
  LEPUSValue done_val, value;
  BOOL done;
  done_val = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_done, obj, 0);
  if (LEPUS_IsException(done_val)) goto fail;
  done = JS_ToBoolFree_RC(ctx, done_val);
  value = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_value, obj, 0);
  if (LEPUS_IsException(value)) goto fail;
  *pdone = done;
  return value;
fail:
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

__exception int js_iterator_get_value_done(LEPUSContext *ctx, LEPUSValue *sp) {
  CallGCFunc(js_iterator_get_value_done_gc, ctx, sp);
  LEPUSValue obj, value;
  BOOL done;
  obj = sp[-1];
  if (!LEPUS_IsObject(obj)) {
    LEPUS_ThrowTypeError(ctx, "iterator must return an object");
    return -1;
  }
  value = JS_IteratorGetCompleteValue(ctx, obj, &done);
  if (LEPUS_IsException(value)) return -1;
  LEPUS_FreeValue(ctx, obj);
  sp[-1] = value;
  sp[0] = LEPUS_NewBool(ctx, done);
  return 0;
}

QJS_STATIC LEPUSValue js_create_iterator_result(LEPUSContext *ctx,
                                                LEPUSValue val, BOOL done) {
  LEPUSValue obj;
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeValue(ctx, val);
    return obj;
  }
  if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_value, val,
                                LEPUS_PROP_C_W_E) < 0) {
    goto fail;
  }
  if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_done,
                                LEPUS_NewBool(ctx, done),
                                LEPUS_PROP_C_W_E) < 0) {
  fail:
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC LEPUSValue js_array_iterator_next(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv, BOOL *pdone,
                                             int magic);

QJS_STATIC LEPUSValue js_create_array_iterator(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int magic);

QJS_STATIC BOOL js_is_fast_array(LEPUSContext *ctx, LEPUSValueConst obj) {
  /* Try and handle fast arrays explicitly */
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {
      return TRUE;
    }
  }
  return FALSE;
}

/* Access an Array's internal LEPUSValue array if available */
QJS_STATIC BOOL js_get_fast_array(LEPUSContext *ctx, LEPUSValueConst obj,
                                  LEPUSValue **arrpp, uint32_t *countp) {
  /* Try and handle fast arrays explicitly */
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {
      *countp = p->u.array.count;
      *arrpp = p->u.array.u.values;
      return TRUE;
    }
  }
  return FALSE;
}

__exception int js_append_enumerate(LEPUSContext *ctx, LEPUSValue *sp) {
  CallGCFunc(js_append_enumerate_gc, ctx, sp);
  LEPUSValue iterator, enumobj, method, value;
  int pos, is_array_iterator;
  LEPUSValue *arrp;
  uint32_t i, count32;

  if (!LEPUS_VALUE_IS_INT(sp[-2])) {
    LEPUS_ThrowInternalError(ctx, "invalid index for append");
    return -1;
  }

  pos = LEPUS_VALUE_GET_INT(sp[-2]);

  /* XXX: further optimisations:
     - use ctx->array_proto_values?
     - check if array_iterator_prototype next method is built-in and
       avoid constructing actual iterator object?
     - build this into js_for_of_start and use in all `for (x of o)` loops
   */
  iterator = JS_GetPropertyInternal_RC(ctx, sp[-1], JS_ATOM_Symbol_iterator,
                                       sp[-1], 0);
  if (LEPUS_IsException(iterator)) return -1;
  is_array_iterator =
      JS_IsCFunction(ctx, iterator, (LEPUSCFunction *)js_create_array_iterator,
                     JS_ITERATOR_KIND_VALUE);
  LEPUS_FreeValue(ctx, iterator);

  enumobj = JS_GetIterator(ctx, sp[-1], FALSE);
  if (LEPUS_IsException(enumobj)) return -1;
  method = JS_GetPropertyInternal_RC(ctx, enumobj, JS_ATOM_next, enumobj, 0);
  if (LEPUS_IsException(method)) {
    LEPUS_FreeValue(ctx, enumobj);
    return -1;
  }
  if (is_array_iterator &&
      JS_IsCFunction(ctx, method, (LEPUSCFunction *)js_array_iterator_next,
                     0) &&
      js_get_fast_array(ctx, sp[-1], &arrp, &count32)) {
    int64_t len;
    /* Handle fast arrays explicitly */
    if (js_get_length64(ctx, &len, sp[-1])) goto exception;
    for (i = 0; i < count32; i++) {
      if (JS_DefinePropertyValueUint32_RC(ctx, sp[-3], pos++,
                                          LEPUS_DupValue(ctx, arrp[i]),
                                          LEPUS_PROP_C_W_E) < 0)
        goto exception;
    }
    // https://262.ecma-international.org/6.0/#sec-argument-lists-runtime-semantics-argumentlistevaluation
    if (len != count32) {
      goto general_case;
    }
  } else {
  general_case:
    for (;;) {
      BOOL done;
      value = JS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);
      if (LEPUS_IsException(value)) goto exception;
      if (done) {
        /* value is LEPUS_UNDEFINED */
        break;
      }
      if (JS_DefinePropertyValueUint32_RC(ctx, sp[-3], pos++, value,
                                          LEPUS_PROP_C_W_E) < 0)
        goto exception;
    }
  }
  sp[-2] = LEPUS_NewInt32(ctx, pos);
  LEPUS_FreeValue(ctx, enumobj);
  LEPUS_FreeValue(ctx, method);
  return 0;

exception:
  JS_IteratorClose(ctx, enumobj, TRUE);
  LEPUS_FreeValue(ctx, enumobj);
  LEPUS_FreeValue(ctx, method);
  return -1;
}

QJS_STATIC __exception int JS_CopyDataProperties(LEPUSContext *ctx,
                                                 LEPUSValueConst target,
                                                 LEPUSValueConst source,
                                                 LEPUSValueConst excluded,
                                                 BOOL setprop) {
  LEPUSPropertyEnum *tab_atom;
  LEPUSValue val;
  uint32_t i, tab_atom_count;
  LEPUSObject *p;
  LEPUSObject *pexcl = NULL;
  int ret = 0, flags;
// <Primjs begin>
#ifdef ENABLE_LEPUSNG
  if (LEPUS_VALUE_IS_LEPUS_REF(source)) {
    if (ctx->rt->primjs_callbacks_.js_get_own_property_names(
            ctx, source, &tab_atom_count, &tab_atom, LEPUS_GPN_ENUM_ONLY)) {
      return -1;
    }
    goto CopyValueProperties;
  }
#endif
  // <Primjs end>

  if (LEPUS_VALUE_IS_NOT_OBJECT(source)) return 0;

  p = LEPUS_VALUE_GET_OBJ(source);
  if (JS_GetOwnPropertyNamesInternal(
          ctx, &tab_atom, &tab_atom_count, p,
          LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK | LEPUS_GPN_ENUM_ONLY))
    return -1;
#ifdef ENABLE_LEPUSNG
CopyValueProperties:
#endif
  if (LEPUS_VALUE_IS_OBJECT(excluded)) pexcl = LEPUS_VALUE_GET_OBJ(excluded);

  flags = LEPUS_PROP_C_W_E;

  for (i = 0; i < tab_atom_count; i++) {
    if (pexcl) {
      ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
      if (ret) {
        if (ret < 0) break;
        ret = 0;
        continue;
      }
    }
    ret = -1;
    val = JS_GetPropertyInternal_RC(ctx, source, tab_atom[i].atom, source, 0);
    if (LEPUS_IsException(val)) break;
    if (setprop)
      ret = JS_SetPropertyInternal_RC(ctx, target, tab_atom[i].atom, val,
                                      LEPUS_PROP_THROW);
    else
      ret =
          JS_DefinePropertyValue_RC(ctx, target, tab_atom[i].atom, val, flags);
    if (ret < 0) break;
    ret = 0;
  }
  js_free_prop_enum(ctx, tab_atom, tab_atom_count);
  return ret;
}

/* only valid inside C functions */
QJS_HIDE LEPUSValueConst JS_GetActiveFunction(LEPUSContext *ctx) {
  if (ctx->rt->current_stack_frame) {
    return ctx->rt->current_stack_frame->cur_func;
  } else {
    return LEPUS_UNDEFINED;
  }
}

JSVarRef *get_var_ref(LEPUSContext *ctx, LEPUSStackFrame *sf, int var_idx,
                      BOOL is_arg) {
  JSVarRef *var_ref;
  struct list_head *el;
  if (likely(sf->var_refs)) {
    if ((var_ref = sf->var_refs[is_arg ? var_idx : sf->arg_count + var_idx])) {
      ++var_ref->header.ref_count;
      return var_ref;
    }
  } else {
    sf->var_refs = static_cast<JSVarRef **>(lepus_mallocz(
        ctx, sizeof(JSVarRef *) * sf->ref_size, ALLOC_TAG_WITHOUT_PTR));
    if (!sf->var_refs) return nullptr;
  }

  /* create a new one */
  var_ref = static_cast<JSVarRef *>(
      lepus_malloc(ctx, sizeof(JSVarRef), ALLOC_TAG_JSVarRef));
  if (!var_ref) return NULL;
  var_ref->header.ref_count = 2;
  var_ref->gc_header.mark = 0;
  var_ref->is_arg = is_arg;
  var_ref->is_detached = 0;
  var_ref->var_idx = var_idx;
  if (is_arg)
    var_ref->pvalue = &sf->arg_buf[var_idx];
  else
    var_ref->pvalue = &sf->var_buf[var_idx];
  var_ref->value = LEPUS_UNDEFINED;
  list_add_tail(&var_ref->link, &sf->var_ref_list);
  sf->var_refs[is_arg ? var_idx : sf->arg_count + var_idx] = var_ref;
  return var_ref;
}

LEPUSValue js_closure2(LEPUSContext *ctx, LEPUSValue func_obj,
                       LEPUSFunctionBytecode *b, JSVarRef **cur_var_refs,
                       LEPUSStackFrame *sf) {
  LEPUSObject *p;
  JSVarRef **var_refs;
  int i;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.func.function_bytecode = b;
  p->u.func.home_object = NULL;
  p->u.func.var_refs = NULL;
  if (b->closure_var_count) {
    var_refs = static_cast<JSVarRef **>(
        lepus_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count,
                      ALLOC_TAG_WITHOUT_PTR));
    if (!var_refs) goto fail;
    p->u.func.var_refs = var_refs;
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      JSVarRef *var_ref;
      if (cv->is_local) {
        /* reuse the existing variable reference if it already exists */
        var_ref = get_var_ref(ctx, sf, cv->var_idx, cv->is_arg);
        if (!var_ref) goto fail;
      } else {
        var_ref = cur_var_refs[cv->var_idx];
        var_ref->header.ref_count++;
      }
      var_refs[i] = var_ref;
    }
  }
  return func_obj;
fail:
  /* bfunc is freed when func_obj is freed */
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_instantiate_prototype(LEPUSContext *ctx,
                                               LEPUSObject *p, JSAtom atom,
                                               void *opaque) {
  LEPUSValue obj, this_val;
  int ret;

  this_val = LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  set_cycle_flag(ctx, obj);
  set_cycle_flag(ctx, this_val);
  ret = JS_DefinePropertyValue_RC(
      ctx, obj, JS_ATOM_constructor, LEPUS_DupValue(ctx, this_val),
      LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

static const uint16_t func_kind_to_class_id[] = {
    [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,
    [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,
    [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,
    [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
};

LEPUSValue js_closure(LEPUSContext *ctx, LEPUSValue bfunc,
                      JSVarRef **cur_var_refs, LEPUSStackFrame *sf) {
  CallGCFunc(js_closure_gc, ctx, bfunc, cur_var_refs, sf);
  LEPUSFunctionBytecode *b;
  LEPUSValue func_obj;
  LEPUSObject *p;
  JSAtom name_atom;
  JSProperty *pr;

  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));
  func_obj = LEPUS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);
  if (LEPUS_IsException(func_obj)) {
    LEPUS_FreeValue(ctx, bfunc);
    return LEPUS_EXCEPTION;
  }
  func_obj = js_closure2(ctx, func_obj, b, cur_var_refs, sf);
  if (LEPUS_IsException(func_obj)) {
    /* bfunc has been freed */
    goto fail;
  }
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  name_atom = b->func_name;
  if (name_atom == JS_ATOM_NULL) name_atom = JS_ATOM_empty_string;
  js_function_set_properties(ctx, p, name_atom, b->defined_arg_count);

  if (b->func_kind & JS_FUNC_GENERATOR) {
    LEPUSValue proto;
    int proto_class_id;
    /* generators have a prototype field which is used as
       prototype for the generator object */
    if (b->func_kind == JS_FUNC_ASYNC_GENERATOR)
      proto_class_id = JS_CLASS_ASYNC_GENERATOR;
    else
      proto_class_id = JS_CLASS_GENERATOR;
    proto = LEPUS_NewObjectProto(ctx, ctx->class_proto[proto_class_id]);
    if (LEPUS_IsException(proto)) goto fail;
    pr = add_property(ctx, p, JS_ATOM_prototype, LEPUS_PROP_WRITABLE);
    if (pr) pr->u.value = proto;
  } else if (b->has_prototype) {
    /* add the 'prototype' property: delay instantiation to avoid
       creating cycles for every javascript function. The prototype
       object is created on the fly when first accessed */
    LEPUS_SetConstructorBit(ctx, func_obj, TRUE);
    pr = add_property(ctx, p, JS_ATOM_prototype,
                      LEPUS_PROP_WRITABLE | LEPUS_PROP_AUTOINIT);
    if (pr) {
      pr->u.init.init_func = js_instantiate_prototype;
      pr->u.init.opaque = nullptr;
    }
  }
  return func_obj;
fail:
  /* bfunc is freed when func_obj is freed */
  LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

#define JS_DEFINE_CLASS_HAS_HERITAGE (1 << 0)

int js_op_define_class(LEPUSContext *ctx, LEPUSValue *sp, JSAtom class_name,
                       int class_flags, JSVarRef **cur_var_refs,
                       LEPUSStackFrame *sf) {
  LEPUSValue bfunc, parent_class, proto = LEPUS_UNDEFINED;
  LEPUSValue ctor = LEPUS_UNDEFINED, parent_proto = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &proto, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&ctor, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&parent_proto, HANDLE_TYPE_LEPUS_VALUE);
  LEPUSFunctionBytecode *b;

  parent_class = sp[-2];
  bfunc = sp[-1];
  func_scope.PushHandle(&parent_class, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&bfunc, HANDLE_TYPE_LEPUS_VALUE);

  if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {
    if (LEPUS_IsNull(parent_class)) {
      parent_proto = LEPUS_NULL;
      parent_class = LEPUS_DupValue(ctx, ctx->function_proto);
    } else {
      if (!LEPUS_IsConstructor(ctx, parent_class)) {
        LEPUS_ThrowTypeError(ctx, "parent class must be constructor");
        goto fail;
      }
      parent_proto = LEPUS_GetPropertyInternal(
          ctx, parent_class, JS_ATOM_prototype, parent_class, 0);
      if (LEPUS_IsException(parent_proto)) goto fail;
      if (!LEPUS_IsNull(parent_proto) && !LEPUS_IsObject(parent_proto)) {
        LEPUS_ThrowTypeError(ctx, "parent prototype must be an object or null");
        goto fail;
      }
    }
  } else {
    /* parent_class is LEPUS_UNDEFINED in this case */
    parent_proto = LEPUS_DupValue(ctx, ctx->class_proto[JS_CLASS_OBJECT]);
    parent_class = LEPUS_DupValue(ctx, ctx->function_proto);
  }
  proto = LEPUS_NewObjectProto(ctx, parent_proto);
  if (LEPUS_IsException(proto)) goto fail;

  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));
  assert(b->func_kind == JS_FUNC_NORMAL);
  ctor =
      LEPUS_NewObjectProtoClass(ctx, parent_class, JS_CLASS_BYTECODE_FUNCTION);
  if (LEPUS_IsException(ctor)) goto fail;
  ctor = js_closure2(ctx, ctor, b, cur_var_refs, sf);
  bfunc = LEPUS_UNDEFINED;
  if (LEPUS_IsException(ctor)) goto fail;
  js_method_set_home_object(ctx, ctor, proto);
  LEPUS_SetConstructorBit(ctx, ctor, TRUE);

  LEPUS_DefinePropertyValue(ctx, ctor, JS_ATOM_length,
                            LEPUS_NewInt32(ctx, b->defined_arg_count),
                            LEPUS_PROP_CONFIGURABLE);

  /* the constructor property must be first. It can be overriden by
     computed property names */
  if (LEPUS_DefinePropertyValue(
          ctx, proto, JS_ATOM_constructor, LEPUS_DupValue(ctx, ctor),
          LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE | LEPUS_PROP_THROW) < 0)
    goto fail;
  /* set the prototype property */
  if (LEPUS_DefinePropertyValue(ctx, ctor, JS_ATOM_prototype,
                                LEPUS_DupValue(ctx, proto),
                                LEPUS_PROP_THROW) < 0)
    goto fail;
  set_cycle_flag(ctx, ctor);
  set_cycle_flag(ctx, proto);

  if (class_name != JS_ATOM_NULL) {
    if (JS_DefineObjectName(ctx, ctor, class_name, LEPUS_PROP_CONFIGURABLE) < 0)
      goto fail;
#ifdef ENABLE_QUICKJS_DEBUGGER
    js_bytecode_function_set_name(ctx, JS_GetFunctionBytecode(ctor),
                                  LEPUS_AtomToString(ctx, class_name));
#endif
  }

  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, parent_proto);
    LEPUS_FreeValue(ctx, parent_class);
  }

  sp[-2] = ctor;
  sp[-1] = proto;
  return 0;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, parent_class);
    LEPUS_FreeValue(ctx, parent_proto);
    LEPUS_FreeValue(ctx, bfunc);
    LEPUS_FreeValue(ctx, proto);
    LEPUS_FreeValue(ctx, ctor);
  }
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC void close_var_refs(LEPUSRuntime *rt, LEPUSStackFrame *sf) {
  struct list_head *el, *el1;
  JSVarRef *var_ref;
  int var_idx;

  list_for_each_safe(el, el1, &sf->var_ref_list) {
    var_ref = list_entry(el, JSVarRef, link);
    if (var_ref->header.ref_count > 1) {
      // still used by function closure.
      var_ref->value = LEPUS_DupValueRT(rt, *var_ref->pvalue);
      var_ref->pvalue = &var_ref->value;
      var_ref->is_detached = 1;
      var_ref->header.ref_count--;
    } else {
      lepus_free_rt(rt, var_ref);
    }
  }
  return;
}

void close_lexical_var(LEPUSContext *ctx, LEPUSStackFrame *sf, int idx) {
  struct list_head *el, *el1;
  JSVarRef *var_ref;
  int var_idx = sf->arg_count + idx;
  if (!sf->var_refs) return;
  var_ref = sf->var_refs[var_idx];
  if (var_ref) {
    var_ref->value = LEPUS_DupValue(ctx, *var_ref->pvalue);
    var_ref->pvalue = &var_ref->value;
    var_ref->is_detached = 1;
    list_del(&var_ref->link);
    if (!ctx->gc_enable) free_var_ref(ctx->rt, var_ref);
    sf->var_refs[var_idx] = nullptr;
  }
  return;
}

QJS_STATIC LEPUSValue js_call_c_function(LEPUSContext *ctx,
                                         LEPUSValueConst func_obj,
                                         LEPUSValueConst this_obj, int argc,
                                         LEPUSValueConst *argv, int flags) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSCFunctionType func;
  LEPUSObject *p;
  LEPUSStackFrame sf_s, *sf = &sf_s, *prev_sf;
  LEPUSValue ret_val;
  LEPUSValueConst *arg_buf;
  int arg_count, i;
  LEPUSCFunctionEnum cproto;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  cproto = static_cast<LEPUSCFunctionEnum>(p->u.cfunc.cproto);
  arg_count = p->u.cfunc.length;

  /* better to always check stack overflow */
  if (js_check_stack_overflow(ctx, sizeof(arg_buf[0]) * arg_count))
    return JS_ThrowStackOverflow(ctx);
#ifdef ENABLE_QUICKJS_DEBUGGER
  BOOL is_debug_mode = ctx->debugger_mode;
  if (is_debug_mode) {
    sf->pthis = this_obj;
  } else {
    sf->pthis = LEPUS_UNDEFINED;
  }
#endif
  prev_sf = rt->current_stack_frame;
  sf->prev_frame = prev_sf;
  sf->cur_func = (LEPUSValue)func_obj;
  rt->current_stack_frame = sf;
#ifdef CONFIG_BIGNUM
  /* we only propagate the bignum mode as some runtime functions
     test it */
  if (prev_sf)
    sf->js_mode = prev_sf->js_mode & JS_MODE_BIGINT;
  else
    sf->js_mode = 0;
#else
  sf->js_mode = 0;
#endif
  sf->arg_count = argc;
  arg_buf = argv;

  // <Primjs begin>
#ifdef OS_IOS
  size_t alloca_size = 0;
#endif
  if (unlikely(argc < arg_count)) {
    /* ensure that at least argc_count arguments are readable */
#ifdef OS_IOS
    alloca_size = sizeof(arg_buf[0]) * arg_count;
    if (js_check_virtual_outofmemory(ctx, alloca_size)) {
      return LEPUS_ThrowOutOfMemory(ctx);
    }
    if (js_check_virtual_sp_overflow(ctx, alloca_size)) {
      return JS_ThrowStackOverflow(ctx);
    }
    arg_buf = js_get_virtual_sp(ctx);
    js_push_virtual_sp(ctx, alloca_size);
#elif !defined(OS_WIN)
    arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(arg_buf[0]) * arg_count));
#else
        arg_buf =
            static_cast<LEPUSValue *>(_alloca(sizeof(arg_buf[0]) * arg_count));
#endif

    for (i = 0; i < argc; i++) arg_buf[i] = argv[i];
    for (i = argc; i < arg_count; i++) arg_buf[i] = LEPUS_UNDEFINED;
    sf->arg_count = arg_count;
  }

  // <Primjs end>
  sf->arg_buf = (LEPUSValue *)arg_buf;

  func = p->u.cfunc.c_function;
  switch (cproto) {
    case LEPUS_CFUNC_constructor:
    case LEPUS_CFUNC_constructor_or_func:
      if (!(flags & LEPUS_CALL_FLAG_CONSTRUCTOR)) {
        if (cproto == LEPUS_CFUNC_constructor) {
        not_a_constructor:
          ret_val = LEPUS_ThrowTypeError(ctx, "must be called with new");
          break;
        } else {
          this_obj = LEPUS_UNDEFINED;
        }
      }
      /* here this_obj is new_target */
      /* fall thru */
    case LEPUS_CFUNC_generic:
      ret_val = func.generic(ctx, this_obj, argc, arg_buf);
      break;
    case LEPUS_CFUNC_constructor_magic:
    case LEPUS_CFUNC_constructor_or_func_magic:
      if (!(flags & LEPUS_CALL_FLAG_CONSTRUCTOR)) {
        if (cproto == LEPUS_CFUNC_constructor_magic) {
          goto not_a_constructor;
        } else {
          this_obj = LEPUS_UNDEFINED;
        }
      }
      /* fall thru */
    case LEPUS_CFUNC_generic_magic:
      ret_val =
          func.generic_magic(ctx, this_obj, argc, arg_buf, p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_getter:
      ret_val = func.getter(ctx, this_obj);
      break;
    case LEPUS_CFUNC_setter:
      ret_val = func.setter(ctx, this_obj, arg_buf[0]);
      break;
    case LEPUS_CFUNC_getter_magic:
      ret_val = func.getter_magic(ctx, this_obj, p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_setter_magic:
      ret_val = func.setter_magic(ctx, this_obj, arg_buf[0], p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_f_f: {
      double d1;

      if (unlikely(LEPUS_ToFloat64(ctx, &d1, arg_buf[0]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      ret_val = LEPUS_NewFloat64(ctx, func.f_f(d1));
    } break;
    case LEPUS_CFUNC_f_f_f: {
      double d1, d2;

      if (unlikely(LEPUS_ToFloat64(ctx, &d1, arg_buf[0]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      if (unlikely(LEPUS_ToFloat64(ctx, &d2, arg_buf[1]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      ret_val = LEPUS_NewFloat64(ctx, func.f_f_f(d1, d2));
    } break;
    case LEPUS_CFUNC_iterator_next: {
      int done;
      ret_val = func.iterator_next(ctx, this_obj, argc, arg_buf, &done,
                                   p->u.cfunc.magic);
      if (!LEPUS_IsException(ret_val) && done != 2) {
        ret_val = js_create_iterator_result(ctx, ret_val, done);
      }
    } break;
    default:
      abort();
  }

  rt->current_stack_frame = sf->prev_frame;
  // <Primjs add>
#ifdef OS_IOS
  js_pop_virtual_sp(ctx, alloca_size);
#endif
  return ret_val;
}

QJS_STATIC LEPUSValue js_call_bound_function(LEPUSContext *ctx,
                                             LEPUSValueConst func_obj,
                                             LEPUSValueConst this_obj, int argc,
                                             LEPUSValueConst *argv, int flags) {
  LEPUSObject *p;
  JSBoundFunction *bf;
  LEPUSValueConst *arg_buf, new_target;
  int arg_count, i;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  bf = p->u.bound_function;
  arg_count = bf->argc + argc;
  if (js_check_stack_overflow(ctx, sizeof(LEPUSValue) * arg_count))
    return JS_ThrowStackOverflow(ctx);
  // <Primjs begin>
  LEPUSValue ret;
#ifdef OS_IOS
  size_t alloca_size = sizeof(LEPUSValue) * arg_count;
  if (js_check_virtual_outofmemory(ctx, alloca_size)) {
    return LEPUS_ThrowOutOfMemory(ctx);
  }
  if (js_check_virtual_sp_overflow(ctx, alloca_size)) {
    return JS_ThrowStackOverflow(ctx);
  }
  // arg_buf = alloca(sizeof(LEPUSValue) * arg_count);
  // allocat stack size
  arg_buf = js_get_virtual_sp(ctx);
  js_push_virtual_sp(ctx, alloca_size);
#elif !defined(OS_WIN)
  arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(LEPUSValue) * arg_count));
#else
      arg_buf =
          static_cast<LEPUSValue *>(_alloca(sizeof(LEPUSValue) * arg_count));
#endif
  // <Primjs end>

  for (i = 0; i < bf->argc; i++) {
    arg_buf[i] = bf->argv[i];
  }
  for (i = 0; i < argc; i++) {
    arg_buf[bf->argc + i] = argv[i];
  }
  if (flags & LEPUS_CALL_FLAG_CONSTRUCTOR) {
    new_target = this_obj;
    if (js_same_value(ctx, func_obj, new_target)) new_target = bf->func_obj;
    ret = LEPUS_CallConstructor2(ctx, bf->func_obj, new_target, arg_count,
                                 arg_buf);
  } else {
    ret = JS_Call_RC(ctx, bf->func_obj, bf->this_val, arg_count, arg_buf);
  }
#ifdef OS_IOS
  js_pop_virtual_sp(ctx, alloca_size);
#endif
  return ret;
  // <Primjs end>
}

QJS_STATIC no_inline __exception int __js_poll_interrupts(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;
  if (rt->interrupt_handler) {
    if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {
      /* XXX: should set a specific flag to avoid catching */
      LEPUS_ThrowInternalError(ctx, "interrupted");
      JS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);
      return -1;
    }
  }
  return 0;
}

QJS_STATIC inline __exception int js_poll_interrupts(LEPUSContext *ctx) {
  if (unlikely(--ctx->interrupt_counter <= 0)) {
    return __js_poll_interrupts(ctx);
  } else {
    return 0;
  }
}

#ifdef ENABLE_QUICKJS_DEBUGGER
void DebuggerCallEachFunc(LEPUSContext *ctx, const uint8_t *pc) {
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->rt->gc_enable) ctx->rt->gc->SetForbidGC();
#endif
  LEPUSDebuggerInfo *info = ctx->debugger_info;
  // only do inspector check when necessary
  // 1. lepusNG: when finishing executing lepusNG, the protocol messages need to
  // process by calling inspectorcheck
  // 2. Need to pause on next statement by calling inspectorcheck
  // in other situations, there is no need to call inspectorcheck
  if (ctx->debugger_need_polling || info->pause_on_next_statement) {
    ctx->debugger_info->debugger_current_pc = pc;
    ctx->rt->debugger_callbacks_.inspector_check(ctx);
  }
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable) ctx->rt->gc->ResetForbidGC();
#endif
  return;
}

void DebuggerCallEachOp(LEPUSContext *ctx, const uint8_t *pc,
                        LEPUSFunctionBytecode *b) {
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable) {
    ctx->rt->gc->SetForbidGC();
  }
#endif
  LEPUSDebuggerInfo *info = ctx->debugger_info;
  if (info->is_profiling_started) return;
  // only call inspector check when necessary
  // 1. after receiving Debugger.stepxxx messages
  // 2. current position hits a breakpoint
  ctx->debugger_info->debugger_current_pc = pc;
  if (info->step_type || (b->bp_num && info->break_bytecode_map.count(pc))) {
    ctx->rt->debugger_callbacks_.inspector_check(ctx);
  }
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable) {
    ctx->rt->gc->ResetForbidGC();
  }
#endif
  return;
}
#endif

/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
QJS_STATIC LEPUSValue JS_CallInternal(LEPUSContext *caller_ctx,
                                      LEPUSValueConst func_obj,
                                      LEPUSValueConst this_obj,
                                      LEPUSValueConst new_target, int argc,
                                      LEPUSValue *argv, int flags) {
  LEPUSRuntime *rt = caller_ctx->rt;
  LEPUSContext *ctx;
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;
  LEPUSStackFrame sf_s, *sf = &sf_s;
  const uint8_t *pc;
  int opcode, arg_allocated_size, i;
  LEPUSValue *local_buf, *stack_buf, *var_buf, *arg_buf, *sp, ret_val, *pval;
  JSVarRef **var_refs;
  size_t alloca_size;
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (caller_ctx->debugger_mode && (!rt->debugger_callbacks_.inspector_check ||
                                    !caller_ctx->debugger_info)) {
    caller_ctx->debugger_mode = false;
  }
  BOOL is_debug_mode = caller_ctx->debugger_mode;
  sf->pthis = is_debug_mode ? this_obj : LEPUS_UNDEFINED;
#endif

#if !DIRECT_DISPATCH
#if 0
#define SWITCH(pc)                                                  \
  opcode = *pc;                                                     \
  if (ctx->op_transform_callback.decode_opcode) {                   \
    opcode = ctx->op_transform_callback.decode_opcode(ctx, opcode); \
  }                                                                 \
  pc++;                                                             \
  switch (opcode)
#else
#define SWITCH(pc) switch (opcode = *pc++)
#endif
#define CASE(op) case op
#define DEFAULT default
#define BREAK break
#else
  static const void *const dispatch_table[256] = {
#define DEF(id, size, n_pop, n_push, f) &&case_OP_##id,
#if SHORT_OPCODES
#define def(id, size, n_pop, n_push, f)
#else
#define def(id, size, n_pop, n_push, f) &&case_default,
#endif
#include "quickjs/include/quickjs-opcode.h"
    [OP_COUNT... 255] = &&case_default
  };
#if 0
#define SWITCH(pc)                                                       \
  opcode = *pc;                                                          \
  if (ctx->op_transform_callback.decode_opcode) {                        \
    opcode = (int)ctx->op_transform_callback.decode_opcode(ctx, opcode); \
  }                                                                      \
  pc++;                                                                  \
  goto *dispatch_table[opcode];
#else
#define SWITCH(pc) goto *dispatch_table[opcode = *pc++];
#endif
#define CASE(op) case_##op
#define DEFAULT case_default
#define BREAK SWITCH(pc)
#endif
  // <Primjs begin>
#ifdef OS_IOS
  BOOL need_free_local_buf = 0;
  // <Primjs end>
#endif
  if (js_poll_interrupts(caller_ctx)) return LEPUS_EXCEPTION;
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func_obj))) {
    if (flags & JS_CALL_FLAG_GENERATOR) {
      JSAsyncFunctionState *s =
          static_cast<JSAsyncFunctionState *>(LEPUS_VALUE_GET_PTR(func_obj));
      /* func_obj get contains a pointer to JSFuncAsyncState */
      /* the stack frame is already allocated */
      sf = &s->frame;
      p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
      b = p->u.func.function_bytecode;
      ctx = caller_ctx;
      var_refs = p->u.func.var_refs;
      local_buf = arg_buf = sf->arg_buf;
      var_buf = sf->var_buf;
      stack_buf = sf->var_buf + b->var_count;
      sp = sf->cur_sp;
      sf->cur_sp = NULL; /* cur_sp is NULL if the function is running */
      pc = sf->cur_pc;
      sf->prev_frame = rt->current_stack_frame;
      rt->current_stack_frame = sf;
      if (s->throw_flag)
        goto exception;
      else
        goto restart;
    } else {
      goto not_a_function;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
    LEPUSClassCall *call_func;
    call_func = rt->class_array[p->class_id].call;
    if (!call_func) {
    not_a_function:
      return JS_ThrowTypeErrorNotFunction(caller_ctx);
    }
    return call_func(caller_ctx, func_obj, this_obj, argc,
                     (LEPUSValueConst *)argv, flags);
  }
  b = p->u.func.function_bytecode;

  if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {
    arg_allocated_size = b->arg_count;
  } else {
    arg_allocated_size = 0;
  }

  alloca_size =
      sizeof(LEPUSValue) * (arg_allocated_size + b->var_count + b->stack_size);
  if (js_check_stack_overflow(caller_ctx, alloca_size))
    return JS_ThrowStackOverflow(caller_ctx);

  sf->js_mode = b->js_mode;
  arg_buf = argv;
  sf->arg_count = argc;
  sf->cur_func = (LEPUSValue)func_obj;
  init_list_head(&sf->var_ref_list);
  var_refs = p->u.func.var_refs;

  // <Primjs begin>
#ifdef OS_IOS
  need_free_local_buf = 1;
  if (js_check_virtual_outofmemory(caller_ctx, alloca_size)) {
    return LEPUS_ThrowOutOfMemory(caller_ctx);
  }
  if (js_check_virtual_sp_overflow(caller_ctx, alloca_size)) {
    return JS_ThrowStackOverflow(caller_ctx);
  }

  local_buf = js_get_virtual_sp(caller_ctx);
  js_push_virtual_sp(caller_ctx, alloca_size);
#elif !defined(OS_WIN)
  local_buf = static_cast<LEPUSValue *>(alloca(alloca_size));
#else
      local_buf = static_cast<LEPUSValue *>(_alloca(alloca_size));
#endif
  // <Bytdance end>
  if (unlikely(arg_allocated_size)) {
    int n = min_int(argc, b->arg_count);
    arg_buf = local_buf;
    for (i = 0; i < n; i++) arg_buf[i] = LEPUS_DupValue(caller_ctx, argv[i]);
    for (; i < b->arg_count; i++) arg_buf[i] = LEPUS_UNDEFINED;
    sf->arg_count = b->arg_count;
  }
  var_buf = local_buf + arg_allocated_size;
  sf->var_buf = var_buf;
  sf->arg_buf = arg_buf;
  sf->ref_size = sf->arg_count + b->var_count;
  sf->var_refs = nullptr;

  for (i = 0; i < b->var_count; i++) var_buf[i] = LEPUS_UNDEFINED;

  stack_buf = var_buf + b->var_count;
  sp = stack_buf;
  pc = b->byte_code_buf;
  sf->prev_frame = rt->current_stack_frame;
  rt->current_stack_frame = sf;
  ctx = caller_ctx;

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (is_debug_mode) {
    DebuggerCallEachFunc(ctx, pc + 1);
  }
#endif
restart:
  for (;;) {
    int call_argc;
    LEPUSValue *call_argv;

    // <Primjs begin>
#ifdef ENABLE_QUICKJS_DEBUGGER
    if (is_debug_mode) {
      DebuggerCallEachOp(ctx, pc + 1, b);
    }
#endif
    // <Primjs end>

    SWITCH(pc) {
      CASE(OP_push_i32) : *sp++ = LEPUS_NewInt32(ctx, get_u32(pc));
      pc += 4;
      BREAK;
      CASE(OP_push_const) : {
        *sp = LEPUS_DupValue(ctx, b->cpool[get_u32(pc)]);
#ifdef ENABLE_QUICKJS_DEBUGGER
        if (is_debug_mode) {
          DebuggerPause(ctx, *sp, pc);
        }
#endif
        sp++;
        pc += 4;
        BREAK;
      }
#if SHORT_OPCODES
      CASE(OP_push_minus1)
          : CASE(OP_push_0)
          : CASE(OP_push_1)
          : CASE(OP_push_2)
          : CASE(OP_push_3)
          : CASE(OP_push_4)
          : CASE(OP_push_5)
          : CASE(OP_push_6)
          : CASE(OP_push_7) : *sp++ = LEPUS_NewInt32(ctx, opcode - OP_push_0);
      BREAK;
      CASE(OP_push_i8) : *sp++ = LEPUS_NewInt32(ctx, get_i8(pc));
      pc += 1;
      BREAK;
      CASE(OP_push_i16) : *sp++ = LEPUS_NewInt32(ctx, get_i16(pc));
      pc += 2;
      BREAK;
      CASE(OP_push_const8) : {
        *sp = LEPUS_DupValue(ctx, b->cpool[*pc]);
#ifdef ENABLE_QUICKJS_DEBUGGER
        if (is_debug_mode) {
          DebuggerPause(ctx, *sp, pc);
        }
#endif
        sp++;
        pc++;
        BREAK;
      }
      CASE(OP_fclosure8)
          : *sp++ = js_closure(ctx, LEPUS_DupValue(ctx, b->cpool[*pc++]),
                               var_refs, sf);
      if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      BREAK;
      CASE(OP_push_empty_string)
          : *sp++ = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
      BREAK;
      CASE(OP_get_length) : {
        LEPUSValue val;

        val = JS_GetPropertyInternal_RC(ctx, sp[-1], JS_ATOM_length, sp[-1], 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
      }
      BREAK;
#endif
      CASE(OP_push_atom_value) : *sp++ = JS_AtomToValue_RC(ctx, get_u32(pc));
      pc += 4;
      BREAK;
      CASE(OP_undefined) : *sp++ = LEPUS_UNDEFINED;
      BREAK;
      CASE(OP_null) : *sp++ = LEPUS_NULL;
      BREAK;
      CASE(OP_push_this)
          : /* OP_push_this is only called at the start of a function */
      {
        LEPUSValue val;
        if (!(b->js_mode & JS_MODE_STRICT)) {
          if (likely(LEPUS_VALUE_IS_OBJECT(this_obj))) goto normal_this;
          if (LEPUS_VALUE_IS_NULL(this_obj) ||
              LEPUS_VALUE_IS_UNDEFINED(this_obj)) {
            val = LEPUS_DupValue(ctx, ctx->global_obj);
          } else {
            val = LEPUS_ToObject(ctx, this_obj);
            if (LEPUS_IsException(val)) goto exception;
          }
        } else {
        normal_this:
          val = LEPUS_DupValue(ctx, this_obj);
        }
        *sp++ = val;
      }
      BREAK;
      CASE(OP_push_false) : *sp++ = LEPUS_FALSE;
      BREAK;
      CASE(OP_push_true) : *sp++ = LEPUS_TRUE;
      BREAK;
      CASE(OP_object) : *sp++ = LEPUS_NewObject(ctx);
      if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      BREAK;
      CASE(OP_special_object) : {
        int arg = *pc++;
        switch (arg) {
          case OP_SPECIAL_OBJECT_ARGUMENTS:
            *sp++ = js_build_arguments(ctx, argc, (LEPUSValueConst *)argv);
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          case OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS:
            *sp++ =
                js_build_mapped_arguments(ctx, argc, (LEPUSValueConst *)argv,
                                          sf, min_int(argc, b->arg_count));
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          case OP_SPECIAL_OBJECT_THIS_FUNC:
            *sp++ = LEPUS_DupValue(ctx, sf->cur_func);
            break;
          case OP_SPECIAL_OBJECT_NEW_TARGET:
            *sp++ = LEPUS_DupValue(ctx, new_target);
            break;
          case OP_SPECIAL_OBJECT_HOME_OBJECT: {
            LEPUSObject *p1;
            p1 = p->u.func.home_object;
            if (unlikely(!p1))
              *sp++ = LEPUS_UNDEFINED;
            else
              *sp++ = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
          } break;
          case OP_SPECIAL_OBJECT_VAR_OBJECT:
            *sp++ = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          default:
            abort();
        }
      }
      BREAK;
      CASE(OP_rest) : {
        int first = get_u16(pc);
        pc += 2;
        *sp++ = js_build_rest(ctx, first, argc, (LEPUSValueConst *)argv);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;

      CASE(OP_drop) : LEPUS_FreeValue(ctx, sp[-1]);
      sp--;
      BREAK;
      CASE(OP_nip) : LEPUS_FreeValue(ctx, sp[-2]);
      sp[-2] = sp[-1];
      sp--;
      BREAK;
      CASE(OP_nip1)
          : /* a b c -> b c */
            LEPUS_FreeValue(ctx, sp[-3]);
      sp[-3] = sp[-2];
      sp[-2] = sp[-1];
      sp--;
      BREAK;
      CASE(OP_dup) : sp[0] = LEPUS_DupValue(ctx, sp[-1]);
      sp++;
      BREAK;
      CASE(OP_dup2)
          : /* a b -> a b a b */
            sp[0] = LEPUS_DupValue(ctx, sp[-2]);
      sp[1] = LEPUS_DupValue(ctx, sp[-1]);
      sp += 2;
      BREAK;
      CASE(OP_dup3)
          : /* a b c -> a b c a b c */
            sp[0] = LEPUS_DupValue(ctx, sp[-3]);
      sp[1] = LEPUS_DupValue(ctx, sp[-2]);
      sp[2] = LEPUS_DupValue(ctx, sp[-1]);
      sp += 3;
      BREAK;
      CASE(OP_dup1)
          : /* a b -> a a b */
            sp[0] = sp[-1];
      sp[-1] = LEPUS_DupValue(ctx, sp[-2]);
      sp++;
      BREAK;
      CASE(OP_insert2)
          : /* obj a -> a obj a (dup_x1) */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_insert3)
          : /* obj prop a -> a obj prop a (dup_x2) */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = sp[-3];
      sp[-3] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_insert4)
          : /* this obj prop a -> a this obj prop a */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = sp[-3];
      sp[-3] = sp[-4];
      sp[-4] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_perm3)
          : /* obj a b -> a obj b (213) */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = tmp;
      }
      BREAK;
      CASE(OP_rot3l)
          : /* x a b -> a b x (231) */
      {
        LEPUSValue tmp;
        tmp = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot4l)
          : /* x a b c -> a b c x */
      {
        LEPUSValue tmp;
        tmp = sp[-4];
        sp[-4] = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot5l)
          : /* x a b c d -> a b c d x */
      {
        LEPUSValue tmp;
        tmp = sp[-5];
        sp[-5] = sp[-4];
        sp[-4] = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot3r)
          : /* a b x -> x a b (312) */
      {
        LEPUSValue tmp;
        tmp = sp[-1];
        sp[-1] = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = tmp;
      }
      BREAK;
      CASE(OP_perm4)
          : /* obj prop a b -> a obj prop b */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = sp[-4];
        sp[-4] = tmp;
      }
      BREAK;
      CASE(OP_perm5)
          : /* this obj prop a b -> a this obj prop b */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = sp[-4];
        sp[-4] = sp[-5];
        sp[-5] = tmp;
      }
      BREAK;
      CASE(OP_swap)
          : /* a b -> b a */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_swap2)
          : /* a b c d -> c d a b */
      {
        LEPUSValue tmp1, tmp2;
        tmp1 = sp[-4];
        tmp2 = sp[-3];
        sp[-4] = sp[-2];
        sp[-3] = sp[-1];
        sp[-2] = tmp1;
        sp[-1] = tmp2;
      }
      BREAK;

      CASE(OP_fclosure) : {
        LEPUSValue bfunc = LEPUS_DupValue(ctx, b->cpool[get_u32(pc)]);
        pc += 4;
        *sp++ = js_closure(ctx, bfunc, var_refs, sf);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;
#if SHORT_OPCODES
      CASE(OP_call0)
          : CASE(OP_call1)
          : CASE(OP_call2) : CASE(OP_call3) : call_argc = opcode - OP_call0;
      goto has_call_argc;
#endif
      CASE(OP_call) : CASE(OP_tail_call) : {
        call_argc = get_u16(pc);
        pc += 2;
      has_call_argc:
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = JS_CallInternal(ctx, call_argv[-1], LEPUS_UNDEFINED,
                                  LEPUS_UNDEFINED, call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        if (opcode == OP_tail_call) goto done;
        for (i = -1; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 1;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_call_constructor) : {
        call_argc = get_u16(pc);
        pc += 2;
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = JS_CallConstructorInternal(ctx, call_argv[-2], call_argv[-1],
                                             call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        for (i = -2; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 2;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_call_method) : CASE(OP_tail_call_method) : {
        call_argc = get_u16(pc);
        pc += 2;
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = JS_CallInternal(ctx, call_argv[-1], call_argv[-2],
                                  LEPUS_UNDEFINED, call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        if (opcode == OP_tail_call_method) goto done;
        for (i = -2; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 2;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_array_from) : {
        int i, ret;

        call_argc = get_u16(pc);
        pc += 2;
        ret_val = LEPUS_NewArray(ctx);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        call_argv = sp - call_argc;
        for (i = 0; i < call_argc; i++) {
          ret = JS_DefinePropertyValue_RC(ctx, ret_val, __JS_AtomFromUInt32(i),
                                          call_argv[i],
                                          LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
          call_argv[i] = LEPUS_UNDEFINED;
          if (ret < 0) {
            LEPUS_FreeValue(ctx, ret_val);
            goto exception;
          }
        }
        sp -= call_argc;
        *sp++ = ret_val;
      }
      BREAK;

      CASE(OP_apply) : {
        int magic;
        magic = get_u16(pc);
        pc += 2;

        ret_val = js_function_apply(ctx, sp[-3], 2, (LEPUSValueConst *)&sp[-2],
                                    magic);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp -= 3;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_return) : ret_val = *--sp;
      goto done;
      CASE(OP_return_undef) : ret_val = LEPUS_UNDEFINED;
      goto done;

      CASE(OP_check_ctor_return)
          : /* return TRUE if 'this' should be returned */
            if (!LEPUS_IsObject(sp[-1])) {
        if (!LEPUS_IsUndefined(sp[-1])) {
          LEPUS_ThrowTypeError(
              caller_ctx,
              "derived class constructor must return an object or undefined");
          goto exception;
        }
        sp[0] = LEPUS_TRUE;
      }
      else {
        sp[0] = LEPUS_FALSE;
      }
      sp++;
      BREAK;
      CASE(OP_check_ctor) : if (LEPUS_IsUndefined(new_target)) {
        LEPUS_ThrowTypeError(caller_ctx,
                             "class constructors must be invoked with 'new'");
        goto exception;
      }
      BREAK;
      CASE(OP_check_brand)
          : if (JS_CheckBrand(ctx, sp[-2], sp[-1]) < 0) goto exception;
      BREAK;
      CASE(OP_add_brand)
          : if (JS_AddBrand(ctx, sp[-2], sp[-1]) < 0) goto exception;
      LEPUS_FreeValue(ctx, sp[-2]);
      LEPUS_FreeValue(ctx, sp[-1]);
      sp -= 2;
      BREAK;

      CASE(OP_throw) : LEPUS_Throw(ctx, *--sp);
      goto exception;

      CASE(OP_throw_var)
          :
#define JS_THROW_VAR_RO 0
#define JS_THROW_VAR_REDECL 1
#define JS_THROW_VAR_UNINITIALIZED 2
#define JS_THROW_ERROR_DELETE_SUPER 3
      {
        JSAtom atom;
        atom = get_u32(pc);
        int type = pc[4];
        pc += 5;
        if (type == JS_THROW_VAR_RO)
          JS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, atom);
        else if (type == JS_THROW_VAR_REDECL)
          JS_ThrowSyntaxErrorVarRedeclaration(ctx, atom);
        else if (type == JS_THROW_VAR_UNINITIALIZED)
          JS_ThrowReferenceErrorUninitialized(ctx, atom);
        else if (type == JS_THROW_ERROR_DELETE_SUPER)
          LEPUS_ThrowReferenceError(ctx, "unsupported reference to 'super'");
        else
          LEPUS_ThrowInternalError(ctx, "invalid throw var type %d", type);
      }
      goto exception;

      CASE(OP_eval) : {
        LEPUSValue obj;
        int scope_idx;

        scope_idx = get_u16(pc) - 1;
        pc += 2;
        obj = sp[-1];
        sp[-1] = JS_EvalObject(ctx, LEPUS_UNDEFINED, obj,
                               LEPUS_EVAL_TYPE_DIRECT, scope_idx);
        LEPUS_FreeValue(ctx, obj);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;

      CASE(OP_regexp) : {
        sp[-2] = js_regexp_constructor_internal(ctx, LEPUS_UNDEFINED, sp[-2],
                                                sp[-1]);
        sp--;
      }
      BREAK;

      CASE(OP_get_super_ctor) : {
        LEPUSValue proto;
        proto = LEPUS_DupValue(ctx, JS_GetPrototype_RC(ctx, sp[-1]));
        if (LEPUS_IsException(proto)) goto exception;
        if (!LEPUS_IsConstructor(ctx, proto)) {
          LEPUS_FreeValue(ctx, proto);
          LEPUS_ThrowTypeError(ctx, "not a constructor");
          goto exception;
        }
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = proto;
      }
      BREAK;

      CASE(OP_get_super) : {
        LEPUSValue proto;
        proto = LEPUS_DupValue(ctx, JS_GetPrototype_RC(ctx, sp[-1]));
        if (LEPUS_IsException(proto)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = proto;
      }
      BREAK;

      CASE(OP_import) : {
#ifndef NO_QUICKJS_COMPILER
        LEPUSValue val;
        val = js_dynamic_import(ctx, sp[-1]);
        if (LEPUS_IsException(val)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
#endif
      }
      BREAK;

      CASE(OP_check_var) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = JS_CheckGlobalVar(ctx, atom);
        if (ret < 0) goto exception;
        *sp++ = LEPUS_NewBool(ctx, ret);
      }
      BREAK;

      CASE(OP_get_var_undef) : CASE(OP_get_var) : {
        LEPUSValue val;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = JS_GetGlobalVar_RC(ctx, atom, opcode - OP_get_var_undef);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_put_var) : CASE(OP_put_var_init) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = JS_SetGlobalVar_RC(ctx, atom, sp[-1], opcode - OP_put_var);
        sp--;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_var_strict) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        /* sp[-2] is LEPUS_TRUE or LEPUS_FALSE */
        if (unlikely(!LEPUS_VALUE_GET_BOOL(sp[-2]))) {
          JS_ThrowReferenceErrorNotDefined(ctx, atom);
          goto exception;
        }
        ret = JS_SetGlobalVar_RC(ctx, atom, sp[-1], 2);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_check_define_var) : {
        JSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (JS_CheckDefineGlobalVar(ctx, atom, flags)) goto exception;
      }
      BREAK;
      CASE(OP_define_var) : {
        JSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (JS_DefineGlobalVar(ctx, atom, flags)) goto exception;
      }
      BREAK;
      CASE(OP_define_func) : {
        JSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (JS_DefineGlobalFunction(ctx, atom, sp[-1], flags)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp--;
      }
      BREAK;

      CASE(OP_get_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        sp[0] = LEPUS_DupValue(ctx, var_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;
      CASE(OP_get_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        sp[0] = LEPUS_DupValue(ctx, arg_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &arg_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &arg_buf[idx], LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;

#if SHORT_OPCODES
      CASE(OP_get_loc8) : *sp++ = LEPUS_DupValue(ctx, var_buf[*pc++]);
      BREAK;
      CASE(OP_put_loc8) : set_value(ctx, &var_buf[*pc++], *--sp);
      BREAK;
      CASE(OP_set_loc8)
          : set_value(ctx, &var_buf[*pc++], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;

      CASE(OP_get_loc0) : *sp++ = LEPUS_DupValue(ctx, var_buf[0]);
      BREAK;
      CASE(OP_get_loc1) : *sp++ = LEPUS_DupValue(ctx, var_buf[1]);
      BREAK;
      CASE(OP_get_loc2) : *sp++ = LEPUS_DupValue(ctx, var_buf[2]);
      BREAK;
      CASE(OP_get_loc3) : *sp++ = LEPUS_DupValue(ctx, var_buf[3]);
      BREAK;
      CASE(OP_put_loc0) : set_value(ctx, &var_buf[0], *--sp);
      BREAK;
      CASE(OP_put_loc1) : set_value(ctx, &var_buf[1], *--sp);
      BREAK;
      CASE(OP_put_loc2) : set_value(ctx, &var_buf[2], *--sp);
      BREAK;
      CASE(OP_put_loc3) : set_value(ctx, &var_buf[3], *--sp);
      BREAK;
      CASE(OP_set_loc0)
          : set_value(ctx, &var_buf[0], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc1)
          : set_value(ctx, &var_buf[1], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc2)
          : set_value(ctx, &var_buf[2], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc3)
          : set_value(ctx, &var_buf[3], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_get_arg0) : *sp++ = LEPUS_DupValue(ctx, arg_buf[0]);
      BREAK;
      CASE(OP_get_arg1) : *sp++ = LEPUS_DupValue(ctx, arg_buf[1]);
      BREAK;
      CASE(OP_get_arg2) : *sp++ = LEPUS_DupValue(ctx, arg_buf[2]);
      BREAK;
      CASE(OP_get_arg3) : *sp++ = LEPUS_DupValue(ctx, arg_buf[3]);
      BREAK;
      CASE(OP_put_arg0) : set_value(ctx, &arg_buf[0], *--sp);
      BREAK;
      CASE(OP_put_arg1) : set_value(ctx, &arg_buf[1], *--sp);
      BREAK;
      CASE(OP_put_arg2) : set_value(ctx, &arg_buf[2], *--sp);
      BREAK;
      CASE(OP_put_arg3) : set_value(ctx, &arg_buf[3], *--sp);
      BREAK;
      CASE(OP_set_arg0)
          : set_value(ctx, &arg_buf[0], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg1)
          : set_value(ctx, &arg_buf[1], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg2)
          : set_value(ctx, &arg_buf[2], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg3)
          : set_value(ctx, &arg_buf[3], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_get_var_ref0) : *sp++ = LEPUS_DupValue(ctx, *var_refs[0]->pvalue);
      BREAK;
      CASE(OP_get_var_ref1) : *sp++ = LEPUS_DupValue(ctx, *var_refs[1]->pvalue);
      BREAK;
      CASE(OP_get_var_ref2) : *sp++ = LEPUS_DupValue(ctx, *var_refs[2]->pvalue);
      BREAK;
      CASE(OP_get_var_ref3) : *sp++ = LEPUS_DupValue(ctx, *var_refs[3]->pvalue);
      BREAK;
      CASE(OP_put_var_ref0) : set_value(ctx, var_refs[0]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref1) : set_value(ctx, var_refs[1]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref2) : set_value(ctx, var_refs[2]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref3) : set_value(ctx, var_refs[3]->pvalue, *--sp);
      BREAK;
      CASE(OP_set_var_ref0)
          : set_value(ctx, var_refs[0]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref1)
          : set_value(ctx, var_refs[1]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref2)
          : set_value(ctx, var_refs[2]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref3)
          : set_value(ctx, var_refs[3]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
#endif

      CASE(OP_get_var_ref) : {
        int idx;
        LEPUSValue val;
        idx = get_u16(pc);
        pc += 2;
        val = *var_refs[idx]->pvalue;
        sp[0] = LEPUS_DupValue(ctx, val);
        sp++;
      }
      BREAK;
      CASE(OP_put_var_ref) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_var_ref) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, var_refs[idx]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;
      CASE(OP_get_var_ref_check) : {
        int idx;
        LEPUSValue val;
        idx = get_u16(pc);
        pc += 2;
        val = *var_refs[idx]->pvalue;
        if (unlikely(LEPUS_IsUninitialized(val))) {
          JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
          goto exception;
        }
        sp[0] = LEPUS_DupValue(ctx, val);
        sp++;
      }
      BREAK;
      CASE(OP_put_var_ref_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(*var_refs[idx]->pvalue))) {
          JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_put_var_ref_check_init) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(!LEPUS_IsUninitialized(*var_refs[idx]->pvalue))) {
          JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_loc_uninitialized) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], LEPUS_UNINITIALIZED);
      }
      BREAK;
      CASE(OP_get_loc_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(var_buf[idx]))) {
          JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
          goto exception;
        }
        sp[0] = LEPUS_DupValue(ctx, var_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_loc_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(var_buf[idx]))) {
          JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_put_loc_check_init) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(!LEPUS_IsUninitialized(var_buf[idx]))) {
          LEPUS_ThrowReferenceError(ctx, "'this' can be initialized only once");
          goto exception;
        }
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_close_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        close_lexical_var(ctx, sf, idx);
      }
      BREAK;

      CASE(OP_make_loc_ref)
          : CASE(OP_make_arg_ref) : CASE(OP_make_var_ref_ref) : {
        JSVarRef *var_ref;
        JSProperty *pr;
        JSAtom atom;
        int idx;
        atom = get_u32(pc);
        idx = get_u16(pc + 4);
        pc += 6;
        *sp++ = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
        if (opcode == OP_make_var_ref_ref) {
          var_ref = var_refs[idx];
          var_ref->header.ref_count++;
        } else {
          var_ref = get_var_ref(ctx, sf, idx, opcode == OP_make_arg_ref);
          if (!var_ref) goto exception;
        }
        pr = add_property(ctx, LEPUS_VALUE_GET_OBJ(sp[-1]), atom,
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_VARREF);
        if (!pr) {
          free_var_ref(rt, var_ref);
          goto exception;
        }
        pr->u.var_ref = var_ref;
        *sp++ = JS_AtomToValue_RC(ctx, atom);
      }
      BREAK;
      CASE(OP_make_var_ref) : {
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        if (JS_GetGlobalVarRef(ctx, atom, sp)) goto exception;
        sp += 2;
      }
      BREAK;

      CASE(OP_goto) : pc += (int32_t)get_u32(pc);
      if (unlikely(js_poll_interrupts(ctx))) goto exception;
      BREAK;
#if SHORT_OPCODES
      CASE(OP_goto16) : pc += (int16_t)get_u16(pc);
      if (unlikely(js_poll_interrupts(ctx))) goto exception;
      BREAK;
      CASE(OP_goto8) : pc += (int8_t)pc[0];
      if (unlikely(js_poll_interrupts(ctx))) goto exception;
      BREAK;
#endif
      CASE(OP_if_true) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 4;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = JS_ToBoolFree_RC(ctx, op1);
        }
        sp--;
        if (res) {
          pc += (int32_t)get_u32(pc - 4) - 4;
        }
        if (unlikely(js_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
      CASE(OP_if_false) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 4;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = JS_ToBoolFree_RC(ctx, op1);
        }
        sp--;
        if (!res) {
          pc += (int32_t)get_u32(pc - 4) - 4;
        }
        if (unlikely(js_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
#if SHORT_OPCODES
      CASE(OP_if_true8) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 1;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = JS_ToBoolFree_RC(ctx, op1);
        }
        sp--;
        if (res) {
          pc += (int8_t)pc[-1] - 1;
        }
        if (unlikely(js_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
      CASE(OP_if_false8) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 1;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = JS_ToBoolFree_RC(ctx, op1);
        }
        sp--;
        if (!res) {
          pc += (int8_t)pc[-1] - 1;
        }
        if (unlikely(js_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
#endif
      CASE(OP_catch) : {
        int32_t diff;
        diff = get_u32(pc);
        sp[0] = LEPUS_NewCatchOffset(ctx, pc + diff - b->byte_code_buf);
        sp++;
        pc += 4;
      }
      BREAK;
      CASE(OP_gosub) : {
        int32_t diff;
        diff = get_u32(pc);
        /* XXX: should have a different tag to avoid security flaw */
        sp[0] = LEPUS_NewInt32(ctx, pc + 4 - b->byte_code_buf);
        sp++;
        pc += diff;
      }
      BREAK;
      CASE(OP_ret) : {
        LEPUSValue op1;
        uint32_t pos;
        op1 = sp[-1];
        if (unlikely(!LEPUS_VALUE_IS_INT(op1))) goto ret_fail;
        pos = LEPUS_VALUE_GET_INT(op1);
        if (unlikely(pos >= b->byte_code_len)) {
        ret_fail:
          LEPUS_ThrowInternalError(ctx, "invalid ret value");
          goto exception;
        }
        sp--;
        pc = b->byte_code_buf + pos;
      }
      BREAK;

      CASE(OP_for_in_start) : if (js_for_in_start(ctx, sp)) goto exception;
      BREAK;
      CASE(OP_for_in_next) : if (js_for_in_next(ctx, sp)) goto exception;
      sp += 2;
      BREAK;
      CASE(OP_for_of_start)
          : if (js_for_of_start(ctx, sp, FALSE)) goto exception;
      sp += 1;
      *sp++ = LEPUS_NewCatchOffset(ctx, 0);
      BREAK;
      CASE(OP_for_of_next) : {
        int offset = -3 - pc[0];
        pc += 1;
        if (js_for_of_next(ctx, sp, offset)) goto exception;
        sp += 2;
      }
      BREAK;
      CASE(OP_for_await_of_start)
          : if (js_for_of_start(ctx, sp, TRUE)) goto exception;
      sp += 1;
      *sp++ = LEPUS_NewCatchOffset(ctx, 0);
      BREAK;
      CASE(OP_for_await_of_next)
          : if (js_for_await_of_next(ctx, sp)) goto exception;
      sp += 1;
      BREAK;
      CASE(OP_iterator_get_value_done)
          : if (js_iterator_get_value_done(ctx, sp)) goto exception;
      sp += 1;
      BREAK;

      CASE(OP_iterator_close)
          : sp--; /* drop the catch offset to avoid getting caught by exception
                   */
      LEPUS_FreeValue(ctx, sp[-1]); /* drop the next method */
      sp--;
      if (!LEPUS_IsUndefined(sp[-1])) {
        if (JS_IteratorClose(ctx, sp[-1], FALSE)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
      }
      sp--;
      BREAK;
      CASE(OP_iterator_close_return) : {
        LEPUSValue ret_val;
        /* iter_obj next catch_offset ... ret_val ->
           ret_eval iter_obj next catch_offset */
        ret_val = *--sp;
        while (sp > stack_buf && !LEPUS_VALUE_IS_CATCH_OFFSET(sp[-1])) {
          LEPUS_FreeValue(ctx, *--sp);
        }
        if (unlikely(sp < stack_buf + 3)) {
          LEPUS_ThrowInternalError(ctx, "iterator_close_return");
          LEPUS_FreeValue(ctx, ret_val);
          goto exception;
        }
        sp[0] = sp[-1];
        sp[-1] = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = ret_val;
        sp++;
      }
      BREAK;

      CASE(OP_async_iterator_close)
          : /* iter_obj next catch_offset -> value flag */
      {
        LEPUSValue ret, method;
        int ret_flag;
        method =
            JS_GetPropertyInternal_RC(ctx, sp[-3], JS_ATOM_return, sp[-3], 0);
        if (LEPUS_IsException(method)) goto exception;
        if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
          ret = LEPUS_UNDEFINED;
          ret_flag = TRUE;
        } else {
          ret = JS_CallFree(ctx, method, sp[-3], 0, NULL);
          if (LEPUS_IsException(ret)) goto exception;
          ret_flag = FALSE;
        }
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-3] = ret;
        sp[-2] = LEPUS_NewBool(ctx, ret_flag);
        sp -= 1;
      }
      BREAK;

      CASE(OP_async_iterator_next)
          : /* stack: iter_obj next catch_offset val */
      {
        LEPUSValue ret;
        ret = JS_Call_RC(ctx, sp[-3], sp[-4], 1, (LEPUSValueConst *)(sp - 1));
        if (LEPUS_IsException(ret)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = ret;
      }
      BREAK;

      CASE(OP_async_iterator_get)
          : /* stack: iter_obj next catch_offset val */
      {
        LEPUSValue method, ret;
        BOOL ret_flag;
        int flags;
        flags = *pc++;
        if (flags == 2) {
          LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
          goto exception;
        }
        method = JS_GetPropertyInternal_RC(
            ctx, sp[-4], flags ? JS_ATOM_throw : JS_ATOM_return, sp[-4], 0);
        if (LEPUS_IsException(method)) goto exception;
        if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
          ret_flag = TRUE;
        } else {
          ret =
              JS_CallFree(ctx, method, sp[-4], 1, (LEPUSValueConst *)(sp - 1));
          if (LEPUS_IsException(ret)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret;
          ret_flag = FALSE;
        }
        sp[0] = LEPUS_NewBool(ctx, ret_flag);
        sp += 1;
      }
      BREAK;

      CASE(OP_lnot) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = JS_ToBoolFree_RC(ctx, op1);
        }
        sp[-1] = LEPUS_NewBool(ctx, !res);
      }
      BREAK;

      CASE(OP_get_field) : {
        LEPUSValue val;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = JS_GetPropertyInternal_RC(ctx, sp[-1], atom, sp[-1], 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
      }
      BREAK;

      CASE(OP_get_field2) : {
        LEPUSValue val;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = JS_GetPropertyInternal_RC(ctx, sp[-1], atom, sp[-1], 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_put_field) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = JS_SetPropertyInternal_RC(ctx, sp[-2], atom, sp[-1],
                                        LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_private_symbol) : {
        JSAtom atom;
        LEPUSValue val;

        atom = get_u32(pc);
        pc += 4;
        val = JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
        if (LEPUS_IsException(val)) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_get_private_field) : {
        LEPUSValue val;

        val = JS_GetPrivateField(ctx, sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp[-2] = val;
        sp--;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_put_private_field) : {
        int ret;
        ret = JS_SetPrivateField(ctx, sp[-3], sp[-1], sp[-2]);
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_private_field) : {
        int ret;
        ret = JS_DefinePrivateField(ctx, sp[-3], sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_field) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = JS_DefinePropertyValue_RC(ctx, sp[-2], atom, sp[-1],
                                        LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
        sp--;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_set_name) : {
        int ret;
        JSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = JS_DefineObjectName(ctx, sp[-1], atom, LEPUS_PROP_CONFIGURABLE);
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;
      CASE(OP_set_name_computed) : {
        int ret;
        ret = JS_DefineObjectNameComputed(ctx, sp[-1], sp[-2],
                                          LEPUS_PROP_CONFIGURABLE);
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;
      CASE(OP_set_proto) : {
        LEPUSValue proto;
        proto = sp[-1];
        if (LEPUS_IsObject(proto) || LEPUS_IsNull(proto)) {
          if (JS_SetPrototypeInternal(ctx, sp[-2], proto, TRUE) < 0)
            goto exception;
        }
        LEPUS_FreeValue(ctx, proto);
        sp--;
      }
      BREAK;
      CASE(OP_set_home_object) : js_method_set_home_object(ctx, sp[-1], sp[-2]);
      BREAK;
      CASE(OP_define_method) : CASE(OP_define_method_computed) : {
        LEPUSValue getter, setter, value;
        LEPUSValueConst obj;
        JSAtom atom;
        int flags, ret, op_flags;
        BOOL is_computed;
#define OP_DEFINE_METHOD_METHOD 0
#define OP_DEFINE_METHOD_GETTER 1
#define OP_DEFINE_METHOD_SETTER 2
#define OP_DEFINE_METHOD_ENUMERABLE 4

        is_computed = (opcode == OP_define_method_computed);
        if (is_computed) {
          atom = js_value_to_atom(ctx, sp[-2]);
          if (unlikely(atom == JS_ATOM_NULL)) goto exception;
          opcode += OP_define_method - OP_define_method_computed;
        } else {
          atom = get_u32(pc);
          pc += 4;
        }
        op_flags = *pc++;

        obj = sp[-2 - is_computed];
        flags = LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE |
                LEPUS_PROP_HAS_ENUMERABLE | LEPUS_PROP_THROW;
        if (op_flags & OP_DEFINE_METHOD_ENUMERABLE)
          flags |= LEPUS_PROP_ENUMERABLE;
        op_flags &= 3;
        value = LEPUS_UNDEFINED;
        getter = LEPUS_UNDEFINED;
        setter = LEPUS_UNDEFINED;
        if (op_flags == OP_DEFINE_METHOD_METHOD) {
          value = sp[-1];
          flags |= LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
                   LEPUS_PROP_WRITABLE;
        } else if (op_flags == OP_DEFINE_METHOD_GETTER) {
          getter = sp[-1];
          flags |= LEPUS_PROP_HAS_GET;
        } else {
          setter = sp[-1];
          flags |= LEPUS_PROP_HAS_SET;
        }
        ret = js_method_set_properties(ctx, sp[-1], atom, flags, obj);
        if (ret >= 0) {
          ret = JS_DefineProperty_RC(ctx, obj, atom, value, getter, setter,
                                     flags);
        }
        LEPUS_FreeValue(ctx, sp[-1]);
        if (is_computed) {
          LEPUS_FreeAtom(ctx, atom);
          LEPUS_FreeValue(ctx, sp[-2]);
        }
        sp -= 1 + is_computed;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_class) : {
        int class_flags;
        JSAtom atom;

        atom = get_u32(pc);
        class_flags = pc[4];
        pc += 5;
        if (js_op_define_class(ctx, sp, atom, class_flags, var_refs, sf) < 0)
          goto exception;
      }
      BREAK;

      CASE(OP_get_array_el) : {
        LEPUSValue val;

        val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp[-2] = val;
        sp--;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_get_array_el2) : {
        LEPUSValue val;

        val = JS_GetPropertyValue(ctx, sp[-2], sp[-1]);
        sp[-1] = val;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_get_ref_value) : {
        LEPUSValue val;
        if (unlikely(LEPUS_IsUndefined(sp[-2]))) {
          JSAtom atom = js_value_to_atom(ctx, sp[-1]);
          if (atom != JS_ATOM_NULL) {
            JS_ThrowReferenceErrorNotDefined(ctx, atom);
            LEPUS_FreeAtom(ctx, atom);
          }
          goto exception;
        }
        val = JS_GetPropertyValue(ctx, sp[-2], LEPUS_DupValue(ctx, sp[-1]));
        if (unlikely(LEPUS_IsException(val))) goto exception;
        sp[0] = val;
        sp++;
      }
      BREAK;

      CASE(OP_get_super_value) : {
        LEPUSValue val;
        JSAtom atom;
        atom = js_value_to_atom(ctx, sp[-1]);
        if (unlikely(atom == JS_ATOM_NULL)) goto exception;
        val = LEPUS_GetPropertyInternal(ctx, sp[-2], atom, sp[-3], FALSE);
        LEPUS_FreeAtom(ctx, atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-3]);
        sp[-3] = val;
        sp -= 2;
      }
      BREAK;

      CASE(OP_put_array_el) : {
        int ret;

        ret = JS_SetPropertyValue(
            ctx, sp[-3], sp[-2], sp[-1],
            (LEPUS_IsTypedArray(ctx, sp[-3]) ? 0 : LEPUS_PROP_THROW_STRICT));
        LEPUS_FreeValue(ctx, sp[-3]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_ref_value) : {
        int ret;
        if (unlikely(LEPUS_IsUndefined(sp[-3]))) {
          if (is_strict_mode(ctx)) {
            JSAtom atom = js_value_to_atom(ctx, sp[-2]);
            if (atom != JS_ATOM_NULL) {
              JS_ThrowReferenceErrorNotDefined(ctx, atom);
              LEPUS_FreeAtom(ctx, atom);
            }
            goto exception;
          } else {
            sp[-3] = LEPUS_DupValue(ctx, ctx->global_obj);
          }
        }
        ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1],
                                  LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-3]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_super_value) : {
        int ret;
        JSAtom atom;
        if (LEPUS_VALUE_IS_NOT_OBJECT(sp[-3])) {
          JS_ThrowTypeErrorNotAnObject(ctx);
          goto exception;
        }
        atom = js_value_to_atom(ctx, sp[-2]);
        if (unlikely(atom == JS_ATOM_NULL)) goto exception;
        ret = JS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(sp[-3]), atom,
                                    sp[-1], sp[-4], LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeAtom(ctx, atom);
        LEPUS_FreeValue(ctx, sp[-4]);
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 4;
        if (ret < 0) goto exception;
      }
      BREAK;

      CASE(OP_define_array_el) : {
        int ret;
        ret = JS_DefinePropertyValueValue(ctx, sp[-3],
                                          LEPUS_DupValue(ctx, sp[-2]), sp[-1],
                                          LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
        sp -= 1;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_append)
          : /* array pos enumobj -- array pos */
      {
        if (js_append_enumerate(ctx, sp)) goto exception;
        LEPUS_FreeValue(ctx, *--sp);
      }
      BREAK;

      CASE(OP_copy_data_properties)
          : /* target source excludeList */
      {
        /* stack offsets (-1 based):
           2 bits for target,
           3 bits for source,
           2 bits for exclusionList */
        int mask;

        mask = *pc++;
        if (JS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],
                                  sp[-1 - ((mask >> 2) & 7)],
                                  sp[-1 - ((mask >> 5) & 7)], 0))
          goto exception;
      }
      BREAK;

      CASE(OP_add) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(op1) + LEPUS_VALUE_GET_INT(op2);
          if (unlikely((int)r != r)) goto add_slow;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          sp[-2] = __JS_NewFloat64(
              ctx, LEPUS_VALUE_GET_FLOAT64(op1) + LEPUS_VALUE_GET_FLOAT64(op2));
          sp--;
        } else {
        add_slow:
          if (js_add_slow(ctx, sp)) goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_add_loc) : {
        LEPUSValue *pv;
        int idx;
        idx = *pc;
        pc += 1;

        pv = &var_buf[idx];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(*pv, sp[-1]))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(*pv) + LEPUS_VALUE_GET_INT(sp[-1]);
          if (unlikely((int)r != r)) goto add_loc_slow;
          *pv = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_IsString(*pv)) {
          LEPUSValue op1;
          op1 = sp[-1];
          sp--;
          op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
          if (LEPUS_IsException(op1)) {
            goto exception;
          }
          op1 = JS_ConcatString(ctx, LEPUS_DupValue(ctx, *pv), op1);
          if (LEPUS_IsException(op1)) {
            goto exception;
          }
          set_value(ctx, pv, op1);
        } else {
          LEPUSValue ops[2];
        add_loc_slow:
          /* In case of exception, js_add_slow frees ops[0]
             and ops[1]. */
          ops[0] = LEPUS_DupValue(ctx, *pv);
          ops[1] = sp[-1];
          sp--;
          if (js_add_slow(ctx, ops + 2)) {
            goto exception;
          }
          set_value(ctx, pv, ops[0]);
        }
      }
      BREAK;
      CASE(OP_sub) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(op1) - LEPUS_VALUE_GET_INT(op2);
          if (unlikely((int)r != r)) goto binary_arith_slow;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          sp[-2] = __JS_NewFloat64(
              ctx, LEPUS_VALUE_GET_FLOAT64(op1) - LEPUS_VALUE_GET_FLOAT64(op2));
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
      CASE(OP_mul) : {
        LEPUSValue op1, op2;
        double d;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int32_t v1, v2;
          int64_t r;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          r = (int64_t)v1 * v2;
#ifdef CONFIG_BIGNUM
          if (unlikely((int)r != r) || (r == 0 && !is_bignum_mode(ctx)))
            goto binary_arith_slow;
#else
          if (unlikely((int)r != r)) {
            d = (double)r;
            goto mul_fp_res;
          }
          /* need to test zero case for -0 result */
          if (unlikely(r == 0 && (v1 | v2) < 0)) {
            d = -0.0;
            goto mul_fp_res;
          }
#endif
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          d = LEPUS_VALUE_GET_FLOAT64(op1) * LEPUS_VALUE_GET_FLOAT64(op2);
#ifndef CONFIG_BIGNUM
        mul_fp_res:
#endif
          sp[-2] = __JS_NewFloat64(ctx, d);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
#ifdef CONFIG_BIGNUM
      CASE(OP_math_div) : CASE(OP_div) : goto binary_arith_slow;
#else
      CASE(OP_div) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int v1, v2;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          sp[-2] = LEPUS_NewFloat64(ctx, (double)v1 / (double)v2);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
#endif
      CASE(OP_mod)
          :
#ifdef CONFIG_BIGNUM
            CASE(OP_math_mod)
          :
#endif
      {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int v1, v2, r;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          /* We must avoid v2 = 0, v1 = INT32_MIN and v2 =
             -1 and the cases where the result is -0. */
          if (unlikely(v1 < 0 || v2 <= 0)) goto binary_arith_slow;
          r = v1 % v2;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
      CASE(OP_pow)
          :
#ifdef CONFIG_BIGNUM
            CASE(OP_math_pow)
          :
#endif
            binary_arith_slow
          : if (js_binary_arith_slow(
                    ctx, sp, static_cast<OPCodeEnum>(opcode))) goto exception;
      sp--;
      BREAK;

      CASE(OP_plus) : {
        LEPUSValue op1;
        uint32_t tag;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) {
        } else {
          if (js_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_neg) : {
        LEPUSValue op1;
        int val;
        double d;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
#ifdef CONFIG_BIGNUM
          if (unlikely(val == INT32_MIN) || (val == 0 && !is_bignum_mode(ctx)))
            goto slow_neg;
#else
          /* Note: -0 cannot be expressed as integer */
          if (unlikely(val == 0)) {
            d = -0.0;
            goto neg_fp_res;
          }
          if (unlikely(val == INT32_MIN)) {
            d = -(double)val;
            goto neg_fp_res;
          }
#endif
          sp[-1] = LEPUS_NewInt32(ctx, -val);
        } else if (LEPUS_VALUE_IS_FLOAT64(op1)) {
          d = -LEPUS_VALUE_GET_FLOAT64(op1);
#ifndef CONFIG_BIGNUM
        neg_fp_res:
#endif
          sp[-1] = __JS_NewFloat64(ctx, d);
        } else {
#ifdef CONFIG_BIGNUM
        slow_neg:
#endif
          if (js_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_inc) : {
        LEPUSValue op1;
        int val;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MAX)) goto inc_slow;
          sp[-1] = LEPUS_NewInt32(ctx, val + 1);
        } else {
        inc_slow:
          if (js_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_dec) : {
        LEPUSValue op1;
        int val;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MIN)) goto dec_slow;
          sp[-1] = LEPUS_NewInt32(ctx, val - 1);
        } else {
        dec_slow:
          if (js_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_post_inc)
          : CASE(OP_post_dec)
          : if (js_post_inc_slow(
                    ctx, sp, static_cast<OPCodeEnum>(opcode))) goto exception;
      sp++;
      BREAK;
      CASE(OP_inc_loc) : {
        LEPUSValue op1;
        int val;
        int idx;
        idx = *pc;
        pc += 1;

        op1 = var_buf[idx];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MAX)) goto inc_loc_slow;
          var_buf[idx] = LEPUS_NewInt32(ctx, val + 1);
        } else {
        inc_loc_slow:
          /* must duplicate otherwise the variable value may
            be destroyed before JS code accesses it */
          op1 = LEPUS_DupValue(ctx, op1);
          if (js_unary_arith_slow(ctx, &op1 + 1, OP_inc)) goto exception;
          set_value(ctx, &var_buf[idx], op1);
        }
      }
      BREAK;
      CASE(OP_dec_loc) : {
        LEPUSValue op1;
        int val;
        int idx;
        idx = *pc;
        pc += 1;

        op1 = var_buf[idx];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MIN)) goto dec_loc_slow;
          var_buf[idx] = LEPUS_NewInt32(ctx, val - 1);
        } else {
        dec_loc_slow:
          /* must duplicate otherwise the variable value may
            be destroyed before JS code accesses it */
          op1 = LEPUS_DupValue(ctx, op1);
          if (js_unary_arith_slow(ctx, &op1 + 1, OP_dec)) goto exception;
          set_value(ctx, &var_buf[idx], op1);
        }
      }
      BREAK;
      CASE(OP_not) : {
        LEPUSValue op1;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          sp[-1] = LEPUS_NewInt32(ctx, ~LEPUS_VALUE_GET_INT(op1));
        } else {
          if (js_not_slow(ctx, sp)) goto exception;
        }
      }
      BREAK;

      CASE(OP_shl) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v1, v2;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
#ifdef CONFIG_BIGNUM
          {
            int64_t r;
            if (is_bignum_mode(ctx)) {
              if (v2 > 0x1f) goto shl_slow;
              r = (int64_t)v1 << v2;
              if ((int)r != r) goto shl_slow;
            } else {
              v2 &= 0x1f;
            }
          }
#else
          v2 &= 0x1f;
#endif
          sp[-2] = LEPUS_NewInt32(ctx, v1 << v2);
          sp--;
        } else {
#ifdef CONFIG_BIGNUM
        shl_slow:
#endif
          if (js_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_shr) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v2;
          v2 = LEPUS_VALUE_GET_INT(op2);
          /* v1 >>> v2 retains its LEPUS semantics if CONFIG_BIGNUM */
          v2 &= 0x1f;
          sp[-2] = JS_NewUint32(ctx, (uint32_t)LEPUS_VALUE_GET_INT(op1) >> v2);
          sp--;
        } else {
          if (js_shr_slow(ctx, sp)) goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_sar) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v2;
          v2 = LEPUS_VALUE_GET_INT(op2);
#ifdef CONFIG_BIGNUM
          if (unlikely(v2 > 0x1f)) {
            if (is_bignum_mode(ctx))
              goto sar_slow;
            else
              v2 &= 0x1f;
          }
#else
          v2 &= 0x1f;
#endif
          sp[-2] = LEPUS_NewInt32(ctx, (int)LEPUS_VALUE_GET_INT(op1) >> v2);
          sp--;
        } else {
#ifdef CONFIG_BIGNUM
        sar_slow:
#endif
          if (js_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_and) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) & LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (js_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_or) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) | LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (js_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_xor) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) ^ LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (js_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;

#define OP_CMP(opcode, binary_op, slow_call)                                 \
  CASE(opcode) : {                                                           \
    LEPUSValue op1, op2;                                                     \
    op1 = sp[-2];                                                            \
    op2 = sp[-1];                                                            \
    if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {                         \
      sp[-2] = LEPUS_NewBool(                                                \
          ctx, LEPUS_VALUE_GET_INT(op1) binary_op LEPUS_VALUE_GET_INT(op2)); \
      sp--;                                                                  \
    } else {                                                                 \
      if (slow_call) goto exception;                                         \
      sp--;                                                                  \
    }                                                                        \
  }                                                                          \
  BREAK

      OP_CMP(OP_lt, <,
             js_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_lte, <=,
             js_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_gt, >,
             js_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_gte, >=,
             js_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_eq, ==, js_eq_slow(ctx, sp, 0));
      OP_CMP(OP_neq, !=, js_eq_slow(ctx, sp, 1));
      OP_CMP(OP_strict_eq, ==, js_strict_eq_slow(ctx, sp, 0));
      OP_CMP(OP_strict_neq, !=, js_strict_eq_slow(ctx, sp, 1));

#ifdef CONFIG_BIGNUM
      CASE(OP_mul_pow10) : if (js_mul_pow10(ctx, sp)) goto exception;
      sp--;
      BREAK;
#endif
      CASE(OP_in) : if (js_operator_in(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_instanceof) : if (js_operator_instanceof(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_typeof) : {
        LEPUSValue op1;
        JSAtom atom;

        op1 = sp[-1];
        atom = js_operator_typeof(ctx, op1);
        LEPUS_FreeValue(ctx, op1);
        sp[-1] = LEPUS_AtomToString(ctx, atom);
      }
      BREAK;
      CASE(OP_delete) : if (js_operator_delete(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_delete_var) : {
        JSAtom atom;
        int ret;

        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_DeleteProperty(ctx, ctx->global_obj, atom, 0);
        if (unlikely(ret < 0)) goto exception;
        *sp++ = LEPUS_NewBool(ctx, ret);
      }
      BREAK;

      CASE(OP_to_object) : if (LEPUS_VALUE_IS_NOT_OBJECT(sp[-1])) {
        ret_val = LEPUS_ToObject(ctx, sp[-1]);
        if (LEPUS_IsException(ret_val)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = ret_val;
      }
      BREAK;

      CASE(OP_to_propkey) : switch (LEPUS_VALUE_GET_TAG(sp[-1])) {
        case LEPUS_TAG_INT:
        case LEPUS_TAG_STRING:
        case LEPUS_TAG_SYMBOL:
        case LEPUS_TAG_SEPARABLE_STRING:
          break;
        default:
          ret_val = LEPUS_ToPropertyKey(ctx, sp[-1]);
          if (LEPUS_IsException(ret_val)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret_val;
          break;
      }
      BREAK;

      CASE(OP_to_propkey2)
          : /* must be tested first */
            if (unlikely(LEPUS_IsUndefined(sp[-2]) || LEPUS_IsNull(sp[-2]))) {
        LEPUS_ThrowTypeError(ctx, "value has no property");
        goto exception;
      }
      switch (LEPUS_VALUE_GET_TAG(sp[-1])) {
        case LEPUS_TAG_INT:
        case LEPUS_TAG_STRING:
        case LEPUS_TAG_SYMBOL:
        case LEPUS_TAG_SEPARABLE_STRING:
          break;
        default:
          ret_val = LEPUS_ToPropertyKey(ctx, sp[-1]);
          if (LEPUS_IsException(ret_val)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret_val;
          break;
      }
      BREAK;
#if 0
        CASE(OP_to_string):
            if (!LEPUS_VALUE_IS_STRING(sp[-1])) {
                ret_val = JS_ToString_RC(ctx, sp[-1]);
                if (LEPUS_IsException(ret_val))
                    goto exception;
                LEPUS_FreeValue(ctx, sp[-1]);
                sp[-1] = ret_val;
            }
            BREAK;
#endif
      CASE(OP_with_get_var)
          : CASE(OP_with_put_var)
          : CASE(OP_with_delete_var)
          : CASE(OP_with_make_ref)
          : CASE(OP_with_get_ref) : CASE(OP_with_get_ref_undef) : {
        JSAtom atom;
        int32_t diff;
        LEPUSValue obj, val;
        int ret, is_with;
        atom = get_u32(pc);
        diff = get_u32(pc + 4);
        is_with = pc[8];
        pc += 9;

        obj = sp[-1];
        ret = LEPUS_HasProperty(ctx, obj, atom);
        if (unlikely(ret < 0)) goto exception;
        if (ret) {
          if (is_with) {
            ret = js_has_unscopable(ctx, obj, atom);
            if (unlikely(ret < 0)) goto exception;
            if (ret) goto no_with;
          }
          switch (opcode) {
            case OP_with_get_var:
              val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              set_value(ctx, &sp[-1], val);
              break;
            case OP_with_put_var:
              ret = JS_SetPropertyInternal_RC(ctx, obj, atom, sp[-2],
                                              LEPUS_PROP_THROW_STRICT);
              LEPUS_FreeValue(ctx, sp[-1]);
              sp -= 2;
              if (unlikely(ret < 0)) goto exception;
              break;
            case OP_with_delete_var:
              ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
              if (unlikely(ret < 0)) goto exception;
              LEPUS_FreeValue(ctx, sp[-1]);
              sp[-1] = LEPUS_NewBool(ctx, ret);
              break;
            case OP_with_make_ref:
              /* produce a pair object/propname on the stack */
              *sp++ = JS_AtomToValue_RC(ctx, atom);
              break;
            case OP_with_get_ref:
              /* produce a pair object/method on the stack */
              val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              *sp++ = val;
              break;
            case OP_with_get_ref_undef:
              /* produce a pair undefined/function on the stack */
              val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              LEPUS_FreeValue(ctx, sp[-1]);
              sp[-1] = LEPUS_UNDEFINED;
              *sp++ = val;
              break;
          }
          pc += diff - 5;
        } else {
        no_with:
          /* if not jumping, drop the object argument */
          LEPUS_FreeValue(ctx, sp[-1]);
          sp--;
        }
      }
      BREAK;

      CASE(OP_await) : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_AWAIT);
      goto done_generator;
      CASE(OP_yield) : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_YIELD);
      goto done_generator;
      CASE(OP_yield_star)
          : CASE(OP_async_yield_star)
          : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_YIELD_STAR);
      goto done_generator;
      CASE(OP_return_async)
          : CASE(OP_initial_yield) : ret_val = LEPUS_UNDEFINED;
      goto done_generator;

      CASE(OP_nop) : BREAK;
#if SHORT_OPCODES
      CASE(OP_is_undefined) : if (LEPUS_VALUE_IS_UNDEFINED(sp[-1])) {
        goto set_true;
      }
      else {
        goto free_and_set_false;
      }
      CASE(OP_is_null) : if (LEPUS_VALUE_IS_NULL(sp[-1])) { goto set_true; }
      else {
        goto free_and_set_false;
      }
      CASE(OP_is_function)
          : if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_function) {
        goto free_and_set_true;
      }
      else {
        goto free_and_set_false;
      }
    free_and_set_true:
      LEPUS_FreeValue(ctx, sp[-1]);
    set_true:
      sp[-1] = LEPUS_TRUE;
      BREAK;
    free_and_set_false:
      LEPUS_FreeValue(ctx, sp[-1]);
      sp[-1] = LEPUS_FALSE;
      BREAK;
#endif
      CASE(OP_invalid)
          : DEFAULT
          : LEPUS_ThrowInternalError(ctx, "invalid opcode: pc=%u opcode=0x%02x",
                                     (int)(pc - b->byte_code_buf - 1), opcode);
      goto exception;
    }
  }
exception:
  if (rt->exception_needs_backtrace) {
    /* add the backtrace information now (it is not done
       before if the exception happens in a bytecode
       operation */
    build_backtrace(ctx, rt->current_exception, NULL, 0, pc, 0);
  }
  if (!JS_IsUncatchableError(ctx, rt->current_exception)) {
    while (sp > stack_buf) {
      LEPUSValue val = *--sp;
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_VALUE_IS_CATCH_OFFSET(val)) {
        int pos = LEPUS_VALUE_GET_CATCH_OFFSET(val);
        if (pos == 0) {
          /* enumerator: close it with a throw */
          LEPUS_FreeValue(ctx, sp[-1]); /* drop the next method */
          sp--;
          JS_IteratorClose(ctx, sp[-1], TRUE);
        } else {
          *sp++ = rt->current_exception;
          rt->current_exception = LEPUS_NULL;
          pc = b->byte_code_buf + pos;
          goto restart;
        }
      }
    }
  }
  ret_val = LEPUS_EXCEPTION;
  /* the local variables are freed by the caller in the generator
     case. Hence the label 'done' should never be reached in a
     generator function. */
  if (b->func_kind != JS_FUNC_NORMAL) {
  done_generator:
    sf->cur_pc = pc;
    sf->cur_sp = sp;
  } else {
  done:
    if (unlikely(!list_empty(&sf->var_ref_list))) {
      /* variable references reference the stack: must close them */
      close_var_refs(rt, sf);
    }
    lepus_free(ctx, sf->var_refs);
    /* free the local variables and stack */
    for (pval = local_buf; pval < sp; pval++) {
      LEPUS_FreeValue(ctx, *pval);
    }
  }
#ifdef OS_IOS
  if (need_free_local_buf) js_pop_virtual_sp(ctx, alloca_size);
#endif
  rt->current_stack_frame = sf->prev_frame;
  return ret_val;
}

QJS_STATIC inline LEPUSValue JS_CallInternalTI(LEPUSContext *caller_ctx,
                                               LEPUSValue func_obj,
                                               LEPUSValue this_obj,
                                               LEPUSValue new_target, int argc,
                                               LEPUSValue *argv, int flags) {
#ifdef ENABLE_PRIMJS_SNAPSHOT
  if (caller_ctx->rt->use_primjs) {
    return entry(this_obj, new_target, func_obj, (address)caller_ctx, argc,
                 argv, flags);
  }
#endif
  return JS_CallInternal(caller_ctx, func_obj, this_obj, new_target, argc, argv,
                         flags);
}

static LEPUSValue JS_Call_RC(LEPUSContext *ctx, LEPUSValueConst func_obj,
                             LEPUSValueConst this_obj, int argc,
                             LEPUSValueConst *argv) {
  LEPUSValue res =
      JS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                        (LEPUSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
  return res;
}

LEPUSValue LEPUS_Call(LEPUSContext *ctx, LEPUSValueConst func_obj,
                      LEPUSValueConst this_obj, int argc,
                      LEPUSValueConst *argv) {
  CallGCFunc(JS_Call_GC, ctx, func_obj, this_obj, argc, argv);
  return JS_Call_RC(ctx, func_obj, this_obj, argc, argv);
}

QJS_STATIC LEPUSValue JS_CallFree(LEPUSContext *ctx, LEPUSValue func_obj,
                                  LEPUSValueConst this_obj, int argc,
                                  LEPUSValueConst *argv) {
  LEPUSValue res =
      JS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                        (LEPUSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
  LEPUS_FreeValue(ctx, func_obj);
  return res;
}

QJS_STATIC LEPUSValue js_get_prototype_from_ctor(LEPUSContext *ctx,
                                                 LEPUSValueConst ctor,
                                                 LEPUSValueConst def_proto) {
  LEPUSValue proto;
  proto = JS_GetPropertyInternal_RC(ctx, ctor, JS_ATOM_prototype, ctor, 0);
  if (LEPUS_IsException(proto)) return proto;
  if (!LEPUS_IsObject(proto)) {
    LEPUS_FreeValue(ctx, proto);
    proto = LEPUS_DupValue(ctx, def_proto);
  }
  return proto;
}

QJS_STATIC LEPUSValue js_create_from_ctor(LEPUSContext *ctx,
                                          LEPUSValueConst ctor, int class_id) {
  CallGCFunc(js_create_from_ctor_GC, ctx, ctor, class_id);
  LEPUSValue proto, obj;
  if (LEPUS_IsUndefined(ctor)) {
    proto = LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
  } else {
    proto = JS_GetPropertyInternal_RC(ctx, ctor, JS_ATOM_prototype, ctor, 0);
    if (LEPUS_IsException(proto)) return proto;
    if (!LEPUS_IsObject(proto)) {
      LEPUS_FreeValue(ctx, proto);
      /* check if revoked proxy */
      {
        JSProxyData *s =
            static_cast<JSProxyData *>(LEPUS_GetOpaque(ctor, JS_CLASS_PROXY));
        if (s && s->is_revoked) return JS_ThrowTypeErrorRevokedProxy(ctx);
      }
      /* XXX: should use the ctor realm instead of 'ctx' */
      proto = LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
    }
  }
  obj = JS_NewObjectProtoClass_RC(ctx, proto, class_id);
  LEPUS_FreeValue(ctx, proto);
  return obj;
}

/* argv[] is modified if (flags & CALL_FLAG_COPY_ARGV) = 0. */
LEPUSValue JS_CallConstructorInternal(LEPUSContext *ctx,
                                      LEPUSValueConst func_obj,
                                      LEPUSValueConst new_target, int argc,
                                      LEPUSValue *argv, int flags) {
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;

  if (js_poll_interrupts(ctx)) return LEPUS_EXCEPTION;
  flags |= LEPUS_CALL_FLAG_CONSTRUCTOR;
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func_obj))) goto not_a_function;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (unlikely(!p->is_constructor))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
    LEPUSClassCall *call_func;
    call_func = ctx->rt->class_array[p->class_id].call;
    if (!call_func) {
    not_a_function:
      return JS_ThrowTypeErrorNotFunction(ctx);
    }
    LEPUSValue res = call_func(ctx, func_obj, new_target, argc,
                               (LEPUSValueConst *)argv, flags);
    return res;
  }

  b = p->u.func.function_bytecode;
  if (b->is_derived_class_constructor) {
    LEPUSValue res = JS_CallInternalTI(ctx, func_obj, LEPUS_UNDEFINED,
                                       new_target, argc, argv, flags);
    return res;
  } else {
    LEPUSValue obj, ret;
    /* legacy constructor behavior */
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);
    if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
    ret = JS_CallInternalTI(ctx, func_obj, obj, new_target, argc, argv, flags);
    if (LEPUS_VALUE_IS_OBJECT(ret) || LEPUS_IsException(ret)) {
      LEPUS_FreeValue(ctx, obj);
      return ret;
    } else {
      LEPUS_FreeValue(ctx, ret);
      return obj;
    }
  }
}

LEPUSValue LEPUS_CallConstructor2(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  LEPUSValueConst new_target, int argc,
                                  LEPUSValueConst *argv) {
  CallGCFunc(JS_CallConstructor2_GC, ctx, func_obj, new_target, argc, argv);
  return JS_CallConstructorInternal(ctx, func_obj, new_target, argc,
                                    (LEPUSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
}

LEPUSValue LEPUS_CallConstructor(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                 int argc, LEPUSValueConst *argv) {
  CallGCFunc(JS_CallConstructor_GC, ctx, func_obj, argc, argv);
  return JS_CallConstructorInternal(ctx, func_obj, func_obj, argc,
                                    (LEPUSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
}

LEPUSValue LEPUS_Invoke(LEPUSContext *ctx, LEPUSValueConst this_val,
                        JSAtom atom, int argc, LEPUSValueConst *argv) {
  CallGCFunc(JS_Invoke_GC, ctx, this_val, atom, argc, argv);
  LEPUSValue func_obj;
  func_obj = JS_GetPropertyInternal_RC(ctx, this_val, atom, this_val, 0);
  if (LEPUS_IsException(func_obj)) return func_obj;
  return JS_CallFree(ctx, func_obj, this_val, argc, argv);
}

QJS_STATIC LEPUSValue JS_InvokeFree(LEPUSContext *ctx, LEPUSValue this_val,
                                    JSAtom atom, int argc,
                                    LEPUSValueConst *argv) {
  LEPUSValue res = LEPUS_Invoke(ctx, this_val, atom, argc, argv);
  LEPUS_FreeValue(ctx, this_val);
  return res;
}

/* JSAsyncFunctionState (used by generator and async functions) */
QJS_STATIC __exception int async_func_init(LEPUSContext *ctx,
                                           JSAsyncFunctionState *s,
                                           LEPUSValueConst func_obj,
                                           LEPUSValueConst this_obj, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;
  LEPUSStackFrame *sf;
  int local_count, i, arg_buf_len, n;

  sf = &s->frame;
  init_list_head(&sf->var_ref_list);
  list_add_tail(&s->link, &ctx->rt->async_func_sf);
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  b = p->u.func.function_bytecode;
  sf->js_mode = b->js_mode;
  sf->cur_pc = b->byte_code_buf;
  arg_buf_len = max_int(b->arg_count, argc);
  local_count =
      arg_buf_len + b->var_count + b->stack_size + 10 * sizeof(char *);
  sf->arg_buf = static_cast<LEPUSValue *>(
      lepus_malloc(ctx, sizeof(LEPUSValue) * max_int(local_count, 1)));
  if (!sf->arg_buf) return -1;
  sf->cur_func = LEPUS_DupValue(ctx, func_obj);
  s->this_val = LEPUS_DupValue(ctx, this_obj);
  s->argc = argc;
  sf->arg_count = arg_buf_len;
  sf->var_buf = sf->arg_buf + arg_buf_len;
  sf->cur_sp = sf->var_buf + b->var_count;
  for (i = 0; i < argc; i++) sf->arg_buf[i] = LEPUS_DupValue(ctx, argv[i]);
  n = arg_buf_len + b->var_count;
  for (i = argc; i < n; i++) sf->arg_buf[i] = LEPUS_UNDEFINED;
  sf->ref_size = sf->arg_count + b->var_count;
  sf->var_refs = nullptr;
  return 0;
}

QJS_STATIC void async_func_mark(LEPUSRuntime *rt, JSAsyncFunctionState *s,
                                LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSStackFrame *sf;
  LEPUSValue *sp;
  list_head *el;
  JSVarRef *var_ref;

  sf = &s->frame;
  // Because sf->var_refs refer var_ref.
  list_for_each(el, &sf->var_ref_list) {
    var_ref = list_entry(el, JSVarRef, link);
    mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_VAR_REF, var_ref), local_idx);
  }

  JS_MarkValue_RC(rt, sf->cur_func, mark_func);
  JS_MarkValue_RC(rt, s->this_val, mark_func);
  if (sf->cur_sp) {
    /* if the function is running, cur_sp is not known so we
       cannot mark the stack. Marking the variables is not needed
       because a running function cannot be part of a removable
       cycle */
    for (sp = sf->arg_buf; sp < sf->cur_sp; sp++) {
      JS_MarkValue_RC(rt, *sp, mark_func);
    }
  }
}

QJS_STATIC void async_func_free(LEPUSRuntime *rt, JSAsyncFunctionState *s) {
  LEPUSStackFrame *sf;
  LEPUSValue *sp;

  sf = &s->frame;
  list_del(&s->link);

  /* close the closure variables. */
  close_var_refs(rt, sf);
  lepus_free_rt(rt, sf->var_refs);
  if (sf->arg_buf) {
    /* cannot free the function if it is running */
    assert(sf->cur_sp != NULL);

    for (sp = sf->arg_buf; sp < sf->cur_sp; sp++) {
      LEPUS_FreeValueRT(rt, *sp);
    }
    lepus_free_rt(rt, sf->arg_buf);
  }
  LEPUS_FreeValueRT(rt, sf->cur_func);
  LEPUS_FreeValueRT(rt, s->this_val);
}

QJS_STATIC LEPUSValue async_func_resume(LEPUSContext *ctx,
                                        JSAsyncFunctionState *s) {
  LEPUSValue func_obj;
  if (unlikely(js_check_stack_overflow(ctx, 0)))
    return JS_ThrowStackOverflow(ctx);
  /* the tag does not matter provided it is not an object */
  func_obj = LEPUS_MKPTR(LEPUS_TAG_STRING, s);

  return JS_CallInternalTI(ctx, func_obj, s->this_val, LEPUS_UNDEFINED, s->argc,
                           s->frame.arg_buf, JS_CALL_FLAG_GENERATOR);
}

/* Generators */

QJS_STATIC void free_generator_stack_rt(LEPUSRuntime *rt, JSGeneratorData *s) {
  if (s->state == JS_GENERATOR_STATE_COMPLETED) return;
  async_func_free(rt, &s->func_state);
  s->state = JS_GENERATOR_STATE_COMPLETED;
}

QJS_STATIC void js_generator_finalizer(LEPUSRuntime *rt, LEPUSValue obj) {
  JSGeneratorData *s =
      static_cast<JSGeneratorData *>(LEPUS_GetOpaque(obj, JS_CLASS_GENERATOR));

  if (s) {
    free_generator_stack_rt(rt, s);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void free_generator_stack(LEPUSContext *ctx, JSGeneratorData *s) {
  free_generator_stack_rt(ctx->rt, s);
}

QJS_STATIC void js_generator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                  LEPUS_MarkFunc *mark_func, int local_idxc) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSGeneratorData *s = p->u.generator_data;

  if (!s || s->state == JS_GENERATOR_STATE_COMPLETED) return;
  async_func_mark(rt, &s->func_state, mark_func);
}

/* XXX: use enum */
#define GEN_MAGIC_NEXT 0
#define GEN_MAGIC_RETURN 1
#define GEN_MAGIC_THROW 2

QJS_STATIC LEPUSValue js_generator_next(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, BOOL *pdone,
                                        int magic) {
  JSGeneratorData *s = static_cast<JSGeneratorData *>(
      LEPUS_GetOpaque(this_val, JS_CLASS_GENERATOR));
  LEPUSStackFrame *sf;
  LEPUSValue ret, func_ret;
  LEPUSValueConst iter_args[1];

  *pdone = TRUE;
  if (!s) return LEPUS_ThrowTypeError(ctx, "not a generator");
  sf = &s->func_state.frame;
redo:
  switch (s->state) {
    default:
    case JS_GENERATOR_STATE_SUSPENDED_START:
      if (magic == GEN_MAGIC_NEXT) {
        goto exec_no_arg;
      } else {
        free_generator_stack(ctx, s);
        goto done;
      }
      break;
    case JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR: {
      int done;
      LEPUSValue method, iter_obj;
      iter_obj = sf->cur_sp[-2];
      if (magic == GEN_MAGIC_NEXT) {
        method = LEPUS_DupValue(ctx, sf->cur_sp[-1]);
      } else {
        method = JS_GetPropertyInternal_RC(
            ctx, iter_obj,
            magic == GEN_MAGIC_RETURN ? JS_ATOM_return : JS_ATOM_throw,
            iter_obj, 0);
        if (LEPUS_IsException(method)) goto iter_exception;
      }
      if (magic != GEN_MAGIC_NEXT &&
          (LEPUS_IsUndefined(method) || LEPUS_IsNull(method))) {
        /* default action */
        if (magic == GEN_MAGIC_RETURN) {
          ret = LEPUS_DupValue(ctx, argv[0]);
          goto iter_done;
        } else {
          if (JS_IteratorClose(ctx, iter_obj, FALSE)) goto iter_exception;
          LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
          goto iter_exception;
        }
      }
      ret = JS_IteratorNext2(ctx, iter_obj, method, argc, argv, &done);
      LEPUS_FreeValue(ctx, method);
      if (LEPUS_IsException(ret)) {
      iter_exception:
        goto exec_throw;
      }
      /* if not done, the iterator returns the exact object
         returned by 'method' */
      if (done == 2) {
        LEPUSValue done_val, value;
        done_val = JS_GetPropertyInternal_RC(ctx, ret, JS_ATOM_done, ret, 0);
        if (LEPUS_IsException(done_val)) {
          LEPUS_FreeValue(ctx, ret);
          goto iter_exception;
        }
        done = JS_ToBoolFree_RC(ctx, done_val);
        if (done) {
          value = JS_GetPropertyInternal_RC(ctx, ret, JS_ATOM_value, ret, 0);
          LEPUS_FreeValue(ctx, ret);
          if (LEPUS_IsException(value)) goto iter_exception;
          ret = value;
          goto iter_done;
        } else {
          *pdone = 2;
        }
      } else {
        if (done) {
          /* 'yield *' returns the value associated to done = true */
        iter_done:
          LEPUS_FreeValue(ctx, sf->cur_sp[-2]);
          LEPUS_FreeValue(ctx, sf->cur_sp[-1]);
          sf->cur_sp--;
          goto exec_arg;
        } else {
          *pdone = FALSE;
        }
      }
      break;
    } break;
    case JS_GENERATOR_STATE_SUSPENDED_YIELD:
      /* cur_sp[-1] was set to LEPUS_UNDEFINED in the previous call */
      ret = LEPUS_DupValue(ctx, argv[0]);
      if (magic == GEN_MAGIC_THROW) {
        LEPUS_Throw(ctx, ret);
      exec_throw:
        s->func_state.throw_flag = TRUE;
      } else {
      exec_arg:
        sf->cur_sp[-1] = ret;
        sf->cur_sp[0] = LEPUS_NewBool(ctx, (magic == GEN_MAGIC_RETURN));
        sf->cur_sp++;
      exec_no_arg:
        s->func_state.throw_flag = FALSE;
      }
      s->state = JS_GENERATOR_STATE_EXECUTING;
      func_ret = async_func_resume(ctx, &s->func_state);
      s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD;
      if (LEPUS_IsException(func_ret)) {
        /* finalize the execution in case of exception */
        free_generator_stack(ctx, s);
        return func_ret;
      }
      if (LEPUS_VALUE_IS_INT(func_ret)) {
        if (LEPUS_VALUE_GET_INT(func_ret) == FUNC_RET_YIELD_STAR) {
          /* 'yield *' */
          s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
          iter_args[0] = LEPUS_UNDEFINED;
          argc = 1;
          argv = iter_args;
          goto redo;
        } else {
          /* get the return the yield value at the top of the stack */
          ret = sf->cur_sp[-1];
          sf->cur_sp[-1] = LEPUS_UNDEFINED;
          *pdone = FALSE;
        }
      } else {
        /* end of iterator */
        ret = sf->cur_sp[-1];
        sf->cur_sp[-1] = LEPUS_UNDEFINED;
        LEPUS_FreeValue(ctx, func_ret);
        free_generator_stack(ctx, s);
      }
      break;
    case JS_GENERATOR_STATE_COMPLETED:
    done:
      /* execution is finished */
      switch (magic) {
        default:
        case GEN_MAGIC_NEXT:
          ret = LEPUS_UNDEFINED;
          break;
        case GEN_MAGIC_RETURN:
          ret = LEPUS_DupValue(ctx, argv[0]);
          break;
        case GEN_MAGIC_THROW:
          ret = LEPUS_Throw(ctx, LEPUS_DupValue(ctx, argv[0]));
          break;
      }
      break;
    case JS_GENERATOR_STATE_EXECUTING:
      ret = LEPUS_ThrowTypeError(ctx, "cannot invoke a running generator");
      break;
  }
  return ret;
}
QJS_STATIC LEPUSValue js_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSValue obj, func_ret;
  JSGeneratorData *s;
  s = static_cast<JSGeneratorData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->state = JS_GENERATOR_STATE_SUSPENDED_START;
  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
    s->state = JS_GENERATOR_STATE_COMPLETED;
    goto fail;
  }

  /* execute the function up to 'OP_initial_yield' */
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) goto fail;
  LEPUS_FreeValue(ctx, func_ret);

  obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_GENERATOR);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_SetOpaque(obj, s);
  return obj;
fail:
  free_generator_stack_rt(ctx->rt, s);
  lepus_free(ctx, s);
  return LEPUS_EXCEPTION;
}

/* AsyncFunction */

QJS_STATIC void js_async_function_terminate(LEPUSRuntime *rt,
                                            JSAsyncFunctionData *s) {
  if (s->is_active) {
    async_func_free(rt, &s->func_state);
    s->is_active = FALSE;
  }
}

QJS_STATIC void js_async_function_free0(LEPUSRuntime *rt,
                                        JSAsyncFunctionData *s) {
  js_async_function_terminate(rt, s);
  LEPUS_FreeValueRT(rt, s->resolving_funcs[0]);
  LEPUS_FreeValueRT(rt, s->resolving_funcs[1]);
  lepus_free_rt(rt, s);
}

QJS_STATIC void js_async_function_free(LEPUSRuntime *rt,
                                       JSAsyncFunctionData *s) {
  if (--s->header.ref_count == 0) {
    js_async_function_free0(rt, s);
  }
}

QJS_STATIC void js_async_function_resolve_finalizer(LEPUSRuntime *rt,
                                                    LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSAsyncFunctionData *s = p->u.async_function_data;
  if (s) {
    js_async_function_free(rt, s);
  }
}

QJS_STATIC void js_async_function_resolve_mark(LEPUSRuntime *rt,
                                               LEPUSValueConst val,
                                               LEPUS_MarkFunc *mark_func,
                                               int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSAsyncFunctionData *s = p->u.async_function_data;
  if (s) {
    JS_MarkValue_RC(rt, LEPUS_MKPTR(LEPUS_TAG_ASYNC_FUNCTION, s), mark_func);
  }
}

QJS_STATIC int js_async_function_resolve_create(LEPUSContext *ctx,
                                                JSAsyncFunctionData *s,
                                                LEPUSValue *resolving_funcs) {
  int i;
  LEPUSObject *p;

  for (i = 0; i < 2; i++) {
    resolving_funcs[i] = JS_NewObjectProtoClass_RC(
        ctx, ctx->function_proto, JS_CLASS_ASYNC_FUNCTION_RESOLVE + i);
    if (LEPUS_IsException(resolving_funcs[i])) {
      if (i == 1) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      return -1;
    }
    p = LEPUS_VALUE_GET_OBJ(resolving_funcs[i]);
    s->header.ref_count++;
    p->u.async_function_data = s;
  }
  return 0;
}

QJS_STATIC void js_async_function_resume(LEPUSContext *ctx,
                                         JSAsyncFunctionData *s) {
  LEPUSValue func_ret, ret2;
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) {
    LEPUSValue error;
  fail:
    error = LEPUS_GetException(ctx);
    ret2 = JS_Call_RC(ctx, s->resolving_funcs[1], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    js_async_function_terminate(ctx->rt, s);
    LEPUS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
  } else {
    LEPUSValue value;
    value = s->func_state.frame.cur_sp[-1];
    s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
    if (LEPUS_IsUndefined(func_ret)) {
      /* function returned */
      ret2 = JS_Call_RC(ctx, s->resolving_funcs[0], LEPUS_UNDEFINED, 1,
                        (LEPUSValueConst *)&value);
      LEPUS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
      LEPUS_FreeValue(ctx, value);
      js_async_function_terminate(ctx->rt, s);
    } else {
      LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
      int i, res;

      /* await */
      LEPUS_FreeValue(ctx, func_ret); /* not used */
      promise = js_promise_resolve(ctx, ctx->promise_ctor, 1,
                                   (LEPUSValueConst *)&value, 0);
      LEPUS_FreeValue(ctx, value);
      if (LEPUS_IsException(promise)) goto fail;
      if (js_async_function_resolve_create(ctx, s, resolving_funcs)) {
        LEPUS_FreeValue(ctx, promise);
        goto fail;
      }

      /* Note: no need to create 'thrownawayCapability' as in
         the spec */
      for (i = 0; i < 2; i++) resolving_funcs1[i] = LEPUS_UNDEFINED;
      res =
          perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs,
                               (LEPUSValueConst *)resolving_funcs1);
      LEPUS_FreeValue(ctx, promise);
      for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
      if (res) goto fail;
    }
  }
}

QJS_STATIC LEPUSValue js_async_function_resolve_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
  JSAsyncFunctionData *s = p->u.async_function_data;
  BOOL is_reject = p->class_id - JS_CLASS_ASYNC_FUNCTION_RESOLVE;
  LEPUSValueConst arg;

  if (argc > 0)
    arg = argv[0];
  else
    arg = LEPUS_UNDEFINED;
  s->func_state.throw_flag = is_reject;
  if (is_reject) {
    LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
  } else {
    /* return value of await */
    s->func_state.frame.cur_sp[-1] = LEPUS_DupValue(ctx, arg);
  }
  js_async_function_resume(ctx, s);
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_async_function_call(LEPUSContext *ctx,
                                             LEPUSValueConst func_obj,
                                             LEPUSValueConst this_obj, int argc,
                                             LEPUSValueConst *argv, int flags) {
  LEPUSValue promise;
  JSAsyncFunctionData *s;

  s = static_cast<JSAsyncFunctionData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->header.ref_count = 1;
  s->gc_header.mark = 0;

  s->is_active = FALSE;
  s->resolving_funcs[0] = LEPUS_UNDEFINED;
  s->resolving_funcs[1] = LEPUS_UNDEFINED;

  promise = LEPUS_NewPromiseCapability(ctx, s->resolving_funcs);
  if (LEPUS_IsException(promise)) goto fail;

  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
  fail:
    LEPUS_FreeValue(ctx, promise);
    js_async_function_free(ctx->rt, s);
    return LEPUS_EXCEPTION;
  }
  s->is_active = TRUE;

  js_async_function_resume(ctx, s);

  js_async_function_free(ctx->rt, s);

  return promise;
}

/* AsyncGenerator */

typedef enum JSAsyncGeneratorStateEnum {
  JS_ASYNC_GENERATOR_STATE_SUSPENDED_START,
  JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD,
  JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR,
  JS_ASYNC_GENERATOR_STATE_EXECUTING,
  JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN,
  JS_ASYNC_GENERATOR_STATE_COMPLETED,
} JSAsyncGeneratorStateEnum;

typedef struct JSAsyncGeneratorRequest {
  struct list_head link;
  /* completion */
  int completion_type; /* GEN_MAGIC_x */
  LEPUSValue result;
  /* promise capability */
  LEPUSValue promise;
  LEPUSValue resolving_funcs[2];
} JSAsyncGeneratorRequest;

typedef struct JSAsyncGeneratorData {
  LEPUSObject *generator; /* back pointer to the object (const) */
  JSAsyncGeneratorStateEnum state;
  JSAsyncFunctionState func_state;
  struct list_head queue; /* list of JSAsyncGeneratorRequest.link */
} JSAsyncGeneratorData;

QJS_STATIC void js_async_generator_free(LEPUSRuntime *rt,
                                        JSAsyncGeneratorData *s) {
  struct list_head *el, *el1;
  JSAsyncGeneratorRequest *req;

  list_for_each_safe(el, el1, &s->queue) {
    req = list_entry(el, JSAsyncGeneratorRequest, link);
    LEPUS_FreeValueRT(rt, req->result);
    LEPUS_FreeValueRT(rt, req->promise);
    LEPUS_FreeValueRT(rt, req->resolving_funcs[0]);
    LEPUS_FreeValueRT(rt, req->resolving_funcs[1]);
    lepus_free_rt(rt, req);
  }
  if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&
      s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
    async_func_free(rt, &s->func_state);
  }
  lepus_free_rt(rt, s);
}

QJS_STATIC void js_async_generator_finalizer(LEPUSRuntime *rt, LEPUSValue obj) {
  JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
      LEPUS_GetOpaque(obj, JS_CLASS_ASYNC_GENERATOR));

  if (s) {
    js_async_generator_free(rt, s);
  }
}

QJS_STATIC void js_async_generator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func,
                                        int local_idx) {
  JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
      LEPUS_GetOpaque(val, JS_CLASS_ASYNC_GENERATOR));
  struct list_head *el;
  JSAsyncGeneratorRequest *req;
  if (s) {
    list_for_each(el, &s->queue) {
      req = list_entry(el, JSAsyncGeneratorRequest, link);
      JS_MarkValue_RC(rt, req->result, mark_func);
      JS_MarkValue_RC(rt, req->promise, mark_func);
      JS_MarkValue_RC(rt, req->resolving_funcs[0], mark_func);
      JS_MarkValue_RC(rt, req->resolving_funcs[1], mark_func);
    }
    if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&
        s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
      async_func_mark(rt, &s->func_state, mark_func);
    }
  }
}

QJS_STATIC LEPUSValue js_async_generator_resolve_function(
    LEPUSContext *ctx, LEPUSValueConst this_obj, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data);

QJS_STATIC int js_async_generator_resolve_function_create(
    LEPUSContext *ctx, LEPUSValueConst generator, LEPUSValue *resolving_funcs,
    BOOL is_resume_next) {
  int i;
  LEPUSValue func;

  for (i = 0; i < 2; i++) {
    func = LEPUS_NewCFunctionData(ctx, js_async_generator_resolve_function, 1,
                                  i + is_resume_next * 2, 1, &generator);
    if (LEPUS_IsException(func)) {
      if (i == 1) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      return -1;
    }
    resolving_funcs[i] = func;
  }
  return 0;
}

QJS_STATIC int js_async_generator_await(LEPUSContext *ctx,
                                        JSAsyncGeneratorData *s,
                                        LEPUSValueConst value) {
  LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
  int i, res;

  promise = js_promise_resolve(ctx, ctx->promise_ctor, 1, &value, 0);
  if (LEPUS_IsException(promise)) goto fail;

  if (js_async_generator_resolve_function_create(
          ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, s->generator), resolving_funcs,
          FALSE)) {
    LEPUS_FreeValue(ctx, promise);
    goto fail;
  }

  /* Note: no need to create 'thrownawayCapability' as in
     the spec */
  for (i = 0; i < 2; i++) resolving_funcs1[i] = LEPUS_UNDEFINED;
  res = perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs,
                             (LEPUSValueConst *)resolving_funcs1);
  LEPUS_FreeValue(ctx, promise);
  for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
  if (res) goto fail;
  return 0;
fail:
  return -1;
}

QJS_STATIC void js_async_generator_resolve_or_reject(LEPUSContext *ctx,
                                                     JSAsyncGeneratorData *s,
                                                     LEPUSValueConst result,
                                                     int is_reject) {
  JSAsyncGeneratorRequest *next;
  LEPUSValue ret;

  next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);
  list_del(&next->link);
  ret = JS_Call_RC(ctx, next->resolving_funcs[is_reject], LEPUS_UNDEFINED, 1,
                   &result);
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, next->result);
  LEPUS_FreeValue(ctx, next->promise);
  LEPUS_FreeValue(ctx, next->resolving_funcs[0]);
  LEPUS_FreeValue(ctx, next->resolving_funcs[1]);
  lepus_free(ctx, next);
}

QJS_STATIC void js_async_generator_resolve(LEPUSContext *ctx,
                                           JSAsyncGeneratorData *s,
                                           LEPUSValueConst value, BOOL done) {
  LEPUSValue result;
  result = js_create_iterator_result(ctx, LEPUS_DupValue(ctx, value), done);
  /* XXX: better exception handling ? */
  js_async_generator_resolve_or_reject(ctx, s, result, 0);
  LEPUS_FreeValue(ctx, result);
}

QJS_STATIC void js_async_generator_reject(LEPUSContext *ctx,
                                          JSAsyncGeneratorData *s,
                                          LEPUSValueConst exception) {
  js_async_generator_resolve_or_reject(ctx, s, exception, 1);
}

QJS_STATIC void js_async_generator_complete(LEPUSContext *ctx,
                                            JSAsyncGeneratorData *s) {
  if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED) {
    s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
    async_func_free(ctx->rt, &s->func_state);
  }
}

QJS_STATIC int js_async_generator_completed_return(LEPUSContext *ctx,
                                                   JSAsyncGeneratorData *s,
                                                   LEPUSValueConst value) {
  LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
  int res;

  promise = js_promise_resolve(ctx, ctx->promise_ctor, 1,
                               (LEPUSValueConst *)&value, 0);
  if (LEPUS_IsException(promise)) return -1;
  if (js_async_generator_resolve_function_create(
          ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, s->generator), resolving_funcs1,
          TRUE)) {
    LEPUS_FreeValue(ctx, promise);
    return -1;
  }
  resolving_funcs[0] = LEPUS_UNDEFINED;
  resolving_funcs[1] = LEPUS_UNDEFINED;
  res = perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs1,
                             (LEPUSValueConst *)resolving_funcs);
  LEPUS_FreeValue(ctx, resolving_funcs1[0]);
  LEPUS_FreeValue(ctx, resolving_funcs1[1]);
  LEPUS_FreeValue(ctx, promise);
  return res;
}

QJS_STATIC void js_async_generator_resume_next(LEPUSContext *ctx,
                                               JSAsyncGeneratorData *s) {
  JSAsyncGeneratorRequest *next;
  LEPUSValue func_ret, value;

  for (;;) {
    if (list_empty(&s->queue)) break;
    next = list_entry(s->queue.next, JSAsyncGeneratorRequest, link);
    switch (s->state) {
      case JS_ASYNC_GENERATOR_STATE_EXECUTING:
        /* only happens when restarting execution after await() */
        goto resume_exec;
      case JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN:
        goto done;
      case JS_ASYNC_GENERATOR_STATE_SUSPENDED_START:
        if (next->completion_type == GEN_MAGIC_NEXT) {
          goto exec_no_arg;
        } else {
          js_async_generator_complete(ctx, s);
        }
        break;
      case JS_ASYNC_GENERATOR_STATE_COMPLETED:
        if (next->completion_type == GEN_MAGIC_NEXT) {
          js_async_generator_resolve(ctx, s, LEPUS_UNDEFINED, TRUE);
        } else if (next->completion_type == GEN_MAGIC_RETURN) {
          s->state = JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;
          js_async_generator_completed_return(ctx, s, next->result);
          goto done;
        } else {
          js_async_generator_reject(ctx, s, next->result);
        }
        goto done;
      case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD:
      case JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
        value = LEPUS_DupValue(ctx, next->result);
        if (next->completion_type == GEN_MAGIC_THROW &&
            s->state == JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD) {
          LEPUS_Throw(ctx, value);
          s->func_state.throw_flag = TRUE;
        } else {
          /* 'yield' returns a value. 'yield *' also returns a value
             in case the 'throw' method is called */
          s->func_state.frame.cur_sp[-1] = value;
          s->func_state.frame.cur_sp[0] =
              LEPUS_NewInt32(ctx, next->completion_type);
          s->func_state.frame.cur_sp++;
        exec_no_arg:
          s->func_state.throw_flag = FALSE;
        }
        s->state = JS_ASYNC_GENERATOR_STATE_EXECUTING;
      resume_exec:
        func_ret = async_func_resume(ctx, &s->func_state);
        if (LEPUS_IsException(func_ret)) {
          value = LEPUS_GetException(ctx);
          js_async_generator_complete(ctx, s);
          js_async_generator_reject(ctx, s, value);
          LEPUS_FreeValue(ctx, value);
        } else if (LEPUS_VALUE_IS_INT(func_ret)) {
          int func_ret_code;
          value = s->func_state.frame.cur_sp[-1];
          s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
          func_ret_code = LEPUS_VALUE_GET_INT(func_ret);
          switch (func_ret_code) {
            case FUNC_RET_YIELD:
            case FUNC_RET_YIELD_STAR:
              if (func_ret_code == FUNC_RET_YIELD_STAR)
                s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
              else
                s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD;
              js_async_generator_resolve(ctx, s, value, FALSE);
              LEPUS_FreeValue(ctx, value);
              break;
            case FUNC_RET_AWAIT:
              js_async_generator_await(ctx, s, value);
              LEPUS_FreeValue(ctx, value);
              goto done;
            default:
              abort();
          }
        } else {
          assert(LEPUS_IsUndefined(func_ret));
          /* end of function */
          value = s->func_state.frame.cur_sp[-1];
          s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
          js_async_generator_complete(ctx, s);
          js_async_generator_resolve(ctx, s, value, TRUE);
          LEPUS_FreeValue(ctx, value);
        }
        break;
      default:
        abort();
    }
  }
done:;
}

QJS_STATIC LEPUSValue js_async_generator_resolve_function(
    LEPUSContext *ctx, LEPUSValueConst this_obj, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  BOOL is_reject = magic & 1;
  JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
      LEPUS_GetOpaque(func_data[0], JS_CLASS_ASYNC_GENERATOR));
  LEPUSValueConst arg = argv[0];

  /* XXX: what if s == NULL */

  if (magic >= 2) {
    /* resume next case in AWAITING_RETURN state */
    assert(s->state == JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN ||
           s->state == JS_ASYNC_GENERATOR_STATE_COMPLETED);
    s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
    if (is_reject) {
      js_async_generator_reject(ctx, s, arg);
    } else {
      js_async_generator_resolve(ctx, s, arg, TRUE);
    }
  } else {
    /* restart function execution after await() */
    assert(s->state == JS_ASYNC_GENERATOR_STATE_EXECUTING);
    s->func_state.throw_flag = is_reject;
    if (is_reject) {
      LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
    } else {
      /* return value of await */
      s->func_state.frame.cur_sp[-1] = LEPUS_DupValue(ctx, arg);
    }
    js_async_generator_resume_next(ctx, s);
  }
  return LEPUS_UNDEFINED;
}

/* magic = GEN_MAGIC_x */
QJS_STATIC LEPUSValue js_async_generator_next(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              int magic) {
  JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
      LEPUS_GetOpaque(this_val, JS_CLASS_ASYNC_GENERATOR));
  LEPUSValue promise, resolving_funcs[2];
  JSAsyncGeneratorRequest *req;

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return LEPUS_EXCEPTION;
  if (!s) {
    LEPUSValue err, res2;
    LEPUS_ThrowTypeError(ctx, "not an AsyncGenerator object");
    err = LEPUS_GetException(ctx);
    res2 = JS_Call_RC(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&err);
    LEPUS_FreeValue(ctx, err);
    LEPUS_FreeValue(ctx, res2);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    return promise;
  }
  req =
      static_cast<JSAsyncGeneratorRequest *>(lepus_mallocz(ctx, sizeof(*req)));
  if (!req) goto fail;
  req->completion_type = magic;
  req->result = LEPUS_DupValue(ctx, argv[0]);
  req->promise = LEPUS_DupValue(ctx, promise);
  req->resolving_funcs[0] = resolving_funcs[0];
  req->resolving_funcs[1] = resolving_funcs[1];
  list_add_tail(&req->link, &s->queue);
  if (s->state != JS_ASYNC_GENERATOR_STATE_EXECUTING) {
    js_async_generator_resume_next(ctx, s);
  }
  return promise;
fail:
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  LEPUS_FreeValue(ctx, promise);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_async_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSValue obj, func_ret;
  JSAsyncGeneratorData *s;

  s = static_cast<JSAsyncGeneratorData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_START;
  init_list_head(&s->queue);
  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
    s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
    goto fail;
  }

  /* execute the function up to 'OP_initial_yield' (no yield nor
     await are possible) */
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) goto fail;
  LEPUS_FreeValue(ctx, func_ret);

  obj = js_create_from_ctor(ctx, func_obj, JS_CLASS_ASYNC_GENERATOR);
  if (LEPUS_IsException(obj)) goto fail;
  s->generator = LEPUS_VALUE_GET_OBJ(obj);
  LEPUS_SetOpaque(obj, s);
  return obj;
fail:
  js_async_generator_free(ctx->rt, s);
  return LEPUS_EXCEPTION;
}

/* unicode code points */
#define CP_NBSP 0x00a0
#define CP_BOM 0xfeff

#define CP_LS 0x2028
#define CP_PS 0x2029

const JSOpCode opcode_info[OP_COUNT + (OP_TEMP_END - OP_TEMP_START)] = {
#define FMT(f)
#if defined(ENABLE_PRIMJS_SNAPSHOT) || defined(DUMP_BYTECODE)
#define DEF(id, size, n_pop, n_push, f) {#id, size, n_pop, n_push, OP_FMT_##f},
#else
#define DEF(id, size, n_pop, n_push, f) {size, n_pop, n_push, OP_FMT_##f},
#endif
#include "quickjs/include/quickjs-opcode.h"
#undef DEF
#undef FMT
};

#ifndef NO_QUICKJS_COMPILER

QJS_STATIC void free_token(JSParseState *s, JSToken *token) {
  switch (token->val) {
#ifdef CONFIG_BIGNUM
    case TOK_NUMBER:
      LEPUS_FreeValue(s->ctx, token->u.num.val);
      break;
#endif
    case TOK_STRING:
    case TOK_TEMPLATE:
      LEPUS_FreeValue(s->ctx, token->u.str.str);
      break;
    case TOK_REGEXP:
      LEPUS_FreeValue(s->ctx, token->u.regexp.body);
      LEPUS_FreeValue(s->ctx, token->u.regexp.flags);
      break;
    case TOK_IDENT:
    case TOK_FIRST_KEYWORD ... TOK_LAST_KEYWORD:
    case TOK_PRIVATE_NAME:
      LEPUS_FreeAtom(s->ctx, token->u.ident.atom);
      break;
    default:
      break;
  }
}

QJS_STATIC void __attribute((unused))
dump_token(JSParseState *s, const JSToken *token) {
  switch (token->val) {
    case TOK_NUMBER: {
      double d;
      LEPUS_ToFloat64(s->ctx, &d, token->u.num.val); /* no exception possible */
      printf("number: %.14g\n", d);
    } break;
    case TOK_IDENT:
    dump_atom: {
      char buf[ATOM_GET_STR_BUF_SIZE];
      printf("ident: '%s'\n",
             JS_AtomGetStr(s->ctx, buf, sizeof(buf), token->u.ident.atom));
    } break;
    case TOK_STRING: {
      const char *str;
      /* XXX: quote the string */
      str = JS_ToCStringLen2_RC(s->ctx, NULL, token->u.str.str, 0);
      printf("string: '%s'\n", str);
      LEPUS_FreeCString(s->ctx, str);
    } break;
    case TOK_TEMPLATE: {
      const char *str;
      str = JS_ToCStringLen2_RC(s->ctx, NULL, token->u.str.str, 0);
      printf("template: `%s`\n", str);
      LEPUS_FreeCString(s->ctx, str);
    } break;
    case TOK_REGEXP: {
      const char *str, *str2;
      str = JS_ToCStringLen2_RC(s->ctx, NULL, token->u.regexp.body, 0);
      str2 = JS_ToCStringLen2_RC(s->ctx, NULL, token->u.regexp.flags, 0);
      printf("regexp: '%s' '%s'\n", str, str2);
      LEPUS_FreeCString(s->ctx, str);
      LEPUS_FreeCString(s->ctx, str2);
    } break;
    case TOK_EOF:
      printf("eof\n");
      break;
    default:
      if (s->token.val >= TOK_NULL && s->token.val <= TOK_LAST_KEYWORD) {
        goto dump_atom;
      } else if (s->token.val >= 256) {
        printf("token: %d\n", token->val);
      } else {
        printf("token: '%c'\n", token->val);
      }
      break;
  }
}

// <Primjs begin>
uint64_t compute_column(JSParseState *s, BOOL is_get_var) {
  uint64_t result;
  int64_t column_number = 0;

  const uint8_t *buf_ptr = (is_get_var ? s->last_last_ptr : s->last_ptr);
  int adapte_size =
      (is_get_var ? s->last_utf8_adapte_size : s->utf8_adapte_size);

  int64_t line_number = s->debugger_last_line_num;

  const uint8_t *line_begin =
      buf_ptr < s->line_begin_ptr ? s->last_line_begin_ptr : s->line_begin_ptr;
  if (buf_ptr) {
    column_number = buf_ptr - line_begin - adapte_size + 1;
  }
  if (column_number < 0) {
    column_number = 0;
  }

  if (line_number >= ((uint64_t)1 << LINE_NUMBER_BITS_COUNT) ||
      column_number >= ((uint64_t)1 << COLUMN_NUMBER_BITS_COUNT)) {
    // even 64 bit is not enough
    result = line_number;
  } else {
    // for compatibility
    result = (uint64_t)((uint64_t)line_number |
                        ((uint64_t)column_number << LINE_NUMBER_BITS_COUNT));
    // set type 1
    result = (uint64_t)(result | (uint64_t)1 << LINE_COLUMN_TYPE_SHIFT);
  }
  return result;
}
// <Primjs end>

int __attribute__((format(printf, 2, 3)))
js_parse_error(JSParseState *s, const char *fmt, ...) {
  LEPUSContext *ctx = s->ctx;
  va_list ap;

  va_start(ap, fmt);
  JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);
  va_end(ap);

  // <Primjs begin>
  uint64_t line_column = compute_column(s, FALSE);
  build_backtrace(ctx, ctx->rt->current_exception, s->filename, line_column,
                  NULL, 0, 1);
  // <Primjs end>
  return -1;
}

int js_parse_expect(JSParseState *s, int tok) {
  if (s->token.val != tok) {
    /* XXX: dump token correctly in all cases */
    return js_parse_error(s, "expecting '%c'", tok);
  }
  return next_token(s);
}

int js_parse_expect_semi(JSParseState *s) {
  if (s->token.val != ';') {
    /* automatic insertion of ';' */
    if (s->token.val == TOK_EOF || s->token.val == '}' || s->got_lf) {
      return 0;
    }
    return js_parse_error(s, "expecting '%c'", ';');
  }
  return next_token(s);
}

int js_parse_error_reserved_identifier(JSParseState *s) {
  char buf1[ATOM_GET_STR_BUF_SIZE];
  return js_parse_error(
      s, "'%s' is a reserved identifier",
      JS_AtomGetStr(s->ctx, buf1, sizeof(buf1), s->token.u.ident.atom));
}

__exception int js_parse_template_part(JSParseState *s, const uint8_t *p) {
  uint32_t c;
  StringBuffer b_s, *b = &b_s;
  HandleScope func_scope(s->ctx);

  /* p points to the first byte of the template part */
  if (string_buffer_init(s->ctx, b, 32)) goto fail;
  func_scope.PushHandle(&b->str, HANDLE_TYPE_HEAP_OBJ);
  for (;;) {
    if (p >= s->buf_end) goto unexpected_eof;
    c = *p++;
    if (c == '`') {
      /* template end part */
      break;
    }
    if (c == '$' && *p == '{') {
      /* template start or middle part */
      p++;
      break;
    }
    if (c == '\\') {
      if (string_buffer_putc8(b, c)) goto fail;
      if (p >= s->buf_end) goto unexpected_eof;
      c = *p++;
    }
    /* newline sequences are normalized as single '\n' bytes */
    if (c == '\r') {
      if (*p == '\n') p++;
      c = '\n';
    }
    if (c == '\n') {
      // <Primjs begin>
      s->last_line_begin_ptr = s->line_begin_ptr;
      s->line_begin_ptr = p;
      s->func_call_adapte_size = -1;
      s->last_utf8_adapte_size = 0;
      s->utf8_adapte_size = 0;
      // <Primjs end>
      s->line_num++;
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
        js_parse_error(s, "invalid UTF-8 sequence");
        goto fail;
      }
      p = p_next;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  s->token.val = TOK_TEMPLATE;
  s->token.u.str.sep = c;
  s->token.u.str.str = LEPUS_UNDEFINED;
  s->token.u.str.str = string_buffer_end(b);
  s->buf_ptr = p;
  return 0;

unexpected_eof:
  js_parse_error(s, "unexpected end of string");
fail:
  if (!s->ctx->gc_enable) string_buffer_free(b);
  return -1;
}

__exception int js_parse_string(JSParseState *s, int sep, BOOL do_throw,
                                const uint8_t *p, JSToken *token,
                                const uint8_t **pp) {
  int ret;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;

  // <Primjs begin>
  int utf8_parsed = 0;
  // <Primjs end>
  /* string */
#ifdef ENABLE_COMPATIBLE_MM
  HandleScope func_scope(s->ctx);
#endif
  if (string_buffer_init(s->ctx, b, 32)) goto fail;
#ifdef ENABLE_COMPATIBLE_MM
  func_scope.PushHandle((void *)&b->str, HANDLE_TYPE_HEAP_OBJ);
#endif
  for (;;) {
    if (p >= s->buf_end) goto invalid_char;
    c = *p;
    if (c < 0x20) {
      if (!s->cur_func) {
        if (do_throw) js_parse_error(s, "invalid character in a JSON string");
        goto fail;
      }
      if (sep == '`') {
        if (c == '\r') {
          if (p[1] == '\n') p++;
          c = '\n';
        }
        /* do not update s->line_num */
      } else if (c == '\n' || c == '\r')
        goto invalid_char;
    }
    p++;
    if (c == sep) break;
    if (c == '$' && *p == '{' && sep == '`') {
      /* template start or middle part */
      p++;
      break;
    }
    if (c == '\\') {
      c = *p;
      switch (c) {
        case '\0':
          if (p >= s->buf_end) goto invalid_char;
          p++;
          break;
        case '\'':
        case '\"':
        case '\\':
          p++;
          break;
        case '\r': /* accept DOS and MAC newline sequences */
          if (p[1] == '\n') {
            p++;
          }
          /* fall thru */
        case '\n':
          /* ignore escaped newline sequence */
          p++;
          if (sep != '`') {
            // <Primjs begin>
            s->last_line_begin_ptr = s->line_begin_ptr;
            s->line_begin_ptr = p;
            s->func_call_adapte_size = -1;
            s->last_utf8_adapte_size = 0;
            s->utf8_adapte_size = 0;
            // <Primjs end>
            s->line_num++;
          }
          continue;
        default:
          if (c >= '0' && c <= '7') {
            if (!s->cur_func) goto invalid_octal; /* JSON case */
            if (!(s->cur_func->js_mode & JS_MODE_STRICT) && sep != '`')
              goto parse_escape;
            if (c == '0' && !(p[1] >= '0' && p[1] <= '9')) {
              p++;
              c = '\0';
            } else {
            invalid_octal:
              if (do_throw)
                js_parse_error(s, "invalid octal syntax in strict mode");
              goto fail;
            }
          } else if (c >= 0x80) {
            const uint8_t *p_next;
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
            // <Primjs begin>
            if (p > s->utf8_parse_front) {
              utf8_parsed += p_next - p;
              s->last_utf8_adapte_size = s->utf8_adapte_size;
              s->utf8_adapte_size += p_next - p;
              s->utf8_parse_front = p_next;
            }
            // <Primjs end>
            if (c > 0x10FFFF) {
              goto invalid_utf8;
            }
            p = p_next;
            /* LS or PS are skipped */
            if (c == CP_LS || c == CP_PS) continue;
          } else {
          parse_escape:
            ret = lre_parse_escape(&p, TRUE);
            if (ret == -1) {
              if (do_throw)
                js_parse_error(s,
                               "malformed escape sequence in string literal");
              goto fail;
            } else if (ret < 0) {
              /* ignore the '\' (could output a warning) */
              p++;
            } else {
              c = ret;
            }
          }
          break;
      }
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      // <Primjs begin>
      if (p > s->utf8_parse_front) {
        utf8_parsed += p_next - p;
        s->utf8_adapte_size += p_next - p;
        s->utf8_parse_front = p_next;
      }
      // <Primjs end
      if (c > 0x10FFFF) goto invalid_utf8;
      p = p_next;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  // <Primjs begin>
  s->last_utf8_adapte_size += utf8_parsed;
  // <Primjs end>
  token->val = TOK_STRING;
  token->u.str.sep = c;
  token->u.str.str = LEPUS_UNDEFINED;
  token->u.str.str = string_buffer_end(b);
  *pp = p;
  return 0;

invalid_utf8:
  if (do_throw) js_parse_error(s, "invalid UTF-8 sequence");
  goto fail;
invalid_char:
  if (do_throw) js_parse_error(s, "unexpected end of string");
fail:
  if (!s->ctx->gc_enable) string_buffer_free(b);
  b->str = NULL;
  return -1;
}

__attribute__((always_inline)) BOOL token_is_pseudo_keyword(JSParseState *s,
                                                            JSAtom atom) {
  return s->token.val == TOK_IDENT && s->token.u.ident.atom == atom &&
         !s->token.u.ident.has_escape;
}

__exception int js_parse_regexp(JSParseState *s) {
  const uint8_t *p;
  BOOL in_class;
  StringBuffer b_s, *b = &b_s;
  StringBuffer b2_s, *b2 = &b2_s;
  uint32_t c;

  p = s->buf_ptr;
  p++;
  in_class = FALSE;
  if (string_buffer_init(s->ctx, b, 32)) return -1;
  HandleScope func_scope(s->ctx, &b->str, HANDLE_TYPE_HEAP_OBJ);
  if (string_buffer_init(s->ctx, b2, 1)) goto fail;
  func_scope.PushHandle(&b2->str, HANDLE_TYPE_HEAP_OBJ);
  for (;;) {
    if (p >= s->buf_end) {
    eof_error:
      js_parse_error(s, "unexpected end of regexp");
      goto fail;
    }
    c = *p++;
    if (c == '\n' || c == '\r') {
      goto eol_error;
    } else if (c == '/') {
      if (!in_class) break;
    } else if (c == '[') {
      in_class = TRUE;
    } else if (c == ']') {
      /* XXX: incorrect as the first character in a class */
      in_class = FALSE;
    } else if (c == '\\') {
      if (string_buffer_putc8(b, c)) goto fail;
      c = *p++;
      if (c == '\n' || c == '\r')
        goto eol_error;
      else if (c == '\0' && p >= s->buf_end)
        goto eof_error;
      else if (c >= 0x80) {
        const uint8_t *p_next;
        c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
        if (c > 0x10FFFF) {
          goto invalid_utf8;
        }
        p = p_next;
        if (c == CP_LS || c == CP_PS) goto eol_error;
      }
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
      invalid_utf8:
        js_parse_error(s, "invalid UTF-8 sequence");
        goto fail;
      }
      p = p_next;
      /* LS or PS are considered as line terminator */
      if (c == CP_LS || c == CP_PS) {
      eol_error:
        js_parse_error(s, "unexpected line terminator in regexp");
        goto fail;
      }
    }
    if (string_buffer_putc(b, c)) goto fail;
  }

  /* flags */
  for (;;) {
    const uint8_t *p_next = p;
    c = *p_next++;
    if (c >= 0x80) {
      c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
        goto invalid_utf8;
      }
    }
    if (!lre_js_is_ident_next(c)) break;
    if (string_buffer_putc(b2, c)) goto fail;
    p = p_next;
  }

  s->token.val = TOK_REGEXP;
  s->token.u.regexp.body = LEPUS_UNDEFINED;
  s->token.u.regexp.flags = LEPUS_UNDEFINED;
  s->token.u.regexp.body = string_buffer_end(b);
  s->token.u.regexp.flags = string_buffer_end(b2);
  s->buf_ptr = p;
  return 0;
fail:
  if (!s->ctx->gc_enable) {
    string_buffer_free(b);
    string_buffer_free(b2);
  } else {
    b->str = NULL;
    b2->str = NULL;
  }
  return -1;
}

#ifdef ENABLE_QUICKJS_DEBUGGER
QJS_STATIC void js_gen_debugger_statement(JSParseState *s, LEPUSContext *ctx);
#endif

__exception int next_token(JSParseState *s) {
  const uint8_t *p;
  int c;
  char buf[4096], *q;
  BOOL ident_has_escape;

  // <Primjs begin>
  int utf8_parsed = 0;
  // <Primjs end>
#ifdef QJS_UNITTEST
  if (unlikely(js_check_stack_overflow(s->ctx, 0))) {
    return js_parse_error(s, "stack overflow");
  }
#endif
#ifdef ENABLE_COMPATIBLE_MM
  if (!s->ctx->gc_enable)
#endif
    free_token(s, &s->token);

  // <Primjs begin>
  if (s->last_ptr > s->last_last_ptr) {
    s->last_last_ptr = s->last_ptr;
  }
  // <Primjs end>

  p = s->last_ptr = s->buf_ptr;
  s->got_lf = FALSE;
  s->last_line_num = s->token.line_num;
  s->debugger_last_line_num = s->last_line_num;
redo:
  s->token.line_num = s->line_num;
  s->token.ptr = p;
  c = *p;
  switch (c) {
    case 0:
      s->token.val = TOK_EOF;
      break;
    case '`':
      if (!s->cur_func) {
        /* JSON does not accept templates */
        goto def_token;
      }
      if (js_parse_template_part(s, p + 1)) goto fail;
      p = s->buf_ptr;
      break;
    case '\'':
      if (!s->cur_func) {
        /* JSON does not accept single quoted strings */
        goto def_token;
      }
      /* fall through */
    case '\"':
      if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p)) goto fail;
      break;
    case '\r': /* accept DOS and MAC newline sequences */
      if (p[1] == '\n') {
        p++;
      }
      /* fall thru */
    case '\n':
      p++;
      // <Primjs begin>
      s->last_last_ptr = s->last_ptr;
      s->last_ptr = p;
      // <Primjs end>
    line_terminator:
      s->got_lf = TRUE;
      // <Primjs begin>
      s->last_line_begin_ptr = s->line_begin_ptr;
      s->line_begin_ptr = p;
      s->utf8_adapte_size = 0;
      s->func_call_adapte_size = -1;
      s->last_utf8_adapte_size = 0;
      // <Primjs end>
      s->line_num++;
      s->debugger_last_line_num = s->line_num;
      goto redo;
    case '\f':
    case '\v':
      if (!s->cur_func) {
        /* JSONWhitespace does not match <VT>, nor <FF> */
        goto def_token;
      }
      /* fall through */
    case ' ':
    case '\t':
      p++;
      // <Primjs begin>
      s->last_ptr = p;
      // <Primjs end>
      goto redo;
    case '/':
      if (p[1] == '*') {
        /* comment */
        p += 2;
        for (;;) {
          if (*p == '\0' && p >= s->buf_end) {
            js_parse_error(s, "unexpected end of comment");
            goto fail;
          }
          if (p[0] == '*' && p[1] == '/') {
            p += 2;
            break;
          }
          if (*p == '\n') {
            s->line_num++;
            s->got_lf = TRUE; /* considered as LF for ASI */
            p++;
            // <Primjs begin>
            s->utf8_adapte_size = 0;
            s->func_call_adapte_size = -1;
            s->last_utf8_adapte_size = 0;
            s->last_line_begin_ptr = s->line_begin_ptr;
            s->line_begin_ptr = p;
            // <Primjs end>
          } else if (*p == '\r') {
            s->got_lf = TRUE; /* considered as LF for ASI */
            p++;
          } else if (*p >= 0x80) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
            if (c == CP_LS || c == CP_PS) {
              s->got_lf = TRUE; /* considered as LF for ASI */
            } else if (c == -1) {
              p++;
            }
          } else {
            p++;
          }
        }
        goto redo;
      } else if (p[1] == '/') {
        /* line comment */
        p += 2;
      skip_line_comment:
        for (;;) {
          if (*p == '\0' && p >= s->buf_end) break;
          if (*p == '\r' || *p == '\n') break;
          if (*p >= 0x80) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
            /* LS or PS are considered as line terminator */
            if (c == CP_LS || c == CP_PS) {
              break;
            } else if (c == -1) {
              p++;
            }
          } else {
            p++;
          }
        }
        goto redo;
      } else if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_DIV_ASSIGN;
      } else {
        p++;
        s->token.val = c;
      }
      break;
    case '\\':
      if (p[1] == 'u') {
        const uint8_t *p1 = p + 1;
        int c1 = lre_parse_escape(&p1, TRUE);
        if (c1 >= 0 && lre_js_is_ident_first(c1)) {
          c = c1;
          p = p1;
          ident_has_escape = TRUE;
          goto has_ident;
        } else {
          /* XXX: syntax error? */
        }
      }
      goto def_token;
    case 'a' ... 'z':
    case 'A' ... 'Z':
    case '_':
    case '$':
      /* identifier */
      p++;
      ident_has_escape = FALSE;
    has_ident:
      q = buf;

      if (p == nullptr) {
        js_parse_error(s,
                       "internal error in function next_token: p is nullptr!");
        goto fail;
      }

      for (;;) {
        const uint8_t *p1 = p;

        if (c < 128) {
          *q++ = c;
        } else {
          q += unicode_to_utf8((uint8_t *)q, c);
        }
        c = *p1++;
        if (c == '\\' && *p1 == 'u') {
          c = lre_parse_escape(&p1, TRUE);
          ident_has_escape = TRUE;
        } else if (c >= 128) {
          c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
          // <Primjs begin>
          if (p >= s->utf8_parse_front) {
            s->utf8_adapte_size += p1 - p - 1;
            s->utf8_parse_front = p1;
          }
          // <Primjs end>
        }
        /* XXX: check if c >= 0 and c <= 0x10FFFF */
        if (!lre_js_is_ident_next(c)) break;
        p = p1;
        if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
          js_parse_error(s, "identifier too long");
          goto fail;
        }
      }
      *q = '\0';
      s->token.u.ident.atom = LEPUS_NewAtomLen(s->ctx, buf, q - buf);
      s->token.u.ident.has_escape = ident_has_escape;
      s->token.u.ident.is_reserved = FALSE;
      if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||
          (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&
           s->cur_func && (s->cur_func->js_mode & JS_MODE_STRICT)) ||
          (s->token.u.ident.atom == JS_ATOM_yield && s->cur_func &&
           ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||
            (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
             !s->cur_func->in_function_body && s->cur_func->parent &&
             (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||
          (s->token.u.ident.atom == JS_ATOM_await &&
           (s->is_module ||
            (s->cur_func &&
             ((s->cur_func->func_kind & JS_FUNC_ASYNC) ||
              (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
               !s->cur_func->in_function_body && s->cur_func->parent &&
               (s->cur_func->parent->func_kind & JS_FUNC_ASYNC))))))) {
        if (ident_has_escape) {
          s->token.u.ident.is_reserved = TRUE;
          s->token.val = TOK_IDENT;
        } else {
          /* The keywords atoms are pre allocated */
          s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;
        }
      } else {
        s->token.val = TOK_IDENT;
      }
      break;
    case '#':
      /* private name */
      {
        const uint8_t *p1;
        p++;
        q = buf;
        *q++ = '#';
        p1 = p;
        c = *p1++;
        if (c == '\\' && *p1 == 'u') {
          c = lre_parse_escape(&p1, TRUE);
        } else if (c >= 128) {
          c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
        }
        if (!lre_js_is_ident_first(c)) {
          js_parse_error(s, "invalid first character of private name");
          goto fail;
        }
        p = p1;
        for (;;) {
          if (c < 128) {
            *q++ = c;
          } else {
            q += unicode_to_utf8((uint8_t *)q, c);
          }
          p1 = p;
          c = *p1++;
          if (c == '\\' && *p1 == 'u') {
            c = lre_parse_escape(&p1, TRUE);
            ident_has_escape = TRUE;
          } else if (c >= 128) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
          }
          /* XXX: check if c >= 0 and c <= 0x10FFFF */
          if (!lre_js_is_ident_next(c)) break;
          p = p1;
          if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
            js_parse_error(s, "private name too long");
            goto fail;
          }
        }
        *q = '\0';
        s->token.u.ident.atom = LEPUS_NewAtomLen(s->ctx, buf, q - buf);
        s->token.val = TOK_PRIVATE_NAME;
      }
      break;
    case '.':
      if (p[1] == '.' && p[2] == '.') {
        p += 3;
        s->token.val = TOK_ELLIPSIS;
        break;
      }
      if (p[1] >= '0' && p[1] <= '9') {
        goto parse_number;
      } else {
        goto def_token;
      }
      break;
    case '0':
      /* in strict or JSON parsing mode, octal literals are not accepted */
      if (is_digit(p[1]) &&
          (!s->cur_func || (s->cur_func->js_mode & JS_MODE_STRICT))) {
        js_parse_error(s, "octal literals are deprecated in strict mode");
        goto fail;
      }
      goto parse_number;
    case '1' ... '9':
      /* number */
    parse_number:
#ifdef CONFIG_BIGNUM
    {
      const uint8_t *p1;
      int flags;
      slimb_t exponent;
      LEPUSValue val;

      s->token.val = TOK_NUMBER;
      s->token.u.num.val = LEPUS_UNDEFINED;
      s->token.u.num.exponent = 0;
      if (!s->cur_func) {
        /* JSON: use current float precision */
        flags = BF_ATOF_THROW;
        if (is_bignum_mode(s->ctx))
          flags |= BF_ATOF_INT_PREC_INF;
        else
          flags |= BF_ATOF_FLOAT64;
        val = js_atof(s->ctx, (const char *)p, (const char **)&p, 10, flags);
        if (LEPUS_IsException(val)) goto bad_number;
      } else {
        bf_t r_s, *r = &r_s;
        BOOL bigint_mode, is_bigint, is_bigfloat;
        int res;

        bigint_mode = (s->cur_func->js_mode & JS_MODE_BIGINT) != 0;
        flags = BF_ATOF_BIN_OCT | BF_ATOF_LEGACY_OCTAL |
                BF_ATOF_UNDERSCORE_SEP | BF_ATOF_INT_PREC_INF | BF_RNDZ;
        if (!bigint_mode) flags |= BF_ATOF_ONLY_DEC_FLOAT;
        p += skip_spaces((char *)p);
        bf_init(s->ctx->bf_ctx, r);
        res = bf_atof2(r, &exponent, (const char *)p, (const char **)&p, 0,
                       BF_PREC_INF, flags);
        if (bf_is_nan(r)) {
          bf_delete(r);
          goto bad_number;
        }
        is_bigint = FALSE;
        is_bigfloat = FALSE;
        if (*p == 'n') {
          if (!(res & BF_ATOF_ST_INTEGER) || (res & BF_ATOF_ST_LEGACY_OCTAL)) {
            bf_delete(r);
            goto bad_number;
          }
          p++;
          is_bigint = TRUE;
        } else if (*p == 'l') {
          p++;
          is_bigfloat = TRUE;
        }
        if ((res & BF_ATOF_ST_INTEGER) && !is_bigfloat &&
            (bigint_mode || is_bigint)) {
          /* in bigint mode: small integer or bigint
             in legacy mode: always a bigint */
          val = JS_NewBigInt2(s->ctx, r, bigint_mode ^ 1);
        } else {
          /* `n` suffix is implied in math mode */
          if (s->cur_func->js_mode & JS_MODE_MATH) is_bigfloat = TRUE;
          if (is_bigfloat) {
            /* infinite precision */
            val = JS_NewBigFloat(s->ctx, r);
            s->token.u.num.exponent = exponent;
          } else {
            double d;
            d = bf_mul_pow10_to_float64(s->ctx, r, exponent);
            bf_delete(r);
            val = LEPUS_NewFloat64(s->ctx, d);
          }
        }
      }
      s->token.u.num.val = val;
      if (lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
      bad_number:
        js_parse_error(s, "invalid number literal");
        goto fail;
      }
    }
#else
    {
      LEPUSValue ret;
      const uint8_t *p1;
      int flags, radix;
      if (!s->cur_func) {
        flags = ATOD_THROW;
        radix = 10;
      } else {
        flags = ATOD_ACCEPT_BIN_OCT | ATOD_THROW | ATOD_ACCEPT_LEGACY_OCTAL |
                ATOD_ACCEPT_UNDERSCORES;
        radix = 0;
      }
      ret = js_atod(s->ctx, (const char *)p, (const char **)&p, radix, flags);
      /* reject `10instanceof Number` */
      if (LEPUS_IsException(ret) ||
          lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
        js_parse_error(s, "invalid number literal");
        goto fail;
      }
      s->token.val = TOK_NUMBER;
      s->token.u.num.val = ret;
    }
#endif
    break;
    case '*':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MUL_ASSIGN;
      } else if (p[1] == '*') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_POW_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_POW;
        }
      } else {
        goto def_token;
      }
      break;
    case '%':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MOD_ASSIGN;
      } else {
        goto def_token;
      }
      break;
    case '+':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_PLUS_ASSIGN;
      } else if (p[1] == '+') {
        p += 2;
        s->token.val = TOK_INC;
      } else {
        goto def_token;
      }
      break;
    case '-':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MINUS_ASSIGN;
      } else if (p[1] == '-') {
        if (s->allow_html_comments && p[2] == '>' &&
            s->last_line_num != s->line_num) {
          /* Annex B: `-->` at beginning of line is an html comment end.
             It extends to the end of the line.
           */
          goto skip_line_comment;
        }
        p += 2;
        s->token.val = TOK_DEC;
      } else {
        goto def_token;
      }
      break;
    case '<':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_LTE;
      } else if (p[1] == '<') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_SHL_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_SHL;
        }
      } else if (s->allow_html_comments && p[1] == '!' && p[2] == '-' &&
                 p[3] == '-') {
        /* Annex B: handle `<!--` single line html comments */
        goto skip_line_comment;
      } else {
        goto def_token;
      }
      break;
    case '>':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_GTE;
      } else if (p[1] == '>') {
        if (p[2] == '>') {
          if (p[3] == '=') {
            p += 4;
            s->token.val = TOK_SHR_ASSIGN;
          } else {
            p += 3;
            s->token.val = TOK_SHR;
          }
        } else if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_SAR_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_SAR;
        }
      } else {
        goto def_token;
      }
      break;
    case '=':
      if (p[1] == '=') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_STRICT_EQ;
        } else {
          p += 2;
          s->token.val = TOK_EQ;
        }
      } else if (p[1] == '>') {
        p += 2;
        s->token.val = TOK_ARROW;
      } else {
        goto def_token;
      }
      break;
    case '!':
      if (p[1] == '=') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_STRICT_NEQ;
        } else {
          p += 2;
          s->token.val = TOK_NEQ;
        }
      } else {
        goto def_token;
      }
      break;
    case '&':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_AND_ASSIGN;
      } else if (p[1] == '&') {
        p += 2;
        s->token.val = TOK_LAND;
      } else {
        goto def_token;
      }
      break;
#ifdef CONFIG_BIGNUM
      /* in math mode, '^' is the power operator. '^^' is always the
         xor operator and '**' is always the power operator */
    case '^':
      if (p[1] == '=') {
        p += 2;
        if (s->cur_func && (s->cur_func->js_mode & JS_MODE_MATH))
          s->token.val = TOK_MATH_POW_ASSIGN;
        else
          s->token.val = TOK_XOR_ASSIGN;
      } else if (p[1] == '^') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_XOR_ASSIGN;
        } else {
          p += 2;
          s->token.val = '^';
        }
      } else {
        p++;
        if (s->cur_func && (s->cur_func->js_mode & JS_MODE_MATH))
          s->token.val = TOK_MATH_POW;
        else
          s->token.val = '^';
      }
      break;
#else
    case '^':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_XOR_ASSIGN;
      } else {
        goto def_token;
      }
      break;
#endif
    case '|':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_OR_ASSIGN;
      } else if (p[1] == '|') {
        p += 2;
        s->token.val = TOK_LOR;
      } else {
        goto def_token;
      }
      break;
    case '?':
      if (p[1] == '?') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_DOUBLE_QUESTION_MARK;
        }
      } else if (p[1] == '.' && !(p[2] >= '0' && p[2] <= '9')) {
        p += 2;
        s->token.val = TOK_QUESTION_MARK_DOT;
      } else {
        goto def_token;
      }
      break;
    default:
      if (c >= 128) {
        /* unicode value */
        // <Primjs begin>
        const uint8_t *p_next;
        c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
        if (p >= s->utf8_parse_front) {
          s->last_utf8_adapte_size = s->utf8_adapte_size;
          s->utf8_adapte_size += p_next - p - 1;
          s->utf8_parse_front = p_next;
        }
        p = p_next;
        // <Primjs end>
        switch (c) {
          case CP_PS:
          case CP_LS:
            if (!s->cur_func) {
              /* <PS> and <LS> are not JSONWhitespace */
              goto def_token;
            } else {
              /* XXX: should avoid incrementing line_number, but
                 needed to handle HTML comments */
              goto line_terminator;
            }
          default:
            if (lre_is_space(c)) {
              if (!s->cur_func) {
                /* category z spaces are not JSONWhitespace */
                goto def_token;
              } else {
                goto redo;
              }
            } else if (lre_js_is_ident_first(c)) {
              ident_has_escape = FALSE;
              goto has_ident;
            } else {
              js_parse_error(s, "unexpected character");
              goto fail;
            }
        }
      }
    def_token:
      s->token.val = c;
      p++;
      break;
  }
  s->buf_ptr = p;
  //    dump_token(s, &s->token);
  return 0;

fail:
  s->token.val = TOK_ERROR;
  return -1;
}

/* only used for ':' and '=>', 'let' or 'function' look-ahead */
/* XXX: handle all unicode cases */
int peek_token(JSParseState *s, BOOL no_line_terminator) {
  const uint8_t *p;
  uint32_t c;

  /* skip spaces and comments */
  for (p = s->buf_ptr;;) {
    switch (c = *p++) {
      case '\r':
      case '\n':
        if (no_line_terminator) return '\n';
        continue;
      case ' ':
      case '\t':
      case '\v':
      case '\f':
        continue;
      case '/':
        if (*p == '/') {
          if (no_line_terminator) return '\n';
          while (*p && *p != '\r' && *p != '\n') p++;
          continue;
        }
        if (*p == '*') {
          while (*++p) {
            if ((*p == '\r' || *p == '\n') && no_line_terminator) return '\n';
            if (*p == '*' && p[1] == '/') {
              p += 2;
              break;
            }
          }
          continue;
        }
        break;
      case '=':
        if (*p == '>') return TOK_ARROW;
        break;
      default:
        if (lre_js_is_ident_first(c)) {
          if (c == 'i' && *p == 'n' && !lre_js_is_ident_next(p[1]))
            return TOK_IN;
          if (c == 'o' && *p == 'f' && !lre_js_is_ident_next(p[1]))
            return TOK_OF;
          else if (c == 'f' && p[0] == 'u' && p[1] == 'n' && p[2] == 'c' &&
                   p[3] == 't' && p[4] == 'i' && p[5] == 'o' && p[6] == 'n' &&
                   !lre_js_is_ident_next(p[7]))
            return TOK_FUNCTION;
          else
            return TOK_IDENT;
        }
        break;
    }
    return c;
  }
}

__attribute__((always_inline)) int get_prev_opcode(JSFunctionDef *fd) {
  if (fd->last_opcode_pos < 0)
    return OP_invalid;
  else
    return fd->byte_code.buf[fd->last_opcode_pos];
}

BOOL js_is_live_code(JSParseState *s) {
  switch (get_prev_opcode(s->cur_func)) {
    case OP_tail_call:
    case OP_tail_call_method:
    case OP_return:
    case OP_return_undef:
    case OP_return_async:
    case OP_throw:
    case OP_throw_var:
    case OP_goto:
#if SHORT_OPCODES
    case OP_goto8:
    case OP_goto16:
#endif
    case OP_ret:
      return FALSE;
    default:
      return TRUE;
  }
}

QJS_STATIC void emit_u8(JSParseState *s, uint8_t val) {
  dbuf_putc(&s->cur_func->byte_code, val);
}

QJS_STATIC void emit_u16(JSParseState *s, uint16_t val) {
  dbuf_put_u16(&s->cur_func->byte_code, val);
}

QJS_STATIC void emit_u32(JSParseState *s, uint32_t val) {
  dbuf_put_u32(&s->cur_func->byte_code, val);
}

void emit_op(JSParseState *s, uint8_t val) {
  JSFunctionDef *fd = s->cur_func;
  DynBuf *bc = &fd->byte_code;

  /* Use the line number of the last token used, not the next token,
     nor the current offset in the source file.
   */
  // <Primjs begin>
  if (unlikely(s->last_emit_ptr != s->last_ptr)) {
    int64_t result = compute_column(s, val == OP_scope_get_var);
    dbuf_putc(bc, OP_line_num);
    dbuf_put_u64(bc, result);
    s->last_emit_ptr = s->last_ptr;
    fd->last_opcode_line_num = s->last_line_num;
  }
  // <Primjs end>
  fd->last_opcode_pos = bc->size;
  dbuf_putc(bc, val);
}

QJS_STATIC void emit_atom(JSParseState *s, JSAtom name) {
#ifdef ENABLE_COMPATIBLE_MM
  if (!s->ctx->gc_enable)
#endif
    LEPUS_DupAtom(s->ctx, name);
  emit_u32(s, name);
}

int update_label(JSFunctionDef *s, int label, int delta) {
  LabelSlot *ls;

  assert(label >= 0 && label < s->label_count);
  ls = &s->label_slots[label];
  ls->ref_count += delta;
  assert(ls->ref_count >= 0);
  return ls->ref_count;
}

int new_label_fd(JSFunctionDef *fd, int label) {
  LabelSlot *ls;

  if (label < 0) {
    if (fd->label_count >= fd->label_size) {
      int new_size;
      size_t slack;
      LabelSlot *new_tab;

      /* XXX: potential arithmetic overflow */
      new_size = fd->label_size * 3 / 2 + 4;
      new_tab = static_cast<LabelSlot *>(
          lepus_realloc2(fd->ctx, fd->label_slots, new_size * sizeof(*new_tab),
                         &slack, ALLOC_TAG_WITHOUT_PTR));
      if (!new_tab) return -1;
      new_size += slack / sizeof(*new_tab);
      fd->label_slots = new_tab;
      fd->label_size = new_size;
    }
    label = fd->label_count++;
    ls = &fd->label_slots[label];
    ls->ref_count = 0;
    ls->pos = -1;
    ls->pos2 = -1;
    ls->addr = -1;
    ls->first_reloc = NULL;
  }
  return label;
}

QJS_STATIC int new_label(JSParseState *s) {
  return new_label_fd(s->cur_func, -1);
}

/* return the label ID offset */
int emit_label(JSParseState *s, int label) {
  if (label >= 0) {
    emit_op(s, OP_label);
    emit_u32(s, label);
    s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;
    return s->cur_func->byte_code.size - 4;
  } else {
    return -1;
  }
}

/* return label or -1 if dead code */
int emit_goto(JSParseState *s, int opcode, int label) {
  if (js_is_live_code(s)) {
    if (label < 0) label = new_label(s);
    emit_op(s, opcode);
    emit_u32(s, label);
    s->cur_func->label_slots[label].ref_count++;
    return label;
  }
  return -1;
}

/* return the constant pool index. 'val' is not duplicated. */
int cpool_add(JSParseState *s, LEPUSValue val) {
  JSFunctionDef *fd = s->cur_func;
  if (fd->cpool_count >= fd->cpool_size) {
    int new_size;
    size_t slack;
    LEPUSValue *new_tab;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(fd->cpool_count + 1, fd->cpool_size * 3 / 2);
    new_tab = static_cast<LEPUSValue *>(
        lepus_realloc2(s->ctx, fd->cpool, new_size * sizeof(LEPUSValue), &slack,
                       ALLOC_TAG_WITHOUT_PTR));
    if (!new_tab) return -1;
    new_size += slack / sizeof(*new_tab);
    fd->cpool = new_tab;
    fd->cpool_size = new_size;
  }
  fd->cpool[fd->cpool_count++] = val;
  return fd->cpool_count - 1;
}

__exception int emit_push_const(JSParseState *s, LEPUSValueConst val,
                                BOOL as_atom) {
  int idx;

  if (LEPUS_VALUE_IS_STRING(val) && as_atom) {
    JSAtom atom;
    /* warning: JS_NewAtomStr frees the string value */
    LEPUS_DupValue(s->ctx, val);
    atom = JS_NewAtomStr(s->ctx, LEPUS_VALUE_GET_STRING(val));
    if (atom != JS_ATOM_NULL && !__JS_AtomIsTaggedInt(atom)) {
#ifdef ENABLE_COMPATIBLE_MM
      HandleScope func_scope(s->ctx);
      func_scope.PushLEPUSAtom(atom);
#endif
      emit_op(s, OP_push_atom_value);
      emit_u32(s, atom);
      return 0;
    }
  }

  idx = cpool_add(s, LEPUS_DupValue(s->ctx, val));
  if (idx < 0) return -1;
  emit_op(s, OP_push_const);
  emit_u32(s, idx);
  return 0;
}

/* return the variable index or -1 if not found,
   add ARGUMENT_VAR_OFFSET for argument variables */
int find_arg(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name) {
  int i;
  for (i = fd->arg_count; i-- > 0;) {
    if (fd->args[i].var_name == name) return i | ARGUMENT_VAR_OFFSET;
  }
  return -1;
}

int find_var(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name) {
  int i;
  for (i = fd->var_count; i-- > 0;) {
    if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0) return i;
  }
  return find_arg(ctx, fd, name);
}

/* find a variable declaration in a given scope */
QJS_STATIC int find_var_in_scope(LEPUSContext *ctx, JSFunctionDef *fd,
                                 JSAtom name, int scope_level) {
  int scope_idx;
  for (scope_idx = fd->scopes[scope_level].first; scope_idx >= 0;
       scope_idx = fd->vars[scope_idx].scope_next) {
    if (fd->vars[scope_idx].scope_level != scope_level) break;
    if (fd->vars[scope_idx].var_name == name) return scope_idx;
  }
  return -1;
}

/* return true if scope == parent_scope or if scope is a child of
   parent_scope */
BOOL is_child_scope(LEPUSContext *ctx, JSFunctionDef *fd, int scope,
                    int parent_scope) {
  while (scope >= 0) {
    if (scope == parent_scope) return TRUE;
    scope = fd->scopes[scope].parent;
  }
  return FALSE;
}

/* find a 'var' declaration in the same scope or a child scope */
int find_var_in_child_scope(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name,
                            int scope_level) {
  int i;
  for (i = 0; i < fd->var_count; i++) {
    JSVarDef *vd = &fd->vars[i];
    if (vd->var_name == name && vd->scope_level == 0) {
      if (is_child_scope(ctx, fd, vd->scope_next, scope_level)) return i;
    }
  }
  return -1;
}

JSHoistedDef *find_hoisted_def(JSFunctionDef *fd, JSAtom name) {
  int i;
  for (i = 0; i < fd->hoisted_def_count; i++) {
    JSHoistedDef *hf = &fd->hoisted_def[i];
    if (hf->var_name == name) return hf;
  }
  return NULL;
}

QJS_STATIC JSHoistedDef *find_lexical_hoisted_def(JSFunctionDef *fd,
                                                  JSAtom name) {
  JSHoistedDef *hf = find_hoisted_def(fd, name);
  if (hf && hf->is_lexical)
    return hf;
  else
    return NULL;
}

int find_lexical_decl(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name,
                      int scope_idx, BOOL check_catch_var) {
  while (scope_idx >= 0) {
    JSVarDef *vd = &fd->vars[scope_idx];
    if (vd->var_name == name &&
        (vd->is_lexical || (vd->var_kind == JS_VAR_CATCH && check_catch_var)))
      return scope_idx;
    scope_idx = vd->scope_next;
  }

  if (fd->is_eval && fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL) {
    if (find_lexical_hoisted_def(fd, name)) return GLOBAL_VAR_OFFSET;
  }
  return -1;
}

int push_scope(JSParseState *s) {
  if (s->cur_func) {
    JSFunctionDef *fd = s->cur_func;
    int scope = fd->scope_count;
    /* XXX: should check for scope overflow */
    if ((fd->scope_count + 1) > fd->scope_size) {
      int new_size;
      size_t slack;
      JSVarScope *new_buf;
      /* XXX: potential arithmetic overflow */
      new_size = max_int(fd->scope_count + 1, fd->scope_size * 3 / 2);
      if (fd->scopes == fd->def_scope_array) {
        new_buf = static_cast<JSVarScope *>(
            lepus_realloc2(s->ctx, NULL, new_size * sizeof(*fd->scopes), &slack,
                           ALLOC_TAG_WITHOUT_PTR));
        if (!new_buf) return -1;
        memcpy(new_buf, fd->scopes, fd->scope_count * sizeof(*fd->scopes));
      } else {
        new_buf = static_cast<JSVarScope *>(
            lepus_realloc2(s->ctx, fd->scopes, new_size * sizeof(*fd->scopes),
                           &slack, ALLOC_TAG_WITHOUT_PTR));
        if (!new_buf) return -1;
      }
      new_size += slack / sizeof(*new_buf);
      fd->scopes = new_buf;
      fd->scope_size = new_size;
    }
    fd->scope_count++;
    fd->scopes[scope].parent = fd->scope_level;
    fd->scopes[scope].first = fd->scope_first;
    emit_op(s, OP_enter_scope);
    emit_u16(s, scope);
    return fd->scope_level = scope;
  }
  return 0;
}

QJS_STATIC int get_first_lexical_var(JSFunctionDef *fd, int scope) {
  while (scope >= 0) {
    int scope_idx = fd->scopes[scope].first;
    if (scope_idx >= 0) return scope_idx;
    scope = fd->scopes[scope].parent;
  }
  return -1;
}

void pop_scope(JSParseState *s) {
  if (s->cur_func) {
    /* disable scoped variables */
    JSFunctionDef *fd = s->cur_func;
    int scope = fd->scope_level;
    emit_op(s, OP_leave_scope);
    emit_u16(s, scope);
    fd->scope_level = fd->scopes[scope].parent;
    fd->scope_first = get_first_lexical_var(fd, fd->scope_level);
  }
}

void close_scopes(JSParseState *s, int scope, int scope_stop) {
  while (scope > scope_stop) {
    emit_op(s, OP_leave_scope);
    emit_u16(s, scope);
    scope = s->cur_func->scopes[scope].parent;
  }
}

/* return the variable index or -1 if error */
int add_var(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name) {
  JSVarDef *vd;

  /* the local variable indexes are currently stored on 16 bits */
  if (fd->var_count >= JS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many local variables");
    return -1;
  }
  if ((fd->var_count + 1) > fd->var_size) {
    int new_size;
    size_t slack;
    JSVarDef *new_buf;
    new_size =
        fd->var_count == 0 ? 4 : max_int(fd->var_count + 1, fd->var_size * 2);
    new_buf = static_cast<JSVarDef *>(
        lepus_realloc2(ctx, fd->vars, new_size * sizeof(*fd->vars), &slack,
                       ALLOC_TAG_WITHOUT_PTR));
    if (!new_buf) return -1;
    new_size += slack / sizeof(*new_buf);
    fd->vars = new_buf;
    fd->var_size = new_size;
  }
  vd = &fd->vars[fd->var_count++];
  memset(vd, 0, sizeof(*vd));
#ifdef ENABLE_COMPATIBLE_MM
  if (!ctx->gc_enable)
#endif
    LEPUS_DupAtom(ctx, name);
  vd->var_name = name;
  vd->func_pool_idx = -1;
  return fd->var_count - 1;
}

int add_scope_var(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name,
                  JSVarKindEnum var_kind) {
  int idx = add_var(ctx, fd, name);
  if (idx >= 0) {
    JSVarDef *vd = &fd->vars[idx];
    vd->var_kind = var_kind;
    vd->scope_level = fd->scope_level;
    vd->scope_next = fd->scope_first;
    fd->scopes[fd->scope_level].first = idx;
    fd->scope_first = idx;
  }
  return idx;
}

QJS_STATIC int add_func_var(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name) {
  int idx = fd->func_var_idx;
  if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
    fd->func_var_idx = idx;
    fd->vars[idx].var_kind = JS_VAR_FUNCTION_NAME;
    if (fd->js_mode & JS_MODE_STRICT) fd->vars[idx].is_const = TRUE;
  }
  return idx;
}

QJS_STATIC int add_arguments_var(LEPUSContext *ctx, JSFunctionDef *fd,
                                 JSAtom name) {
  int idx = fd->arguments_var_idx;
  if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
    fd->arguments_var_idx = idx;
  }
  return idx;
}

/* add an argument definition in the argument scope. Only needed when
   "eval()" may be called in the argument scope. Return 0 if OK. */
QJS_STATIC int add_arguments_arg(LEPUSContext *ctx, JSFunctionDef *fd) {
  int idx;
  if (fd->arguments_arg_idx < 0) {
    idx = find_var_in_scope(ctx, fd, JS_ATOM_arguments, ARG_SCOPE_INDEX);
    if (idx < 0) {
      /* XXX: the scope links are not fully updated. May be an
         issue if there are child scopes of the argument
         scope */
      idx = add_var(ctx, fd, JS_ATOM_arguments);
      if (idx < 0) return -1;
      fd->vars[idx].scope_next = fd->scopes[ARG_SCOPE_INDEX].first;
      fd->scopes[ARG_SCOPE_INDEX].first = idx;
      fd->vars[idx].scope_level = ARG_SCOPE_INDEX;
      fd->vars[idx].is_lexical = TRUE;

      fd->arguments_arg_idx = idx;
    }
  }
  return 0;
}

int add_arg(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name) {
  JSVarDef *vd;

  /* the local variable indexes are currently stored on 16 bits */
  if (fd->arg_count >= JS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many arguments");
    return -1;
  }
  if ((fd->arg_count + 1) > fd->arg_size) {
    int new_size;
    size_t slack;
    JSVarDef *new_buf;
    new_size = max_int(fd->arg_count + 1, fd->arg_size * 3 / 2);
    new_buf = static_cast<JSVarDef *>(
        lepus_realloc2(ctx, fd->args, new_size * sizeof(*fd->args), &slack,
                       ALLOC_TAG_WITHOUT_PTR));
    if (!new_buf) return -1;
    new_size += slack / sizeof(*new_buf);
    fd->args = new_buf;
    fd->arg_size = new_size;
  }
  vd = &fd->args[fd->arg_count++];
  memset(vd, 0, sizeof(*vd));
  vd->var_name = LEPUS_DupAtom(ctx, name);
  vd->func_pool_idx = -1;
  return fd->arg_count - 1;
}

/* add a Hoisted definition for a function (cpool_idx >= 0) or a
   global variable (cpool_idx = -1) */
JSHoistedDef *add_hoisted_def(LEPUSContext *ctx, JSFunctionDef *s,
                              int cpool_idx, JSAtom name, int var_idx,
                              BOOL is_lexical) {
  JSHoistedDef *hf;

  if (s->hoisted_def_count >= s->hoisted_def_size) {
    int new_size;
    size_t slack;
    JSHoistedDef *new_tab;
    new_size = max_int(s->hoisted_def_count + 1, s->hoisted_def_size * 3 / 2);
    new_tab = static_cast<JSHoistedDef *>(lepus_realloc2(
        ctx, s->hoisted_def, new_size * sizeof(s->hoisted_def[0]), &slack,
        ALLOC_TAG_WITHOUT_PTR));
    if (!new_tab) return NULL;
    new_size += slack / sizeof(*new_tab);
    s->hoisted_def = new_tab;
    s->hoisted_def_size = new_size;
  }
  hf = &s->hoisted_def[s->hoisted_def_count++];
  hf->cpool_idx = cpool_idx;
  hf->force_init = 0;
  hf->is_lexical = is_lexical;
  hf->is_const = FALSE;
  hf->var_idx = var_idx;
  hf->scope_level = s->scope_level;
  if (!ctx->gc_enable) LEPUS_DupAtom(ctx, name);
  hf->var_name = name;
  return hf;
}

QJS_STATIC int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
                          JSVarDefEnum var_def_type) {
  CallGCParserFunc(define_var_GC, s, fd, name, var_def_type);
  LEPUSContext *ctx = s->ctx;
  JSVarDef *vd;
  int idx;

  switch (var_def_type) {
    case JS_VAR_DEF_WITH:
      idx = add_scope_var(ctx, fd, name, JS_VAR_NORMAL);
      break;

    case JS_VAR_DEF_LET:
    case JS_VAR_DEF_CONST:
    case JS_VAR_DEF_FUNCTION_DECL:
    case JS_VAR_DEF_NEW_FUNCTION_DECL:
      idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);
      if (idx >= 0) {
        if (idx < GLOBAL_VAR_OFFSET) {
          if (fd->vars[idx].scope_level == fd->scope_level) {
            /* same scope: in non strict mode, functions can be redefined (annex
             * B.3.3.4). */
            if (!(!(fd->js_mode & JS_MODE_STRICT) &&
                  var_def_type == JS_VAR_DEF_FUNCTION_DECL &&
                  fd->vars[idx].var_kind == JS_VAR_FUNCTION_DECL)) {
              goto redef_lex_error;
            }
          } else if (fd->vars[idx].var_kind == JS_VAR_CATCH &&
                     (fd->vars[idx].scope_level + 2) == fd->scope_level) {
            goto redef_lex_error;
          }
        } else {
          if (fd->scope_level == fd->body_scope) {
          redef_lex_error:
            /* redefining a scoped var in the same scope: error */
            return js_parse_error(s,
                                  "invalid redefinition of lexical identifier");
          }
        }
      }
      if (var_def_type != JS_VAR_DEF_FUNCTION_DECL &&
          var_def_type != JS_VAR_DEF_NEW_FUNCTION_DECL &&
          fd->scope_level == fd->body_scope && find_arg(ctx, fd, name) >= 0) {
        /* lexical variable redefines a parameter name */
        return js_parse_error(s, "invalid redefinition of parameter name");
      }

      if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {
        return js_parse_error(s, "invalid redefinition of a variable");
      }

      if (fd->is_global_var) {
        JSHoistedDef *hf;
        hf = find_hoisted_def(fd, name);
        /* XXX: should check scope chain */
        if (hf && is_child_scope(ctx, fd, hf->scope_level, fd->scope_level)) {
          return js_parse_error(s, "invalid redefinition of global identifier");
        }
      }

      if (fd->is_eval &&
          (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
           fd->eval_type == LEPUS_EVAL_TYPE_MODULE) &&
          fd->scope_level == fd->body_scope) {
        JSHoistedDef *hf;
        hf = add_hoisted_def(s->ctx, fd, -1, name, -1, TRUE);
        if (!hf) return -1;
        hf->is_lexical = TRUE;
        hf->is_const = (var_def_type == JS_VAR_DEF_CONST);
        idx = GLOBAL_VAR_OFFSET;
      } else {
        JSVarKindEnum var_kind;
        if (var_def_type == JS_VAR_DEF_FUNCTION_DECL)
          var_kind = JS_VAR_FUNCTION_DECL;
        else if (var_def_type == JS_VAR_DEF_NEW_FUNCTION_DECL)
          var_kind = JS_VAR_NEW_FUNCTION_DECL;
        else
          var_kind = JS_VAR_NORMAL;
        idx = add_scope_var(ctx, fd, name, var_kind);
        if (idx >= 0) {
          vd = &fd->vars[idx];
          vd->is_lexical = 1;
          vd->is_const = (var_def_type == JS_VAR_DEF_CONST);
        }
      }
      break;

    case JS_VAR_DEF_CATCH:
      idx = add_scope_var(ctx, fd, name, JS_VAR_CATCH);
      break;

    case JS_VAR_DEF_VAR:
      if (find_lexical_decl(ctx, fd, name, fd->scope_first, FALSE) >= 0) {
      invalid_lexical_redefinition:
        /* error to redefine a var that inside a lexical scope */
        return js_parse_error(s, "invalid redefinition of lexical identifier");
      }
      if (fd->is_global_var) {
        JSHoistedDef *hf;
        hf = find_hoisted_def(fd, name);
        if (hf && hf->is_lexical && hf->scope_level == fd->scope_level &&
            fd->eval_type == LEPUS_EVAL_TYPE_MODULE) {
          goto invalid_lexical_redefinition;
        }
        hf = add_hoisted_def(s->ctx, fd, -1, name, -1, FALSE);
        if (!hf) return -1;
        idx = GLOBAL_VAR_OFFSET;
      } else {
        /* if the variable already exists, don't add it again  */
        idx = find_var(ctx, fd, name);
        if (idx >= 0) break;
        idx = add_var(ctx, fd, name);
        if (idx >= 0) {
          if (name == JS_ATOM_arguments && fd->has_arguments_binding)
            fd->arguments_var_idx = idx;
          fd->vars[idx].scope_next = fd->scope_level;
        }
      }
      break;
    default:
      abort();
  }
  return idx;
}

QJS_STATIC __exception int js_parse_function_decl(JSParseState *s,
                                                  JSParseFunctionEnum func_type,
                                                  JSFunctionKindEnum func_kind,
                                                  JSAtom func_name,
                                                  const uint8_t *ptr,
                                                  int start_line);
QJS_STATIC JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s);
QJS_STATIC __exception int js_parse_function_decl2(
    JSParseState *s, JSParseFunctionEnum func_type,
    JSFunctionKindEnum func_kind, JSAtom func_name, const uint8_t *ptr,
    int function_line_num, JSParseExportEnum export_flag, JSFunctionDef **pfd);
QJS_STATIC __exception int js_parse_unary(JSParseState *s,
                                          int exponentiation_flag);
QJS_STATIC void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
                                 JSAtom label_name, int label_break,
                                 int label_cont, int drop_count);
QJS_STATIC void pop_break_entry(JSFunctionDef *fd);

/* Note: all the fields are already sealed except length */
QJS_STATIC int seal_template_obj(LEPUSContext *ctx, LEPUSValueConst obj) {
  CallGCFunc(seal_template_obj_GC, ctx, obj);
  LEPUSObject *p;
  JSShapeProperty *prs;

  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property1(p, JS_ATOM_length);
  if (prs) {
    if (js_update_property_flags(
            ctx, p, &prs,
            prs->flags & ~(LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)))
      return -1;
  }
  p->extensible = FALSE;
  return 0;
}

/* allow the 'in' binary operator */
#define PF_IN_ACCEPTED (1 << 0)
/* allow function calls parsing in js_parse_postfix_expr() */
#define PF_POSTFIX_CALL (1 << 1)
/* allow arrow functions parsing in js_parse_postfix_expr() */
#define PF_ARROW_FUNC (1 << 2)
/* allow the exponentiation operator in js_parse_unary() */
#define PF_POW_ALLOWED (1 << 3)
/* forbid the exponentiation operator in js_parse_unary() */
#define PF_POW_FORBIDDEN (1 << 4)
#define PF_LASTEST_ISNEW (1 << 5)

__exception int js_parse_template(JSParseState *s, int call, int *argc) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue raw_array, template_object;
  JSToken cooked;
  memset(&cooked, 0, sizeof(cooked));
  HandleScope func_scope(s->ctx, &cooked, HANDLE_TYPE_LEPUS_TOKEN);
  int depth, ret;

  raw_array = LEPUS_UNDEFINED;       /* avoid warning */
  template_object = LEPUS_UNDEFINED; /* avoid warning */
  func_scope.PushHandle(&raw_array, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&template_object, HANDLE_TYPE_LEPUS_VALUE);
  if (call) {
    /* Create a template object: an array of cooked strings */
    /* Create an array of raw strings and store it to the raw property */
    template_object = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(template_object)) return -1;
    //        pool_idx = s->cur_func->cpool_count;
    ret = emit_push_const(s, template_object, 0);
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, template_object);
    if (ret) return -1;
    raw_array = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(raw_array)) return -1;
    if (LEPUS_DefinePropertyValue(ctx, template_object, JS_ATOM_raw, raw_array,
                                  LEPUS_PROP_THROW) < 0) {
      return -1;
    }
  }

  depth = 0;
  while (s->token.val == TOK_TEMPLATE) {
    const uint8_t *p = s->token.ptr + 1;
    cooked = s->token;
    if (call) {
      if (LEPUS_DefinePropertyValueUint32(
              ctx, raw_array, depth, LEPUS_DupValue(ctx, s->token.u.str.str),
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_THROW) < 0) {
        return -1;
      }
      /* re-parse the string with escape sequences but do not throw a
         syntax error if it contains invalid sequences
       */
      if (js_parse_string(s, '`', FALSE, p, &cooked, &p)) {
        cooked.u.str.str = LEPUS_UNDEFINED;
      }
      if (LEPUS_DefinePropertyValueUint32(
              ctx, template_object, depth, cooked.u.str.str,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_THROW) < 0) {
        return -1;
      }
    } else {
      JSString *str;
      /* re-parse the string with escape sequences and throw a
         syntax error if it contains invalid sequences
       */
      if (!ctx->gc_enable) LEPUS_FreeValue(ctx, s->token.u.str.str);
      s->token.u.str.str = LEPUS_UNDEFINED;
      if (js_parse_string(s, '`', TRUE, p, &cooked, &p)) return -1;
      str = LEPUS_VALUE_GET_STRING(cooked.u.str.str);
      if (str->len != 0 || depth == 0) {
        ret = emit_push_const(s, cooked.u.str.str, 1);
        if (!ctx->gc_enable) LEPUS_FreeValue(s->ctx, cooked.u.str.str);
        if (ret) return -1;
        if (depth == 0) {
          if (s->token.u.str.sep == '`') goto done1;
          emit_op(s, OP_get_field2);
          emit_atom(s, JS_ATOM_concat);
        }
        depth++;
      } else {
        if (!ctx->gc_enable) LEPUS_FreeValue(s->ctx, cooked.u.str.str);
      }
    }
    if (s->token.u.str.sep == '`') goto done;
    if (next_token(s)) return -1;
    if (js_parse_expr(s)) return -1;
    depth++;
    if (s->token.val != '}') {
      return js_parse_error(s, "expected '}' after template expression");
    }
    /* XXX: should convert to string at this stage? */
    if (!ctx->gc_enable) free_token(s, &s->token);
    /* Resume TOK_TEMPLATE parsing (s->token.line_num and s->token.ptr are OK)
     */
    s->got_lf = FALSE;
    s->last_line_num = s->token.line_num;
    s->debugger_last_line_num = s->last_line_num;
    if (js_parse_template_part(s, s->buf_ptr)) return -1;
  }
  return js_parse_expect(s, TOK_TEMPLATE);

done:
  if (call) {
    /* Seal the objects */
    seal_template_obj(ctx, raw_array);
    seal_template_obj(ctx, template_object);
    *argc = depth + 1;
  } else {
    emit_op(s, OP_call_method);
    emit_u16(s, depth - 1);
  }
done1:
  return next_token(s);
}

#define PROP_TYPE_IDENT 0
#define PROP_TYPE_VAR 1
#define PROP_TYPE_GET 2
#define PROP_TYPE_SET 3
#define PROP_TYPE_STAR 4
#define PROP_TYPE_ASYNC 5
#define PROP_TYPE_ASYNC_STAR 6

#define PROP_TYPE_PRIVATE (1 << 4)

BOOL token_is_ident(int tok) {
  /* Accept keywords and reserved words as property names */
  return (tok == TOK_IDENT ||
          (tok >= TOK_FIRST_KEYWORD && tok <= TOK_LAST_KEYWORD));
}

/* if the property is an expression, name = JS_ATOM_NULL */
QJS_STATIC int __exception js_parse_property_name(JSParseState *s,
                                                  JSAtom *pname,
                                                  BOOL allow_method,
                                                  BOOL allow_var,
                                                  BOOL allow_private) {
  int is_private = 0;
  JSAtom name;
  int prop_type;

  prop_type = PROP_TYPE_IDENT;
  if (allow_method) {
    if ((token_is_pseudo_keyword(s, JS_ATOM_get) ||
         token_is_pseudo_keyword(s, JS_ATOM_set)) &&
        peek_token(s, FALSE) != ',' && peek_token(s, FALSE) != '}') {
      /* get x(), set x() */
      name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
      if (next_token(s)) goto fail1;
      if (s->token.val == ':' || s->token.val == ',' || s->token.val == '}' ||
          s->token.val == '(')
        goto done;
      prop_type = PROP_TYPE_GET + (name == JS_ATOM_set);
      LEPUS_FreeAtom(s->ctx, name);
    } else if (s->token.val == '*') {
      if (next_token(s)) goto fail;
      prop_type = PROP_TYPE_STAR;
    } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
               peek_token(s, TRUE) != '\n') {
      name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
      if (next_token(s)) goto fail1;
      if (s->token.val == '}' || s->token.val == ',') {
        prop_type = PROP_TYPE_VAR;
        goto done;
      }
      if (s->token.val == ':' || s->token.val == '(') goto done;
      LEPUS_FreeAtom(s->ctx, name);
      if (s->token.val == '*') {
        if (next_token(s)) goto fail;
        prop_type = PROP_TYPE_ASYNC_STAR;
      } else {
        prop_type = PROP_TYPE_ASYNC;
      }
    }
  }

  if (token_is_ident(s->token.val)) {
    /* variable can only be a non-reserved identifier */
    if (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
        prop_type == PROP_TYPE_IDENT && allow_var) {
      int tok = peek_token(s, FALSE);
      if (!(tok == ':' || (tok == '(' && allow_method))) {
        prop_type = PROP_TYPE_VAR;
      }
    }
    /* keywords and reserved words have a valid atom */
    name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail1;
  } else if (s->token.val == TOK_STRING) {
    name = js_value_to_atom(s->ctx, s->token.u.str.str);
    if (name == JS_ATOM_NULL) goto fail;
    if (next_token(s)) goto fail1;
  } else if (s->token.val == TOK_NUMBER) {
    LEPUSValue val;
    val = s->token.u.num.val;
#ifdef CONFIG_BIGNUM
    if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      double d;
      d = bf_mul_pow10_to_float64(s->ctx, &p->num, s->token.u.num.exponent);
      val = __JS_NewFloat64(s->ctx, d);
      name = js_value_to_atom(s->ctx, val);
      LEPUS_FreeValue(s->ctx, val);
    } else
#endif
    {
      name = js_value_to_atom(s->ctx, val);
    }
    if (name == JS_ATOM_NULL) goto fail;
    if (next_token(s)) goto fail1;
  } else if (s->token.val == '[') {
    if (next_token(s)) goto fail;
    if (js_parse_expr(s)) goto fail;
    if (js_parse_expect(s, ']')) goto fail;
    name = JS_ATOM_NULL;
  } else if (s->token.val == TOK_PRIVATE_NAME && allow_private) {
    name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail1;
    is_private = PROP_TYPE_PRIVATE;
  } else {
    goto invalid_prop;
  }
  if (prop_type != PROP_TYPE_IDENT && prop_type != PROP_TYPE_VAR &&
      s->token.val != '(') {
    LEPUS_FreeAtom(s->ctx, name);
  invalid_prop:
    js_parse_error(s, "invalid property name");
    goto fail;
  }
done:
  *pname = name;
  return prop_type | is_private;
fail1:
  LEPUS_FreeAtom(s->ctx, name);
fail:
  *pname = JS_ATOM_NULL;
  return -1;
}

typedef struct JSParsePos {
  int last_line_num;
  int line_num;
  BOOL got_lf;
  const uint8_t *ptr;
  // <Primjs begin>
  const uint8_t *last_line_begin_ptr;
  const uint8_t *line_begin_ptr;
  const uint8_t *utf8_parse_front;
  int utf8_adapte_size;
  int last_utf8_adapte_size;
  // <Primjs end>
} JSParsePos;

int js_parse_get_pos(JSParseState *s, JSParsePos *sp) {
  sp->last_line_num = s->last_line_num;
  sp->line_num = s->token.line_num;
  sp->ptr = s->token.ptr;
  sp->got_lf = s->got_lf;
  // <Primjs begin>
  sp->last_line_begin_ptr = s->last_line_begin_ptr;
  sp->line_begin_ptr = s->line_begin_ptr;
  sp->utf8_adapte_size = s->utf8_adapte_size;
  sp->last_utf8_adapte_size = s->last_utf8_adapte_size;
  sp->utf8_parse_front = s->utf8_parse_front;
  // <Primjs end>
  return 0;
}

__exception int js_parse_seek_token(JSParseState *s, const JSParsePos *sp) {
  s->token.line_num = sp->last_line_num;
  s->line_num = sp->line_num;
  s->buf_ptr = sp->ptr;
  // <Primjs begin>
  s->utf8_parse_front = sp->ptr;
  s->last_utf8_adapte_size = sp->last_utf8_adapte_size;
  s->utf8_adapte_size = sp->utf8_adapte_size;
  s->line_begin_ptr = sp->line_begin_ptr;
  // <Primjs end>
  s->got_lf = sp->got_lf;
  return next_token(s);
}

/* return TRUE if a regexp literal is allowed after this token */
QJS_STATIC BOOL is_regexp_allowed(int tok) {
  switch (tok) {
    case TOK_NUMBER:
    case TOK_STRING:
    case TOK_REGEXP:
    case TOK_DEC:
    case TOK_INC:
    case TOK_NULL:
    case TOK_FALSE:
    case TOK_TRUE:
    case TOK_THIS:
    case ')':
    case ']':
    case '}': /* XXX: regexp may occur after */
    case TOK_IDENT:
      return FALSE;
    default:
      return TRUE;
  }
}

#define SKIP_HAS_SEMI (1 << 0)
#define SKIP_HAS_ELLIPSIS (1 << 1)
#define SKIP_HAS_ASSIGNMENT (1 << 2)

/* XXX: improve speed with early bailout */
/* XXX: no longer works if regexps are present. Could use previous
   regexp parsing heuristics to handle most cases */
int js_parse_skip_parens_token(JSParseState *s, int *pbits,
                               BOOL no_line_terminator, BOOL *has_ellipsis) {
  char state[256];
  size_t level = 0;
  JSParsePos pos;
  int last_tok, tok = TOK_EOF;
  int c, tok_len, bits = 0;

  /* protect from underflow */
  state[level++] = 0;

  js_parse_get_pos(s, &pos);
  last_tok = 0;
  for (;;) {
    switch (s->token.val) {
      case '(':
      case '[':
      case '{':
        if (level >= sizeof(state)) goto done;
        state[level++] = s->token.val;
        break;
      case ')':
        if (state[--level] != '(') goto done;
        break;
      case ']':
        if (state[--level] != '[') goto done;
        break;
      case '}':
        c = state[--level];
        if (c == '`') {
          /* continue the parsing of the template */
          if (!s->ctx->gc_enable) free_token(s, &s->token);
          /* Resume TOK_TEMPLATE parsing (s->token.line_num and
           * s->token.ptr are OK) */
          s->got_lf = FALSE;
          s->last_line_num = s->token.line_num;
          if (js_parse_template_part(s, s->buf_ptr)) goto done;
          goto handle_template;
        } else if (c != '{') {
          goto done;
        }
        break;
      case TOK_TEMPLATE:
      handle_template:
        if (s->token.u.str.sep != '`') {
          /* '${' inside the template : closing '}' and continue
             parsing the template */
          if (level >= sizeof(state)) goto done;
          state[level++] = '`';
        }
        break;
      case TOK_EOF:
        goto done;
      case ';':
        if (level == 2) {
          bits |= SKIP_HAS_SEMI;
        }
        break;
      case TOK_ELLIPSIS:
        if (has_ellipsis) *has_ellipsis = TRUE;
        if (level == 2) {
          bits |= SKIP_HAS_ELLIPSIS;
        }
        break;
      case '=':
        bits |= SKIP_HAS_ASSIGNMENT;
        break;
      case TOK_DIV_ASSIGN:
      case '/':
        if (s->token.val == TOK_DIV_ASSIGN) {
          tok_len = 2;
        } else if (s->token.val == '/') {
          tok_len = 1;
        }
        if (is_regexp_allowed(last_tok)) {
          s->buf_ptr -= tok_len;
          if (js_parse_regexp(s)) {
            /* XXX: should clear the exception */
            goto done;
          }
        }
        break;
    }
    /* last_ok is only used to recognize regexps */
    if (s->token.val == TOK_IDENT &&
        (token_is_pseudo_keyword(s, JS_ATOM_of) ||
         token_is_pseudo_keyword(s, JS_ATOM_yield))) {
      last_tok = TOK_OF;
    } else {
      last_tok = s->token.val;
    }
    if (next_token(s)) {
      /* XXX: should clear the exception generated by next_token() */
      break;
    }
    if (level <= 1) {
      tok = s->token.val;
      if (token_is_pseudo_keyword(s, JS_ATOM_of)) tok = TOK_OF;
      if (no_line_terminator && s->last_line_num != s->token.line_num)
        tok = '\n';
      break;
    }
  }
done:
  if (pbits) {
    *pbits = bits;
  }
  if (js_parse_seek_token(s, &pos)) return -1;
  return tok;
}

BOOL set_object_name(JSParseState *s, JSAtom name) {
  JSFunctionDef *fd = s->cur_func;

  if (get_prev_opcode(fd) == OP_set_name) {
    /* XXX: should free atom after OP_set_name? */
    fd->byte_code.size = fd->last_opcode_pos;
    fd->last_opcode_pos = -1;
    emit_op(s, OP_set_name);
    emit_atom(s, name);
    return TRUE;
  }
  return FALSE;
}

void set_object_name_computed(JSParseState *s) {
  JSFunctionDef *fd = s->cur_func;

  if (get_prev_opcode(fd) == OP_set_name) {
    /* XXX: should free atom after OP_set_name? */
    fd->byte_code.size = fd->last_opcode_pos;
    fd->last_opcode_pos = -1;
    emit_op(s, OP_set_name_computed);
  }
}

QJS_STATIC __exception int js_parse_object_literal(JSParseState *s) {
  CallGCParserFunc(js_parse_object_literal_GC, s);
  JSAtom name = JS_ATOM_NULL;
  const uint8_t *start_ptr;
  int start_line, prop_type;
  BOOL has_proto;

  if (next_token(s)) goto fail;
  /* XXX: add an initial length that will be patched back */
  emit_op(s, OP_object);
  has_proto = FALSE;
  while (s->token.val != '}') {
    /* specific case for getter/setter */
    start_ptr = s->token.ptr;
    start_line = s->token.line_num;

    if (s->token.val == TOK_ELLIPSIS) {
      if (next_token(s)) return -1;
      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      emit_op(s, OP_null); /* dummy excludeList */
      emit_op(s, OP_copy_data_properties);
      emit_u8(s, 2 | (1 << 2) | (0 << 5));
      emit_op(s, OP_drop); /* pop excludeList */
      emit_op(s, OP_drop); /* pop src object */
      goto next;
    }

    prop_type = js_parse_property_name(s, &name, TRUE, TRUE, FALSE);
    if (prop_type < 0) goto fail;

    if (prop_type == PROP_TYPE_VAR) {
      /* shortcut for x: x */
      emit_op(s, OP_scope_get_var);
      emit_atom(s, name);
      emit_u16(s, s->cur_func->scope_level);
      emit_op(s, OP_define_field);
      emit_atom(s, name);
    } else if (s->token.val == '(') {
      BOOL is_getset =
          (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET);
      JSParseFunctionEnum func_type;
      JSFunctionKindEnum func_kind;
      int op_flags;

      func_kind = JS_FUNC_NORMAL;
      if (is_getset) {
        func_type = static_cast<JSParseFunctionEnum>(JS_PARSE_FUNC_GETTER +
                                                     prop_type - PROP_TYPE_GET);
      } else {
        func_type = JS_PARSE_FUNC_METHOD;
        if (prop_type == PROP_TYPE_STAR)
          func_kind = JS_FUNC_GENERATOR;
        else if (prop_type == PROP_TYPE_ASYNC)
          func_kind = JS_FUNC_ASYNC;
        else if (prop_type == PROP_TYPE_ASYNC_STAR)
          func_kind = JS_FUNC_ASYNC_GENERATOR;
      }
      if (js_parse_function_decl(s, func_type, func_kind, JS_ATOM_NULL,
                                 start_ptr, start_line))
        goto fail;
      if (name == JS_ATOM_NULL) {
        emit_op(s, OP_define_method_computed);
      } else {
        emit_op(s, OP_define_method);
        emit_atom(s, name);
      }
      if (is_getset) {
        op_flags = OP_DEFINE_METHOD_GETTER + prop_type - PROP_TYPE_GET;
      } else {
        op_flags = OP_DEFINE_METHOD_METHOD;
      }
      emit_u8(s, op_flags | OP_DEFINE_METHOD_ENUMERABLE);
    } else {
      if (js_parse_expect(s, ':')) goto fail;
      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
      if (name == JS_ATOM_NULL) {
        set_object_name_computed(s);
        emit_op(s, OP_define_array_el);
        emit_op(s, OP_drop);
      } else if (name == JS_ATOM___proto__) {
        if (has_proto) {
          js_parse_error(s, "duplicate __proto__ property name");
          goto fail;
        }
        emit_op(s, OP_set_proto);
        has_proto = TRUE;
      } else {
        set_object_name(s, name);
        emit_op(s, OP_define_field);
        emit_atom(s, name);
      }
    }
    LEPUS_FreeAtom(s->ctx, name);
  next:
    name = JS_ATOM_NULL;
    if (s->token.val != ',') break;
    if (next_token(s)) goto fail;
  }
  if (js_parse_expect(s, '}')) goto fail;
  return 0;
fail:
  LEPUS_FreeAtom(s->ctx, name);
  return -1;
}

void optional_chain_test(JSParseState *s, int *poptional_chaining_label,
                         int drop_count) {
  int label_next_1, label_next_2, i;
  if (*poptional_chaining_label < 0) *poptional_chaining_label = new_label(s);
  /* XXX: could be more efficient with a specific opcode */
  emit_op(s, OP_dup);
  emit_op(s, OP_is_undefined);
  label_next_1 = emit_goto(s, OP_if_true, -1);

  emit_op(s, OP_dup);
  emit_op(s, OP_is_null);
  label_next_2 = emit_goto(s, OP_if_false, -1);

  emit_label(s, label_next_1);
  for (i = 0; i < drop_count; i++) emit_op(s, OP_drop);
  emit_op(s, OP_undefined);
  emit_goto(s, OP_goto, *poptional_chaining_label);
  emit_label(s, label_next_2);
}

QJS_STATIC __exception int js_parse_postfix_expr(JSParseState *s,
                                                 int parse_flags);

QJS_STATIC __exception int js_parse_left_hand_side_expr(JSParseState *s) {
  return js_parse_postfix_expr(s, PF_POSTFIX_CALL);
}

/* XXX: is there is nicer solution ? */
__exception int js_parse_class_default_ctor(JSParseState *s, BOOL has_super,
                                            JSFunctionDef **pfd) {
  JSParsePos pos;
  const char *str;
  int ret, line_num;
  JSParseFunctionEnum func_type;
  const uint8_t *saved_buf_end;

  js_parse_get_pos(s, &pos);
  if (has_super) {
    /* spec change: no argument evaluation */
    str = "(){super(...arguments);}";
    func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
  } else {
    str = "(){}";
    func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
  }
  line_num = s->token.line_num;
  saved_buf_end = s->buf_end;
  s->buf_ptr = (uint8_t *)str;
  s->buf_end = (uint8_t *)(str + strlen(str));
  ret = next_token(s);
  if (!ret) {
    ret = js_parse_function_decl2(s, func_type, JS_FUNC_NORMAL, JS_ATOM_NULL,
                                  (uint8_t *)str, line_num,
                                  JS_PARSE_EXPORT_NONE, pfd);
  }
  s->buf_end = saved_buf_end;
  ret |= js_parse_seek_token(s, &pos);
  return ret;
}

/* find field in the current scope */
int find_private_class_field(LEPUSContext *ctx, JSFunctionDef *fd, JSAtom name,
                             int scope_level) {
  int idx;
  idx = fd->scopes[scope_level].first;
  while (idx != -1) {
    if (fd->vars[idx].scope_level != scope_level) break;
    if (fd->vars[idx].var_name == name) return idx;
    idx = fd->vars[idx].scope_next;
  }
  return -1;
}

/* add field in the current scope */
QJS_STATIC int add_private_class_field(JSParseState *s, JSFunctionDef *fd,
                                       JSAtom name, JSVarKindEnum var_kind) {
  LEPUSContext *ctx = s->ctx;
  JSVarDef *vd;
  int idx;

  idx = add_scope_var(ctx, fd, name, var_kind);
  if (idx < 0) return idx;
  vd = &fd->vars[idx];
  vd->is_lexical = 1;
  vd->is_const = 1;
  return idx;
}

/* initialize the class fields, called by the constructor. Note:
   super() can be called in an arrow function, so <this> and
   <class_fields_init> can be variable references */
QJS_STATIC void emit_class_field_init(JSParseState *s) {
  int label_next;

  emit_op(s, OP_scope_get_var);
  emit_atom(s, JS_ATOM_class_fields_init);
  emit_u16(s, s->cur_func->scope_level);

  /* no need to call the class field initializer if not defined */
  emit_op(s, OP_dup);
  label_next = emit_goto(s, OP_if_false, -1);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, JS_ATOM_this);
  emit_u16(s, 0);

  emit_op(s, OP_swap);

  emit_op(s, OP_call_method);
  emit_u16(s, 0);

  emit_label(s, label_next);
  emit_op(s, OP_drop);
}

/* build a private setter function name from the private getter name */
QJS_STATIC JSAtom get_private_setter_name(LEPUSContext *ctx, JSAtom name) {
  return js_atom_concat_str(ctx, name, "<set>");
}

typedef struct {
  JSFunctionDef *fields_init_fd;
  int computed_fields_count;
  BOOL has_brand;
  int brand_push_pos;
} ClassFieldsDef;

QJS_STATIC __exception int emit_class_init_start(JSParseState *s,
                                                 ClassFieldsDef *cf) {
  int label_add_brand;

  cf->fields_init_fd = js_parse_function_class_fields_init(s);
  if (!cf->fields_init_fd) return -1;

  s->cur_func = cf->fields_init_fd;

  /* XXX: would be better to add the code only if needed, maybe in a
     later pass */
  emit_op(s, OP_push_false); /* will be patched later */
  cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
  label_add_brand = emit_goto(s, OP_if_false, -1);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, JS_ATOM_this);
  emit_u16(s, 0);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, JS_ATOM_home_object);
  emit_u16(s, 0);

  emit_op(s, OP_add_brand);

  emit_label(s, label_add_brand);

  s->cur_func = s->cur_func->parent;
  return 0;
}

QJS_STATIC __exception int add_brand(JSParseState *s, ClassFieldsDef *cf) {
  if (!cf->has_brand) {
    /* define the brand field in 'this' of the initializer */
    if (!cf->fields_init_fd) {
      if (emit_class_init_start(s, cf)) return -1;
    }
    /* patch the start of the function to enable the OP_add_brand code */
    cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;

    cf->has_brand = TRUE;
  }
  return 0;
}

QJS_STATIC void emit_class_init_end(JSParseState *s, ClassFieldsDef *cf) {
  int cpool_idx;

  s->cur_func = cf->fields_init_fd;
  emit_op(s, OP_return_undef);
  s->cur_func = s->cur_func->parent;

  cpool_idx = cpool_add(s, LEPUS_NULL);
  cf->fields_init_fd->parent_cpool_idx = cpool_idx;
  emit_op(s, OP_fclosure);
  emit_u32(s, cpool_idx);
  emit_op(s, OP_set_home_object);
}

__exception int js_parse_class(JSParseState *s, BOOL is_class_expr,
                               JSParseExportEnum export_flag) {
  LEPUSContext *ctx = s->ctx;
  JSFunctionDef *fd = s->cur_func;
  HandleScope func_scope(ctx->rt);
  JSAtom name = JS_ATOM_NULL, class_name = JS_ATOM_NULL, class_name1;
  JSAtom class_var_name = JS_ATOM_NULL;
  JSFunctionDef *method_fd, *ctor_fd;
  int saved_js_mode, class_name_var_idx, prop_type, ctor_cpool_offset;
  int class_flags = 0, i;
  BOOL is_static, is_private;
  const uint8_t *class_start_ptr = s->token.ptr;
  const uint8_t *start_ptr;
  ClassFieldsDef class_fields[2];

  /* classes are parsed and executed in strict mode */
  saved_js_mode = fd->js_mode;
  fd->js_mode |= JS_MODE_STRICT;
  if (next_token(s)) goto fail;
  if (s->token.val == TOK_IDENT) {
    if (s->token.u.ident.is_reserved) {
      js_parse_error_reserved_identifier(s);
      goto fail;
    }
    class_name = ctx->gc_enable ? s->token.u.ident.atom
                                : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail;
  } else if (!is_class_expr && export_flag != JS_PARSE_EXPORT_DEFAULT) {
    js_parse_error(s, "class statement requires a name");
    goto fail;
  }
  if (!is_class_expr) {
    if (class_name == JS_ATOM_NULL)
      class_var_name = JS_ATOM__default_; /* export default */
    else
      class_var_name = class_name;
    class_var_name =
        ctx->gc_enable ? class_var_name : LEPUS_DupAtom(ctx, class_var_name);
  }

  push_scope(s);

  if (s->token.val == TOK_EXTENDS) {
    class_flags = JS_DEFINE_CLASS_HAS_HERITAGE;
    if (next_token(s)) goto fail;
      /* XXX: the grammar only allows LeftHandSideExpression */
#ifdef ENABLE_COMPATIBLE_MM
    if (ctx->gc_enable) {
      if (js_parse_left_hand_side_expr_GC(s)) goto fail;
    } else
#endif
    {
      if (js_parse_left_hand_side_expr(s)) goto fail;
    }
  } else {
    emit_op(s, OP_undefined);
  }

  /* add a 'const' definition for the class name */
  if (class_name != JS_ATOM_NULL) {
    class_name_var_idx = define_var(s, fd, class_name, JS_VAR_DEF_CONST);
    if (class_name_var_idx < 0) goto fail;
  }

  if (js_parse_expect(s, '{')) goto fail;

  /* this scope contains the private fields */
  push_scope(s);

  emit_op(s, OP_push_const);
  ctor_cpool_offset = fd->byte_code.size;
  emit_u32(s, 0); /* will be patched at the end of the class parsing */

  if (class_var_name != JS_ATOM_NULL && class_name == JS_ATOM_NULL)
    class_name1 = JS_ATOM_default;
  else
    class_name1 = class_name;

  emit_op(s, OP_define_class);
  emit_atom(s, class_name1);
  emit_u8(s, class_flags);

  for (i = 0; i < 2; i++) {
    ClassFieldsDef *cf = &class_fields[i];
    cf->fields_init_fd = NULL;
    cf->computed_fields_count = 0;
    cf->has_brand = FALSE;
  }

  ctor_fd = NULL;
  while (s->token.val != '}') {
    if (s->token.val == ';') {
      if (next_token(s)) goto fail;
      continue;
    }
    is_static = (s->token.val == TOK_STATIC);
    prop_type = -1;
    if (is_static) {
      if (next_token(s)) goto fail;
      /* allow "static" field name */
      if (s->token.val == ';' || s->token.val == '=') {
        is_static = FALSE;
        name = ctx->gc_enable ? JS_ATOM_static
                              : LEPUS_DupAtom(ctx, JS_ATOM_static);
        prop_type = PROP_TYPE_IDENT;
      }
    }
    if (is_static) emit_op(s, OP_swap);
    start_ptr = s->token.ptr;
    if (prop_type < 0) {
#ifdef ENABLE_COMPATIBLE_MM
      if (ctx->gc_enable)
        prop_type = js_parse_property_name_GC(s, &name, TRUE, FALSE, TRUE);
      else
#endif
        prop_type = js_parse_property_name(s, &name, TRUE, FALSE, TRUE);
      func_scope.PushLEPUSAtom(name);
      if (prop_type < 0) goto fail;
    }
    is_private = prop_type & PROP_TYPE_PRIVATE;
    prop_type &= ~PROP_TYPE_PRIVATE;

    if ((name == JS_ATOM_constructor && !is_static &&
         prop_type != PROP_TYPE_IDENT) ||
        (name == JS_ATOM_prototype && is_static) ||
        name == JS_ATOM_hash_constructor) {
      js_parse_error(s, "invalid method name");
      goto fail;
    }
    if (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET) {
      BOOL is_set = prop_type - PROP_TYPE_GET;
      JSFunctionDef *method_fd;

      if (is_private) {
        int idx, var_kind;
        idx = find_private_class_field(ctx, fd, name, fd->scope_level);
        if (idx >= 0) {
          var_kind = fd->vars[idx].var_kind;
          if (var_kind == JS_VAR_PRIVATE_FIELD ||
              var_kind == JS_VAR_PRIVATE_METHOD ||
              var_kind == JS_VAR_PRIVATE_GETTER_SETTER ||
              var_kind == (JS_VAR_PRIVATE_GETTER + is_set)) {
            goto private_field_already_defined;
          }
          fd->vars[idx].var_kind = JS_VAR_PRIVATE_GETTER_SETTER;
        } else {
          if (add_private_class_field(s, fd, name,
                                      static_cast<JSVarKindEnum>(
                                          JS_VAR_PRIVATE_GETTER + is_set)) < 0)
            goto fail;
        }
        if (add_brand(s, &class_fields[is_static]) < 0) goto fail;
      }

      if (js_parse_function_decl2(
              s,
              static_cast<JSParseFunctionEnum>(JS_PARSE_FUNC_GETTER + is_set),
              JS_FUNC_NORMAL, JS_ATOM_NULL, start_ptr, s->token.line_num,
              JS_PARSE_EXPORT_NONE, &method_fd))
        goto fail;
      if (is_private) {
        method_fd->need_home_object = TRUE; /* needed for brand check */
        emit_op(s, OP_set_home_object);
        /* XXX: missing function name */
        emit_op(s, OP_scope_put_var_init);
        if (is_set) {
          JSAtom setter_name;
          HandleScope func_scope(ctx->rt);
          int ret;

          setter_name = get_private_setter_name(ctx, name);
          if (setter_name == JS_ATOM_NULL) goto fail;
          func_scope.PushLEPUSAtom(setter_name);
          emit_atom(s, setter_name);
          ret = add_private_class_field(s, fd, setter_name,
                                        JS_VAR_PRIVATE_SETTER);
          if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, setter_name);
          if (ret < 0) goto fail;
        } else {
          emit_atom(s, name);
        }
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (name == JS_ATOM_NULL) {
          emit_op(s, OP_define_method_computed);
        } else {
          emit_op(s, OP_define_method);
          emit_atom(s, name);
        }
        emit_u8(s, OP_DEFINE_METHOD_GETTER + is_set);
      }
    } else if (prop_type == PROP_TYPE_IDENT && s->token.val != '(') {
      ClassFieldsDef *cf = &class_fields[is_static];
      JSAtom field_var_name = JS_ATOM_NULL;

      /* class field */

      /* XXX: spec: not consistent with method name checks */
      if (name == JS_ATOM_constructor || name == JS_ATOM_prototype) {
        js_parse_error(s, "invalid field name");
        goto fail;
      }

      if (is_private) {
        if (find_private_class_field(ctx, fd, name, fd->scope_level) >= 0) {
          goto private_field_already_defined;
        }
        if (add_private_class_field(s, fd, name, JS_VAR_PRIVATE_FIELD) < 0)
          goto fail;
        emit_op(s, OP_private_symbol);
        emit_atom(s, name);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }

      if (!cf->fields_init_fd) {
        if (emit_class_init_start(s, cf)) goto fail;
      }
      if (name == JS_ATOM_NULL) {
        HandleScope func_scope(ctx->rt);
        /* save the computed field name into a variable */
        field_var_name = js_atom_concat_num(
            ctx, JS_ATOM_computed_field + is_static, cf->computed_fields_count);
        if (field_var_name == JS_ATOM_NULL) goto fail;
        func_scope.PushLEPUSAtom(field_var_name);
        if (define_var(s, fd, field_var_name, JS_VAR_DEF_CONST) < 0) {
          if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, field_var_name);
          goto fail;
        }
        emit_op(s, OP_to_propkey);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, field_var_name);
        emit_u16(s, s->cur_func->scope_level);
      }
      s->cur_func = cf->fields_init_fd;
      emit_op(s, OP_scope_get_var);
      emit_atom(s, JS_ATOM_this);
      emit_u16(s, 0);

      if (name == JS_ATOM_NULL) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, field_var_name);
        emit_u16(s, s->cur_func->scope_level);
        cf->computed_fields_count++;
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, field_var_name);
      } else if (is_private) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }

      if (s->token.val == '=') {
        if (next_token(s)) goto fail;
        if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
      } else {
        emit_op(s, OP_undefined);
      }
      if (is_private) {
        set_object_name_computed(s);
        emit_op(s, OP_define_private_field);
      } else if (name == JS_ATOM_NULL) {
        set_object_name_computed(s);
        emit_op(s, OP_define_array_el);
        emit_op(s, OP_drop);
      } else {
        set_object_name(s, name);
        emit_op(s, OP_define_field);
        emit_atom(s, name);
      }
      s->cur_func = s->cur_func->parent;
      if (js_parse_expect_semi(s)) goto fail;
    } else {
      JSParseFunctionEnum func_type;
      JSFunctionKindEnum func_kind;

      func_type = JS_PARSE_FUNC_METHOD;
      func_kind = JS_FUNC_NORMAL;
      if (prop_type == PROP_TYPE_STAR) {
        func_kind = JS_FUNC_GENERATOR;
      } else if (prop_type == PROP_TYPE_ASYNC) {
        func_kind = JS_FUNC_ASYNC;
      } else if (prop_type == PROP_TYPE_ASYNC_STAR) {
        func_kind = JS_FUNC_ASYNC_GENERATOR;
      } else if (name == JS_ATOM_constructor && !is_static) {
        if (ctor_fd) {
          js_parse_error(s, "property constructor appears more than once");
          goto fail;
        }
        if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE)
          func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
        else
          func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
      }
      if (is_private) {
        if (add_brand(s, &class_fields[is_static]) < 0) goto fail;
      }
      if (js_parse_function_decl2(s, func_type, func_kind, JS_ATOM_NULL,
                                  start_ptr, s->token.line_num,
                                  JS_PARSE_EXPORT_NONE, &method_fd))
        goto fail;
      if (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR ||
          func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
        ctor_fd = method_fd;
      } else if (is_private) {
        method_fd->need_home_object = TRUE; /* needed for brand check */
        if (find_private_class_field(ctx, fd, name, fd->scope_level) >= 0) {
        private_field_already_defined:
          js_parse_error(s, "private class field is already defined");
          goto fail;
        }
        if (add_private_class_field(s, fd, name, JS_VAR_PRIVATE_METHOD) < 0)
          goto fail;
        emit_op(s, OP_set_home_object);
        emit_op(s, OP_set_name);
        emit_atom(s, name);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (name == JS_ATOM_NULL) {
          emit_op(s, OP_define_method_computed);
        } else {
          emit_op(s, OP_define_method);
          emit_atom(s, name);
        }
        emit_u8(s, OP_DEFINE_METHOD_METHOD);
      }
    }
    if (is_static) emit_op(s, OP_swap);
    if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, name);
    name = JS_ATOM_NULL;
  }

  if (s->token.val != '}') {
    js_parse_error(s, "expecting '%c'", '}');
    goto fail;
  }

  if (!ctor_fd) {
    if (js_parse_class_default_ctor(
            s, class_flags & JS_DEFINE_CLASS_HAS_HERITAGE, &ctor_fd))
      goto fail;
  }
  /* patch the constant pool index for the constructor */
  put_u32(fd->byte_code.buf + ctor_cpool_offset, ctor_fd->parent_cpool_idx);

  /* store the class source code in the constructor. */
  if (!(fd->js_mode & JS_MODE_STRIP)) {
    system_free(ctor_fd->source);
    auto offset = ctor_fd->src_start - (const char *)class_start_ptr;
    for (uint32_t i = 0, size = ctor_fd->caller_count; i < size; ++i) {
      auto &slot = ctor_fd->caller_slots[i];
      slot.off += offset;
    }
    ctor_fd->source_len = s->buf_ptr - class_start_ptr;
    ctor_fd->source =
        js_strmalloc((const char *)class_start_ptr, ctor_fd->source_len);
    if (!ctor_fd->source) goto fail;
  }

  /* consume the '}' */
  if (next_token(s)) goto fail;

  /* store the function to initialize the fields to that it can be
     referenced by the constructor */
  {
    ClassFieldsDef *cf = &class_fields[0];
    int var_idx;

    var_idx = define_var(s, fd, JS_ATOM_class_fields_init, JS_VAR_DEF_CONST);
    if (var_idx < 0) goto fail;
    if (cf->fields_init_fd) {
      emit_class_init_end(s, cf);
    } else {
      emit_op(s, OP_undefined);
    }
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, JS_ATOM_class_fields_init);
    emit_u16(s, s->cur_func->scope_level);
  }

  /* drop the prototype */
  emit_op(s, OP_drop);

  /* initialize the static fields */
  if (class_fields[1].fields_init_fd != NULL) {
    ClassFieldsDef *cf = &class_fields[1];
    emit_op(s, OP_dup);
    emit_class_init_end(s, cf);
    emit_op(s, OP_call_method);
    emit_u16(s, 0);
    emit_op(s, OP_drop);
  }

  if (class_name != JS_ATOM_NULL) {
    /* store the class name in the scoped class name variable (it
       is independent from the class statement variable
       definition) */
    emit_op(s, OP_dup);
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, class_name);
    emit_u16(s, fd->scope_level);
  }
  pop_scope(s);
  pop_scope(s);

  /* the class statements have a block level scope */
  if (class_var_name != JS_ATOM_NULL) {
    if (define_var(s, fd, class_var_name, JS_VAR_DEF_LET) < 0) goto fail;
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, class_var_name);
    emit_u16(s, fd->scope_level);
  } else {
    if (class_name == JS_ATOM_NULL) {
      /* XXX: should be done before calling the initializers. It
         could be done with a specific opcode to patch the code
         before */
      emit_op(s, OP_set_name);
      emit_atom(s, class_name); /* will be patched by assignment */
    }
  }

  if (export_flag != JS_PARSE_EXPORT_NONE) {
    if (!add_export_entry(s, fd->module, class_var_name,
                          export_flag == JS_PARSE_EXPORT_NAMED
                              ? class_var_name
                              : JS_ATOM_default,
                          JS_EXPORT_TYPE_LOCAL))
      goto fail;
  }

  if (!ctx->gc_enable) {
    LEPUS_FreeAtom(ctx, class_name);
    LEPUS_FreeAtom(ctx, class_var_name);
  }
  fd->js_mode = saved_js_mode;
  return 0;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeAtom(ctx, name);
    LEPUS_FreeAtom(ctx, class_name);
    LEPUS_FreeAtom(ctx, class_var_name);
  }
  fd->js_mode = saved_js_mode;
  return -1;
}

__exception int js_parse_array_literal(JSParseState *s) {
  uint32_t idx;
  BOOL need_length;

  if (next_token(s)) return -1;
  /* small regular arrays are created on the stack */
  idx = 0;
  while (s->token.val != ']' && idx < 32) {
    if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS) break;
    if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    idx++;
    /* accept trailing comma */
    if (s->token.val == ',') {
      if (next_token(s)) return -1;
    } else if (s->token.val != ']')
      goto done;
  }
  emit_op(s, OP_array_from);
  emit_u16(s, idx);

  /* larger arrays and holes are handled with explicit indices */
  need_length = FALSE;
  while (s->token.val != ']' && idx < 0x7fffffff) {
    if (s->token.val == TOK_ELLIPSIS) break;
    need_length = TRUE;
    if (s->token.val != ',') {
      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      emit_op(s, OP_define_field);
      emit_u32(s, __JS_AtomFromUInt32(idx));
      need_length = FALSE;
    }
    idx++;
    /* accept trailing comma */
    if (s->token.val == ',') {
      if (next_token(s)) return -1;
    }
  }
  if (s->token.val == ']') {
    if (need_length) {
      /* Set the length: Cannot use OP_define_field because
         length is not configurable */
      emit_op(s, OP_dup);
      emit_op(s, OP_push_i32);
      emit_u32(s, idx);
      emit_op(s, OP_put_field);
      emit_atom(s, JS_ATOM_length);
    }
    goto done;
  }

  /* huge arrays and spread elements require a dynamic index on the stack */
  emit_op(s, OP_push_i32);
  emit_u32(s, idx);

  /* stack has array, index */
  while (s->token.val != ']') {
    if (s->token.val == TOK_ELLIPSIS) {
      if (next_token(s)) return -1;
      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
#if 1
      emit_op(s, OP_append);
#else
      int label_next, label_done;
      label_next = new_label(s);
      label_done = new_label(s);
      /* enumerate object */
      emit_op(s, OP_for_of_start);
      emit_op(s, OP_rot5l);
      emit_op(s, OP_rot5l);
      emit_label(s, label_next);
      /* on stack: enum_rec array idx */
      emit_op(s, OP_for_of_next);
      emit_u8(s, 2);
      emit_goto(s, OP_if_true, label_done);
      /* append element */
      /* enum_rec array idx val -> enum_rec array new_idx */
      emit_op(s, OP_define_array_el);
      emit_op(s, OP_inc);
      emit_goto(s, OP_goto, label_next);
      emit_label(s, label_done);
      /* close enumeration */
      emit_op(s, OP_drop); /* drop undef val */
      emit_op(s, OP_nip1); /* drop enum_rec */
      emit_op(s, OP_nip1);
      emit_op(s, OP_nip1);
#endif
    } else {
      need_length = TRUE;
      if (s->token.val != ',') {
        if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
        /* a idx val */
        emit_op(s, OP_define_array_el);
        need_length = FALSE;
      }
      emit_op(s, OP_inc);
    }
    if (s->token.val != ',') break;
    if (next_token(s)) return -1;
  }
  if (need_length) {
    /* Set the length: cannot use OP_define_field because
       length is not configurable */
    emit_op(s, OP_dup1); /* array length - array array length */
    emit_op(s, OP_put_field);
    emit_atom(s, JS_ATOM_length);
  } else {
    emit_op(s, OP_drop); /* array length - array */
  }
done:
  return js_parse_expect(s, ']');
}

/* XXX: remove */
QJS_STATIC BOOL has_with_scope(JSFunctionDef *s, int scope_level) {
  /* check if scope chain contains a with statement */
  while (s) {
    int scope_idx = s->scopes[scope_level].first;
    while (scope_idx >= 0) {
      JSVarDef *vd = &s->vars[scope_idx];

      if (vd->var_name == JS_ATOM__with_) return TRUE;
      scope_idx = vd->scope_next;
    }
    /* check parent scopes */
    scope_level = s->parent_scope_level;
    s = s->parent;
  }
  return FALSE;
}

typedef struct JSLValue {
  int opcode;
  int scope;
  int label;
  int depth;
  int tok;
  JSAtom name;
} JSLValue;

__exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,
                           JSAtom *pname, int *plabel, int *pdepth, BOOL keep,
                           int tok) {
  JSFunctionDef *fd;
  int opcode, scope, label, depth;
  JSAtom name;

  /* we check the last opcode to get the lvalue type */
  fd = s->cur_func;
  scope = 0;
  name = JS_ATOM_NULL;
  label = -1;
  depth = 0;
  switch (opcode = get_prev_opcode(fd)) {
    case OP_scope_get_var:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
      if ((name == JS_ATOM_arguments || name == JS_ATOM_eval) &&
          (fd->js_mode & JS_MODE_STRICT)) {
        return js_parse_error(s, "invalid lvalue in strict mode");
      }
      if (name == JS_ATOM_this || name == JS_ATOM_new_target)
        goto invalid_lvalue;
      depth = 2; /* will generate OP_get_ref_value */
      break;
    case OP_get_field:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      depth = 1;
      break;
    case OP_scope_get_private_field:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
      depth = 1;
      break;
    case OP_get_array_el:
      depth = 2;
      break;
    case OP_get_super_value:
      depth = 3;
      break;
    default:
    invalid_lvalue:
      if (tok == TOK_FOR) {
        return js_parse_error(s, "invalid for in/of left hand-side");
      } else if (tok == TOK_INC || tok == TOK_DEC) {
        return js_parse_error(s, "invalid increment/decrement operand");
      } else if (tok == '[' || tok == '{') {
        return js_parse_error(s, "invalid destructuring target");
      } else {
        return js_parse_error(s, "invalid assignment left-hand side");
      }
  }
  /* remove the last opcode */
  fd->byte_code.size = fd->last_opcode_pos;
  fd->last_opcode_pos = -1;

  if (keep) {
    /* get the value but keep the object/fields on the stack */
    switch (opcode) {
      case OP_scope_get_var:
        label = new_label(s);
        emit_op(s, OP_scope_make_ref);
        emit_atom(s, name);
        emit_u32(s, label);
        emit_u16(s, scope);
        update_label(fd, label, 1);
        emit_op(s, OP_get_ref_value);
        opcode = OP_get_ref_value;
        break;
      case OP_get_field:
        emit_op(s, OP_get_field2);
        emit_atom(s, name);
        break;
      case OP_scope_get_private_field:
        emit_op(s, OP_scope_get_private_field2);
        emit_atom(s, name);
        emit_u16(s, scope);
        break;
      case OP_get_array_el:
        /* XXX: replace by a single opcode ? */
        emit_op(s, OP_to_propkey2);
        emit_op(s, OP_dup2);
        emit_op(s, OP_get_array_el);
        break;
      case OP_get_super_value:
        emit_op(s, OP_to_propkey);
        emit_op(s, OP_dup3);
        emit_op(s, OP_get_super_value);
        break;
      default:
        abort();
    }
  } else {
    switch (opcode) {
      case OP_scope_get_var:
        label = new_label(s);
        emit_op(s, OP_scope_make_ref);
        emit_atom(s, name);
        emit_u32(s, label);
        emit_u16(s, scope);
        update_label(fd, label, 1);
        opcode = OP_get_ref_value;
        break;
      case OP_get_array_el:
        emit_op(s, OP_to_propkey2);
        break;
      case OP_get_super_value:
        emit_op(s, OP_to_propkey);
        break;
    }
  }

  *popcode = opcode;
  *pscope = scope;
  /* name has refcount for OP_get_field and OP_get_ref_value,
     and JS_ATOM_NULL for other opcodes */
  *pname = name;
  *plabel = label;
  if (pdepth) *pdepth = depth;
  return 0;
}

/* name has a live reference. 'is_let' is only used with opcode =
   OP_scope_get_var which is never generated by get_lvalue(). */
void put_lvalue(JSParseState *s, int opcode, int scope, JSAtom name, int label,
                PutLValueEnum special, BOOL is_let) {
  switch (opcode) {
    case OP_get_field:
    case OP_scope_get_private_field:
      /* depth = 1 */
      switch (special) {
        case PUT_LVALUE_NOKEEP:
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert2); /* obj v -> v obj v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_swap);
          break;
        default:
          abort();
      }
      break;
    case OP_get_array_el:
    case OP_get_ref_value:
      /* depth = 2 */
      if (opcode == OP_get_ref_value) {
        if (!s->ctx->gc_enable) LEPUS_FreeAtom(s->ctx, name);
        emit_label(s, label);
      }
      switch (special) {
        case PUT_LVALUE_NOKEEP:
          emit_op(s, OP_nop); /* will trigger optimization */
          break;
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_rot3l);
          break;
        default:
          abort();
      }
      break;
    case OP_get_super_value:
      /* depth = 3 */
      switch (special) {
        case PUT_LVALUE_NOKEEP:
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_rot4l);
          break;
        default:
          abort();
      }
      break;
    default:
      break;
  }

  switch (opcode) {
    case OP_scope_get_var: /* val -- */
      assert(special == PUT_LVALUE_NOKEEP ||
             special == PUT_LVALUE_NOKEEP_DEPTH);
      emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);
      emit_u32(s, name); /* has refcount */
      emit_u16(s, scope);
      break;
    case OP_get_field:
      emit_op(s, OP_put_field);
      emit_u32(s, name); /* name has refcount */
      break;
    case OP_scope_get_private_field:
      emit_op(s, OP_scope_put_private_field);
      emit_u32(s, name); /* name has refcount */
      emit_u16(s, scope);
      break;
    case OP_get_array_el:
      emit_op(s, OP_put_array_el);
      break;
    case OP_get_ref_value:
      emit_op(s, OP_put_ref_value);
      break;
    case OP_get_super_value:
      emit_op(s, OP_put_super_value);
      break;
    default:
      abort();
  }
}

__exception int js_parse_expr_paren(JSParseState *s) {
  if (js_parse_expect(s, '(')) return -1;
  if (js_parse_expr(s)) return -1;
  if (js_parse_expect(s, ')')) return -1;
  return 0;
}

QJS_STATIC int js_unsupported_keyword(JSParseState *s, JSAtom atom) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return js_parse_error(s, "unsupported keyword: %s",
                        JS_AtomGetStr(s->ctx, buf, sizeof(buf), atom));
}

__exception int js_define_var(JSParseState *s, JSAtom name, int tok) {
  JSFunctionDef *fd = s->cur_func;

  if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {
    return js_parse_error(s, "yield is a reserved identifier");
  }
  if ((name == JS_ATOM_arguments || name == JS_ATOM_eval) &&
      (fd->js_mode & JS_MODE_STRICT)) {
    return js_parse_error(s, "invalid variable name in strict mode");
  }
  if ((name == JS_ATOM_let || name == JS_ATOM_undefined) &&
      (tok == TOK_LET || tok == TOK_CONST)) {
    return js_parse_error(s, "invalid lexical variable name");
  }
  JSVarDefEnum var_def_type;
  switch (tok) {
    case TOK_LET:
      var_def_type = JS_VAR_DEF_LET;
      break;
    case TOK_CONST:
      var_def_type = JS_VAR_DEF_CONST;
      break;
    case TOK_VAR:
      var_def_type = JS_VAR_DEF_VAR;
      break;
    case TOK_CATCH:
      var_def_type = JS_VAR_DEF_CATCH;
      break;
    default:
      abort();
  }
  if (define_var(s, fd, name, var_def_type) < 0) return -1;
  return 0;
}

QJS_STATIC void js_emit_spread_code(JSParseState *s, int depth) {
  int label_rest_next, label_rest_done;

  /* XXX: could check if enum object is an actual array and optimize
     slice extraction. enumeration record and target array are in a
     different order from OP_append case. */
  /* enum_rec xxx -- enum_rec xxx array 0 */
  emit_op(s, OP_array_from);
  emit_u16(s, 0);
  emit_op(s, OP_push_i32);
  emit_u32(s, 0);
  emit_label(s, label_rest_next = new_label(s));
  emit_op(s, OP_for_of_next);
  emit_u8(s, 2 + depth);
  label_rest_done = emit_goto(s, OP_if_true, -1);
  /* array idx val -- array idx */
  emit_op(s, OP_define_array_el);
  emit_op(s, OP_inc);
  emit_goto(s, OP_goto, label_rest_next);
  emit_label(s, label_rest_done);
  /* enum_rec xxx array idx undef -- enum_rec xxx array */
  emit_op(s, OP_drop);
  emit_op(s, OP_drop);
}

int js_parse_check_duplicate_parameter(JSParseState *s, JSAtom name) {
  /* Check for duplicate parameter names */
  JSFunctionDef *fd = s->cur_func;
  int i;
  for (i = 0; i < fd->arg_count; i++) {
    if (fd->args[i].var_name == name) goto duplicate;
  }
  for (i = 0; i < fd->var_count; i++) {
    if (fd->vars[i].var_name == name) goto duplicate;
  }
  return 0;

duplicate:
  return js_parse_error(
      s, "duplicate parameter names not allowed in this context");
}

JSAtom js_parse_destructing_var(JSParseState *s, int tok, int is_arg) {
  JSAtom name;

  if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||
      ((s->cur_func->js_mode & JS_MODE_STRICT) &&
       (s->token.u.ident.atom == JS_ATOM_eval ||
        s->token.u.ident.atom == JS_ATOM_arguments))) {
    js_parse_error(s, "invalid destructuring target");
    return JS_ATOM_NULL;
  }
  name = s->ctx->gc_enable ? s->token.u.ident.atom
                           : LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
  if (is_arg && js_parse_check_duplicate_parameter(s, name)) goto fail;
  if (next_token(s)) goto fail;

  return name;
fail:
  if (!s->ctx->gc_enable) LEPUS_FreeAtom(s->ctx, name);
  return JS_ATOM_NULL;
}

/* Return -1 if error, 0 if no initializer, 1 if an initializer is
   present at the top level. */
QJS_STATIC int js_parse_destructing_element(JSParseState *s, int tok,
                                            int is_arg, int hasval,
                                            int has_ellipsis,
                                            BOOL allow_initializer) {
  CallGCParserFunc(js_parse_destructing_element_GC, s, tok, is_arg, hasval,
                   has_ellipsis, allow_initializer);
  int label_parse, label_assign, label_done, label_lvalue, depth_lvalue;
  int start_addr, assign_addr;
  JSAtom prop_name, var_name;
  int opcode, scope, tok1, skip_bits;
  BOOL has_initializer;

  if (has_ellipsis < 0) {
    /* pre-parse destructuration target for spread detection */
    js_parse_skip_parens_token(s, &skip_bits, FALSE);
    has_ellipsis = skip_bits & SKIP_HAS_ELLIPSIS;
  }

  label_parse = new_label(s);
  label_assign = new_label(s);

  start_addr = s->cur_func->byte_code.size;
  if (hasval) {
    /* consume value from the stack */
    emit_op(s, OP_dup);
    emit_op(s, OP_undefined);
    emit_op(s, OP_strict_eq);
    emit_goto(s, OP_if_true, label_parse);
    emit_label(s, label_assign);
  } else {
    emit_goto(s, OP_goto, label_parse);
    emit_label(s, label_assign);
    /* leave value on the stack */
    emit_op(s, OP_dup);
  }
  assign_addr = s->cur_func->byte_code.size;
  if (s->token.val == '{') {
    if (next_token(s)) return -1;
    /* throw an exception if the value cannot be converted to an object */
    emit_op(s, OP_to_object);
    if (has_ellipsis) {
      /* add excludeList on stack just below src object */
      emit_op(s, OP_object);
      emit_op(s, OP_swap);
    }
    while (s->token.val != '}') {
      int prop_type;
      if (s->token.val == TOK_ELLIPSIS) {
        if (!has_ellipsis) {
          LEPUS_ThrowInternalError(s->ctx, "unexpected ellipsis token");
          return -1;
        }
        if (next_token(s)) return -1;
        if (tok) {
          var_name = js_parse_destructing_var(s, tok, is_arg);
          if (var_name == JS_ATOM_NULL) return -1;
          opcode = OP_scope_get_var;
          scope = s->cur_func->scope_level;
          label_lvalue = -1;
          depth_lvalue = 0;
        } else {
          if (js_parse_left_hand_side_expr(s)) return -1;

          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &depth_lvalue, FALSE, '{'))
            return -1;
        }
        if (s->token.val != '}') {
          js_parse_error(s, "assignment rest property must be last");
          goto var_error;
        }
        emit_op(s, OP_object); /* target */
        emit_op(s, OP_copy_data_properties);
        emit_u8(s, 0 | ((depth_lvalue + 1) << 2) | ((depth_lvalue + 2) << 5));
        goto set_val;
      }
      prop_type = js_parse_property_name(s, &prop_name, FALSE, TRUE, FALSE);
      if (prop_type < 0) return -1;
      var_name = JS_ATOM_NULL;
      opcode = OP_scope_get_var;
      scope = s->cur_func->scope_level;
      label_lvalue = -1;
      depth_lvalue = 0;
      if (prop_type == PROP_TYPE_IDENT) {
        if (next_token(s)) goto prop_error;
        if ((s->token.val == '[' || s->token.val == '{') &&
            ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == ',' ||
             tok1 == '=' || tok1 == '}')) {
          if (prop_name == JS_ATOM_NULL) {
            /* computed property name on stack */
            if (has_ellipsis) {
              /* define the property in excludeList */
              emit_op(s, OP_to_propkey); /* avoid calling ToString twice */
              emit_op(s, OP_perm3);      /* TOS: src excludeList prop */
              emit_op(s, OP_null);       /* TOS: src excludeList prop null */
              emit_op(s, OP_define_array_el); /* TOS: src excludeList prop */
              emit_op(s, OP_perm3);           /* TOS: excludeList src prop */
            }
            /* get the computed property from the source object */
            emit_op(s, OP_get_array_el2);
          } else {
            /* named property */
            if (has_ellipsis) {
              /* define the property in excludeList */
              emit_op(s, OP_swap);         /* TOS: src excludeList */
              emit_op(s, OP_null);         /* TOS: src excludeList null */
              emit_op(s, OP_define_field); /* TOS: src excludeList */
              emit_atom(s, prop_name);
              emit_op(s, OP_swap); /* TOS: excludeList src */
            }
            /* get the named property from the source object */
            emit_op(s, OP_get_field2);
            emit_u32(s, prop_name);
          }
          if (js_parse_destructing_element(s, tok, is_arg, TRUE, -1, TRUE) < 0)
            return -1;
          if (s->token.val == '}') break;
          /* accept a trailing comma before the '}' */
          if (js_parse_expect(s, ',')) return -1;
          continue;
        }
        if (prop_name == JS_ATOM_NULL) {
          emit_op(s, OP_to_propkey2);
          if (has_ellipsis) {
            /* define the property in excludeList */
            emit_op(s, OP_perm3);
            emit_op(s, OP_null);
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_perm3);
          }
          /* source prop -- source source prop */
          emit_op(s, OP_dup1);
        } else {
          if (has_ellipsis) {
            /* define the property in excludeList */
            emit_op(s, OP_swap);
            emit_op(s, OP_null);
            emit_op(s, OP_define_field);
            emit_atom(s, prop_name);
            emit_op(s, OP_swap);
          }
          /* source -- source source */
          emit_op(s, OP_dup);
        }
        if (tok) {
          var_name = js_parse_destructing_var(s, tok, is_arg);
          if (var_name == JS_ATOM_NULL) goto prop_error;
        } else {
          if (js_parse_left_hand_side_expr(s)) goto prop_error;
        lvalue:
          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &depth_lvalue, FALSE, '{'))
            goto prop_error;
          /* swap ref and lvalue object if any */
          if (prop_name == JS_ATOM_NULL) {
            switch (depth_lvalue) {
              case 1:
                /* source prop x -> x source prop */
                emit_op(s, OP_rot3r);
                break;
              case 2:
                /* source prop x y -> x y source prop */
                emit_op(s, OP_swap2); /* t p2 s p1 */
                break;
              case 3:
                /* source prop x y z -> x y z source prop */
                emit_op(s, OP_rot5l);
                emit_op(s, OP_rot5l);
                break;
            }
          } else {
            switch (depth_lvalue) {
              case 1:
                /* source x -> x source */
                emit_op(s, OP_swap);
                break;
              case 2:
                /* source x y -> x y source */
                emit_op(s, OP_rot3l);
                break;
              case 3:
                /* source x y z -> x y z source */
                emit_op(s, OP_rot4l);
                break;
            }
          }
        }
        if (prop_name == JS_ATOM_NULL) {
          /* computed property name on stack */
          /* XXX: should have OP_get_array_el2x with depth */
          /* source prop -- val */
          emit_op(s, OP_get_array_el);
        } else {
          /* named property */
          /* XXX: should have OP_get_field2x with depth */
          /* source -- val */
          emit_op(s, OP_get_field);
          emit_u32(s, prop_name);
        }
      } else {
        /* prop_type = PROP_TYPE_VAR, cannot be a computed property */
        if (is_arg && js_parse_check_duplicate_parameter(s, prop_name))
          goto prop_error;
        if ((s->cur_func->js_mode & JS_MODE_STRICT) &&
            (prop_name == JS_ATOM_eval || prop_name == JS_ATOM_arguments)) {
          js_parse_error(s, "invalid destructuring target");
          goto prop_error;
        }
        if (has_ellipsis) {
          /* define the property in excludeList */
          emit_op(s, OP_swap);
          emit_op(s, OP_null);
          emit_op(s, OP_define_field);
          emit_atom(s, prop_name);
          emit_op(s, OP_swap);
        }
        if (!tok || tok == TOK_VAR) {
          /* generate reference */
          /* source -- source source */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_get_var);
          emit_atom(s, prop_name);
          emit_u16(s, s->cur_func->scope_level);
          goto lvalue;
        }
        var_name = LEPUS_DupAtom(s->ctx, prop_name);
        /* source -- source val */
        emit_op(s, OP_get_field2);
        emit_u32(s, prop_name);
      }
    set_val:
      if (tok) {
        if (js_define_var(s, var_name, tok)) goto var_error;
        scope = s->cur_func->scope_level;
      }
      if (s->token.val == '=') { /* handle optional default value */
        int label_hasval;
        emit_op(s, OP_dup);
        emit_op(s, OP_undefined);
        emit_op(s, OP_strict_eq);
        label_hasval = emit_goto(s, OP_if_false, -1);
        if (next_token(s)) goto var_error;
        emit_op(s, OP_drop);
        if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto var_error;
        if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
          set_object_name(s, var_name);
        emit_label(s, label_hasval);
      }
      /* store value into lvalue object */
      put_lvalue(s, opcode, scope, var_name, label_lvalue,
                 PUT_LVALUE_NOKEEP_DEPTH, (tok == TOK_CONST || tok == TOK_LET));
      if (s->token.val == '}') break;
      /* accept a trailing comma before the '}' */
      if (js_parse_expect(s, ',')) return -1;
    }
    /* drop the source object */
    emit_op(s, OP_drop);
    if (has_ellipsis) {
      emit_op(s, OP_drop); /* pop excludeList */
    }
    if (next_token(s)) return -1;
  } else if (s->token.val == '[') {
    BOOL has_spread;
    int enum_depth;
    BlockEnv block_env;

    if (next_token(s)) return -1;
    /* the block environment is only needed in generators in case
       'yield' triggers a 'return' */
    push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL, -1, -1, 2);
    block_env.has_iterator = TRUE;
    emit_op(s, OP_for_of_start);
    has_spread = FALSE;
    while (s->token.val != ']') {
      /* get the next value */
      if (s->token.val == TOK_ELLIPSIS) {
        if (next_token(s)) return -1;
        if (s->token.val == ',' || s->token.val == ']')
          return js_parse_error(s, "missing binding pattern...");
        has_spread = TRUE;
      }
      if (s->token.val == ',') {
        /* do nothing, skip the value, has_spread is false */
        emit_op(s, OP_for_of_next);
        emit_u8(s, 0);
        emit_op(s, OP_drop);
        emit_op(s, OP_drop);
      } else if ((s->token.val == '[' || s->token.val == '{') &&
                 ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) ==
                      ',' ||
                  tok1 == '=' || tok1 == ']')) {
        if (has_spread) {
          if (tok1 == '=')
            return js_parse_error(s,
                                  "rest element cannot have a default value");
          js_emit_spread_code(s, 0);
        } else {
          emit_op(s, OP_for_of_next);
          emit_u8(s, 0);
          emit_op(s, OP_drop);
        }
        if (js_parse_destructing_element(
                s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        var_name = JS_ATOM_NULL;
        enum_depth = 0;
        if (tok) {
          var_name = js_parse_destructing_var(s, tok, is_arg);
          if (var_name == JS_ATOM_NULL) goto var_error;
          if (js_define_var(s, var_name, tok)) goto var_error;
          opcode = OP_scope_get_var;
          scope = s->cur_func->scope_level;
        } else {
          if (js_parse_left_hand_side_expr(s)) return -1;
          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &enum_depth, FALSE, '[')) {
            return -1;
          }
        }
        if (has_spread) {
          js_emit_spread_code(s, enum_depth);
        } else {
          emit_op(s, OP_for_of_next);
          emit_u8(s, enum_depth);
          emit_op(s, OP_drop);
        }
        if (s->token.val == '=' && !has_spread) {
          /* handle optional default value */
          int label_hasval;
          emit_op(s, OP_dup);
          emit_op(s, OP_undefined);
          emit_op(s, OP_strict_eq);
          label_hasval = emit_goto(s, OP_if_false, -1);
          if (next_token(s)) goto var_error;
          emit_op(s, OP_drop);
          if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto var_error;
          if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
            set_object_name(s, var_name);
          emit_label(s, label_hasval);
        }
        /* store value into lvalue object */
        put_lvalue(s, opcode, scope, var_name, label_lvalue,
                   PUT_LVALUE_NOKEEP_DEPTH,
                   (tok == TOK_CONST || tok == TOK_LET));
      }
      if (s->token.val == ']') break;
      if (has_spread)
        return js_parse_error(s, "rest element must be the last one");
      /* accept a trailing comma before the ']' */
      if (js_parse_expect(s, ',')) return -1;
    }
    /* close iterator object:
       if completed, enum_obj has been replaced by undefined */
    emit_op(s, OP_iterator_close);
    pop_break_entry(s->cur_func);
    if (next_token(s)) return -1;
  } else {
    return js_parse_error(s, "invalid assignment syntax");
  }
  if (s->token.val == '=' && allow_initializer) {
    label_done = emit_goto(s, OP_goto, -1);
    if (next_token(s)) return -1;
    emit_label(s, label_parse);
    if (hasval) emit_op(s, OP_drop);
    if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    emit_goto(s, OP_goto, label_assign);
    emit_label(s, label_done);
    has_initializer = TRUE;
  } else {
    /* normally hasval is true except if
      js_parse_skip_parens_token() was wrong in the parsing */
    //        assert(hasval);
    if (!hasval) {
      js_parse_error(s, "too complicated destructuring expression");
      return -1;
    }
    /* remove test and decrement label ref count */
    memset(s->cur_func->byte_code.buf + start_addr, OP_nop,
           assign_addr - start_addr);
    s->cur_func->label_slots[label_parse].ref_count--;
    has_initializer = FALSE;
  }
  return has_initializer;

prop_error:
  LEPUS_FreeAtom(s->ctx, prop_name);
var_error:
  LEPUS_FreeAtom(s->ctx, var_name);
  return -1;
}

typedef enum FuncCallType {
  FUNC_CALL_NORMAL,
  FUNC_CALL_NEW,
  FUNC_CALL_SUPER_CTOR,
  FUNC_CALL_TEMPLATE,
} FuncCallType;

/* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */
QJS_STATIC __exception int js_parse_postfix_expr(JSParseState *s,
                                                 int parse_flags) {
  FuncCallType call_type;
  int optional_chaining_label;
  BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;

  call_type = FUNC_CALL_NORMAL;
  int is_parsing_newnew_pattern = 0;

  const uint8_t *caller_start = nullptr, *caller_end = nullptr;
  caller_start = s->token.ptr;
  switch (s->token.val) {
    case TOK_NUMBER: {
      LEPUSValue val;
      val = s->token.u.num.val;

      if (LEPUS_VALUE_IS_INT(val)) {
        emit_op(s, OP_push_i32);
        emit_u32(s, LEPUS_VALUE_GET_INT(val));
      } else
#ifdef CONFIG_BIGNUM
          if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
        bf_t r_s, *r = &r_s;
        slimb_t e;
        int ret;

        /* need a runtime conversion */
        /* XXX: could add a cache and/or do it once at
           the start of the function */
        if (emit_push_const(s, val, 0) < 0) return -1;
        e = s->token.u.num.exponent;
        if (e == (int32_t)e) {
          emit_op(s, OP_push_i32);
          emit_u32(s, e);
        } else {
          bf_init(s->ctx->bf_ctx, r);
          bf_set_si(r, e);
          val = JS_NewBigInt(s->ctx, r);
          ret = emit_push_const(s, val, 0);
          LEPUS_FreeValue(s->ctx, val);
          if (ret < 0) return -1;
        }
        emit_op(s, OP_mul_pow10);
      } else
#endif
      {
        if (emit_push_const(s, val, 0) < 0) return -1;
      }
    }
      if (next_token(s)) return -1;
      break;
    case TOK_TEMPLATE:
      if (js_parse_template(s, 0, NULL)) return -1;
      break;
    case TOK_STRING:
      if (emit_push_const(s, s->token.u.str.str, 1)) return -1;
      if (next_token(s)) return -1;
      break;

    case TOK_DIV_ASSIGN:
      s->buf_ptr -= 2;
      goto parse_regexp;
    case '/':
      s->buf_ptr--;
    parse_regexp: {
      LEPUSValue str;
      int ret;
      if (!s->ctx->compile_regexp)
        return js_parse_error(s, "RegExp are not supported");
      /* the previous token is '/' or '/=', so no need to free */
      if (js_parse_regexp(s)) return -1;
      ret = emit_push_const(s, s->token.u.regexp.body, 0);
      str = s->ctx->compile_regexp(s->ctx, s->token.u.regexp.body,
                                   s->token.u.regexp.flags);
      if (LEPUS_IsException(str)) {
        /* add the line number info */
        build_backtrace(s->ctx, s->ctx->rt->current_exception, s->filename,
                        s->token.line_num, NULL, 0);
        return -1;
      }
      ret = emit_push_const(s, str, 0);
      LEPUS_FreeValue(s->ctx, str);
      if (ret) return -1;
      /* we use a specific opcode to be sure the correct
         function is called (otherwise the bytecode would have
         to be verified by the RegExp constructor) */
      emit_op(s, OP_regexp);
      if (next_token(s)) return -1;
    } break;
    case '(':
      if ((parse_flags & PF_ARROW_FUNC) &&
          js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
        if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW, JS_FUNC_NORMAL,
                                   JS_ATOM_NULL, s->token.ptr,
                                   s->token.line_num))
          return -1;
      } else {
        if (js_parse_expr_paren(s)) return -1;
      }
      break;
    case TOK_FUNCTION:
      if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR, JS_FUNC_NORMAL,
                                 JS_ATOM_NULL, s->token.ptr, s->token.line_num))
        return -1;
      break;
    case TOK_CLASS:
      if (js_parse_class(s, TRUE, JS_PARSE_EXPORT_NONE)) return -1;
      break;
    case TOK_NULL:
      if (next_token(s)) return -1;
      emit_op(s, OP_null);
      break;
    case TOK_THIS:
      if (next_token(s)) return -1;
      emit_op(s, OP_scope_get_var);
      emit_atom(s, JS_ATOM_this);
      emit_u16(s, 0);
      break;
    case TOK_FALSE:
      if (next_token(s)) return -1;
      emit_op(s, OP_push_false);
      break;
    case TOK_TRUE:
      if (next_token(s)) return -1;
      emit_op(s, OP_push_true);
      break;
    case TOK_IDENT: {
      JSAtom name;
      if (s->token.u.ident.is_reserved) {
        return js_parse_error_reserved_identifier(s);
      }
      if ((parse_flags & PF_ARROW_FUNC) && peek_token(s, TRUE) == TOK_ARROW) {
        if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW, JS_FUNC_NORMAL,
                                   JS_ATOM_NULL, s->token.ptr,
                                   s->token.line_num))
          return -1;
      } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
                 peek_token(s, TRUE) != '\n') {
        const uint8_t *source_ptr;
        int source_line_num;

        source_ptr = s->token.ptr;
        source_line_num = s->token.line_num;
        if (next_token(s)) return -1;
        if (s->token.val == TOK_FUNCTION) {
          if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR, JS_FUNC_ASYNC,
                                     JS_ATOM_NULL, source_ptr, source_line_num))
            return -1;
        } else if ((parse_flags & PF_ARROW_FUNC) &&
                   ((s->token.val == '(' &&
                     js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
                    (s->token.val == TOK_IDENT &&
                     !s->token.u.ident.is_reserved &&
                     peek_token(s, TRUE) == TOK_ARROW))) {
          if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW, JS_FUNC_ASYNC,
                                     JS_ATOM_NULL, source_ptr, source_line_num))
            return -1;
        } else {
          name = LEPUS_DupAtom(s->ctx, JS_ATOM_async);
          goto do_get_var;
        }
      } else {
        if (s->token.u.ident.atom == JS_ATOM_arguments &&
            !s->cur_func->arguments_allowed) {
          js_parse_error(s,
                         "'arguments' identifier is not allowed in class field "
                         "initializer");
          return -1;
        }
        name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
        if (next_token(s)) /* update line number before emitting code */
          return -1;
      do_get_var:
        emit_op(s, OP_scope_get_var);
        emit_u32(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }
    } break;
    case '{':
    case '[': {
      int skip_bits;
      if (js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
        if (js_parse_destructing_element(
                s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        if (s->token.val == '{') {
          if (js_parse_object_literal(s)) return -1;
        } else {
          if (js_parse_array_literal(s)) return -1;
        }
      }
    } break;
    case TOK_NEW:
      if (next_token(s)) return -1;
      if (s->token.val == '.') {
        if (next_token(s)) return -1;
        if (!token_is_pseudo_keyword(s, JS_ATOM_target))
          return js_parse_error(s, "expecting target");
        if (!s->cur_func->new_target_allowed)
          return js_parse_error(s, "new.target only allowed within functions");
        if (next_token(s)) return -1;
        emit_op(s, OP_scope_get_var);
        emit_atom(s, JS_ATOM_new_target);
        emit_u16(s, 0);
      } else {
        caller_start = s->token.ptr;
        if (js_parse_postfix_expr(s, FALSE | PF_LASTEST_ISNEW)) return -1;
        is_parsing_newnew_pattern = parse_flags & PF_LASTEST_ISNEW;
        accept_lparen = TRUE;
        caller_end = s->token.ptr;
        if (s->token.val != '(') {
          /* new operator on an object */
          if (!emit_name_str(s, caller_start, caller_end)) return -1;
          emit_op(s, OP_dup);
          emit_op(s, OP_call_constructor);
          emit_u16(s, 0);
        } else {
          call_type = FUNC_CALL_NEW;
        }
      }
      break;
    case TOK_SUPER:
      if (next_token(s)) return -1;
      if (s->token.val == '(') {
        if (!s->cur_func->super_call_allowed)
          return js_parse_error(
              s, "super() is only valid in a derived class constructor");
        call_type = FUNC_CALL_SUPER_CTOR;
      } else if (s->token.val == '.' || s->token.val == '[') {
        if (!s->cur_func->super_allowed)
          return js_parse_error(s, "'super' is only valid in a method");
        emit_op(s, OP_scope_get_var);
        emit_atom(s, JS_ATOM_this);
        emit_u16(s, 0);
        emit_op(s, OP_scope_get_var);
        emit_atom(s, JS_ATOM_home_object);
        emit_u16(s, 0);
        emit_op(s, OP_get_super);
      } else {
        return js_parse_error(s, "invalid use of 'super'");
      }
      break;
    case TOK_IMPORT:
      if (!accept_lparen) return js_parse_error(s, "invalid use of 'import'");
      if (next_token(s)) return -1;
      if (js_parse_expect(s, '(')) return -1;
      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      if (js_parse_expect(s, ')')) return -1;
      emit_op(s, OP_import);
      break;
    default:
      return js_parse_error(s, "unexpected token in expression: '%.*s'",
                            (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
  }

  optional_chaining_label = -1;
  for (;;) {
    JSFunctionDef *fd = s->cur_func;
    BOOL has_optional_chain = FALSE;

    if (s->token.val == TOK_QUESTION_MARK_DOT) {
      /* optional chaining */
      if (next_token(s)) return -1;
      has_optional_chain = TRUE;
      if (s->token.val == '(' && accept_lparen) {
        goto parse_func_call;
      } else if (s->token.val == '[') {
        goto parse_array_access;
      } else {
        goto parse_property;
      }
    } else if (s->token.val == TOK_TEMPLATE && call_type == FUNC_CALL_NORMAL) {
      if (optional_chaining_label >= 0) {
        return js_parse_error(
            s, "template literal cannot appear in an optional chain");
      }
      call_type = FUNC_CALL_TEMPLATE;
      caller_end = s->token.ptr;
      goto parse_func_call2;
    }
    if (s->token.val == '(' && accept_lparen) {
      if (is_parsing_newnew_pattern) accept_lparen = FALSE;
      int opcode;
      int arg_count;
      int drop_count;
      // <ByeDance begin>
      s->func_call_ptr = s->token.ptr;
      if (s->func_call_ptr < s->utf8_parse_front) {
        s->func_call_adapte_size =
            s->utf8_adapte_size - s->last_utf8_adapte_size;
      } else {
        s->func_call_adapte_size = s->utf8_adapte_size;
      }
      // <Primjs end>

      /* function call */
    parse_func_call:
      caller_end = s->token.ptr;
      if (next_token(s)) return -1;

      if (call_type == FUNC_CALL_NORMAL) {
      parse_func_call2:
        switch (opcode = get_prev_opcode(fd)) {
          case OP_get_field:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
            drop_count = 2;
            break;
          case OP_scope_get_private_field:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] =
                OP_scope_get_private_field2;
            drop_count = 2;
            break;
          case OP_get_array_el:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
            drop_count = 2;
            break;
          case OP_scope_get_var: {
            JSAtom name;
            int scope;
            name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
            scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
            if (name == JS_ATOM_eval && call_type == FUNC_CALL_NORMAL &&
                !has_optional_chain) {
              /* direct 'eval' */
              LEPUS_FreeAtom(s->ctx, name);
              fd->byte_code.size = fd->last_opcode_pos;
              fd->last_opcode_pos = -1;
              opcode = OP_eval;
            } else {
              /* verify if function name resolves to a simple
                 get_loc/get_arg: a function call inside a `with`
                 statement can resolve to a method call of the
                 `with` context object
               */
              /* XXX: always generate the OP_scope_get_ref
                 and remove it in variable resolution
                 pass ? */
              if (has_with_scope(fd, scope)) {
                opcode = OP_scope_get_ref;
                fd->byte_code.buf[fd->last_opcode_pos] = opcode;
              }
            }
            drop_count = 1;
          } break;
          case OP_get_super_value:
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el;
            /* on stack: this func_obj */
            opcode = OP_get_array_el;
            drop_count = 2;
            break;
          default:
            opcode = OP_invalid;
            drop_count = 1;
            break;
        }
        if (has_optional_chain) {
          optional_chain_test(s, &optional_chaining_label, drop_count);
        }
      } else {
        opcode = OP_invalid;
      }

      if (call_type == FUNC_CALL_TEMPLATE) {
        if (js_parse_template(s, 1, &arg_count)) return -1;
        goto emit_func_call;
      } else if (call_type == FUNC_CALL_SUPER_CTOR) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, JS_ATOM_this_active_func);
        emit_u16(s, 0);

        emit_op(s, OP_get_super_ctor);

        emit_op(s, OP_scope_get_var);
        emit_atom(s, JS_ATOM_new_target);
        emit_u16(s, 0);
      } else if (call_type == FUNC_CALL_NEW) {
        emit_op(s, OP_dup); /* new.target = function */
      }

      /* parse arguments */
      arg_count = 0;
      while (s->token.val != ')') {
        if (arg_count >= 65535) {
          return js_parse_error(s, "Too many call arguments");
        }
        if (s->token.val == TOK_ELLIPSIS) break;
        if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
        arg_count++;
        if (s->token.val == ')') break;
        /* accept a trailing comma before the ')' */
        if (js_parse_expect(s, ',')) return -1;
      }
      if (s->token.val == TOK_ELLIPSIS) {
        emit_op(s, OP_array_from);
        emit_u16(s, arg_count);
        emit_op(s, OP_push_i32);
        emit_u32(s, arg_count);

        /* on stack: array idx */
        while (s->token.val != ')') {
          if (s->token.val == TOK_ELLIPSIS) {
            if (next_token(s)) return -1;
            if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
#if 1
            /* XXX: could pass is_last indicator? */
            emit_op(s, OP_append);
#else
            int label_next, label_done;
            label_next = new_label(s);
            label_done = new_label(s);
            /* push enumerate object below array/idx pair */
            emit_op(s, OP_for_of_start);
            emit_op(s, OP_rot5l);
            emit_op(s, OP_rot5l);
            emit_label(s, label_next);
            /* on stack: enum_rec array idx */
            emit_op(s, OP_for_of_next);
            emit_u8(s, 2);
            emit_goto(s, OP_if_true, label_done);
            /* append element */
            /* enum_rec array idx val -> enum_rec array new_idx */
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_inc);
            emit_goto(s, OP_goto, label_next);
            emit_label(s, label_done);
            /* close enumeration, drop enum_rec and idx */
            emit_op(s, OP_drop); /* drop undef */
            emit_op(s, OP_nip1); /* drop enum_rec */
            emit_op(s, OP_nip1);
            emit_op(s, OP_nip1);
#endif
          } else {
            if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
            /* array idx val */
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_inc);
          }
          if (s->token.val == ')') break;
          /* accept a trailing comma before the ')' */
          if (js_parse_expect(s, ',')) return -1;
        }
        if (next_token(s)) return -1;
        /* drop the index */
        emit_op(s, OP_drop);

        /* apply function call */
        switch (opcode) {
          case OP_get_field:
          case OP_scope_get_private_field:
          case OP_get_array_el:
          case OP_scope_get_ref:
            /* obj func array -> func obj array */
            emit_op(s, OP_perm3);
            emit_op(s, OP_apply);
            emit_u16(s, call_type == FUNC_CALL_NEW);
            break;
          case OP_eval:
            /* eval needs a single argument */
            emit_op(s, OP_get_field);
            emit_atom(s, __JS_AtomFromUInt32(0));
            emit_op(s, OP_eval);
            emit_u16(s, fd->scope_level);
            fd->has_eval_call = TRUE;
            break;
          default:
            if (call_type == FUNC_CALL_SUPER_CTOR) {
              emit_op(s, OP_apply);
              emit_u16(s, 1);
              /* set the 'this' value */
              emit_op(s, OP_dup);
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, JS_ATOM_this);
              emit_u16(s, 0);

              emit_class_field_init(s);
            } else if (call_type == FUNC_CALL_NEW) {
              /* obj func array -> func obj array */
              emit_op(s, OP_perm3);
              emit_op(s, OP_apply);
              emit_u16(s, 1);
            } else {
              /* func array -> func undef array */
              emit_op(s, OP_undefined);
              emit_op(s, OP_swap);
              emit_op(s, OP_apply);
              emit_u16(s, 0);
            }
            break;
        }
      } else {
        if (next_token(s)) return -1;
      emit_func_call:
        switch (opcode) {
          case OP_get_field:
          case OP_scope_get_private_field:
          case OP_get_array_el:
          case OP_scope_get_ref:
            if (!emit_name_str(s, caller_start, caller_end)) return -1;
            emit_op(s, OP_call_method);
            emit_u16(s, arg_count);
            break;
          case OP_eval:
            /* eval needs a single argument */
            if (arg_count == 0) {
              /* no actual eval call is needed? */
              emit_op(s, OP_undefined);
            } else {
              int i;
              /* pop extra arguments. Contrary to ECMA spec,
                 browsers seem to evaluate extra arguments
                 to direct eval */
              for (i = 1; i < arg_count; i++) emit_op(s, OP_drop);
              emit_op(s, OP_eval);
              emit_u16(s, fd->scope_level);
              fd->has_eval_call = TRUE;
            }
            break;
          default:
            if (!emit_name_str(s, caller_start, caller_end)) return -1;
            if (call_type == FUNC_CALL_SUPER_CTOR) {
              emit_op(s, OP_call_constructor);
              emit_u16(s, arg_count);

              /* set the 'this' value */
              emit_op(s, OP_dup);
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, JS_ATOM_this);
              emit_u16(s, 0);

              emit_class_field_init(s);
            } else if (call_type == FUNC_CALL_NEW) {
              emit_op(s, OP_call_constructor);
              emit_u16(s, arg_count);
            } else {
              emit_op(s, OP_call);
              emit_u16(s, arg_count);
            }
            break;
        }
      }
      // <ByeDance begin>
      s->func_call_ptr = NULL;
      s->func_call_adapte_size = -1;
      // <Primjs end>
      call_type = FUNC_CALL_NORMAL;
    } else if (s->token.val == '.') {
      if (next_token(s)) return -1;
    parse_property:
      if (s->token.val == TOK_PRIVATE_NAME) {
        /* private class field */
        if (get_prev_opcode(fd) == OP_get_super) {
          return js_parse_error(s, "private class field forbidden after super");
        }
        if (has_optional_chain) {
          optional_chain_test(s, &optional_chaining_label, 1);
        }
        emit_op(s, OP_scope_get_private_field);
        emit_atom(s, s->token.u.ident.atom);
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (!token_is_ident(s->token.val)) {
          return js_parse_error(s, "expecting field name");
        }
        if (get_prev_opcode(fd) == OP_get_super) {
          LEPUSValue val;
          int ret;
          val = JS_AtomToValue_RC(s->ctx, s->token.u.ident.atom);
          ret = emit_push_const(s, val, 1);
          LEPUS_FreeValue(s->ctx, val);
          if (ret) return -1;
          emit_op(s, OP_get_super_value);
        } else {
          if (has_optional_chain) {
            optional_chain_test(s, &optional_chaining_label, 1);
          }
          emit_op(s, OP_get_field);
          emit_atom(s, s->token.u.ident.atom);
        }
      }
      if (next_token(s)) return -1;
    } else if (s->token.val == '[') {
      int prev_op;
    parse_array_access:
      prev_op = get_prev_opcode(fd);
      if (has_optional_chain) {
        optional_chain_test(s, &optional_chaining_label, 1);
      }
      if (next_token(s)) return -1;
      if (js_parse_expr(s)) return -1;
      if (js_parse_expect(s, ']')) return -1;
      if (prev_op == OP_get_super) {
        emit_op(s, OP_get_super_value);
      } else {
        emit_op(s, OP_get_array_el);
      }
    } else {
      break;
    }
  }
  if (optional_chaining_label >= 0) emit_label(s, optional_chaining_label);
  return 0;
}

QJS_STATIC __exception int js_parse_delete(JSParseState *s) {
  JSFunctionDef *fd = s->cur_func;
  JSAtom name;
  int opcode;

  if (next_token(s)) return -1;
  if (js_parse_unary(s, -1)) return -1;
  switch (opcode = get_prev_opcode(fd)) {
    case OP_get_field: {
      LEPUSValue val;
      int ret;

      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      fd->byte_code.size = fd->last_opcode_pos;
      fd->last_opcode_pos = -1;
      val = JS_AtomToValue_RC(s->ctx, name);
      ret = emit_push_const(s, val, 1);
      LEPUS_FreeValue(s->ctx, val);
      LEPUS_FreeAtom(s->ctx, name);
      if (ret) return ret;
    }
      goto do_delete;
    case OP_get_array_el:
      fd->byte_code.size = fd->last_opcode_pos;
      fd->last_opcode_pos = -1;
    do_delete:
      emit_op(s, OP_delete);
      break;
    case OP_scope_get_var:
      /* 'delete this': this is not a reference */
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      if (name == JS_ATOM_this || name == JS_ATOM_new_target) goto ret_true;
      if (fd->js_mode & JS_MODE_STRICT) {
        return js_parse_error(
            s, "cannot delete a direct reference in strict mode");
      } else {
        fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_delete_var;
      }
      break;
    case OP_scope_get_private_field:
      return js_parse_error(s, "cannot delete a private class field");
    case OP_get_super_value:
      emit_op(s, OP_throw_var);
      emit_atom(s, JS_ATOM_NULL);
      emit_u8(s, JS_THROW_ERROR_DELETE_SUPER);
      break;
    default:
    ret_true:
      emit_op(s, OP_drop);
      emit_op(s, OP_push_true);
      break;
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */
QJS_STATIC __exception int js_parse_unary(JSParseState *s, int parse_flags) {
  CallGCParserFunc(js_parse_unary_GC, s, parse_flags);
  int op;

  switch (s->token.val) {
    case '+':
    case '-':
    case '!':
    case '~':
    case TOK_VOID:
      op = s->token.val;
      if (next_token(s)) return -1;
      if (js_parse_unary(s, PF_POW_FORBIDDEN)) return -1;
      switch (op) {
        case '-':
          emit_op(s, OP_neg);
          break;
        case '+':
          emit_op(s, OP_plus);
          break;
        case '!':
          emit_op(s, OP_lnot);
          break;
        case '~':
          emit_op(s, OP_not);
          break;
        case TOK_VOID:
          emit_op(s, OP_drop);
          emit_op(s, OP_undefined);
          break;
        default:
          abort();
      }
      parse_flags = 0;
      break;
    case TOK_DEC:
    case TOK_INC: {
      int opcode, op, scope, label;
      JSAtom name;
      op = s->token.val;
      if (next_token(s)) return -1;
      /* XXX: should parse LeftHandSideExpression */
      if (js_parse_unary(s, 0)) return -1;
      if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
        return -1;
      emit_op(s, OP_dec + op - TOK_DEC);
      put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
    } break;
    case TOK_TYPEOF: {
      JSFunctionDef *fd;
      if (next_token(s)) return -1;
      if (js_parse_unary(s, -1)) return -1;
      /* reference access should not return an exception, so we
         patch the get_var */
      fd = s->cur_func;
      if (get_prev_opcode(fd) == OP_scope_get_var) {
        fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;
      }
      emit_op(s, OP_typeof);
      parse_flags = 0;
    } break;
    case TOK_DELETE:
      if (js_parse_delete(s)) return -1;
      parse_flags = 0;
      break;
    case TOK_AWAIT:
      if (!(s->cur_func->func_kind & JS_FUNC_ASYNC))
        return js_parse_error(s, "unexpected 'await' keyword");
      if (!s->cur_func->in_function_body)
        return js_parse_error(s, "await in default expression");
      if (next_token(s)) return -1;
      if (js_parse_unary(s, -1)) return -1;
      emit_op(s, OP_await);
      parse_flags = 0;
      break;
    default:
      if (js_parse_postfix_expr(
              s, (parse_flags & PF_ARROW_FUNC) | PF_POSTFIX_CALL))
        return -1;
      if (!s->got_lf && (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
        int opcode, op, scope, label;
        JSAtom name;
        op = s->token.val;
        if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
          return -1;
        emit_op(s, OP_post_dec + op - TOK_DEC);
        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
                   FALSE);
        if (next_token(s)) return -1;
      }
      break;
  }
  if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {
#ifdef CONFIG_BIGNUM
    if (s->token.val == TOK_POW || s->token.val == TOK_MATH_POW) {
      /* Extended exponentiation syntax rules: we extend the ES7
         grammar in order to have more intuitive semantics:
         -2**2 evaluates to -4. */
      if (!(s->cur_func->js_mode & JS_MODE_MATH)) {
        if ((parse_flags & PF_POW_FORBIDDEN) < 0) {
          LEPUS_ThrowSyntaxError(
              s->ctx,
              "unparenthesized unary expression can't appear "
              "on the left-hand side of '**'");
          return -1;
        }
      }
      if (next_token(s)) return -1;
      if (js_parse_unary(s, PF_POW_ALLOWED)) return -1;
      if (s->cur_func->js_mode & JS_MODE_MATH)
        emit_op(s, OP_math_pow);
      else
        emit_op(s, OP_pow);
    }
#else
    if (s->token.val == TOK_POW) {
      /* Strict ES7 exponentiation syntax rules: To solve
         conficting semantics between different implementations
         regarding the precedence of prefix operators and the
         postifx exponential, ES7 specifies that -2**2 is a
         syntax error. */
      if (parse_flags & PF_POW_FORBIDDEN) {
        LEPUS_ThrowSyntaxError(
            s->ctx,
            "unparenthesized unary expression can't appear on "
            "the left-hand side of '**'");
        return -1;
      }
      if (next_token(s)) return -1;
      if (js_parse_unary(s, PF_POW_ALLOWED)) return -1;
      emit_op(s, OP_pow);
    }
#endif
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
QJS_STATIC __exception int js_parse_expr_binary(JSParseState *s, int level,
                                                int parse_flags) {
  int op, opcode;

  if (level == 0) {
    return js_parse_unary(s, (parse_flags & PF_ARROW_FUNC) | PF_POW_ALLOWED);
  }
  if (js_parse_expr_binary(s, level - 1, parse_flags)) return -1;
  for (;;) {
    op = s->token.val;
    switch (level) {
      case 1:
        switch (op) {
          case '*':
            opcode = OP_mul;
            break;
          case '/':
#ifdef CONFIG_BIGNUM
            if (s->cur_func->js_mode & JS_MODE_MATH)
              opcode = OP_math_div;
            else
#endif
              opcode = OP_div;
            break;
          case '%':
#ifdef CONFIG_BIGNUM
            if (s->cur_func->js_mode & JS_MODE_MATH)
              opcode = OP_math_mod;
            else
#endif
              opcode = OP_mod;
            break;
          default:
            return 0;
        }
        break;
      case 2:
        switch (op) {
          case '+':
            opcode = OP_add;
            break;
          case '-':
            opcode = OP_sub;
            break;
          default:
            return 0;
        }
        break;
      case 3:
        switch (op) {
          case TOK_SHL:
            opcode = OP_shl;
            break;
          case TOK_SAR:
            opcode = OP_sar;
            break;
          case TOK_SHR:
            opcode = OP_shr;
            break;
          default:
            return 0;
        }
        break;
      case 4:
        switch (op) {
          case '<':
            opcode = OP_lt;
            break;
          case '>':
            opcode = OP_gt;
            break;
          case TOK_LTE:
            opcode = OP_lte;
            break;
          case TOK_GTE:
            opcode = OP_gte;
            break;
          case TOK_INSTANCEOF:
            opcode = OP_instanceof;
            break;
          case TOK_IN:
            if (parse_flags & PF_IN_ACCEPTED) {
              opcode = OP_in;
            } else {
              return 0;
            }
            break;
          default:
            return 0;
        }
        break;
      case 5:
        switch (op) {
          case TOK_EQ:
            opcode = OP_eq;
            break;
          case TOK_NEQ:
            opcode = OP_neq;
            break;
          case TOK_STRICT_EQ:
            opcode = OP_strict_eq;
            break;
          case TOK_STRICT_NEQ:
            opcode = OP_strict_neq;
            break;
          default:
            return 0;
        }
        break;
      case 6:
        switch (op) {
          case '&':
            opcode = OP_and;
            break;
          default:
            return 0;
        }
        break;
      case 7:
        switch (op) {
          case '^':
            opcode = OP_xor;
            break;
          default:
            return 0;
        }
        break;
      case 8:
        switch (op) {
          case '|':
            opcode = OP_or;
            break;
          default:
            return 0;
        }
        break;
      default:
        abort();
    }
    if (next_token(s)) return -1;
    if (js_parse_expr_binary(s, level - 1, parse_flags & ~PF_ARROW_FUNC))
      return -1;
    emit_op(s, opcode);
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
QJS_STATIC __exception int js_parse_logical_and_or(JSParseState *s, int op,
                                                   int parse_flags) {
  int label1;

  if (op == TOK_LAND) {
    if (js_parse_expr_binary(s, 8, parse_flags)) return -1;
  } else {
    if (js_parse_logical_and_or(s, TOK_LAND, parse_flags)) return -1;
  }
  if (s->token.val == op) {
    label1 = new_label(s);

    for (;;) {
      if (next_token(s)) return -1;
      emit_op(s, OP_dup);
      emit_goto(s, op == TOK_LAND ? OP_if_false : OP_if_true, label1);
      emit_op(s, OP_drop);

      if (op == TOK_LAND) {
        if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC)) return -1;
      } else {
        if (js_parse_logical_and_or(s, TOK_LAND, parse_flags & ~PF_ARROW_FUNC))
          return -1;
      }
      if (s->token.val != op) {
        if (s->token.val == TOK_DOUBLE_QUESTION_MARK)
          return js_parse_error(s, "cannot mix ?? with && or ||");
        break;
      }
    }

    emit_label(s, label1);
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
__exception int js_parse_cond_expr(JSParseState *s, int parse_flags) {
  int label1, label2;

  if (js_parse_logical_and_or(s, TOK_LOR, parse_flags)) return -1;
  if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {
    label1 = new_label(s);
    for (;;) {
      if (next_token(s)) return -1;

      emit_op(s, OP_dup);
      emit_op(s, OP_is_undefined);
      emit_goto(s, OP_if_false, label1);
      emit_op(s, OP_drop);

      if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC)) return -1;
      if (s->token.val != TOK_DOUBLE_QUESTION_MARK) break;
    }
    emit_label(s, label1);
  }
  if (s->token.val == '?') {
    if (next_token(s)) return -1;
    label1 = emit_goto(s, OP_if_false, -1);

    if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    if (js_parse_expect(s, ':')) return -1;

    label2 = emit_goto(s, OP_goto, -1);

    emit_label(s, label1);

    if (js_parse_assign_expr(s, parse_flags & PF_IN_ACCEPTED)) return -1;

    emit_label(s, label2);
  }
  return 0;
}

/* allowed parse_flags: PF_IN_ACCEPTED */
__exception int js_parse_assign_expr(JSParseState *s, int parse_flags) {
  int opcode, op, scope;
  JSAtom name0 = JS_ATOM_NULL;
  JSAtom name;
#ifdef ENABLE_COMPATIBLE_MM
  HandleScope func_scope(s->ctx->rt);
#endif

  if (s->token.val == TOK_YIELD) {
    BOOL is_star = FALSE;
    if (!(s->cur_func->func_kind & JS_FUNC_GENERATOR))
      return js_parse_error(s, "unexpected 'yield' keyword");
    if (!s->cur_func->in_function_body)
      return js_parse_error(s, "yield in default expression");
    if (next_token(s)) return -1;
    /* XXX: is there a better method to detect 'yield' without
       parameters ? */
    if (s->token.val != ';' && s->token.val != ')' && s->token.val != ']' &&
        s->token.val != '}' && s->token.val != ',' && s->token.val != ':' &&
        !s->got_lf) {
      if (s->token.val == '*') {
        is_star = TRUE;
        if (next_token(s)) return -1;
      }
      if (js_parse_assign_expr(s, parse_flags)) return -1;
    } else {
      emit_op(s, OP_undefined);
    }
    if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
      int label_loop, label_return, label_next;
      int label_return1, label_yield, label_throw, label_throw1;
      int label_throw2;

      if (is_star) {
        label_loop = new_label(s);
        label_yield = new_label(s);

        emit_op(s, OP_for_await_of_start);

        /* remove the catch offset (XXX: could avoid pushing back
           undefined) */
        emit_op(s, OP_drop);
        emit_op(s, OP_undefined);

        emit_op(s, OP_undefined); /* initial value */

        emit_label(s, label_loop);
        emit_op(s, OP_async_iterator_next);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        label_next = emit_goto(s, OP_if_true, -1); /* end of loop */
        emit_op(s, OP_await);
        emit_label(s, label_yield);
        emit_op(s, OP_async_yield_star);
        emit_op(s, OP_dup);
        label_return = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_drop);
        emit_goto(s, OP_goto, label_loop);

        emit_label(s, label_return);
        emit_op(s, OP_push_i32);
        emit_u32(s, 2);
        emit_op(s, OP_strict_eq);
        label_throw = emit_goto(s, OP_if_true, -1);

        /* return handling */
        emit_op(s, OP_await);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 0);
        label_return1 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        /* XXX: the spec does not indicate that an await should be
           performed in case done = true, but the tests assume it */
        emit_goto(s, OP_if_false, label_yield);

        emit_label(s, label_return1);
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
        emit_return(s, TRUE);

        /* throw handling */
        emit_label(s, label_throw);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 1);
        label_throw1 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        emit_goto(s, OP_if_false, label_yield);
        /* XXX: the spec does not indicate that an await should be
           performed in case done = true, but the tests assume it */
        emit_op(s, OP_await);
        emit_goto(s, OP_goto, label_next);
        /* close the iterator and throw a type error exception */
        emit_label(s, label_throw1);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 0);
        label_throw2 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_label(s, label_throw2);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 2);       /* throw the type error exception */
        emit_op(s, OP_drop); /* never reached */

        emit_label(s, label_next);
        emit_op(s, OP_nip); /* keep the value associated with
                               done = true */
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
      } else {
        emit_op(s, OP_await);
        emit_op(s, OP_yield);
        label_next = emit_goto(s, OP_if_false, -1);
        emit_return(s, TRUE);
        emit_label(s, label_next);
      }
    } else {
      int label_next;
      if (is_star) {
        emit_op(s, OP_for_of_start);
        emit_op(s, OP_drop); /* drop the catch offset */
        emit_op(s, OP_yield_star);
      } else {
        emit_op(s, OP_yield);
      }
      label_next = emit_goto(s, OP_if_false, -1);
      emit_return(s, TRUE);
      emit_label(s, label_next);
    }
    return 0;
  }
  if (s->token.val == TOK_IDENT) {
    /* name0 is used to check for OP_set_name pattern, not duplicated */
    name0 = s->token.u.ident.atom;
  }
  if (js_parse_cond_expr(s, parse_flags | PF_ARROW_FUNC)) return -1;

  op = s->token.val;
  if (op == '=' || (op >= TOK_MUL_ASSIGN && op <= TOK_POW_ASSIGN)) {
    int label;
    if (next_token(s)) return -1;
    if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, (op != '='), op) <
        0)
      return -1;
#ifdef ENABLE_COMPATIBLE_MM
    func_scope.PushLEPUSAtom(name);
#endif

    if (js_parse_assign_expr(s, parse_flags)) {
      if (!s->ctx->gc_enable) LEPUS_FreeAtom(s->ctx, name);
      return -1;
    }

    if (op == '=') {
      if (opcode == OP_get_ref_value && name == name0) {
        set_object_name(s, name);
      }
    } else {
      static const uint8_t assign_opcodes[] = {
          OP_mul, OP_div, OP_mod, OP_add, OP_sub, OP_shl,
          OP_sar, OP_shr, OP_and, OP_xor, OP_or,
#ifdef CONFIG_BIGNUM
          OP_pow,
#endif
          OP_pow,
      };
      op = assign_opcodes[op - TOK_MUL_ASSIGN];
#ifdef CONFIG_BIGNUM
      if (s->cur_func->js_mode & JS_MODE_MATH) {
        if (op == OP_div)
          op = OP_math_div;
        else if (op == OP_mod)
          op = OP_math_mod;
        else if (op == OP_pow)
          op = OP_math_pow;
      }
#endif
      emit_op(s, op);
    }
    put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
  }
  return 0;
}

/* allowed parse_flags: PF_IN_ACCEPTED */
__exception int js_parse_expr2(JSParseState *s, int parse_flags) {
  BOOL comma = FALSE;
  for (;;) {
    if (js_parse_assign_expr(s, parse_flags)) return -1;
    if (comma) {
      /* prevent get_lvalue from using the last expression
         as an lvalue. This also prevents the conversion of
         of get_var to get_ref for method lookup in function
         call inside `with` statement.
       */
      s->cur_func->last_opcode_pos = -1;
    }
    if (s->token.val != ',') break;
    comma = TRUE;
    if (next_token(s)) return -1;
    emit_op(s, OP_drop);
  }
  return 0;
}

__exception int js_parse_expr(JSParseState *s) {
  return js_parse_expr2(s, PF_IN_ACCEPTED);
}

QJS_STATIC void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
                                 JSAtom label_name, int label_break,
                                 int label_cont, int drop_count) {
  be->prev = fd->top_break;
  fd->top_break = be;
  be->label_name = label_name;
  be->label_break = label_break;
  be->label_cont = label_cont;
  be->drop_count = drop_count;
  be->label_finally = -1;
  be->scope_level = fd->scope_level;
  be->has_iterator = FALSE;
}

QJS_STATIC void pop_break_entry(JSFunctionDef *fd) {
  BlockEnv *be;
  be = fd->top_break;
  fd->top_break = be->prev;
}

__exception int emit_break(JSParseState *s, JSAtom name, int is_cont) {
  BlockEnv *top;
  int i, scope_level;

  scope_level = s->cur_func->scope_level;
  top = s->cur_func->top_break;
  while (top != NULL) {
    close_scopes(s, scope_level, top->scope_level);
    scope_level = top->scope_level;
    if (is_cont && top->label_cont != -1 &&
        (name == JS_ATOM_NULL || top->label_name == name)) {
      /* continue stays inside the same block */
      emit_goto(s, OP_goto, top->label_cont);
      return 0;
    }
    if (!is_cont && top->label_break != -1 &&
        (name == JS_ATOM_NULL || top->label_name == name)) {
      emit_goto(s, OP_goto, top->label_break);
      return 0;
    }
    i = 0;
    if (top->has_iterator) {
      emit_op(s, OP_iterator_close);
      i += 3;
    }
    for (; i < top->drop_count; i++) emit_op(s, OP_drop);
    if (top->label_finally != -1) {
      /* must push dummy value to keep same stack depth */
      emit_op(s, OP_undefined);
      emit_goto(s, OP_gosub, top->label_finally);
      emit_op(s, OP_drop);
    }
    top = top->prev;
  }
  if (name == JS_ATOM_NULL) {
    if (is_cont)
      return js_parse_error(s, "continue must be inside loop");
    else
      return js_parse_error(s, "break must be inside loop or switch");
  } else {
    return js_parse_error(s, "break/continue label not found");
  }
}

/* execute the finally blocks before return */
void emit_return(JSParseState *s, BOOL hasval) {
  BlockEnv *top;
  int drop_count;

  drop_count = 0;
  top = s->cur_func->top_break;
  while (top != NULL) {
    /* XXX: emit the appropriate OP_leave_scope opcodes? Probably not
       required as all local variables will be closed upon returning
       from JS_CallInternal, but not in the same order. */
    if (top->has_iterator) {
      /* with 'yield', the exact number of OP_drop to emit is
         unknown, so we use a specific operation to look for
         the catch offset */
      if (!hasval) {
        emit_op(s, OP_undefined);
        hasval = TRUE;
      }
      emit_op(s, OP_iterator_close_return);
      if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
        int label_next;
        emit_op(s, OP_async_iterator_close);
        label_next = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_label(s, label_next);
        emit_op(s, OP_drop);
      } else {
        emit_op(s, OP_iterator_close);
      }
      drop_count = -3;
    }
    drop_count += top->drop_count;
    if (top->label_finally != -1) {
      while (drop_count) {
        /* must keep the stack top if hasval */
        emit_op(s, hasval ? OP_nip : OP_drop);
        drop_count--;
      }
      if (!hasval) {
        /* must push return value to keep same stack size */
        emit_op(s, OP_undefined);
        hasval = TRUE;
      }
      emit_goto(s, OP_gosub, top->label_finally);
    }
    top = top->prev;
  }
  if (s->cur_func->is_derived_class_constructor) {
    int label_return;

    /* 'this' can be uninitialized, so it may be accessed only if
       the derived class constructor does not return an object */
    if (hasval) {
      emit_op(s, OP_check_ctor_return);
      label_return = emit_goto(s, OP_if_false, -1);
      emit_op(s, OP_drop);
    } else {
      label_return = -1;
    }

    emit_op(s, OP_scope_get_var);
    emit_atom(s, JS_ATOM_this);
    emit_u16(s, 0);

    emit_label(s, label_return);
    emit_op(s, OP_return);
  } else if (s->cur_func->func_kind != JS_FUNC_NORMAL) {
    if (!hasval) {
      emit_op(s, OP_undefined);
    } else if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
      emit_op(s, OP_await);
    }
    emit_op(s, OP_return_async);
  } else {
    emit_op(s, hasval ? OP_return : OP_return_undef);
  }
}

#define DECL_MASK_FUNC (1 << 0) /* allow normal function declaration */
/* ored with DECL_MASK_FUNC if function declarations are allowed with a label */
#define DECL_MASK_FUNC_WITH_LABEL (1 << 1)
#define DECL_MASK_OTHER (1 << 2) /* all other declarations */
#define DECL_MASK_ALL \
  (DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL | DECL_MASK_OTHER)

QJS_STATIC __exception int js_parse_statement_or_decl(JSParseState *s,
                                                      int decl_mask);

QJS_STATIC __exception int js_parse_statement(JSParseState *s) {
  return js_parse_statement_or_decl(s, 0);
}

QJS_STATIC __exception int js_parse_block(JSParseState *s) {
  if (js_parse_expect(s, '{')) return -1;
  if (s->token.val != '}') {
    push_scope(s);
    for (;;) {
      if (js_parse_statement_or_decl(s, DECL_MASK_ALL)) return -1;
      if (s->token.val == '}') break;
    }
    pop_scope(s);
  }
  if (next_token(s)) return -1;
  return 0;
}

/* allowed parse_flags: PF_IN_ACCEPTED */
__exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                             BOOL export_flag) {
  LEPUSContext *ctx = s->ctx;
  JSFunctionDef *fd = s->cur_func;
  JSAtom name = JS_ATOM_NULL;
  bool is_rc = !ctx->gc_enable;

  for (;;) {
    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved) {
        return js_parse_error_reserved_identifier(s);
      }
      name = is_rc ? LEPUS_DupAtom(ctx, s->token.u.ident.atom)
                   : s->token.u.ident.atom;
      if (name == JS_ATOM_let && (tok == TOK_LET || tok == TOK_CONST)) {
        js_parse_error(s, "'let' is not a valid lexical identifier");
        goto var_error;
      }
      if (next_token(s)) goto var_error;
      if (js_define_var(s, name, tok)) goto var_error;
      if (export_flag) {
        if (!add_export_entry(s, s->cur_func->module, name, name,
                              JS_EXPORT_TYPE_LOCAL))
          goto var_error;
      }

      if (s->token.val == '=') {
        if (next_token(s)) goto var_error;
        if (tok == TOK_VAR) {
          /* Must make a reference for proper `with` semantics */
          int opcode, scope, label;
          JSAtom name1;

          emit_op(s, OP_scope_get_var);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
          if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') <
              0)
            goto var_error;
          if (js_parse_assign_expr(s, parse_flags)) {
            if (is_rc) LEPUS_FreeAtom(ctx, name1);
            goto var_error;
          }
          set_object_name(s, name);
          put_lvalue(s, opcode, scope, name1, label, PUT_LVALUE_NOKEEP, FALSE);
        } else {
          if (js_parse_assign_expr(s, parse_flags)) goto var_error;
          set_object_name(s, name);
          emit_op(s, (tok == TOK_CONST || tok == TOK_LET)
                         ? OP_scope_put_var_init
                         : OP_scope_put_var);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        }
      } else {
        if (tok == TOK_CONST) {
          js_parse_error(s, "missing initializer for const variable");
          goto var_error;
        }
        if (tok == TOK_LET) {
          /* initialize lexical variable upon entering its scope */
          emit_op(s, OP_undefined);
          emit_op(s, OP_scope_put_var_init);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        }
      }
      if (is_rc) LEPUS_FreeAtom(ctx, name);
    } else {
      int skip_bits;
      if ((s->token.val == '[' || s->token.val == '{') &&
          js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
        emit_op(s, OP_undefined);
        if (js_parse_destructing_element(
                s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        return js_parse_error(s, "variable name expected");
      }
    }
    if (s->token.val != ',') break;
    if (next_token(s)) return -1;
  }
  return 0;

var_error:
  if (is_rc) LEPUS_FreeAtom(ctx, name);
  return -1;
}

/* test if the current token is a label. Use simplistic look-ahead scanner */
QJS_STATIC BOOL is_label(JSParseState *s) {
  return (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
          peek_token(s, FALSE) == ':');
}

/* test if the current token is a let keyword. Use simplistic look-ahead scanner
 */
int is_let(JSParseState *s, int decl_mask) {
  int res = FALSE;

  if (token_is_pseudo_keyword(s, JS_ATOM_let)) {
#if 1
    JSParsePos pos;
    js_parse_get_pos(s, &pos);
    for (;;) {
      if (next_token(s)) {
        res = -1;
        break;
      }
      if (s->token.val == '[') {
        /* let [ is a syntax restriction:
           it never introduces an ExpressionStatement */
        res = TRUE;
        break;
      }
      if (s->token.val == '{' ||
          (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||
          s->token.val == TOK_LET || s->token.val == TOK_YIELD ||
          s->token.val == TOK_AWAIT) {
        /* Check for possible ASI if not scanning for Declaration */
        /* XXX: should also check that `{` introduces a BindingPattern,
           but Firefox does not and rejects eval("let=1;let\n{if(1)2;}") */
        if (s->last_line_num == s->token.line_num ||
            (decl_mask & DECL_MASK_OTHER)) {
          res = TRUE;
          break;
        }
        break;
      }
      break;
    }
    if (js_parse_seek_token(s, &pos)) {
      res = -1;
    }
#else
    int tok = peek_token(s, TRUE);
    if (tok == '{' || tok == TOK_IDENT || peek_token(s, FALSE) == '[') {
      res = TRUE;
    }
#endif
  }
  return res;
}

/* XXX: handle IteratorClose when exiting the loop before the
   enumeration is done */
QJS_STATIC __exception int js_parse_for_in_of(JSParseState *s, int label_name,
                                              BOOL is_async) {
  LEPUSContext *ctx = s->ctx;
  JSFunctionDef *fd = s->cur_func;
  JSAtom var_name;
  BOOL has_initializer, is_for_of, has_destructuring;
  int tok, tok1, opcode, scope, block_scope_level;
  int label_next, label_expr, label_cont, label_body, label_break;
  int pos_next, pos_expr;
  BlockEnv break_entry;

  has_initializer = FALSE;
  has_destructuring = FALSE;
  is_for_of = FALSE;
  block_scope_level = fd->scope_level;
  label_cont = new_label(s);
  label_body = new_label(s);
  label_break = new_label(s);
  label_next = new_label(s);

  /* create scope for the lexical variables declared in the enumeration
     expressions. XXX: Not completely correct because of weird capturing
     semantics in `for (i of o) a.push(function(){return i})` */
  push_scope(s);

  /* local for_in scope starts here so individual elements
     can be closed in statement. */
  push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                   label_cont, 1);
  break_entry.scope_level = block_scope_level;

  label_expr = emit_goto(s, OP_goto, -1);

  pos_next = s->cur_func->byte_code.size;
  emit_label(s, label_next);

  tok = s->token.val;
  switch (is_let(s, DECL_MASK_OTHER)) {
    case TRUE:
      tok = TOK_LET;
      break;
    case FALSE:
      break;
    default:
      return -1;
  }
  if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
    if (next_token(s)) return -1;

    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
      if (s->token.val == '[' || s->token.val == '{') {
        if (js_parse_destructing_element(s, tok, 0, TRUE, -1, FALSE) < 0)
          return -1;
        has_destructuring = TRUE;
      } else {
        return js_parse_error(s, "variable name expected");
      }
      var_name = JS_ATOM_NULL;
    } else {
      var_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      if (next_token(s)) {
        LEPUS_FreeAtom(s->ctx, var_name);
        return -1;
      }
      if (js_define_var(s, var_name, tok)) {
        LEPUS_FreeAtom(s->ctx, var_name);
        return -1;
      }
      emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ? OP_scope_put_var_init
                                                      : OP_scope_put_var);
      emit_atom(s, var_name);
      emit_u16(s, fd->scope_level);
    }
  } else {
    int skip_bits;
    if ((s->token.val == '[' || s->token.val == '{') &&
        ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == TOK_IN ||
         tok1 == TOK_OF)) {
      if (js_parse_destructing_element(s, 0, 0, TRUE,
                                       skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
        return -1;
    } else {
      int lvalue_label, depth;
      if (js_parse_left_hand_side_expr(s)) return -1;
      if (get_lvalue(s, &opcode, &scope, &var_name, &lvalue_label, &depth,
                     FALSE, TOK_FOR))
        return -1;
      put_lvalue(s, opcode, scope, var_name, lvalue_label,
                 PUT_LVALUE_NOKEEP_BOTTOM, FALSE);
    }
    var_name = JS_ATOM_NULL;
  }
  emit_goto(s, OP_goto, label_body);

  pos_expr = s->cur_func->byte_code.size;
  emit_label(s, label_expr);
  if (s->token.val == '=') {
    /* XXX: potential scoping issue if inside `with` statement */
    has_initializer = TRUE;
    /* parse and evaluate initializer prior to evaluating the
       object (only used with "for in" with a non lexical variable
       in non strict mode */
    if (next_token(s) || js_parse_assign_expr(s, 0)) {
      LEPUS_FreeAtom(ctx, var_name);
      return -1;
    }
    if (var_name != JS_ATOM_NULL) {
      emit_op(s, OP_scope_put_var);
      emit_atom(s, var_name);
      emit_u16(s, fd->scope_level);
    }
  }
  LEPUS_FreeAtom(ctx, var_name);

  if (token_is_pseudo_keyword(s, JS_ATOM_of)) {
    break_entry.has_iterator = is_for_of = TRUE;
    break_entry.drop_count += 2;
    if (has_initializer) goto initializer_error;
  } else if (s->token.val == TOK_IN) {
    if (is_async)
      return js_parse_error(s, "'for await' loop should be used with 'of'");
    if (has_initializer && (tok != TOK_VAR || (fd->js_mode & JS_MODE_STRICT) ||
                            has_destructuring)) {
    initializer_error:
      return js_parse_error(s,
                            "a declaration in the head of a for-%s loop can't "
                            "have an initializer",
                            is_for_of ? "of" : "in");
    }
  } else {
    return js_parse_error(s, "expected 'of' or 'in' in for control expression");
  }
  if (next_token(s)) return -1;
  if (is_for_of) {
    if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
  } else {
    if (js_parse_expr(s)) return -1;
  }
  /* close the scope after having evaluated the expression so that
     the TDZ values are in the closures */
  close_scopes(s, s->cur_func->scope_level, block_scope_level);
  if (is_for_of) {
    if (is_async)
      emit_op(s, OP_for_await_of_start);
    else
      emit_op(s, OP_for_of_start);
    /* on stack: enum_rec */
  } else {
    emit_op(s, OP_for_in_start);
    /* on stack: enum_obj */
  }
  emit_goto(s, OP_goto, label_cont);

  if (js_parse_expect(s, ')')) return -1;

  if (OPTIMIZE) {
    /* move the `next` code here */
    DynBuf *bc = &s->cur_func->byte_code;
    int chunk_size = pos_expr - pos_next;
    int offset = bc->size - pos_next;
    int i;
    dbuf_realloc(bc, bc->size + chunk_size);
    dbuf_put(bc, bc->buf + pos_next, chunk_size);
    memset(bc->buf + pos_next, OP_nop, chunk_size);
    /* `next` part ends with a goto */
    s->cur_func->last_opcode_pos = bc->size - 5;
    /* relocate labels */
    for (i = label_cont; i < s->cur_func->label_count; i++) {
      LabelSlot *ls = &s->cur_func->label_slots[i];
      if (ls->pos >= pos_next && ls->pos < pos_expr) ls->pos += offset;
    }
  }

  emit_label(s, label_body);
  if (js_parse_statement(s)) return -1;

  close_scopes(s, s->cur_func->scope_level, block_scope_level);

  emit_label(s, label_cont);
  if (is_for_of) {
    if (is_async) {
      /* call the next method */
      emit_op(s, OP_dup3);
      emit_op(s, OP_drop);
      emit_op(s, OP_call_method);
      emit_u16(s, 0);
      /* get the result of the promise */
      emit_op(s, OP_await);
      /* unwrap the value and done values */
      emit_op(s, OP_iterator_get_value_done);
    } else {
      emit_op(s, OP_for_of_next);
      emit_u8(s, 0);
    }
  } else {
    emit_op(s, OP_for_in_next);
  }
  /* on stack: enum_rec / enum_obj value bool */
  emit_goto(s, OP_if_false, label_next);
  /* drop the undefined value from for_xx_next */
  emit_op(s, OP_drop);

  emit_label(s, label_break);
  if (is_for_of) {
    /* close and drop enum_rec */
    emit_op(s, OP_iterator_close);
  } else {
    emit_op(s, OP_drop);
  }
  pop_break_entry(s->cur_func);
  pop_scope(s);
  return 0;
}

QJS_STATIC void set_eval_ret_undefined(JSParseState *s) {
  if (s->cur_func->eval_ret_idx >= 0) {
    emit_op(s, OP_undefined);
    emit_op(s, OP_put_loc);
    emit_u16(s, s->cur_func->eval_ret_idx);
  }
}

#ifdef ENABLE_QUICKJS_DEBUGGER
QJS_STATIC void js_gen_debugger_statement(JSParseState *s, LEPUSContext *ctx) {
  LEPUSValue statement = LEPUS_NewString(ctx, "statement");
  if (LEPUS_IsException(statement)) return;
  if (emit_push_const(s, statement, 0) < 0) {
    LEPUS_FreeValue(ctx, statement);
    return;
  }
  LEPUS_FreeValue(ctx, statement);
  emit_op(s, OP_drop);
}
#endif

QJS_STATIC __exception int js_parse_statement_or_decl(JSParseState *s,
                                                      int decl_mask) {
  LEPUSContext *ctx = s->ctx;
  JSAtom label_name;
  int tok;

  /* specific label handling */
  /* XXX: support multiple labels on loop statements */
  label_name = JS_ATOM_NULL;
  if (is_label(s)) {
    BlockEnv *be;

    label_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);

    for (be = s->cur_func->top_break; be; be = be->prev) {
      if (be->label_name == label_name) {
        js_parse_error(s, "duplicate label name");
        goto fail;
      }
    }

    if (next_token(s)) goto fail;
    if (js_parse_expect(s, ':')) goto fail;
    if (s->token.val != TOK_FOR && s->token.val != TOK_DO &&
        s->token.val != TOK_WHILE) {
      /* labelled regular statement */
      int label_break, mask;
      BlockEnv break_entry;

      label_break = new_label(s);
      push_break_entry(s->cur_func, &break_entry, label_name, label_break, -1,
                       0);
      if (!(s->cur_func->js_mode & JS_MODE_STRICT) &&
          (decl_mask & DECL_MASK_FUNC_WITH_LABEL)) {
        mask = DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL;
      } else {
        mask = 0;
      }
      if (js_parse_statement_or_decl(s, mask)) goto fail;
      emit_label(s, label_break);
      pop_break_entry(s->cur_func);
      goto done;
    }
  }

  switch (tok = s->token.val) {
    case '{':
      if (js_parse_block(s)) goto fail;
      break;
    case TOK_RETURN:
      if (s->cur_func->is_eval) {
        js_parse_error(s, "return not in a function");
        goto fail;
      }
      if (next_token(s)) goto fail;
      if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {
        if (js_parse_expr(s)) goto fail;
        emit_return(s, TRUE);
      } else {
        emit_return(s, FALSE);
      }
      if (js_parse_expect_semi(s)) goto fail;
      break;
    case TOK_THROW:
      if (next_token(s)) goto fail;
      if (s->got_lf) {
        js_parse_error(s, "line terminator not allowed after throw");
        goto fail;
      }
      if (js_parse_expr(s)) goto fail;
      emit_op(s, OP_throw);
      if (js_parse_expect_semi(s)) goto fail;
      break;
    case TOK_LET:
    case TOK_CONST:
    haslet:
      if (!(decl_mask & DECL_MASK_OTHER)) {
        js_parse_error(
            s, "lexical declarations can't appear in single-statement context");
        goto fail;
      }
      /* fall thru */
    case TOK_VAR:
      if (next_token(s)) goto fail;
      if (js_parse_var(s, TRUE, tok, FALSE)) goto fail;
      if (js_parse_expect_semi(s)) goto fail;
      break;
    case TOK_IF: {
      int label1, label2, mask;
      if (next_token(s)) goto fail;
      /* create a new scope for `let f;if(1) function f(){}` */
      push_scope(s);
      set_eval_ret_undefined(s);
      if (js_parse_expr_paren(s)) goto fail;
      label1 = emit_goto(s, OP_if_false, -1);
      if (s->cur_func->js_mode & JS_MODE_STRICT)
        mask = 0;
      else
        mask = DECL_MASK_FUNC; /* Annex B.3.4 */

      if (js_parse_statement_or_decl(s, mask)) goto fail;

      if (s->token.val == TOK_ELSE) {
        label2 = emit_goto(s, OP_goto, -1);
        if (next_token(s)) goto fail;

        emit_label(s, label1);
        if (js_parse_statement_or_decl(s, mask)) goto fail;

        label1 = label2;
      }
      emit_label(s, label1);
      pop_scope(s);
    } break;
    case TOK_WHILE: {
      int label_cont, label_break;
      BlockEnv break_entry;

      label_cont = new_label(s);
      label_break = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);

      emit_label(s, label_cont);
      if (js_parse_expr_paren(s)) goto fail;
      emit_goto(s, OP_if_false, label_break);

      if (js_parse_statement(s)) goto fail;
      emit_goto(s, OP_goto, label_cont);

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
    } break;
    case TOK_DO: {
      int label_cont, label_break, label1;
      BlockEnv break_entry;

      label_cont = new_label(s);
      label_break = new_label(s);
      label1 = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      if (next_token(s)) goto fail;

      emit_label(s, label1);

      set_eval_ret_undefined(s);

      if (js_parse_statement(s)) goto fail;

      emit_label(s, label_cont);
      if (js_parse_expect(s, TOK_WHILE)) goto fail;
      if (js_parse_expr_paren(s)) goto fail;
      /* Insert semicolon if missing */
      if (s->token.val == ';') {
        if (next_token(s)) goto fail;
      }
      emit_goto(s, OP_if_true, label1);

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
    } break;
    case TOK_FOR: {
      int label_cont, label_break, label_body, label_test;
      int pos_cont, pos_body, block_scope_level;
      BlockEnv break_entry;
      int tok, bits;
      BOOL is_async;

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);
      bits = 0;
      is_async = FALSE;
      if (s->token.val == '(') {
        js_parse_skip_parens_token(s, &bits, FALSE);
      } else if (s->token.val == TOK_AWAIT) {
        if (!(s->cur_func->func_kind & JS_FUNC_ASYNC)) {
          js_parse_error(s,
                         "for await is only valid in asynchronous functions");
          goto fail;
        }
        is_async = TRUE;
        if (next_token(s)) goto fail;
      }
      if (js_parse_expect(s, '(')) goto fail;

      if (!(bits & SKIP_HAS_SEMI)) {
        /* parse for/in or for/of */
        if (js_parse_for_in_of(s, label_name, is_async)) goto fail;
        break;
      }
      block_scope_level = s->cur_func->scope_level;

      /* create scope for the lexical variables declared in the initial,
         test and increment expressions */
      push_scope(s);
      /* initial expression */
      tok = s->token.val;
      if (tok != ';') {
        switch (is_let(s, DECL_MASK_OTHER)) {
          case TRUE:
            tok = TOK_LET;
            break;
          case FALSE:
            break;
          default:
            goto fail;
        }
        if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
          if (next_token(s)) goto fail;
          if (js_parse_var(s, FALSE, tok, FALSE)) goto fail;
        } else {
          if (js_parse_expr2(s, FALSE)) goto fail;
          emit_op(s, OP_drop);
        }

        /* close the closures before the first iteration */
        close_scopes(s, s->cur_func->scope_level, block_scope_level);
      }
      if (js_parse_expect(s, ';')) goto fail;

      label_test = new_label(s);
      label_cont = new_label(s);
      label_body = new_label(s);
      label_break = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      /* test expression */
      if (s->token.val == ';') {
        /* no test expression */
        label_test = label_body;
      } else {
        emit_label(s, label_test);
        if (js_parse_expr(s)) goto fail;
        emit_goto(s, OP_if_false, label_break);
      }
      if (js_parse_expect(s, ';')) goto fail;

      if (s->token.val == ')') {
        /* no end expression */
        break_entry.label_cont = label_cont = label_test;
        pos_cont = 0; /* avoid warning */
      } else {
        /* skip the end expression */
        emit_goto(s, OP_goto, label_body);

        pos_cont = s->cur_func->byte_code.size;
        emit_label(s, label_cont);
        if (js_parse_expr(s)) goto fail;
        emit_op(s, OP_drop);
        if (label_test != label_body) emit_goto(s, OP_goto, label_test);
      }
      if (js_parse_expect(s, ')')) goto fail;

      pos_body = s->cur_func->byte_code.size;
      emit_label(s, label_body);
      if (js_parse_statement(s)) goto fail;

      /* close the closures before the next iteration */
      /* XXX: check continue case */
      close_scopes(s, s->cur_func->scope_level, block_scope_level);

      if (OPTIMIZE && label_test != label_body && label_cont != label_test) {
        /* move the increment code here */
        DynBuf *bc = &s->cur_func->byte_code;
        int chunk_size = pos_body - pos_cont;
        int offset = bc->size - pos_cont;
        int i;
        dbuf_realloc(bc, bc->size + chunk_size);
        dbuf_put(bc, bc->buf + pos_cont, chunk_size);
        memset(bc->buf + pos_cont, OP_nop, chunk_size);
        /* increment part ends with a goto */
        s->cur_func->last_opcode_pos = bc->size - 5;
        /* relocate labels */
        for (i = label_cont; i < s->cur_func->label_count; i++) {
          LabelSlot *ls = &s->cur_func->label_slots[i];
          if (ls->pos >= pos_cont && ls->pos < pos_body) ls->pos += offset;
        }
      } else {
        emit_goto(s, OP_goto, label_cont);
      }

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
      pop_scope(s);
    } break;
    case TOK_BREAK:
    case TOK_CONTINUE: {
      int is_cont = s->token.val - TOK_BREAK;
      int label;

      if (next_token(s)) goto fail;
      if (!s->got_lf && s->token.val == TOK_IDENT &&
          !s->token.u.ident.is_reserved)
        label = s->token.u.ident.atom;
      else
        label = JS_ATOM_NULL;
      if (emit_break(s, label, is_cont)) goto fail;
      if (label != JS_ATOM_NULL) {
        if (next_token(s)) goto fail;
      }
      if (js_parse_expect_semi(s)) goto fail;
    } break;
    case TOK_SWITCH: {
      int label_case, label_break, label1;
      int default_label_pos;
      BlockEnv break_entry;

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);
      if (js_parse_expr_paren(s)) goto fail;

      push_scope(s);
      label_break = new_label(s);
      push_break_entry(s->cur_func, &break_entry, label_name, label_break, -1,
                       1);

      if (js_parse_expect(s, '{')) goto fail;

      default_label_pos = -1;
      label_case = -1;
      while (s->token.val != '}') {
        if (s->token.val == TOK_CASE) {
          label1 = -1;
          if (label_case >= 0) {
            /* skip the case if needed */
            label1 = emit_goto(s, OP_goto, -1);
          }
          emit_label(s, label_case);
          label_case = -1;
          for (;;) {
            /* parse a sequence of case clauses */
            if (next_token(s)) goto fail;
            emit_op(s, OP_dup);
            if (js_parse_expr(s)) goto fail;
            if (js_parse_expect(s, ':')) goto fail;
            emit_op(s, OP_strict_eq);
            if (s->token.val == TOK_CASE) {
              label1 = emit_goto(s, OP_if_true, label1);
            } else {
              label_case = emit_goto(s, OP_if_false, -1);
              emit_label(s, label1);
              break;
            }
          }
        } else if (s->token.val == TOK_DEFAULT) {
          if (next_token(s)) goto fail;
          if (js_parse_expect(s, ':')) goto fail;
          if (default_label_pos >= 0) {
            js_parse_error(s, "duplicate default");
            goto fail;
          }
          if (label_case < 0) {
            /* falling thru direct from switch expression */
            label_case = emit_goto(s, OP_goto, -1);
          }
          /* Emit a dummy label opcode. Label will be patched after
             the end of the switch body. Do not use emit_label(s, 0)
             because it would clobber label 0 address, preventing
             proper optimizer operation.
           */
          emit_op(s, OP_label);
          emit_u32(s, 0);
          default_label_pos = s->cur_func->byte_code.size - 4;
        } else {
          if (label_case < 0) {
            /* falling thru direct from switch expression */
            js_parse_error(s, "invalid switch statement");
            goto fail;
          }
          if (js_parse_statement_or_decl(s, DECL_MASK_ALL)) goto fail;
        }
      }
      if (js_parse_expect(s, '}')) goto fail;
      if (default_label_pos >= 0) {
        /* Ugly patch for the the `default` label, shameful and risky */
        put_u32(s->cur_func->byte_code.buf + default_label_pos, label_case);
        s->cur_func->label_slots[label_case].pos = default_label_pos + 4;
      } else {
        emit_label(s, label_case);
      }
      emit_label(s, label_break);
      emit_op(s, OP_drop); /* drop the switch expression */

      pop_break_entry(s->cur_func);
      pop_scope(s);
    } break;
    case TOK_TRY: {
      int label_catch, label_catch2, label_finally, label_end;
      JSAtom name;
      BlockEnv block_env;

      set_eval_ret_undefined(s);
      if (next_token(s)) goto fail;
      label_catch = new_label(s);
      label_catch2 = new_label(s);
      label_finally = new_label(s);
      label_end = new_label(s);

      emit_goto(s, OP_catch, label_catch);

      push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL, -1, -1, 1);
      block_env.label_finally = label_finally;

      if (js_parse_block(s)) goto fail;

      pop_break_entry(s->cur_func);

      if (js_is_live_code(s)) {
        /* drop the catch offset */
        emit_op(s, OP_drop);
        /* must push dummy value to keep same stack size */
        emit_op(s, OP_undefined);
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_drop);

        emit_goto(s, OP_goto, label_end);
      }

      if (s->token.val == TOK_CATCH) {
        if (next_token(s)) goto fail;

        push_scope(s); /* catch variable */
        emit_label(s, label_catch);

        if (s->token.val == '{') {
          /* support optional-catch-binding feature */
          emit_op(s, OP_drop); /* pop the exception object */
        } else {
          if (js_parse_expect(s, '(')) goto fail;
          if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
            if (s->token.val == '[' || s->token.val == '{') {
              /* XXX: TOK_LET is not completely correct */
              if (js_parse_destructing_element(s, TOK_LET, 0, TRUE, -1, TRUE) <
                  0)
                goto fail;
            } else {
              js_parse_error(s, "identifier expected");
              goto fail;
            }
          } else {
            name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
            if (next_token(s) || js_define_var(s, name, TOK_CATCH) < 0) {
              LEPUS_FreeAtom(ctx, name);
              goto fail;
            }
            /* store the exception value in the catch variable */
            emit_op(s, OP_scope_put_var);
            emit_u32(s, name);
            emit_u16(s, s->cur_func->scope_level);
          }
          if (js_parse_expect(s, ')')) goto fail;
        }
        /* XXX: should keep the address to nop it out if there is no finally
         * block */
        emit_goto(s, OP_catch, label_catch2);

        push_scope(s); /* catch block */
        push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL, -1, -1, 1);
        block_env.label_finally = label_finally;

        if (js_parse_block(s)) goto fail;

        pop_break_entry(s->cur_func);
        pop_scope(s); /* catch block */
        pop_scope(s); /* catch variable */

        if (js_is_live_code(s)) {
          /* drop the catch2 offset */
          emit_op(s, OP_drop);
          /* XXX: should keep the address to nop it out if there is no finally
           * block */
          /* must push dummy value to keep same stack size */
          emit_op(s, OP_undefined);
          emit_goto(s, OP_gosub, label_finally);
          emit_op(s, OP_drop);
          emit_goto(s, OP_goto, label_end);
        }
        /* catch exceptions thrown in the catch block to execute the
         * finally clause and rethrow the exception */
        emit_label(s, label_catch2);
        /* catch value is at TOS, no need to push undefined */
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_throw);

      } else if (s->token.val == TOK_FINALLY) {
        /* finally without catch : execute the finally clause
         * and rethrow the exception */
        emit_label(s, label_catch);
        /* catch value is at TOS, no need to push undefined */
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_throw);
      } else {
        js_parse_error(s, "expecting catch or finally");
        goto fail;
      }
      emit_label(s, label_finally);
      if (s->token.val == TOK_FINALLY) {
        int saved_eval_ret_idx;
        if (next_token(s)) goto fail;
        /* on the stack: ret_value gosub_ret_value */
        push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL, -1, -1, 2);
        if (s->cur_func->eval_ret_idx >= 0) {
          /* 'finally' updates eval_ret only if not a normal
             termination */
          saved_eval_ret_idx = add_var(s->ctx, s->cur_func, JS_ATOM__ret_);
          if (saved_eval_ret_idx < 0) goto fail;
          emit_op(s, OP_get_loc);
          emit_u16(s, s->cur_func->eval_ret_idx);
          emit_op(s, OP_put_loc);
          emit_u16(s, saved_eval_ret_idx);
          set_eval_ret_undefined(s);
        }

        if (js_parse_block(s)) goto fail;

        if (s->cur_func->eval_ret_idx >= 0) {
          emit_op(s, OP_get_loc);
          emit_u16(s, saved_eval_ret_idx);
          emit_op(s, OP_put_loc);
          emit_u16(s, s->cur_func->eval_ret_idx);
        }
        pop_break_entry(s->cur_func);
      }
      emit_op(s, OP_ret);
      emit_label(s, label_end);
    } break;
    case ';':
      /* empty statement */
      if (next_token(s)) goto fail;
      break;
    case TOK_WITH:
      if (s->cur_func->js_mode & JS_MODE_STRICT) {
        js_parse_error(s, "invalid keyword: with");
        goto fail;
      } else {
        int with_idx;

        if (next_token(s)) goto fail;

        if (js_parse_expr_paren(s)) goto fail;

        push_scope(s);
        with_idx = define_var(s, s->cur_func, JS_ATOM__with_, JS_VAR_DEF_WITH);
        if (with_idx < 0) goto fail;
        emit_op(s, OP_to_object);
        emit_op(s, OP_put_loc);
        emit_u16(s, with_idx);

        set_eval_ret_undefined(s);
        if (js_parse_statement(s)) goto fail;

        /* Popping scope drops lexical context for the with object variable */
        pop_scope(s);
      }
      break;
    case TOK_FUNCTION:
      /* ES6 Annex B.3.2 and B.3.3 semantics */
      if (!(decl_mask & DECL_MASK_FUNC)) goto func_decl_error;
      if (!(decl_mask & DECL_MASK_OTHER) && peek_token(s, FALSE) == '*')
        goto func_decl_error;
      goto parse_func_var;
    case TOK_IDENT:
      if (s->token.u.ident.is_reserved) {
        js_parse_error_reserved_identifier(s);
        goto fail;
      }
      /* Determine if `let` introduces a Declaration or an ExpressionStatement
       */
      switch (is_let(s, decl_mask)) {
        case TRUE:
          tok = TOK_LET;
          goto haslet;
        case FALSE:
          break;
        default:
          goto fail;
      }
      if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
          peek_token(s, TRUE) == TOK_FUNCTION) {
        if (!(decl_mask & DECL_MASK_OTHER)) {
        func_decl_error:
          js_parse_error(
              s,
              "function declarations can't appear in single-statement context");
          goto fail;
        }
      parse_func_var:
        if (js_parse_function_decl(s, JS_PARSE_FUNC_VAR, JS_FUNC_NORMAL,
                                   JS_ATOM_NULL, s->token.ptr,
                                   s->token.line_num))
          goto fail;
        break;
      }
      goto hasexpr;

    case TOK_CLASS:
      if (!(decl_mask & DECL_MASK_OTHER)) {
        js_parse_error(
            s, "class declarations can't appear in single-statement context");
        goto fail;
      }
      if (js_parse_class(s, FALSE, JS_PARSE_EXPORT_NONE)) return -1;
      break;

    case TOK_DEBUGGER:
#ifdef ENABLE_QUICKJS_DEBUGGER
      if (next_token(s)) goto fail;
      // generate opcode: op_push_const
      LEPUSValue debugger;
      debugger = LEPUS_NewString(ctx, "debugger");
      if (LEPUS_IsException(debugger)) goto fail;
      if (emit_push_const(s, debugger, 0) < 0) {
        LEPUS_FreeValue(ctx, debugger);
        goto fail;
      }
      LEPUS_FreeValue(ctx, debugger);
      emit_op(s, OP_drop);
      break;
#endif
    case TOK_ENUM:
    case TOK_EXPORT:
    case TOK_EXTENDS:
      js_unsupported_keyword(s, s->token.u.ident.atom);
      goto fail;

    default:
    hasexpr:
      if (js_parse_expr(s)) goto fail;
      if (s->cur_func->eval_ret_idx >= 0) {
        /* store the expression value so that it can be returned
           by eval() */
        emit_op(s, OP_put_loc);
        emit_u16(s, s->cur_func->eval_ret_idx);
      } else {
        emit_op(s, OP_drop); /* drop the result */
      }
      if (js_parse_expect_semi(s)) goto fail;
      break;
  }
done:
  LEPUS_FreeAtom(ctx, label_name);
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (ctx->debugger_mode) {
    js_gen_debugger_statement(s, s->ctx);
  }
#endif
  return 0;
fail:
  LEPUS_FreeAtom(ctx, label_name);
  return -1;
}
#endif

/* 'name' is freed */
LEPUSModuleDef *js_new_module_def(LEPUSContext *ctx, JSAtom name) {
  LEPUSModuleDef *m;
  m = static_cast<LEPUSModuleDef *>(
      lepus_mallocz(ctx, sizeof(*m), ALLOC_TAG_LEPUSModuleDef));
  if (!m) {
    if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, name);
    return NULL;
  }
  if (!ctx->gc_enable) m->header.ref_count = 1;
  m->module_name = name;
  m->module_ns = LEPUS_UNDEFINED;
  m->func_obj = LEPUS_UNDEFINED;
  m->eval_exception = LEPUS_UNDEFINED;
  list_add_tail(&m->link, &ctx->loaded_modules);
  return m;
}

QJS_STATIC void js_free_module_def(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;

  LEPUS_FreeAtom(ctx, m->module_name);

  for (i = 0; i < m->req_module_entries_count; i++) {
    JSReqModuleEntry *rme = &m->req_module_entries[i];
    LEPUS_FreeAtom(ctx, rme->module_name);
  }
  lepus_free(ctx, m->req_module_entries);

  for (i = 0; i < m->export_entries_count; i++) {
    JSExportEntry *me = &m->export_entries[i];
    if (me->export_type == JS_EXPORT_TYPE_LOCAL)
      free_var_ref(ctx->rt, me->u.local.var_ref);
    LEPUS_FreeAtom(ctx, me->export_name);
    LEPUS_FreeAtom(ctx, me->local_name);
  }
  lepus_free(ctx, m->export_entries);

  lepus_free(ctx, m->star_export_entries);

  for (i = 0; i < m->import_entries_count; i++) {
    JSImportEntry *mi = &m->import_entries[i];
    LEPUS_FreeAtom(ctx, mi->import_name);
  }
  lepus_free(ctx, m->import_entries);

  LEPUS_FreeValue(ctx, m->module_ns);
  LEPUS_FreeValue(ctx, m->func_obj);
  LEPUS_FreeValue(ctx, m->eval_exception);
  list_del(&m->link);
  lepus_free(ctx, m);
}

#ifndef NO_QUICKJS_COMPILER
int js_resize_array(LEPUSContext *ctx, void **parray, int elem_size, int *psize,
                    int *pcount, int new_count) {
  if (unlikely(new_count > *psize)) {
    int new_size;
    size_t slack;
    void *new_array;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(new_count, *psize * 3 / 2);
    new_array = lepus_realloc2(ctx, *parray, new_size * elem_size, &slack,
                               ALLOC_TAG_WITHOUT_PTR);
    if (!new_array) return -1;
    new_size += slack / elem_size;
    *psize = new_size;
    *parray = new_array;
  }
  *pcount = new_count;
  return 0;
}

int add_req_module_entry(LEPUSContext *ctx, LEPUSModuleDef *m,
                         JSAtom module_name) {
  JSReqModuleEntry *rme;
  int i;

  /* no need to add the module request if it is already present */
  for (i = 0; i < m->req_module_entries_count; i++) {
    rme = &m->req_module_entries[i];
    if (rme->module_name == module_name) return i;
  }

  if (js_resize_array(ctx, (void **)&m->req_module_entries,
                      sizeof(JSReqModuleEntry), &m->req_module_entries_size,
                      &m->req_module_entries_count,
                      m->req_module_entries_count + 1))
    return -1;
  i = m->req_module_entries_count - 1;
  rme = &m->req_module_entries[i];
  if (ctx->gc_enable)
    rme->module_name = module_name;
  else
    rme->module_name = LEPUS_DupAtom(ctx, module_name);
  rme->module = NULL;
  return i;
}

JSExportEntry *find_export_entry(LEPUSContext *ctx, LEPUSModuleDef *m,
                                 JSAtom export_name) {
  JSExportEntry *me;
  int i;
  for (i = 0; i < m->export_entries_count; i++) {
    me = &m->export_entries[i];
    if (me->export_name == export_name) return me;
  }
  return NULL;
}

QJS_STATIC JSExportEntry *add_export_entry2(LEPUSContext *ctx, JSParseState *s,
                                            LEPUSModuleDef *m,
                                            JSAtom local_name,
                                            JSAtom export_name,
                                            JSExportTypeEnum export_type) {
  JSExportEntry *me;

  if (find_export_entry(ctx, m, export_name)) {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    if (s) {
      js_parse_error(s, "duplicate exported name '%s'",
                     JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));
    } else {
      JS_ThrowSyntaxErrorAtom(ctx, "duplicate exported name '%s'", export_name);
    }
    return NULL;
  }

  if (js_resize_array(ctx, (void **)&m->export_entries, sizeof(JSExportEntry),
                      &m->export_entries_size, &m->export_entries_count,
                      m->export_entries_count + 1))
    return NULL;
  me = &m->export_entries[m->export_entries_count - 1];
  memset(me, 0, sizeof(*me));
  if (!ctx->gc_enable) {
    LEPUS_DupAtom(ctx, local_name);
    LEPUS_DupAtom(ctx, export_name);
  }
  me->local_name = local_name;
  me->export_name = export_name;
  me->export_type = export_type;
  return me;
}

JSExportEntry *add_export_entry(JSParseState *s, LEPUSModuleDef *m,
                                JSAtom local_name, JSAtom export_name,
                                JSExportTypeEnum export_type) {
  return add_export_entry2(s->ctx, s, m, local_name, export_name, export_type);
}

int add_star_export_entry(LEPUSContext *ctx, LEPUSModuleDef *m,
                          int req_module_idx) {
  JSStarExportEntry *se;

  if (js_resize_array(ctx, (void **)&m->star_export_entries,
                      sizeof(JSStarExportEntry), &m->star_export_entries_size,
                      &m->star_export_entries_count,
                      m->star_export_entries_count + 1))
    return -1;
  se = &m->star_export_entries[m->star_export_entries_count - 1];
  se->req_module_idx = req_module_idx;
  return 0;
}

/* create a C module */
LEPUSModuleDef *LEPUS_NewCModule(LEPUSContext *ctx, const char *name_str,
                                 LEPUSModuleInitFunc *func) {
  LEPUSModuleDef *m;
  JSAtom name;
  name = LEPUS_NewAtom(ctx, name_str);
  HandleScope func_scope(ctx->rt);
  func_scope.PushLEPUSAtom(name);
  if (name == JS_ATOM_NULL) return NULL;
  m = js_new_module_def(ctx, name);
  m->init_func = func;
  return m;
}

int LEPUS_AddModuleExport(LEPUSContext *ctx, LEPUSModuleDef *m,
                          const char *export_name) {
  JSExportEntry *me;
  JSAtom name;
  name = LEPUS_NewAtom(ctx, export_name);
  if (name == JS_ATOM_NULL) return -1;
  HandleScope func_scope(ctx->rt);
  func_scope.PushLEPUSAtom(name);
  me =
      add_export_entry2(ctx, NULL, m, JS_ATOM_NULL, name, JS_EXPORT_TYPE_LOCAL);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, name);
  if (!me)
    return -1;
  else
    return 0;
}

int LEPUS_SetModuleExport(LEPUSContext *ctx, LEPUSModuleDef *m,
                          const char *export_name, LEPUSValue val) {
  JSExportEntry *me;
  JSAtom name = LEPUS_NewAtom(ctx, export_name);
  HandleScope func_scope(ctx->rt);
  if (name == JS_ATOM_NULL) goto fail;
  func_scope.PushLEPUSAtom(name);
  me = find_export_entry(ctx, m, name);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, name);
  if (!me) goto fail;
#ifdef ENABLE_COMPATIBLE_MM
  if (ctx->gc_enable) {
    set_value_gc(ctx, me->u.local.var_ref->pvalue, val);
  } else
#endif
    set_value(ctx, me->u.local.var_ref->pvalue, val);
  return 0;
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, val);
  return -1;
}

void LEPUS_SetModuleLoaderFunc(LEPUSRuntime *rt,
                               LEPUSModuleNormalizeFunc *module_normalize,
                               LEPUSModuleLoaderFunc *module_loader,
                               void *opaque) {
  rt->module_normalize_func = module_normalize;
  rt->module_loader_func = module_loader;
  rt->module_loader_opaque = opaque;
}

/* default module filename normalizer */
QJS_STATIC char *js_default_module_normalize_name(LEPUSContext *ctx,
                                                  const char *base_name,
                                                  const char *name) {
  char *filename, *p;
  const char *r;
  int len;

  if (name[0] != '.') {
    /* if no initial dot, the module name is not modified */
    return lepus_strdup(ctx, name);
  }

  p = const_cast<char *>(strrchr(base_name, '/'));
  if (p)
    len = p - base_name;
  else
    len = 0;

  filename = static_cast<char *>(
      lepus_malloc(ctx, len + strlen(name) + 1 + 1, ALLOC_TAG_WITHOUT_PTR));
  if (!filename) return NULL;
  memcpy(filename, base_name, len);
  filename[len] = '\0';

  /* we only normalize the leading '..' or '.' */
  r = name;
  for (;;) {
    if (r[0] == '.' && r[1] == '/') {
      r += 2;
    } else if (r[0] == '.' && r[1] == '.' && r[2] == '/') {
      if (filename[0] == '\0') break;
      p = strrchr(filename, '/');
      if (!p) p = filename;
      *p = '\0';
      r += 3;
    } else {
      break;
    }
  }
  if (filename[0] != '\0') strcat(filename, "/");
  strcat(filename, r);
  //    printf("normalize: %s %s -> %s\n", base_name, name, filename);
  return filename;
}

/* return NULL in case of exception (e.g. module could not be loaded) */
QJS_STATIC LEPUSModuleDef *js_host_resolve_imported_module(
    LEPUSContext *ctx, JSAtom base_module_name, JSAtom module_name1) {
  LEPUSRuntime *rt = ctx->rt;
  struct list_head *el;
  LEPUSModuleDef *m;
  char *cname;
  const char *base_cname, *cname1;
  JSAtom module_name;

  base_cname = LEPUS_AtomToCString(ctx, base_module_name);
  if (!base_cname) return NULL;
  HandleScope func_scope(ctx, &base_cname, HANDLE_TYPE_CSTRING);
  cname1 = LEPUS_AtomToCString(ctx, module_name1);
  if (!cname1) {
    if (!ctx->gc_enable) LEPUS_FreeCString(ctx, base_cname);
    return NULL;
  }
  func_scope.PushHandle(&cname1, HANDLE_TYPE_CSTRING);

  if (!rt->module_normalize_func) {
    cname = js_default_module_normalize_name(ctx, base_cname, cname1);
  } else {
    cname = rt->module_normalize_func(ctx, base_cname, cname1,
                                      rt->module_loader_opaque);
  }
  if (!ctx->gc_enable) {
    LEPUS_FreeCString(ctx, base_cname);
    LEPUS_FreeCString(ctx, cname1);
  }
  if (!cname) return NULL;
  func_scope.PushHandle(cname, HANDLE_TYPE_DIR_HEAP_OBJ);

  module_name = LEPUS_NewAtom(ctx, cname);
  if (module_name == JS_ATOM_NULL) {
    if (!ctx->gc_enable) lepus_free(ctx, cname);
    return NULL;
  }
  func_scope.PushLEPUSAtom(module_name);

  /* first look at the loaded modules */
  list_for_each(el, &ctx->loaded_modules) {
    m = list_entry(el, LEPUSModuleDef, link);
    if (m->module_name == module_name) {
      if (!ctx->gc_enable) {
        lepus_free(ctx, cname);
        LEPUS_FreeAtom(ctx, module_name);
      }
      return m;
    }
  }

  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, module_name);

  /* load the module */
  if (!rt->module_loader_func) {
    /* XXX: use a syntax error ? */
    LEPUS_ThrowReferenceError(ctx, "could not load module '%s'", cname);
    if (!ctx->gc_enable) lepus_free(ctx, cname);
    return NULL;
  }

  m = rt->module_loader_func(ctx, cname, rt->module_loader_opaque);
  if (!ctx->gc_enable) lepus_free(ctx, cname);
  return m;
}

typedef struct JSResolveEntry {
  LEPUSModuleDef *module;
  JSAtom name;
} JSResolveEntry;

typedef struct JSResolveState {
  JSResolveEntry *array;
  int size;
  int count;
} JSResolveState;

QJS_STATIC int find_resolve_entry(JSResolveState *s, LEPUSModuleDef *m,
                                  JSAtom name) {
  int i;
  for (i = 0; i < s->count; i++) {
    JSResolveEntry *re = &s->array[i];
    if (re->module == m && re->name == name) return i;
  }
  return -1;
}

QJS_STATIC int add_resolve_entry(LEPUSContext *ctx, JSResolveState *s,
                                 LEPUSModuleDef *m, JSAtom name) {
  JSResolveEntry *re;

  if (js_resize_array(ctx, (void **)&s->array, sizeof(JSResolveEntry), &s->size,
                      &s->count, s->count + 1))
    return -1;
  re = &s->array[s->count - 1];
  re->module = m;
  re->name = ctx->gc_enable ? name : LEPUS_DupAtom(ctx, name);
  return 0;
}

typedef enum JSResolveResultEnum {
  JS_RESOLVE_RES_EXCEPTION = -1, /* memory alloc error */
  JS_RESOLVE_RES_FOUND = 0,
  JS_RESOLVE_RES_NOT_FOUND,
  JS_RESOLVE_RES_CIRCULAR,
  JS_RESOLVE_RES_AMBIGUOUS,
} JSResolveResultEnum;

QJS_STATIC JSResolveResultEnum js_resolve_export1(
    LEPUSContext *ctx, LEPUSModuleDef **pmodule, JSExportEntry **pme,
    LEPUSModuleDef *m, JSAtom export_name, JSResolveState *s) {
  JSExportEntry *me;

  *pmodule = NULL;
  *pme = NULL;
  if (find_resolve_entry(s, m, export_name) >= 0)
    return JS_RESOLVE_RES_CIRCULAR;
  if (add_resolve_entry(ctx, s, m, export_name) < 0)
    return JS_RESOLVE_RES_EXCEPTION;
  me = find_export_entry(ctx, m, export_name);
  if (me) {
    if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
      /* local export */
      *pmodule = m;
      *pme = me;
      return JS_RESOLVE_RES_FOUND;
    } else {
      /* indirect export */
      LEPUSModuleDef *m1;
      m1 = m->req_module_entries[me->u.req_module_idx].module;
      if (me->local_name == JS_ATOM__star_) {
        /* export ns from */
        *pmodule = m;
        *pme = me;
        return JS_RESOLVE_RES_FOUND;
      } else {
        return js_resolve_export1(ctx, pmodule, pme, m1, me->local_name, s);
      }
    }
  } else {
    if (export_name != JS_ATOM_default) {
      /* not found in direct or indirect exports: try star exports */
      int i;

      for (i = 0; i < m->star_export_entries_count; i++) {
        JSStarExportEntry *se = &m->star_export_entries[i];
        LEPUSModuleDef *m1, *res_m;
        JSExportEntry *res_me;
        JSResolveResultEnum ret;

        m1 = m->req_module_entries[se->req_module_idx].module;
        ret = js_resolve_export1(ctx, &res_m, &res_me, m1, export_name, s);
        if (ret == JS_RESOLVE_RES_AMBIGUOUS ||
            ret == JS_RESOLVE_RES_EXCEPTION) {
          return ret;
        } else if (ret == JS_RESOLVE_RES_FOUND) {
          if (*pme != NULL) {
            if (*pmodule != res_m || res_me->local_name != (*pme)->local_name) {
              *pmodule = NULL;
              *pme = NULL;
              return JS_RESOLVE_RES_AMBIGUOUS;
            }
          } else {
            *pmodule = res_m;
            *pme = res_me;
          }
        }
      }
      if (*pme != NULL) return JS_RESOLVE_RES_FOUND;
    }
    return JS_RESOLVE_RES_NOT_FOUND;
  }
}

/* If the return value is JS_RESOLVE_RES_FOUND, return the module
  (*pmodule) and the corresponding local export entry
  (*pme). Otherwise return (NULL, NULL) */
QJS_STATIC JSResolveResultEnum js_resolve_export(LEPUSContext *ctx,
                                                 LEPUSModuleDef **pmodule,
                                                 JSExportEntry **pme,
                                                 LEPUSModuleDef *m,
                                                 JSAtom export_name) {
  JSResolveState ss, *s = &ss;
  int i;
  JSResolveResultEnum ret;

  s->array = NULL;
  HandleScope func_scope(ctx, &s->array, HANDLE_TYPE_HEAP_OBJ);
  s->size = 0;
  s->count = 0;

  ret = js_resolve_export1(ctx, pmodule, pme, m, export_name, s);

  if (!ctx->gc_enable) {
    for (i = 0; i < s->count; i++) LEPUS_FreeAtom(ctx, s->array[i].name);
    lepus_free(ctx, s->array);
  }
  return ret;
}

QJS_STATIC void js_resolve_export_throw_error(LEPUSContext *ctx,
                                              JSResolveResultEnum res,
                                              LEPUSModuleDef *m,
                                              JSAtom export_name) {
  char buf1[ATOM_GET_STR_BUF_SIZE];
  char buf2[ATOM_GET_STR_BUF_SIZE];
  switch (res) {
    case JS_RESOLVE_RES_EXCEPTION:
      break;
    default:
    case JS_RESOLVE_RES_NOT_FOUND:
      LEPUS_ThrowSyntaxError(
          ctx, "export '%s' in module '%s' is ambiguous",
          JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
    case JS_RESOLVE_RES_CIRCULAR:
      LEPUS_ThrowSyntaxError(
          ctx, "Could not find export '%s' in module '%s'",
          JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
    case JS_RESOLVE_RES_AMBIGUOUS:
      LEPUS_ThrowSyntaxError(
          ctx, "circular reference when looking for export '%s' in module '%s'",
          JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
  }
}

typedef enum {
  EXPORTED_NAME_AMBIGUOUS,
  EXPORTED_NAME_NORMAL,
  EXPORTED_NAME_NS,
} ExportedNameEntryEnum;

typedef struct ExportedNameEntry {
  JSAtom export_name;
  ExportedNameEntryEnum export_type;
  union {
    JSExportEntry *me;      /* using when the list is built */
    JSVarRef *var_ref;      /* EXPORTED_NAME_NORMAL */
    LEPUSModuleDef *module; /* for EXPORTED_NAME_NS */
  } u;
} ExportedNameEntry;

typedef struct GetExportNamesState {
  LEPUSModuleDef **modules;
  int modules_size;
  int modules_count;

  ExportedNameEntry *exported_names;
  int exported_names_size;
  int exported_names_count;
} GetExportNamesState;

QJS_STATIC int find_exported_name(GetExportNamesState *s, JSAtom name) {
  int i;
  for (i = 0; i < s->exported_names_count; i++) {
    if (s->exported_names[i].export_name == name) return i;
  }
  return -1;
}

QJS_STATIC __exception int get_exported_names(LEPUSContext *ctx,
                                              GetExportNamesState *s,
                                              LEPUSModuleDef *m,
                                              BOOL from_star) {
  ExportedNameEntry *en;
  int i, j;

  /* check circular reference */
  for (i = 0; i < s->modules_count; i++) {
    if (s->modules[i] == m) return 0;
  }
  if (js_resize_array(ctx, (void **)&s->modules, sizeof(s->modules[0]),
                      &s->modules_size, &s->modules_count,
                      s->modules_count + 1))
    return -1;
  s->modules[s->modules_count - 1] = m;

  for (i = 0; i < m->export_entries_count; i++) {
    JSExportEntry *me = &m->export_entries[i];
    if (from_star && me->export_name == JS_ATOM_default) continue;
    j = find_exported_name(s, me->export_name);
    if (j < 0) {
      if (js_resize_array(ctx, (void **)&s->exported_names,
                          sizeof(s->exported_names[0]), &s->exported_names_size,
                          &s->exported_names_count,
                          s->exported_names_count + 1))
        return -1;
      en = &s->exported_names[s->exported_names_count - 1];
      en->export_name = me->export_name;
      /* avoid a second lookup for simple module exports */
      if (from_star || me->export_type != JS_EXPORT_TYPE_LOCAL)
        en->u.me = NULL;
      else
        en->u.me = me;
    } else {
      en = &s->exported_names[j];
      en->u.me = NULL;
    }
  }
  for (i = 0; i < m->star_export_entries_count; i++) {
    JSStarExportEntry *se = &m->star_export_entries[i];
    LEPUSModuleDef *m1;
    m1 = m->req_module_entries[se->req_module_idx].module;
    if (get_exported_names(ctx, s, m1, TRUE)) return -1;
  }
  return 0;
}

/* Unfortunately, the spec gives a different behavior from GetOwnProperty ! */
QJS_STATIC int js_module_ns_has(LEPUSContext *ctx, LEPUSValueConst obj,
                                JSAtom atom) {
  return (find_own_property1(LEPUS_VALUE_GET_OBJ(obj), atom) != NULL);
}

QJS_STATIC int exported_names_cmp(const void *p1, const void *p2,
                                  void *opaque) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  const ExportedNameEntry *me1 = static_cast<const ExportedNameEntry *>(p1);
  const ExportedNameEntry *me2 = static_cast<const ExportedNameEntry *>(p2);
  LEPUSValue str1, str2;
  int ret;

  /* XXX: should avoid allocation memory in atom comparison */
  str1 = LEPUS_AtomToString(ctx, me1->export_name);
  str2 = LEPUS_AtomToString(ctx, me2->export_name);
  HandleScope func_scope(ctx, &str1, HANDLE_TYPE_LEPUS_VALUE);
  func_scope.PushHandle(&str2, HANDLE_TYPE_LEPUS_VALUE);
  if (LEPUS_IsException(str1) || LEPUS_IsException(str2)) {
    /* XXX: raise an error ? */
    ret = 0;
  } else {
    ret = js_string_compare(ctx, LEPUS_VALUE_GET_STRING(str1),
                            LEPUS_VALUE_GET_STRING(str2));
  }
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, str1);
    LEPUS_FreeValue(ctx, str2);
  }
  return ret;
}

QJS_STATIC LEPUSValue js_get_module_ns(LEPUSContext *ctx, LEPUSModuleDef *m);

QJS_STATIC LEPUSValue js_module_ns_autoinit(LEPUSContext *ctx, LEPUSObject *p,
                                            JSAtom atom, void *opaque) {
  LEPUSModuleDef *m = static_cast<LEPUSModuleDef *>(opaque);
  return js_get_module_ns(ctx, m);
}

QJS_STATIC LEPUSValue js_build_module_ns(LEPUSContext *ctx, LEPUSModuleDef *m) {
  LEPUSValue obj;
  LEPUSObject *p;
  GetExportNamesState s_s, *s = &s_s;
  int i, ret;
  JSProperty *pr;

  obj = LEPUS_NewObjectClass(ctx, JS_CLASS_MODULE_NS);
  if (LEPUS_IsException(obj)) return obj;
  HandleScope func_scope(ctx, &obj, HANDLE_TYPE_LEPUS_VALUE);
  p = LEPUS_VALUE_GET_OBJ(obj);

  memset(s, 0, sizeof(*s));
  func_scope.PushHandle(&s->modules, HANDLE_TYPE_HEAP_OBJ);
  func_scope.PushHandle(&s->exported_names, HANDLE_TYPE_HEAP_OBJ);
  ret = get_exported_names(ctx, s, m, FALSE);
  if (!ctx->gc_enable) lepus_free(ctx, s->modules);
  if (ret) goto fail;

  /* Resolve the exported names. The ambiguous exports are removed */
  for (i = 0; i < s->exported_names_count; i++) {
    ExportedNameEntry *en = &s->exported_names[i];
    JSResolveResultEnum res;
    JSExportEntry *res_me;
    LEPUSModuleDef *res_m;

    if (en->u.me) {
      res_me = en->u.me; /* fast case: no resolution needed */
      res_m = m;
      res = JS_RESOLVE_RES_FOUND;
    } else {
      res = js_resolve_export(ctx, &res_m, &res_me, m, en->export_name);
    }
    if (res != JS_RESOLVE_RES_FOUND) {
      if (res != JS_RESOLVE_RES_AMBIGUOUS) {
        js_resolve_export_throw_error(ctx, res, m, en->export_name);
        goto fail;
      }
      en->export_type = EXPORTED_NAME_AMBIGUOUS;
    } else {
      if (res_me->local_name == JS_ATOM__star_) {
        en->export_type = EXPORTED_NAME_NS;
        en->u.module =
            res_m->req_module_entries[res_me->u.req_module_idx].module;
      } else {
        en->export_type = EXPORTED_NAME_NORMAL;
        if (res_me->u.local.var_ref) {
          en->u.var_ref = res_me->u.local.var_ref;
        } else {
          LEPUSObject *p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
          p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
          en->u.var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
        }
      }
    }
  }

  /* sort the exported names */
  rqsort(s->exported_names, s->exported_names_count,
         sizeof(s->exported_names[0]), exported_names_cmp, ctx);

  for (i = 0; i < s->exported_names_count; i++) {
    ExportedNameEntry *en = &s->exported_names[i];
    switch (en->export_type) {
      case EXPORTED_NAME_NORMAL: {
        JSVarRef *var_ref = en->u.var_ref;
#ifdef ENABLE_COMPATIBLE_MM
        if (ctx->gc_enable)
          pr = add_property_gc(
              ctx, p, en->export_name,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE | LEPUS_PROP_VARREF);
        else
#endif
          pr = add_property(
              ctx, p, en->export_name,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE | LEPUS_PROP_VARREF);
        if (!pr) goto fail;
        var_ref->header.ref_count++;
        pr->u.var_ref = var_ref;
      } break;
      case EXPORTED_NAME_NS:
        /* the exported namespace must be created on demand */
        int result;
#ifdef ENABLE_COMPATIBLE_MM
        if (ctx->gc_enable)
          result = JS_DefineAutoInitProperty_GC(
              ctx, obj, en->export_name, js_module_ns_autoinit, en->u.module,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE);
        else
#endif
          result = JS_DefineAutoInitProperty(
              ctx, obj, en->export_name, js_module_ns_autoinit, en->u.module,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE);
        if (result < 0) goto fail;
        break;
      default:
        break;
    }
  }

  if (!ctx->gc_enable) lepus_free(ctx, s->exported_names);

  LEPUS_DefinePropertyValue(ctx, obj, JS_ATOM_Symbol_toStringTag,
                            LEPUS_AtomToString(ctx, JS_ATOM_Module), 0);

  p->extensible = FALSE;
  return obj;
fail:
  if (!ctx->gc_enable) {
    lepus_free(ctx, s->exported_names);
    LEPUS_FreeValue(ctx, obj);
  }
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_get_module_ns(LEPUSContext *ctx, LEPUSModuleDef *m) {
  if (LEPUS_IsUndefined(m->module_ns)) {
    LEPUSValue val;
    val = js_build_module_ns(ctx, m);
    if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
    m->module_ns = val;
  }
  if (!ctx->gc_enable) LEPUS_DupValue(ctx, m->module_ns);
  return m->module_ns;
}

/* Load all the required modules for module 'm' */
int js_resolve_module(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;
  LEPUSModuleDef *m1;

  if (m->resolved) return 0;
#ifdef DUMP_MODULE_RESOLVE
  {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    printf("resolving module '%s':\n",
           JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
  }
#endif
  m->resolved = TRUE;
  /* resolve each requested module */
  for (i = 0; i < m->req_module_entries_count; i++) {
    JSReqModuleEntry *rme = &m->req_module_entries[i];
    m1 = js_host_resolve_imported_module(ctx, m->module_name, rme->module_name);
    if (!m1) return -1;
    rme->module = m1;
    /* already done in js_host_resolve_imported_module() except if
       the module was loaded with LEPUS_EvalBinary() */
    if (js_resolve_module(ctx, m1) < 0) return -1;
  }
  return 0;
}

JSVarRef *js_create_module_var(LEPUSContext *ctx, BOOL is_lexical) {
  JSVarRef *var_ref;
  var_ref = static_cast<JSVarRef *>(
      lepus_malloc(ctx, sizeof(JSVarRef), ALLOC_TAG_JSVarRef));
  if (!var_ref) return NULL;
  var_ref->header.ref_count = 1;
  var_ref->gc_header.mark = 0;
  var_ref->is_detached = 1;
  if (is_lexical)
    var_ref->value = LEPUS_UNINITIALIZED;
  else
    var_ref->value = LEPUS_UNDEFINED;
  var_ref->pvalue = &var_ref->value;
  return var_ref;
}

/* Create the <eval> function associated with the module */
int js_create_module_function(LEPUSContext *ctx, LEPUSModuleDef *m) {
  LEPUSFunctionBytecode *b;
  int i;
  JSVarRef **var_refs;
  LEPUSValue func_obj, bfunc;
  LEPUSObject *p;

  bfunc = m->func_obj;
  HandleScope func_scope(ctx, &bfunc, HANDLE_TYPE_LEPUS_VALUE);
  func_obj = LEPUS_NewObjectProtoClass(ctx, ctx->function_proto,
                                       JS_CLASS_BYTECODE_FUNCTION);

  if (LEPUS_IsException(func_obj)) return -1;
  func_scope.PushHandle(&func_obj, HANDLE_TYPE_LEPUS_VALUE);
  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.func.function_bytecode = b;
  b->header.ref_count++;
  p->u.func.home_object = NULL;
  p->u.func.var_refs = NULL;
  if (b->closure_var_count) {
    var_refs = static_cast<JSVarRef **>(
        lepus_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count,
                      ALLOC_TAG_WITHOUT_PTR));
    if (!var_refs) goto fail;
    p->u.func.var_refs = var_refs;

    /* create the global variables. The other variables are
       imported from other modules */
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      JSVarRef *var_ref;
      if (cv->is_local) {
        var_ref = js_create_module_var(ctx, cv->is_lexical);
        if (!var_ref) goto fail;
#ifdef DUMP_MODULE_RESOLVE
        printf("local %d: %p\n", i, var_ref);
#endif
        var_refs[i] = var_ref;
      }
    }
  }
  m->func_obj = func_obj;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, bfunc);
  return 0;
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, func_obj);
  return -1;
}

/* Prepare a module to be executed by resolving all the imported
   variables. */
int js_link_module(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;
  JSImportEntry *mi;
  LEPUSModuleDef *m1;
  JSVarRef **var_refs, *var_ref;
  LEPUSObject *p;
  BOOL is_c_module;
  LEPUSValue ret_val;

  if (m->instantiated) return 0;
  m->instantiated = TRUE;

  is_c_module = (m->init_func != NULL);

  if (is_c_module) {
    /* initialize the exported variables */
    for (i = 0; i < m->export_entries_count; i++) {
      JSExportEntry *me = &m->export_entries[i];
      if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
        var_ref = js_create_module_var(ctx, FALSE);
        if (!var_ref) goto fail;
        me->u.local.var_ref = var_ref;
      }
    }
  } else {
    if (js_create_module_function(ctx, m) < 0) goto fail;
  }

  for (i = 0; i < m->req_module_entries_count; i++) {
    JSReqModuleEntry *rme = &m->req_module_entries[i];
    if (js_link_module(ctx, rme->module) < 0) goto fail;
  }

#ifdef DUMP_MODULE_RESOLVE
  {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    printf("instantiating module '%s':\n",
           JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
  }
#endif
  /* check the indirect exports */
  for (i = 0; i < m->export_entries_count; i++) {
    JSExportEntry *me = &m->export_entries[i];
    if (me->export_type == JS_EXPORT_TYPE_INDIRECT &&
        me->local_name != JS_ATOM__star_) {
      JSResolveResultEnum ret;
      JSExportEntry *res_me;
      LEPUSModuleDef *res_m, *m1;
      m1 = m->req_module_entries[me->u.req_module_idx].module;
      ret = js_resolve_export(ctx, &res_m, &res_me, m1, me->local_name);
      if (ret != JS_RESOLVE_RES_FOUND) {
        js_resolve_export_throw_error(ctx, ret, m, me->export_name);
        goto fail;
      }
    }
  }

#ifdef DUMP_MODULE_RESOLVE
  {
    printf("exported bindings:\n");
    for (i = 0; i < m->export_entries_count; i++) {
      JSExportEntry *me = &m->export_entries[i];
      printf(" name=");
      print_atom(ctx, me->export_name);
      printf(" local=");
      print_atom(ctx, me->local_name);
      printf(" type=%d idx=%d\n", me->export_type, me->u.local.var_idx);
    }
  }
#endif

  if (!is_c_module) {
    p = LEPUS_VALUE_GET_OBJ(m->func_obj);
    var_refs = p->u.func.var_refs;

    for (i = 0; i < m->import_entries_count; i++) {
      mi = &m->import_entries[i];
#ifdef DUMP_MODULE_RESOLVE
      printf("import var_idx=%d name=", mi->var_idx);
      print_atom(ctx, mi->import_name);
      printf(": ");
#endif
      m1 = m->req_module_entries[mi->req_module_idx].module;
      if (mi->import_name == JS_ATOM__star_) {
        LEPUSValue val;
        /* name space import */
        val = js_get_module_ns(ctx, m1);
        if (LEPUS_IsException(val)) goto fail;
#ifdef ENABLE_COMPATIBLE_MM
        if (ctx->gc_enable)
          set_value_gc(ctx, &var_refs[mi->var_idx]->value, val);
        else
#endif
          set_value(ctx, &var_refs[mi->var_idx]->value, val);
#ifdef DUMP_MODULE_RESOLVE
        printf("namespace\n");
#endif
      } else {
        JSResolveResultEnum ret;
        JSExportEntry *res_me;
        LEPUSModuleDef *res_m;
        LEPUSObject *p1;

        ret = js_resolve_export(ctx, &res_m, &res_me, m1, mi->import_name);
        if (ret != JS_RESOLVE_RES_FOUND) {
          js_resolve_export_throw_error(ctx, ret, m1, mi->import_name);
          goto fail;
        }
        if (res_me->local_name == JS_ATOM__star_) {
          HandleScope block_scope(ctx->rt);
          LEPUSValue val;
          LEPUSModuleDef *m2;
          /* name space import from */
          m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;
          val = js_get_module_ns(ctx, m2);
          if (LEPUS_IsException(val)) goto fail;
          block_scope.PushHandle(&val, HANDLE_TYPE_LEPUS_VALUE);
          var_ref = js_create_module_var(ctx, TRUE);
          if (!var_ref) {
            if (!ctx->gc_enable) LEPUS_FreeValue(ctx, val);
            goto fail;
          }
#ifdef ENABLE_COMPATIBLE_MM
          if (ctx->gc_enable)
            set_value_gc(ctx, &var_ref->value, val);
          else
#endif
            set_value(ctx, &var_ref->value, val);
          var_refs[mi->var_idx] = var_ref;
#ifdef DUMP_MODULE_RESOLVE
          printf("namespace from\n");
#endif
        } else {
          var_ref = res_me->u.local.var_ref;
          if (!var_ref) {
            p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
            var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
          }
          var_ref->header.ref_count++;
          var_refs[mi->var_idx] = var_ref;
#ifdef DUMP_MODULE_RESOLVE
          printf("local export (var_ref=%p)\n", var_ref);
#endif
        }
      }
    }

    /* keep the exported variables in the module export entries (they
       are used when the eval function is deleted and cannot be
       initialized before in case imports are exported) */
    for (i = 0; i < m->export_entries_count; i++) {
      JSExportEntry *me = &m->export_entries[i];
      if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
        var_ref = var_refs[me->u.local.var_idx];
        var_ref->header.ref_count++;
        me->u.local.var_ref = var_ref;
      }
    }
  }

#ifdef DUMP_MODULE_RESOLVE
  printf("done instantiate\n");
#endif
  return 0;
fail:
  return -1;
}

LEPUSValue js_dynamic_import(LEPUSContext *ctx, LEPUSValueConst specifier) {
  HandleScope func_scope(ctx);
  LEPUSStackFrame *sf;
  LEPUSFunctionBytecode *b;
  LEPUSObject *p;
  LEPUSModuleDef *m;
  JSAtom basename, filename;
  LEPUSValue promise, resolving_funcs[2];
  func_scope.PushLEPUSValueArrayHandle(resolving_funcs, 2);
  LEPUSValue specifierString, ret = LEPUS_UNDEFINED, func_obj, err, ns;
  func_scope.PushHandle(&ret, HANDLE_TYPE_LEPUS_VALUE);

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return promise;
  func_scope.PushHandle(&promise, HANDLE_TYPE_LEPUS_VALUE);

  /* XXX: currently we just use the filename of the englobing
     function. It does not work for eval(). Need to add a
     ScriptOrModule info in LEPUSFunctionBytecode */
  sf = ctx->rt->current_stack_frame;
  assert(sf != NULL);
  assert(LEPUS_VALUE_IS_OBJECT(sf->cur_func));
  p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
  assert(lepus_class_has_bytecode(p->class_id));
  b = p->u.func.function_bytecode;
  if (!b->has_debug) {
    LEPUS_ThrowTypeError(ctx, "no function filename for import()");
    goto exception;
  }
  basename = b->debug.filename;

  specifierString = LEPUS_ToString(ctx, specifier);
  if (LEPUS_IsException(specifierString)) goto exception;
  func_scope.PushHandle(&specifierString, HANDLE_TYPE_LEPUS_VALUE);
  filename = js_value_to_atom(ctx, specifierString);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, specifierString);
  if (filename == JS_ATOM_NULL) goto exception;
  func_scope.PushLEPUSAtom(filename);

  m = js_host_resolve_imported_module(ctx, basename, filename);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, filename);
  if (!m) {
    goto exception;
  }

  if (js_resolve_module(ctx, m) < 0) {
    if (!ctx->gc_enable) js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
    goto exception;
  }

  /* Evaluate the module code */
  func_obj = ctx->gc_enable
                 ? LEPUS_MKPTR(LEPUS_TAG_MODULE, m)
                 : LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  func_scope.PushHandle(&func_obj, HANDLE_TYPE_LEPUS_VALUE);
  ret = LEPUS_EvalFunction(ctx, func_obj, ctx->global_obj);
  if (LEPUS_IsException(ret)) goto exception;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, ret);

  /* return the module namespace */
  ns = js_get_module_ns(ctx, m);
  if (LEPUS_IsException(ret)) goto exception;
  func_scope.PushHandle(&ns, HANDLE_TYPE_LEPUS_VALUE);

  ret = LEPUS_Call(ctx, resolving_funcs[0], LEPUS_UNDEFINED, 1,
                   (LEPUSValueConst *)&ns);
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
    LEPUS_FreeValue(ctx, ns);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
  }
  return promise;

exception:
  err = LEPUS_GetException(ctx);
  func_scope.PushHandle(&err, HANDLE_TYPE_LEPUS_VALUE);
  ret = LEPUS_Call(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                   (LEPUSValueConst *)&err);
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
    LEPUS_FreeValue(ctx, err);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
  }
  return promise;
}

/* Run the <eval> function of the module and of all its requested
   modules. */
LEPUSValue js_evaluate_module(LEPUSContext *ctx, LEPUSModuleDef *m) {
  LEPUSModuleDef *m1;
  int i;
  LEPUSValue ret_val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &ret_val, HANDLE_TYPE_LEPUS_VALUE);

  if (m->eval_mark) return LEPUS_UNDEFINED; /* avoid cycles */

  if (m->evaluated) {
    /* if the module was already evaluated, rethrow the exception
       it raised */
    if (m->eval_has_exception) {
      if (!ctx->gc_enable) LEPUS_DupValue(ctx, m->eval_exception);
      return LEPUS_Throw(ctx, m->eval_exception);
    } else {
      return LEPUS_UNDEFINED;
    }
  }

  m->eval_mark = TRUE;

  for (i = 0; i < m->req_module_entries_count; i++) {
    JSReqModuleEntry *rme = &m->req_module_entries[i];
    m1 = rme->module;
    if (!m1->eval_mark) {
      ret_val = js_evaluate_module(ctx, m1);
      if (LEPUS_IsException(ret_val)) {
        m->eval_mark = FALSE;
        return ret_val;
      }
      if (!ctx->gc_enable) LEPUS_FreeValue(ctx, ret_val);
    }
  }

  if (m->init_func) {
    /* C module init */
    if (m->init_func(ctx, m) < 0)
      ret_val = LEPUS_EXCEPTION;
    else
      ret_val = LEPUS_UNDEFINED;
  } else {
    if (!ctx->gc_enable)
      ret_val = JS_CallFree(ctx, m->func_obj, LEPUS_UNDEFINED, 0, NULL);
#ifdef ENABLE_COMPATIBLE_MM
    else
      ret_val = JS_CallFree_GC(ctx, m->func_obj, LEPUS_UNDEFINED, 0, NULL);
#endif
    m->func_obj = LEPUS_UNDEFINED;
  }
  if (LEPUS_IsException(ret_val)) {
    /* save the thrown exception value */
    m->eval_has_exception = TRUE;
    if (!ctx->gc_enable) LEPUS_DupValue(ctx, ctx->rt->current_exception);
    m->eval_exception = ctx->rt->current_exception;
  }
  m->eval_mark = FALSE;
  m->evaluated = TRUE;
  return ret_val;
}

__exception JSAtom js_parse_from_clause(JSParseState *s) {
  JSAtom module_name;
  if (!token_is_pseudo_keyword(s, JS_ATOM_from)) {
    js_parse_error(s, "from clause expected");
    return JS_ATOM_NULL;
  }
  if (next_token(s)) return JS_ATOM_NULL;
  if (s->token.val != TOK_STRING) {
    js_parse_error(s, "string expected");
    return JS_ATOM_NULL;
  }
  module_name = js_value_to_atom(s->ctx, s->token.u.str.str);
  if (module_name == JS_ATOM_NULL) return JS_ATOM_NULL;
  HandleScope func_scope(s->ctx->rt);
  func_scope.PushLEPUSAtom(module_name);
  if (next_token(s)) {
    if (!s->ctx->gc_enable) LEPUS_FreeAtom(s->ctx, module_name);
    return JS_ATOM_NULL;
  }
  return module_name;
}

__exception int js_parse_export(JSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSModuleDef *m = s->cur_func->module;
  JSAtom local_name, export_name;
  int first_export, idx, i, tok;
  JSAtom module_name;
  JSExportEntry *me;

  if (next_token(s)) return -1;

  tok = s->token.val;
  if (tok == TOK_CLASS) {
    return js_parse_class(s, FALSE, JS_PARSE_EXPORT_NAMED);
  } else if (tok == TOK_FUNCTION ||
             (token_is_pseudo_keyword(s, JS_ATOM_async) &&
              peek_token(s, TRUE) == TOK_FUNCTION)) {
    return js_parse_function_decl2(
        s, JS_PARSE_FUNC_STATEMENT, JS_FUNC_NORMAL, JS_ATOM_NULL, s->token.ptr,
        s->token.line_num, JS_PARSE_EXPORT_NAMED, NULL);
  }

  if (next_token(s)) return -1;

  switch (tok) {
    case '{':
      first_export = m->export_entries_count;
      while (s->token.val != '}') {
        if (!token_is_ident(s->token.val)) {
          js_parse_error(s, "identifier expected");
          return -1;
        }
        local_name = ctx->gc_enable ? s->token.u.ident.atom
                                    : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        export_name = JS_ATOM_NULL;
        if (next_token(s)) goto fail;
        if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
          if (next_token(s)) goto fail;
          if (!token_is_ident(s->token.val)) {
            js_parse_error(s, "identifier expected");
            goto fail;
          }
          export_name = ctx->gc_enable
                            ? s->token.u.ident.atom
                            : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
          if (next_token(s)) {
          fail:
            if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, local_name);
          fail1:
            if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, export_name);
            return -1;
          }
        } else {
          export_name =
              ctx->gc_enable ? local_name : LEPUS_DupAtom(ctx, local_name);
        }
        me = add_export_entry(s, m, local_name, export_name,
                              JS_EXPORT_TYPE_LOCAL);
        if (!ctx->gc_enable) {
          LEPUS_FreeAtom(ctx, local_name);
          LEPUS_FreeAtom(ctx, export_name);
        }
        if (!me) return -1;
        if (s->token.val != ',') break;
        if (next_token(s)) return -1;
      }
      if (js_parse_expect(s, '}')) return -1;
      if (token_is_pseudo_keyword(s, JS_ATOM_from)) {
        module_name = js_parse_from_clause(s);
        if (module_name == JS_ATOM_NULL) return -1;
        idx = add_req_module_entry(ctx, m, module_name);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) return -1;
        for (i = first_export; i < m->export_entries_count; i++) {
          me = &m->export_entries[i];
          me->export_type = JS_EXPORT_TYPE_INDIRECT;
          me->u.req_module_idx = idx;
        }
      }
      break;
    case '*':
      if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
        /* export ns from */
        if (next_token(s)) return -1;
        if (!token_is_ident(s->token.val)) {
          js_parse_error(s, "identifier expected");
          return -1;
        }
        export_name = ctx->gc_enable
                          ? s->token.u.ident.atom
                          : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        if (next_token(s)) goto fail1;
        module_name = js_parse_from_clause(s);
        if (module_name == JS_ATOM_NULL) goto fail1;
        idx = add_req_module_entry(ctx, m, module_name);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) goto fail1;
        me = add_export_entry(s, m, JS_ATOM__star_, export_name,
                              JS_EXPORT_TYPE_INDIRECT);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, export_name);
        if (!me) return -1;
        me->u.req_module_idx = idx;
      } else {
        module_name = js_parse_from_clause(s);
        if (module_name == JS_ATOM_NULL) return -1;
        HandleScope func_scope(ctx->rt);
        func_scope.PushLEPUSAtom(module_name);
        idx = add_req_module_entry(ctx, m, module_name);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) return -1;
        if (add_star_export_entry(ctx, m, idx) < 0) return -1;
      }
      break;
    case TOK_DEFAULT:
      if (s->token.val == TOK_CLASS) {
        return js_parse_class(s, FALSE, JS_PARSE_EXPORT_DEFAULT);
      } else if (s->token.val == TOK_FUNCTION ||
                 (token_is_pseudo_keyword(s, JS_ATOM_async) &&
                  peek_token(s, TRUE) == TOK_FUNCTION)) {
        return js_parse_function_decl2(
            s, JS_PARSE_FUNC_STATEMENT, JS_FUNC_NORMAL, JS_ATOM_NULL,
            s->token.ptr, s->token.line_num, JS_PARSE_EXPORT_DEFAULT, NULL);
      } else {
        if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      }
      /* set the name of anonymous functions */
      set_object_name(s, JS_ATOM_default);

      /* store the value in the _default_ global variable and export
         it */
      local_name = JS_ATOM__default_;
      if (define_var(s, s->cur_func, local_name, JS_VAR_DEF_LET) < 0) return -1;
      emit_op(s, OP_scope_put_var_init);
      emit_atom(s, local_name);
      emit_u16(s, 0);

      if (!add_export_entry(s, m, local_name, JS_ATOM_default,
                            JS_EXPORT_TYPE_LOCAL))
        return -1;
      break;
    case TOK_VAR:
    case TOK_LET:
    case TOK_CONST:
      return js_parse_var(s, TRUE, tok, TRUE);
    default:
      return js_parse_error(s, "invalid export syntax");
  }
  return js_parse_expect_semi(s);
}

QJS_STATIC int add_import(JSParseState *s, LEPUSModuleDef *m, JSAtom local_name,
                          JSAtom import_name) {
  LEPUSContext *ctx = s->ctx;
  int i, var_idx;
  JSImportEntry *mi;
  BOOL is_local;

  if (local_name == JS_ATOM_arguments || local_name == JS_ATOM_eval)
    return js_parse_error(s, "invalid import binding");

  if (local_name != JS_ATOM_default) {
    for (i = 0; i < s->cur_func->closure_var_count; i++) {
      if (s->cur_func->closure_var[i].var_name == local_name)
        return js_parse_error(s, "duplicate import binding");
    }
  }

  is_local = (import_name == JS_ATOM__star_);
  var_idx = add_closure_var(ctx, s->cur_func, is_local, FALSE,
                            m->import_entries_count, local_name, TRUE, TRUE,
                            static_cast<JSVarKindEnum>(FALSE));
  if (var_idx < 0) return -1;
  if (js_resize_array(ctx, (void **)&m->import_entries, sizeof(JSImportEntry),
                      &m->import_entries_size, &m->import_entries_count,
                      m->import_entries_count + 1))
    return -1;
  mi = &m->import_entries[m->import_entries_count - 1];
  if (ctx->gc_enable)
    mi->import_name = import_name;
  else
    mi->import_name = LEPUS_DupAtom(ctx, import_name);
  mi->var_idx = var_idx;
  return 0;
}

__exception int js_parse_import(JSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSModuleDef *m = s->cur_func->module;
  JSAtom local_name, import_name, module_name;
  int first_import, i, idx;
  bool is_gc = ctx->gc_enable;

  if (next_token(s)) return -1;

  first_import = m->import_entries_count;
  if (s->token.val == TOK_STRING) {
    module_name = js_value_to_atom(ctx, s->token.u.str.str);
    if (module_name == JS_ATOM_NULL) return -1;
    HandleScope func_scope(ctx->rt);
    func_scope.PushLEPUSAtom(module_name);
    if (next_token(s)) {
      if (!is_gc) LEPUS_FreeAtom(ctx, module_name);
      return -1;
    }
  } else {
    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved) {
        return js_parse_error_reserved_identifier(s);
      }
      /* "default" import */
      local_name = is_gc ? s->token.u.ident.atom
                         : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      import_name = JS_ATOM_default;
      if (next_token(s)) goto fail;
      if (add_import(s, m, local_name, import_name)) goto fail;
      if (!is_gc) LEPUS_FreeAtom(ctx, local_name);

      if (s->token.val != ',') goto end_import_clause;
      if (next_token(s)) return -1;
    }

    if (s->token.val == '*') {
      /* name space import */
      if (next_token(s)) return -1;
      if (!token_is_pseudo_keyword(s, JS_ATOM_as))
        return js_parse_error(s, "expecting 'as'");
      if (next_token(s)) return -1;
      local_name = is_gc ? s->token.u.ident.atom
                         : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      import_name = JS_ATOM__star_;
      if (next_token(s)) goto fail;
      if (add_import(s, m, local_name, import_name)) goto fail;
      if (!is_gc) LEPUS_FreeAtom(ctx, local_name);
    } else if (s->token.val == '{') {
      if (next_token(s)) return -1;

      while (s->token.val != '}') {
        if (!token_is_ident(s->token.val)) {
          js_parse_error(s, "identifier expected");
          return -1;
        }
        import_name = is_gc ? s->token.u.ident.atom
                            : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        local_name = JS_ATOM_NULL;
        if (next_token(s)) goto fail;
        if (token_is_pseudo_keyword(s, JS_ATOM_as)) {
          if (next_token(s)) goto fail;
          if (!token_is_ident(s->token.val)) {
            js_parse_error(s, "identifier expected");
            goto fail;
          }
          local_name = is_gc ? s->token.u.ident.atom
                             : LEPUS_DupAtom(ctx, s->token.u.ident.atom);
          if (next_token(s)) {
          fail:
            if (!is_gc) {
              LEPUS_FreeAtom(ctx, local_name);
              LEPUS_FreeAtom(ctx, import_name);
            }
            return -1;
          }
        } else {
          local_name = is_gc ? import_name : LEPUS_DupAtom(ctx, import_name);
        }
        if (add_import(s, m, local_name, import_name)) goto fail;
        if (!is_gc) {
          LEPUS_FreeAtom(ctx, local_name);
          LEPUS_FreeAtom(ctx, import_name);
        }
        if (s->token.val != ',') break;
        if (next_token(s)) return -1;
      }
      if (js_parse_expect(s, '}')) return -1;
    }
  end_import_clause:
    module_name = js_parse_from_clause(s);
    if (module_name == JS_ATOM_NULL) return -1;
  }
  idx = add_req_module_entry(ctx, m, module_name);
  if (!is_gc) LEPUS_FreeAtom(ctx, module_name);
  if (idx < 0) return -1;
  for (i = first_import; i < m->import_entries_count; i++)
    m->import_entries[i].req_module_idx = idx;

  return js_parse_expect_semi(s);
}

QJS_STATIC __exception int js_parse_source_element(JSParseState *s) {
  JSFunctionDef *fd = s->cur_func;
  int tok;

  if (s->token.val == TOK_FUNCTION ||
      (token_is_pseudo_keyword(s, JS_ATOM_async) &&
       peek_token(s, TRUE) == TOK_FUNCTION)) {
    if (js_parse_function_decl(s, JS_PARSE_FUNC_STATEMENT, JS_FUNC_NORMAL,
                               JS_ATOM_NULL, s->token.ptr, s->token.line_num))
      return -1;
  } else if (s->token.val == TOK_EXPORT && fd->module) {
    if (js_parse_export(s)) return -1;
  } else if (s->token.val == TOK_IMPORT && fd->module &&
             ((tok = peek_token(s, FALSE)) != '(' && tok != '.')) {
    /* the peek_token is needed to avoid confusion with ImportCall
       (dynamic import) */
    if (js_parse_import(s)) return -1;
  } else {
    if (js_parse_statement_or_decl(s, DECL_MASK_ALL)) return -1;
  }
  return 0;
}

QJS_STATIC JSFunctionDef *js_new_function_def(LEPUSContext *ctx,
                                              JSFunctionDef *parent,
                                              BOOL is_eval, BOOL is_func_expr,
                                              const char *filename,
                                              int line_num) {
  JSFunctionDef *fd;

  fd = static_cast<JSFunctionDef *>(lepus_mallocz(ctx, sizeof(*fd)));
  if (!fd) return NULL;

  fd->ctx = ctx;
  init_list_head(&fd->child_list);

  /* insert in parent list */
  fd->parent = parent;
  fd->parent_cpool_idx = -1;
  if (parent) {
    list_add_tail(&fd->link, &parent->child_list);
    fd->js_mode = parent->js_mode;
    fd->parent_scope_level = parent->scope_level;
  }

  fd->is_eval = is_eval;
  fd->is_func_expr = is_func_expr;
  js_dbuf_init(ctx, &fd->byte_code);
  fd->last_opcode_pos = -1;
  fd->func_name = JS_ATOM_NULL;
  fd->var_object_idx = -1;
  fd->arg_var_object_idx = -1;
  fd->arguments_var_idx = -1;
  fd->arguments_arg_idx = -1;
  fd->func_var_idx = -1;
  fd->eval_ret_idx = -1;
  fd->this_var_idx = -1;
  fd->new_target_var_idx = -1;
  fd->this_active_func_var_idx = -1;
  fd->home_object_var_idx = -1;

  /* XXX: should distinguish arg, var and var object and body scopes */
  fd->scope_level = 0; /* 0: var/arg scope, 1:body scope */
  fd->scope_first = -1;
  fd->body_scope = -1;
  fd->scopes = fd->def_scope_array;
  fd->scope_size = countof(fd->def_scope_array);
  fd->scope_count = 1;
  fd->scopes[0].first = -1;
  fd->scopes[0].parent = -1;

  fd->filename = LEPUS_NewAtom(ctx, filename);
  fd->line_num = line_num;

  js_dbuf_init(ctx, &fd->pc2line);
  // fd->pc2line_last_line_num = line_num;
  // fd->pc2line_last_pc = 0;
  fd->last_opcode_line_num = line_num;

  return fd;
}
#endif

QJS_STATIC void free_bytecode_atoms(LEPUSRuntime *rt, const uint8_t *bc_buf,
                                    int bc_len, BOOL use_short_opcodes) {
  int pos, len, op;
  JSAtom atom;
  const JSOpCode *oi;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];

    len = oi->size;
    switch (oi->fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        atom = get_u32(bc_buf + pos + 1);
        LEPUS_FreeAtomRT(rt, atom);
        break;
      default:
        break;
    }
    pos += len;
  }
}

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC void js_free_function_def(LEPUSContext *ctx, JSFunctionDef *fd) {
  int i;
  struct list_head *el, *el1;

  /* free the child functions */
  list_for_each_safe(el, el1, &fd->child_list) {
    JSFunctionDef *fd1;
    fd1 = list_entry(el, JSFunctionDef, link);
    js_free_function_def(ctx, fd1);
  }

  free_bytecode_atoms(ctx->rt, fd->byte_code.buf, fd->byte_code.size,
                      fd->use_short_opcodes);
  dbuf_free(&fd->byte_code);
  lepus_free(ctx, fd->jump_slots);
  lepus_free(ctx, fd->label_slots);
  lepus_free(ctx, fd->line_number_slots);

  if (fd->caller_slots)
    free_caller_slot(ctx->rt, fd->caller_slots, fd->caller_count);

  for (i = 0; i < fd->cpool_count; i++) {
    LEPUS_FreeValue(ctx, fd->cpool[i]);
  }
  lepus_free(ctx, fd->cpool);

  LEPUS_FreeAtom(ctx, fd->func_name);

  for (i = 0; i < fd->var_count; i++) {
    LEPUS_FreeAtom(ctx, fd->vars[i].var_name);
  }
  lepus_free(ctx, fd->vars);
  for (i = 0; i < fd->arg_count; i++) {
    LEPUS_FreeAtom(ctx, fd->args[i].var_name);
  }
  lepus_free(ctx, fd->args);

  for (i = 0; i < fd->hoisted_def_count; i++) {
    LEPUS_FreeAtom(ctx, fd->hoisted_def[i].var_name);
  }
  lepus_free(ctx, fd->hoisted_def);

  for (i = 0; i < fd->closure_var_count; i++) {
    LEPUSClosureVar *cv = &fd->closure_var[i];
    LEPUS_FreeAtom(ctx, cv->var_name);
  }
  lepus_free(ctx, fd->closure_var);

  if (fd->scopes != fd->def_scope_array) lepus_free(ctx, fd->scopes);

  LEPUS_FreeAtom(ctx, fd->filename);
  dbuf_free(&fd->pc2line);

  system_free(fd->source);

  if (fd->parent) {
    /* remove in parent list */
    list_del(&fd->link);
  }
  lepus_free(ctx, fd);
}

#ifdef DUMP_BYTECODE
static const char *skip_lines(const char *p, int n) {
  while (n-- > 0 && *p) {
    while (*p && *p++ != '\n') continue;
  }
  return p;
}

static void print_lines(const char *source, int line, int line1) {
  const char *s = source;
  const char *p = skip_lines(s, line);
  if (*p) {
    while (line++ < line1) {
      p = skip_lines(s = p, 1);
      printf(";; %.*s", (int)(p - s), s);
      if (!*p) {
        if (p[-1] != '\n') printf("\n");
        break;
      }
    }
  }
}

static void dump_byte_code(LEPUSContext *ctx, int pass, const uint8_t *tab,
                           int len, const JSVarDef *args, int arg_count,
                           const JSVarDef *vars, int var_count,
                           const LEPUSClosureVar *closure_var,
                           int closure_var_count, const LEPUSValue *cpool,
                           uint32_t cpool_count, const char *source,
                           int line_num, const LabelSlot *label_slots,
                           LEPUSFunctionBytecode *b) {
  const JSOpCode *oi;
  int pos, pos_next, op, size, idx, addr, line, line1, in_source;
  int64_t col_num;
  uint8_t *bits =
      static_cast<uint8_t *>(lepus_mallocz(ctx, len * sizeof(*bits)));
  BOOL use_short_opcodes = (b != NULL);

  /* scan for jump targets */
  for (pos = 0; pos < len; pos = pos_next) {
    op = tab[pos];
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];
    pos_next = pos + oi->size;
    if (op < OP_COUNT) {
      switch (oi->fmt) {
#if SHORT_OPCODES
        case OP_FMT_label8:
          pos++;
          addr = (int8_t)tab[pos];
          goto has_addr;
        case OP_FMT_label16:
          pos++;
          addr = (int16_t)get_u16(tab + pos);
          goto has_addr;
#endif
        case OP_FMT_atom_label_u8:
        case OP_FMT_atom_label_u16:
          pos += 4;
          /* fall thru */
        case OP_FMT_label:
        case OP_FMT_label_u16:
          pos++;
          addr = get_u32(tab + pos);
          goto has_addr;
        has_addr:
          if (pass == 1) addr = label_slots[addr].pos;
          if (pass == 2) addr = label_slots[addr].pos2;
          if (pass == 3) addr += pos;
          if (addr >= 0 && addr < len) bits[addr] |= 1;
          break;
      }
    }
  }
  in_source = 0;
  if (source) {
    /* Always print first line: needed if single line */
    print_lines(source, 0, 1);
    in_source = 1;
  }
  line1 = line = 1;
  pos = 0;
  while (pos < len) {
    op = tab[pos];
    if (source) {
      if (b) {
        ComputeLineCol(find_line_num(ctx, b, pos), &line1, &col_num);
        line1 = line1 - line_num + 1;
      }
      // <Primjs begin>
      else if (op == OP_line_num) {
        ComputeLineCol(get_u64(tab + pos + 1), &line1, &col_num);
        line1 = line1 - line_num + 1;
      }
      // <Primjs end>
      if (line1 > line) {
        if (!in_source) printf("\n");
        in_source = 1;
        print_lines(source, line, line1);
        line = line1;
        // bits[pos] |= 2;
      }
    }
    if (in_source) printf("\n");
    in_source = 0;
    if (op >= OP_COUNT) {
      printf("invalid opcode (0x%02x)\n", op);
      pos++;
      continue;
    }
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];
    size = oi->size;
    if (pos + size > len) {
      printf("truncated opcode (0x%02x)\n", op);
      break;
    }
#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 16)
    {
      int i, x, x0;
      x = x0 = printf("%5d ", pos);
      for (i = 0; i < size; i++) {
        if (i == 6) {
          printf("\n%*s", x = x0, "");
        }
        x += printf(" %02X", tab[pos + i]);
      }
      printf("%*s", x0 + 20 - x, "");
    }
#endif
    if (bits[pos]) {
      printf("%5d:  ", pos);
    } else {
      printf("        ");
    }
    printf("%s", oi->name);
    pos++;
    switch (oi->fmt) {
      case OP_FMT_none_int:
        printf(" %d", op - OP_push_0);
        break;
      case OP_FMT_npopx:
        printf(" %d", op - OP_call0);
        break;
      case OP_FMT_u8:
        printf(" %u", get_u8(tab + pos));
        break;
      case OP_FMT_i8:
        printf(" %d", get_i8(tab + pos));
        break;
      case OP_FMT_u16:
      case OP_FMT_npop:
        printf(" %u", get_u16(tab + pos));
        break;
      case OP_FMT_i16:
        printf(" %d", get_i16(tab + pos));
        break;
      case OP_FMT_i32:
        printf(" %d", get_i32(tab + pos));
        break;
      case OP_FMT_u32:
        printf(" %u", get_u32(tab + pos));
        break;
      // <Primjs begin>
      case OP_FMT_u64:
        if (op == OP_line_num) {
          ComputeLineCol(get_u64(tab + pos), &line1, &col_num);
          printf(" line: %d, col:%lld", line1, col_num);
        } else {
          printf(" %llu", get_u64(tab + pos));
        }
        break;
        // <Primjs end>
#if SHORT_OPCODES
      case OP_FMT_label8:
        addr = get_i8(tab + pos);
        goto has_addr1;
      case OP_FMT_label16:
        addr = get_i16(tab + pos);
        goto has_addr1;
#endif
      case OP_FMT_label:
        addr = get_u32(tab + pos);
        goto has_addr1;
      has_addr1:
        if (pass == 1) printf(" %u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(" %u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(" %u", addr + pos);
        break;
      case OP_FMT_label_u16:
        addr = get_u32(tab + pos);
        if (pass == 1) printf(" %u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(" %u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(" %u", addr + pos);
        printf(",%u", get_u16(tab + pos + 4));
        break;
#if SHORT_OPCODES
      case OP_FMT_const8:
        idx = get_u8(tab + pos);
        goto has_pool_idx;
#endif
      case OP_FMT_const:
        idx = get_u32(tab + pos);
        goto has_pool_idx;
      has_pool_idx:
        printf(" %u: ", idx);
        if (idx < cpool_count) {
          JS_DumpValue(ctx, cpool[idx]);
        }
        break;
      case OP_FMT_atom:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        break;
      case OP_FMT_atom_u8:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        printf(",%d", get_u8(tab + pos + 4));
        break;
      case OP_FMT_atom_u16:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        printf(",%d", get_u16(tab + pos + 4));
        break;
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        addr = get_u32(tab + pos + 4);
        if (pass == 1) printf(",%u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(",%u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(",%u", addr + pos + 4);
        if (oi->fmt == OP_FMT_atom_label_u8) {
          printf(",%u", get_u8(tab + pos + 8));
        } else {
          printf(",%u", get_u16(tab + pos + 8));
        }
        break;
      case OP_FMT_none_loc:
        idx = (op - OP_get_loc0) % 4;
        goto has_loc;
      case OP_FMT_loc8:
        idx = get_u8(tab + pos);
        goto has_loc;
      case OP_FMT_loc:
        idx = get_u16(tab + pos);
      has_loc:
        printf(" %d: ", idx);
        if (idx < var_count) {
          print_atom(ctx, vars[idx].var_name);
        }
        break;
      case OP_FMT_none_arg:
        idx = (op - OP_get_arg0) % 4;
        goto has_arg;
      case OP_FMT_arg:
        idx = get_u16(tab + pos);
      has_arg:
        printf(" %d: ", idx);
        if (idx < arg_count) {
          print_atom(ctx, args[idx].var_name);
        }
        break;
      case OP_FMT_none_var_ref:
        idx = (op - OP_get_var_ref0) % 4;
        goto has_var_ref;
      case OP_FMT_var_ref:
        idx = get_u16(tab + pos);
      has_var_ref:
        printf(" %d: ", idx);
        if (idx < closure_var_count) {
          print_atom(ctx, closure_var[idx].var_name);
        }
        break;
      default:
        break;
    }
    printf("\n");
    pos += oi->size - 1;
  }
  if (source) {
    if (!in_source) printf("\n");
    print_lines(source, line, INT32_MAX);
  }
  lepus_free(ctx, bits);
}

static __attribute__((unused)) void dump_pc2line(LEPUSContext *ctx,
                                                 const uint8_t *buf, int len,
                                                 int line_num) {
  const uint8_t *p_end, *p_next, *p;
  int pc, v;
  unsigned int op;

  if (len <= 0) return;

  printf("%5s %5s\n", "PC", "LINE");

  p = buf;
  p_end = buf + len;
  pc = 0;
  while (p < p_end) {
    op = *p++;
    if (op == 0) {
      v = unicode_from_utf8(p, p_end - p, &p_next);
      if (v < 0) goto fail;
      pc += v;
      p = p_next;
      v = unicode_from_utf8(p, p_end - p, &p_next);
      if (v < 0) {
      fail:
        printf("invalid pc2line encode pos=%d\n", (int)(p - buf));
        return;
      }
      if (!(v & 1)) {
        v = v >> 1;
      } else {
        v = -(v >> 1) - 1;
      }
      line_num += v;
      p = p_next;
    } else {
      op -= PC2LINE_OP_FIRST;
      pc += (op / PC2LINE_RANGE);
      line_num += (op % PC2LINE_RANGE) + PC2LINE_BASE;
    }
    printf("%5d %5d\n", pc, line_num);
  }
}

static __attribute__((unused)) void js_dump_function_bytecode(
    LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  int i;
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  const char *str;

  if (b->has_debug && b->debug.filename != JS_ATOM_NULL) {
    str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename);
    printf("%s:%d: ", str, b->debug.line_num);
  }

  str = JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->func_name);
  printf("function: %s%s\n", &"*"[b->func_kind != JS_FUNC_GENERATOR], str);
  if (b->js_mode) {
    printf("  mode:");
    if (b->js_mode & JS_MODE_STRICT) printf(" strict");
#ifdef CONFIG_BIGNUM
    if (b->js_mode & JS_MODE_MATH) printf(" math");
#endif
    printf("\n");
  }
  if (b->arg_count && b->vardefs) {
    printf("  args:");
    for (i = 0; i < b->arg_count; i++) {
      printf(" %s", JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf),
                                  b->vardefs[i].var_name));
    }
    printf("\n");
  }
  if (b->var_count && b->vardefs) {
    printf("  locals:\n");
    for (i = 0; i < b->var_count; i++) {
      JSVarDef *vd = &b->vardefs[b->arg_count + i];
      printf("%5d: %s %s", i,
             vd->var_kind == JS_VAR_CATCH ? "catch"
             : (vd->var_kind == JS_VAR_FUNCTION_DECL ||
                vd->var_kind == JS_VAR_NEW_FUNCTION_DECL)
                 ? "function"
             : vd->is_const   ? "const"
             : vd->is_lexical ? "let"
                              : "var",
             JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), vd->var_name));
      if (vd->scope_level)
        printf(" [level:%d next:%d]", vd->scope_level, vd->scope_next);
      printf("\n");
    }
  }
  if (b->closure_var_count) {
    printf("  closure vars:\n");
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      printf("%5d: %s %s:%s%d %s\n", i,
             JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), cv->var_name),
             cv->is_local ? "local" : "parent", cv->is_arg ? "arg" : "loc",
             cv->var_idx,
             cv->is_const     ? "const"
             : cv->is_lexical ? "let"
                              : "var");
    }
  }
  printf("  stack_size: %d\n", b->stack_size);
  printf("  opcodes:\n");
  dump_byte_code(ctx, 3, b->byte_code_buf, b->byte_code_len, b->vardefs,
                 b->arg_count, b->vardefs ? b->vardefs + b->arg_count : NULL,
                 b->var_count, b->closure_var, b->closure_var_count, b->cpool,
                 b->cpool_count, b->has_debug ? b->debug.source : NULL,
                 b->has_debug ? b->debug.line_num : -1, NULL, b);
#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 32)
  if (b->has_debug)
    dump_pc2line(ctx, b->debug.pc2line_buf, b->debug.pc2line_len,
                 b->debug.line_num);
#endif
  printf("\n");
}
#endif

int add_closure_var(LEPUSContext *ctx, JSFunctionDef *s, BOOL is_local,
                    BOOL is_arg, int var_idx, JSAtom var_name, BOOL is_const,
                    BOOL is_lexical, JSVarKindEnum var_kind) {
  LEPUSClosureVar *cv;

  /* the closure variable indexes are currently stored on 16 bits */
  if (s->closure_var_count >= JS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many closure variables");
    return -1;
  }

  if (s->closure_var_count >= s->closure_var_size) {
    LEPUSClosureVar *new_tab;
    int new_size;
    size_t slack;
    new_size = max_int(s->closure_var_count + 1, s->closure_var_size * 3 / 2);
    new_tab = static_cast<LEPUSClosureVar *>(
        lepus_realloc2(ctx, s->closure_var, new_size * sizeof(LEPUSClosureVar),
                       &slack, ALLOC_TAG_WITHOUT_PTR));
    if (!new_tab) return -1;
    new_size += slack / sizeof(*new_tab);
    s->closure_var = new_tab;
    s->closure_var_size = new_size;
  }
  cv = &s->closure_var[s->closure_var_count++];
  cv->is_local = is_local;
  cv->is_arg = is_arg;
  cv->is_const = is_const;
  cv->is_lexical = is_lexical;
  cv->var_kind = var_kind;
  cv->var_idx = var_idx;
  if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
  cv->var_name = var_name;
  return s->closure_var_count - 1;
}

static int find_closure_var(LEPUSContext *ctx, JSFunctionDef *s,
                            JSAtom var_name) {
  int i;
  for (i = 0; i < s->closure_var_count; i++) {
    LEPUSClosureVar *cv = &s->closure_var[i];
    if (cv->var_name == var_name) return i;
  }
  return -1;
}

/* 'fd' must be a parent of 's'. Create in 's' a closure referencing a
   local variable (is_local = TRUE) or a closure (is_local = FALSE) in
   'fd' */
QJS_STATIC int get_closure_var2(LEPUSContext *ctx, JSFunctionDef *s,
                                JSFunctionDef *fd, BOOL is_local, BOOL is_arg,
                                int var_idx, JSAtom var_name, BOOL is_const,
                                BOOL is_lexical, JSVarKindEnum var_kind) {
  int i;

  if (fd != s->parent) {
    var_idx = get_closure_var2(ctx, s->parent, fd, is_local, is_arg, var_idx,
                               var_name, is_const, is_lexical, var_kind);
    if (var_idx < 0) return -1;
    is_local = FALSE;
  }
  for (i = 0; i < s->closure_var_count; i++) {
    LEPUSClosureVar *cv = &s->closure_var[i];
    if (cv->var_idx == var_idx && cv->is_arg == is_arg &&
        cv->is_local == is_local)
      return i;
  }
  return add_closure_var(ctx, s, is_local, is_arg, var_idx, var_name, is_const,
                         is_lexical, var_kind);
}

QJS_STATIC int get_closure_var(LEPUSContext *ctx, JSFunctionDef *s,
                               JSFunctionDef *fd, BOOL is_arg, int var_idx,
                               JSAtom var_name, BOOL is_const, BOOL is_lexical,
                               JSVarKindEnum var_kind) {
  return get_closure_var2(ctx, s, fd, TRUE, is_arg, var_idx, var_name, is_const,
                          is_lexical, var_kind);
}

QJS_STATIC int get_with_scope_opcode(int op) {
  if (op == OP_scope_get_var_undef)
    return OP_with_get_var;
  else
    return OP_with_get_var + (op - OP_scope_get_var);
}

QJS_STATIC BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos) {
  int opcode = bc_buf[pos];
  return (bc_buf[pos + 1] == OP_put_ref_value &&
          (opcode == OP_insert3 || opcode == OP_perm4 || opcode == OP_nop ||
           opcode == OP_rot3l));
}

QJS_STATIC BOOL can_opt_put_global_ref_value(const uint8_t *bc_buf, int pos) {
  int opcode = bc_buf[pos];
  return (bc_buf[pos + 1] == OP_put_ref_value &&
          (opcode == OP_insert3 || opcode == OP_perm4 || opcode == OP_nop ||
           opcode == OP_rot3l));
}

QJS_STATIC int optimize_scope_make_ref(LEPUSContext *ctx, JSFunctionDef *s,
                                       DynBuf *bc, uint8_t *bc_buf,
                                       LabelSlot *ls, int pos_next, int get_op,
                                       int var_idx) {
  int label_pos, end_pos, pos;

  /* XXX: should optimize `loc(a) += expr` as `expr add_loc(a)`
     but only if expr does not modify `a`.
     should scan the code between pos_next and label_pos
     for operations that can potentially change `a`:
     OP_scope_make_ref(a), function calls, jumps and gosub.
   */
  /* replace the reference get/put with normal variable
     accesses */
  if (bc_buf[pos_next] == OP_get_ref_value) {
    dbuf_putc(bc, get_op);
    dbuf_put_u16(bc, var_idx);
    pos_next++;
  }
  /* remove the OP_label to make room for replacement */
  /* label should have a refcount of 0 anyway */
  /* XXX: should avoid this patch by inserting nops in phase 1 */
  label_pos = ls->pos;
  pos = label_pos - 5;
  assert(bc_buf[pos] == OP_label);
  /* label points to an instruction pair:
     - insert3 / put_ref_value
     - perm4 / put_ref_value
     - rot3l / put_ref_value
     - nop / put_ref_value
   */
  end_pos = label_pos + 2;
  if (bc_buf[label_pos] == OP_insert3) bc_buf[pos++] = OP_dup;
  bc_buf[pos] = get_op + 1;
  put_u16(bc_buf + pos + 1, var_idx);
  pos += 3;
  /* pad with OP_nop */
  while (pos < end_pos) bc_buf[pos++] = OP_nop;
  return pos_next;
}

QJS_STATIC int optimize_scope_make_global_ref(LEPUSContext *ctx,
                                              JSFunctionDef *s, DynBuf *bc,
                                              uint8_t *bc_buf, LabelSlot *ls,
                                              int pos_next, JSAtom var_name) {
  int label_pos, end_pos, pos, op;
  BOOL is_strict;
  is_strict = ((s->js_mode & JS_MODE_STRICT) != 0);

  /* replace the reference get/put with normal variable
     accesses */
  if (is_strict) {
    /* need to check if the variable exists before evaluating the right
       expression */
    /* XXX: need an extra OP_true if destructuring an array */
    dbuf_putc(bc, OP_check_var);
    if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
    dbuf_put_u32(bc, var_name);
  } else {
    /* XXX: need 2 extra OP_true if destructuring an array */
  }
  if (bc_buf[pos_next] == OP_get_ref_value) {
    dbuf_putc(bc, OP_get_var);
    if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
    dbuf_put_u32(bc, var_name);
    pos_next++;
  }
  /* remove the OP_label to make room for replacement */
  /* label should have a refcount of 0 anyway */
  /* XXX: should have emitted several OP_nop to avoid this kludge */
  label_pos = ls->pos;
  pos = label_pos - 5;
  assert(bc_buf[pos] == OP_label);
  end_pos = label_pos + 2;
  op = bc_buf[label_pos];
  if (is_strict) {
    if (op != OP_nop) {
      switch (op) {
        case OP_insert3:
          op = OP_insert2;
          break;
        case OP_perm4:
          op = OP_perm3;
          break;
        case OP_rot3l:
          op = OP_swap;
          break;
        default:
          abort();
      }
      bc_buf[pos++] = op;
    }
  } else {
    if (op == OP_insert3) bc_buf[pos++] = OP_dup;
  }
  if (is_strict) {
    bc_buf[pos] = OP_put_var_strict;
    /* XXX: need 1 extra OP_drop if destructuring an array */
  } else {
    bc_buf[pos] = OP_put_var;
    /* XXX: need 2 extra OP_drop if destructuring an array */
  }
  if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
  put_u32(bc_buf + pos + 1, var_name);
  pos += 5;
  /* pad with OP_nop */
  while (pos < end_pos) bc_buf[pos++] = OP_nop;
  return pos_next;
}

QJS_STATIC int add_var_this(LEPUSContext *ctx, JSFunctionDef *fd) {
  int idx;
  idx = add_var(ctx, fd, JS_ATOM_this);
  if (idx >= 0 && fd->is_derived_class_constructor) {
    JSVarDef *vd = &fd->vars[idx];
    /* XXX: should have is_this flag or var type */
    vd->is_lexical = 1; /* used to trigger 'uninitialized' checks
                           in a derived class constructor */
  }
  return idx;
}

QJS_STATIC int resolve_pseudo_var(LEPUSContext *ctx, JSFunctionDef *s,
                                  JSAtom var_name) {
  int var_idx;

  if (!s->has_this_binding) return -1;
  switch (var_name) {
    case JS_ATOM_home_object:
      /* 'home_object' pseudo variable */
      var_idx = s->home_object_var_idx = add_var(ctx, s, var_name);
      break;
    case JS_ATOM_this_active_func:
      /* 'this.active_func' pseudo variable */
      var_idx = s->this_active_func_var_idx = add_var(ctx, s, var_name);
      break;
    case JS_ATOM_new_target:
      /* 'new.target' pseudo variable */
      var_idx = s->new_target_var_idx = add_var(ctx, s, var_name);
      break;
    case JS_ATOM_this:
      /* 'this' pseudo variable */
      var_idx = s->this_var_idx = add_var_this(ctx, s);
      break;
    default:
      var_idx = -1;
      break;
  }
  return var_idx;
}

/* return the position of the next opcode */
QJS_STATIC int resolve_scope_var(LEPUSContext *ctx, JSFunctionDef *s,
                                 JSAtom var_name, int scope_level, int op,
                                 DynBuf *bc, uint8_t *bc_buf, LabelSlot *ls,
                                 int pos_next) {
  int idx, var_idx, is_put;
  int label_done;
  JSFunctionDef *fd;
  JSVarDef *vd;
  BOOL is_pseudo_var, is_arg_scope;
  JSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
  HandleScope func_scope(ctx->rt);
  func_scope.PushLEPUSAtom(atom_arg_var);

  label_done = -1;
  bool is_rc = !ctx->gc_enable;

  /* XXX: could be simpler to use a specific function to
     resolve the pseudo variables */
  is_pseudo_var = (var_name == JS_ATOM_home_object ||
                   var_name == JS_ATOM_this_active_func ||
                   var_name == JS_ATOM_new_target || var_name == JS_ATOM_this);

  /* resolve local scoped variables */
  var_idx = -1;
  for (idx = s->scopes[scope_level].first; idx >= 0;) {
    vd = &s->vars[idx];
    if (vd->var_name == var_name) {
      if (op == OP_scope_put_var || op == OP_scope_make_ref) {
        if (vd->is_const) {
          dbuf_putc(bc, OP_throw_var);
          if (is_rc) LEPUS_DupAtom(ctx, var_name);
          dbuf_put_u32(bc, var_name);
          dbuf_putc(bc, JS_THROW_VAR_RO);
          goto done;
        }
      }
      var_idx = idx;
      break;
    } else if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {
      dbuf_putc(bc, OP_get_loc);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 1);
      update_label(s, label_done, 1);
      s->jump_size++;
    }
    idx = vd->scope_next;
  }
  is_arg_scope = (idx == ARG_SCOPE_END);
  if (var_idx < 0) {
    /* XXX: scoping issues:
       should not resolve vars from the function body during argument parse,
       `arguments` and function-name should not be hidden by later vars.
     */
    var_idx = find_var(ctx, s, var_name);
    if (var_idx >= 0) {
      var_idx = find_var(ctx, s, var_name);
    }

    if (var_idx < 0 && is_pseudo_var)
      var_idx = resolve_pseudo_var(ctx, s, var_name);

    if (var_idx < 0 && var_name == JS_ATOM_arguments &&
        s->has_arguments_binding) {
      /* 'arguments' pseudo variable */
      var_idx = add_arguments_var(ctx, s, var_name);
    }
    if (var_idx < 0 && s->is_func_expr && var_name == s->func_name) {
      /* add a new variable with the function name */
      var_idx = add_func_var(ctx, s, var_name);
    }
  }
  if (var_idx >= 0) {
    if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
        !(var_idx & ARGUMENT_VAR_OFFSET) && s->vars[var_idx].is_const) {
      /* only happens when assigning a function expression name
         in strict mode */
      dbuf_putc(bc, OP_throw_var);
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      dbuf_putc(bc, JS_THROW_VAR_RO);
      goto done;
    }
    /* OP_scope_put_var_init is only used to initialize a
       lexical variable, so it is never used in a with or var object. It
       can be used with a closure (module global variable case). */
    switch (op) {
      case OP_scope_make_ref:
        if (!(var_idx & ARGUMENT_VAR_OFFSET) &&
            s->vars[var_idx].var_kind == JS_VAR_FUNCTION_NAME) {
          /* Create a dummy object reference for the func_var */
          dbuf_putc(bc, OP_object);
          dbuf_putc(bc, OP_get_loc);
          dbuf_put_u16(bc, var_idx);
          dbuf_putc(bc, OP_define_field);
          if (is_rc) {
            LEPUS_DupAtom(ctx, var_name);
            LEPUS_DupAtom(ctx, var_name);
          }
          dbuf_put_u32(bc, var_name);
          dbuf_putc(bc, OP_push_atom_value);
          dbuf_put_u32(bc, var_name);
        } else if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {
          int get_op;
          if (var_idx & ARGUMENT_VAR_OFFSET) {
            get_op = OP_get_arg;
            var_idx -= ARGUMENT_VAR_OFFSET;
          } else {
            if (s->vars[var_idx].is_lexical)
              get_op = OP_get_loc_check;
            else
              get_op = OP_get_loc;
          }
          pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls, pos_next,
                                             get_op, var_idx);
        } else {
          /* Create a dummy object with a named slot that is
             a reference to the local variable */
          if (var_idx & ARGUMENT_VAR_OFFSET) {
            dbuf_putc(bc, OP_make_arg_ref);
            if (is_rc) LEPUS_DupAtom(ctx, var_name);
            dbuf_put_u32(bc, var_name);
            dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
          } else {
            dbuf_putc(bc, OP_make_loc_ref);
            if (is_rc) LEPUS_DupAtom(ctx, var_name);
            dbuf_put_u32(bc, var_name);
            dbuf_put_u16(bc, var_idx);
          }
        }
        break;
      case OP_scope_get_ref:
        dbuf_putc(bc, OP_undefined);
        /* fall thru */
      case OP_scope_get_var_undef:
      case OP_scope_get_var:
      case OP_scope_put_var:
      case OP_scope_put_var_init:
        is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
        if (var_idx & ARGUMENT_VAR_OFFSET) {
          dbuf_putc(bc, OP_get_arg + is_put);
          dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
          /* XXX: should test if argument reference needs TDZ check */
        } else {
          if (is_put) {
            if (s->vars[var_idx].is_lexical) {
              if (op == OP_scope_put_var_init) {
                /* 'this' can only be initialized once */
                if (var_name == JS_ATOM_this)
                  dbuf_putc(bc, OP_put_loc_check_init);
                else
                  dbuf_putc(bc, OP_put_loc);
              } else {
                dbuf_putc(bc, OP_put_loc_check);
              }
            } else {
              dbuf_putc(bc, OP_put_loc);
            }
          } else {
            if (s->vars[var_idx].is_lexical) {
              dbuf_putc(bc, OP_get_loc_check);
            } else {
              dbuf_putc(bc, OP_get_loc);
            }
          }
          dbuf_put_u16(bc, var_idx);
        }
        break;
      case OP_scope_delete_var:
        dbuf_putc(bc, OP_push_false);
        break;
    }
    goto done;
  }
  /* check eval object */
  if (!is_arg_scope && s->var_object_idx >= 0 && !is_pseudo_var) {
    dbuf_putc(bc, OP_get_loc);
    dbuf_put_u16(bc, s->var_object_idx);
    dbuf_putc(bc, get_with_scope_opcode(op));
    if (is_rc) LEPUS_DupAtom(ctx, var_name);
    dbuf_put_u32(bc, var_name);
    label_done = new_label_fd(s, label_done);
    dbuf_put_u32(bc, label_done);
    dbuf_putc(bc, 0);
    update_label(s, label_done, 1);
    s->jump_size++;
  }
  /* check eval object in argument scope */
  if (s->arg_var_object_idx >= 0 && !is_pseudo_var) {
    dbuf_putc(bc, OP_get_loc);
    dbuf_put_u16(bc, s->arg_var_object_idx);
    dbuf_putc(bc, get_with_scope_opcode(op));
    if (is_rc) LEPUS_DupAtom(ctx, var_name);
    dbuf_put_u32(bc, var_name);
    label_done = new_label_fd(s, label_done);
    dbuf_put_u32(bc, label_done);
    dbuf_putc(bc, 0);
    update_label(s, label_done, 1);
    s->jump_size++;
  }
  /* check parent scopes */
  for (fd = s; fd->parent;) {
    scope_level = fd->parent_scope_level;
    fd = fd->parent;
    for (idx = fd->scopes[scope_level].first; idx >= 0;) {
      vd = &fd->vars[idx];
      if (vd->var_name == var_name) {
        if (op == OP_scope_put_var || op == OP_scope_make_ref) {
          if (vd->is_const) {
            dbuf_putc(bc, OP_throw_var);
            if (is_rc) LEPUS_DupAtom(ctx, var_name);
            dbuf_put_u32(bc, var_name);
            dbuf_putc(bc, JS_THROW_VAR_RO);
            goto done;
          }
        }
        var_idx = idx;
        break;
      } else if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {
        vd->is_captured = 1;
        idx = get_closure_var(ctx, s, fd, FALSE, idx, vd->var_name, FALSE,
                              FALSE, JS_VAR_NORMAL);
        if (idx >= 0) {
          dbuf_putc(bc, OP_get_var_ref);
          dbuf_put_u16(bc, idx);
          dbuf_putc(bc, get_with_scope_opcode(op));
          if (is_rc) LEPUS_DupAtom(ctx, var_name);
          dbuf_put_u32(bc, var_name);
          label_done = new_label_fd(s, label_done);
          dbuf_put_u32(bc, label_done);
          dbuf_putc(bc, 1);
          update_label(s, label_done, 1);
          s->jump_size++;
        }
      }
      idx = vd->scope_next;
    }
    is_arg_scope = (idx == ARG_SCOPE_END);
    if (var_idx >= 0) break;

    if (!is_arg_scope) {
      var_idx = find_var(ctx, fd, var_name);
      if (var_idx >= 0) break;
    }

    if (is_pseudo_var) {
      var_idx = resolve_pseudo_var(ctx, fd, var_name);
      if (var_idx >= 0) break;
    }
    if (var_name == JS_ATOM_arguments && fd->has_arguments_binding) {
      var_idx = add_arguments_var(ctx, fd, var_name);
      break;
    }
    if (fd->is_func_expr && fd->func_name == var_name) {
      /* add a new variable with the function name */
      var_idx = add_func_var(ctx, fd, var_name);
      break;
    }

    /* check eval object */
    if (!is_arg_scope && fd->var_object_idx >= 0 && !is_pseudo_var) {
      fd->vars[fd->var_object_idx].is_captured = 1;
      idx = get_closure_var(ctx, s, fd, FALSE, fd->var_object_idx,
                            JS_ATOM__var_, FALSE, FALSE, JS_VAR_NORMAL);
      dbuf_putc(bc, OP_get_var_ref);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 0);
      update_label(s, label_done, 1);
      s->jump_size++;
    }

    /* check eval object in argument scope */
    if (fd->arg_var_object_idx >= 0 && !is_pseudo_var) {
      vd = &fd->vars[fd->arg_var_object_idx];
      vd->is_captured = 1;
      idx = get_closure_var(ctx, s, fd, FALSE, fd->arg_var_object_idx,
                            vd->var_name, FALSE, FALSE, JS_VAR_NORMAL);
      dbuf_putc(bc, OP_get_var_ref);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 0);
      update_label(s, label_done, 1);
      s->jump_size++;
    }

    if (fd->is_eval) break; /* it it necessarily the top level function */
  }

  /* check direct eval scope (in the closure of the eval function
     which is necessarily at the top level) */
  if (!fd) fd = s;
  if (var_idx < 0 && fd->is_eval) {
    int idx1;
    for (idx1 = 0; idx1 < fd->closure_var_count; idx1++) {
      LEPUSClosureVar *cv = &fd->closure_var[idx1];
      if (var_name == cv->var_name) {
        if (fd != s) {
          idx = get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx1,
                                 cv->var_name, cv->is_const, cv->is_lexical,
                                 static_cast<JSVarKindEnum>(cv->var_kind));
        } else {
          idx = idx1;
        }
        goto has_idx;
      } else if ((cv->var_name == JS_ATOM__var_ ||
                  cv->var_name == atom_arg_var ||
                  cv->var_name == JS_ATOM__with_) &&
                 !is_pseudo_var) {
        int is_with = (cv->var_name == JS_ATOM__with_);
        if (fd != s) {
          idx = get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx1,
                                 cv->var_name, FALSE, FALSE, JS_VAR_NORMAL);
        } else {
          idx = idx1;
        }
        dbuf_putc(bc, OP_get_var_ref);
        dbuf_put_u16(bc, idx);
        dbuf_putc(bc, get_with_scope_opcode(op));
        if (is_rc) LEPUS_DupAtom(ctx, var_name);
        dbuf_put_u32(bc, var_name);
        label_done = new_label_fd(s, label_done);
        dbuf_put_u32(bc, label_done);
        dbuf_putc(bc, is_with);
        update_label(s, label_done, 1);
        s->jump_size++;
      }
    }
  }

  if (var_idx >= 0) {
    /* find the corresponding closure variable */
    if (var_idx & ARGUMENT_VAR_OFFSET) {
      fd->args[var_idx - ARGUMENT_VAR_OFFSET].is_captured = 1;
      idx = get_closure_var(ctx, s, fd, TRUE, var_idx - ARGUMENT_VAR_OFFSET,
                            var_name, FALSE, FALSE, JS_VAR_NORMAL);
    } else {
      fd->vars[var_idx].is_captured = 1;
      idx = get_closure_var(
          ctx, s, fd, FALSE, var_idx, var_name, fd->vars[var_idx].is_const,
          fd->vars[var_idx].is_lexical,
          static_cast<JSVarKindEnum>(fd->vars[var_idx].var_kind));
    }
    if (idx >= 0) {
    has_idx:
      if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
          s->closure_var[idx].is_const) {
        dbuf_putc(bc, OP_throw_var);
        if (is_rc) LEPUS_DupAtom(ctx, var_name);
        dbuf_put_u32(bc, var_name);
        dbuf_putc(bc, JS_THROW_VAR_RO);
        goto done;
      }
      switch (op) {
        case OP_scope_make_ref:
          if (s->closure_var[idx].var_kind == JS_VAR_FUNCTION_NAME) {
            /* Create a dummy object reference for the func_var */
            dbuf_putc(bc, OP_object);
            dbuf_putc(bc, OP_get_var_ref);
            dbuf_put_u16(bc, idx);
            dbuf_putc(bc, OP_define_field);
            if (is_rc) {
              LEPUS_DupAtom(ctx, var_name);
              LEPUS_DupAtom(ctx, var_name);
            }
            dbuf_put_u32(bc, var_name);
            dbuf_putc(bc, OP_push_atom_value);
            dbuf_put_u32(bc, var_name);
          } else if (label_done == -1 &&
                     can_opt_put_ref_value(bc_buf, ls->pos)) {
            int get_op;
            if (s->closure_var[idx].is_lexical)
              get_op = OP_get_var_ref_check;
            else
              get_op = OP_get_var_ref;
            pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls, pos_next,
                                               get_op, idx);
          } else {
            /* Create a dummy object with a named slot that is
               a reference to the closure variable */
            dbuf_putc(bc, OP_make_var_ref_ref);
            if (is_rc) LEPUS_DupAtom(ctx, var_name);
            dbuf_put_u32(bc, var_name);
            dbuf_put_u16(bc, idx);
          }
          break;
        case OP_scope_get_ref:
          /* XXX: should create a dummy object with a named slot that is
             a reference to the closure variable */
          dbuf_putc(bc, OP_undefined);
          /* fall thru */
        case OP_scope_get_var_undef:
        case OP_scope_get_var:
        case OP_scope_put_var:
        case OP_scope_put_var_init:
          is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
          if (is_put) {
            if (s->closure_var[idx].is_lexical) {
              if (op == OP_scope_put_var_init) {
                /* 'this' can only be initialized once */
                if (var_name == JS_ATOM_this)
                  dbuf_putc(bc, OP_put_var_ref_check_init);
                else
                  dbuf_putc(bc, OP_put_var_ref);
              } else {
                dbuf_putc(bc, OP_put_var_ref_check);
              }
            } else {
              dbuf_putc(bc, OP_put_var_ref);
            }
          } else {
            if (s->closure_var[idx].is_lexical) {
              dbuf_putc(bc, OP_get_var_ref_check);
            } else {
              dbuf_putc(bc, OP_get_var_ref);
            }
          }
          dbuf_put_u16(bc, idx);
          break;
        case OP_scope_delete_var:
          dbuf_putc(bc, OP_push_false);
          break;
      }
      goto done;
    }
  }

  /* global variable access */

  switch (op) {
    case OP_scope_make_ref:
      if (label_done == -1 && can_opt_put_global_ref_value(bc_buf, ls->pos)) {
        pos_next = optimize_scope_make_global_ref(ctx, s, bc, bc_buf, ls,
                                                  pos_next, var_name);
      } else {
        dbuf_putc(bc, OP_make_var_ref);
        if (is_rc) LEPUS_DupAtom(ctx, var_name);
        dbuf_put_u32(bc, var_name);
      }
      break;
    case OP_scope_get_ref:
      /* XXX: should create a dummy object with a named slot that is
         a reference to the global variable */
      dbuf_putc(bc, OP_undefined);
      dbuf_putc(bc, OP_get_var);
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      break;
    case OP_scope_get_var_undef:
    case OP_scope_get_var:
    case OP_scope_put_var:
      dbuf_putc(bc, OP_get_var_undef + (op - OP_scope_get_var_undef));
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      break;
    case OP_scope_put_var_init:
      dbuf_putc(bc, OP_put_var_init);
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      break;
    case OP_scope_delete_var:
      dbuf_putc(bc, OP_delete_var);
      if (is_rc) LEPUS_DupAtom(ctx, var_name);
      dbuf_put_u32(bc, var_name);
      break;
  }
done:
  if (is_rc) LEPUS_FreeAtom(ctx, atom_arg_var);
  if (label_done >= 0) {
    dbuf_putc(bc, OP_label);
    dbuf_put_u32(bc, label_done);
    s->label_slots[label_done].pos2 = bc->size;
  }
  return pos_next;
}

/* search in all scopes */
QJS_STATIC int find_private_class_field_all(LEPUSContext *ctx,
                                            JSFunctionDef *fd, JSAtom name,
                                            int scope_level) {
  int idx;

  idx = fd->scopes[scope_level].first;
  while (idx >= 0) {
    if (fd->vars[idx].var_name == name) return idx;
    idx = fd->vars[idx].scope_next;
  }
  return -1;
}

QJS_STATIC void get_loc_or_ref(DynBuf *bc, BOOL is_ref, int idx) {
  if (is_ref)
    dbuf_putc(bc, OP_get_var_ref);
  else
    dbuf_putc(bc, OP_get_loc);
  dbuf_put_u16(bc, idx);
}

QJS_STATIC int resolve_scope_private_field1(LEPUSContext *ctx, BOOL *pis_ref,
                                            int *pvar_kind, JSFunctionDef *s,
                                            JSAtom var_name, int scope_level) {
  int idx, var_kind;
  JSFunctionDef *fd;
  BOOL is_ref;

  fd = s;
  is_ref = FALSE;
  for (;;) {
    idx = find_private_class_field_all(ctx, fd, var_name, scope_level);
    if (idx >= 0) {
      var_kind = fd->vars[idx].var_kind;
      if (is_ref) {
        idx = get_closure_var(ctx, s, fd, FALSE, idx, var_name, TRUE, TRUE,
                              JS_VAR_NORMAL);
        if (idx < 0) return -1;
      }
      break;
    }
    scope_level = fd->parent_scope_level;
    if (!fd->parent) {
      char buf[ATOM_GET_STR_BUF_SIZE];

      if (fd->is_eval) {
        /* closure of the eval function (top level) */
        for (idx = 0; idx < fd->closure_var_count; idx++) {
          LEPUSClosureVar *cv = &fd->closure_var[idx];
          if (cv->var_name == var_name) {
            var_kind = cv->var_kind;
            is_ref = TRUE;
            if (fd != s) {
              idx = get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx,
                                     cv->var_name, cv->is_const, cv->is_lexical,
                                     static_cast<JSVarKindEnum>(cv->var_kind));
              if (idx < 0) return -1;
            }
            goto done;
          }
        }
      }
      /* XXX: no line number info */
      JS_ThrowSyntaxErrorAtom(ctx, "undefined private field '%s'", var_name);
      return -1;
    } else {
      fd = fd->parent;
    }
    is_ref = TRUE;
  }
done:
  *pis_ref = is_ref;
  *pvar_kind = var_kind;
  return idx;
}

/* return 0 if OK or -1 if the private field could not be resolved */
QJS_STATIC int resolve_scope_private_field(LEPUSContext *ctx, JSFunctionDef *s,
                                           JSAtom var_name, int scope_level,
                                           int op, DynBuf *bc) {
  int idx, var_kind;
  BOOL is_ref;

  idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s, var_name,
                                     scope_level);
  if (idx < 0) return -1;
  assert(var_kind != JS_VAR_NORMAL);
  switch (op) {
    case OP_scope_get_private_field:
    case OP_scope_get_private_field2:
      switch (var_kind) {
        case JS_VAR_PRIVATE_FIELD:
          if (op == OP_scope_get_private_field2) dbuf_putc(bc, OP_dup);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_get_private_field);
          break;
        case JS_VAR_PRIVATE_METHOD:
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_check_brand);
          if (op != OP_scope_get_private_field2) dbuf_putc(bc, OP_nip);
          break;
        case JS_VAR_PRIVATE_GETTER:
        case JS_VAR_PRIVATE_GETTER_SETTER:
          if (op == OP_scope_get_private_field2) dbuf_putc(bc, OP_dup);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_check_brand);
          dbuf_putc(bc, OP_call_method);
          dbuf_put_u16(bc, 0);
          break;
        case JS_VAR_PRIVATE_SETTER:
          /* XXX: add clearer error message */
          dbuf_putc(bc, OP_throw_var);
          if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
          dbuf_put_u32(bc, var_name);
          dbuf_putc(bc, JS_THROW_VAR_RO);
          break;
        default:
          abort();
      }
      break;
    case OP_scope_put_private_field:
      switch (var_kind) {
        case JS_VAR_PRIVATE_FIELD:
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_put_private_field);
          break;
        case JS_VAR_PRIVATE_METHOD:
        case JS_VAR_PRIVATE_GETTER:
          /* XXX: add clearer error message */
          dbuf_putc(bc, OP_throw_var);
          if (!ctx->gc_enable) LEPUS_DupAtom(ctx, var_name);
          dbuf_put_u32(bc, var_name);
          dbuf_putc(bc, JS_THROW_VAR_RO);
          break;
        case JS_VAR_PRIVATE_SETTER:
        case JS_VAR_PRIVATE_GETTER_SETTER: {
          JSAtom setter_name = get_private_setter_name(ctx, var_name);
          if (setter_name == JS_ATOM_NULL) return -1;
          HandleScope func_scope(ctx->rt);
          func_scope.PushLEPUSAtom(setter_name);
          idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s,
                                             setter_name, scope_level);
          if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, setter_name);
          if (idx < 0) return -1;
          assert(var_kind == JS_VAR_PRIVATE_SETTER);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_swap);
          /* obj func value */
          dbuf_putc(bc, OP_rot3r);
          /* value obj func */
          dbuf_putc(bc, OP_check_brand);
          dbuf_putc(bc, OP_rot3l);
          /* obj func value */
          dbuf_putc(bc, OP_call_method);
          dbuf_put_u16(bc, 1);
        } break;
        default:
          abort();
      }
      break;
    default:
      abort();
  }
  return 0;
}

QJS_STATIC void mark_eval_captured_variables(LEPUSContext *ctx,
                                             JSFunctionDef *s,
                                             int scope_level) {
  int idx;
  JSVarDef *vd;

  for (idx = s->scopes[scope_level].first; idx >= 0;) {
    vd = &s->vars[idx];
    vd->is_captured = 1;
    idx = vd->scope_next;
  }
}

BOOL is_var_in_arg_scope(LEPUSContext *ctx, const JSVarDef *vd) {
  JSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
  BOOL ret =
      (vd->var_name == JS_ATOM_home_object ||
       vd->var_name == JS_ATOM_this_active_func ||
       vd->var_name == JS_ATOM_new_target || vd->var_name == JS_ATOM_this ||
       vd->var_name == atom_arg_var || vd->var_kind == JS_VAR_FUNCTION_NAME);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom_arg_var);
  return ret;
}

QJS_STATIC void add_eval_variables(LEPUSContext *ctx, JSFunctionDef *s) {
  JSFunctionDef *fd;
  JSVarDef *vd;
  int i, scope_level, scope_idx;
  BOOL has_arguments_binding, has_this_binding, is_arg_scope;

  /* in non strict mode, variables are created in the caller's
     environment object */
  if (!s->is_eval && !(s->js_mode & JS_MODE_STRICT)) {
    s->var_object_idx = add_var(ctx, s, JS_ATOM__var_);
    if (s->has_parameter_expressions) {
      /* an additional variable object is needed for the
         argument scope */
      JSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
      HandleScope func_scope(ctx->rt);
      func_scope.PushLEPUSAtom(atom_arg_var);
      s->arg_var_object_idx = add_var(ctx, s, atom_arg_var);
      if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom_arg_var);
    }
  }

  /* eval can potentially use 'arguments' so we must define it */
  has_this_binding = s->has_this_binding;
  if (has_this_binding) {
    if (s->this_var_idx < 0) s->this_var_idx = add_var_this(ctx, s);
    if (s->new_target_var_idx < 0)
      s->new_target_var_idx = add_var(ctx, s, JS_ATOM_new_target);
    if (s->is_derived_class_constructor && s->this_active_func_var_idx < 0)
      s->this_active_func_var_idx = add_var(ctx, s, JS_ATOM_this_active_func);
    if (s->has_home_object && s->home_object_var_idx < 0)
      s->home_object_var_idx = add_var(ctx, s, JS_ATOM_home_object);
  }
  has_arguments_binding = s->has_arguments_binding;
  if (has_arguments_binding) {
    add_arguments_var(ctx, s, JS_ATOM_arguments);
    if (s->has_parameter_expressions && !(s->js_mode & JS_MODE_STRICT))
      add_arguments_arg(ctx, s);
  }
  if (s->is_func_expr && s->func_name != JS_ATOM_NULL)
    add_func_var(ctx, s, s->func_name);

  /* eval can use all the variables of the enclosing functions, so
     they must be all put in the closure. The closure variables are
     ordered by scope. It works only because no closure are created
     before. */
  assert(s->is_eval || s->closure_var_count == 0);

  /* XXX: inefficient, but eval performance is less critical */
  fd = s;
  for (;;) {
    scope_level = fd->parent_scope_level;
    fd = fd->parent;
    if (!fd) break;
    /* add 'this' if it was not previously added */
    if (!has_this_binding && fd->has_this_binding) {
      if (fd->this_var_idx < 0) fd->this_var_idx = add_var_this(ctx, fd);
      if (fd->new_target_var_idx < 0)
        fd->new_target_var_idx = add_var(ctx, fd, JS_ATOM_new_target);
      if (fd->is_derived_class_constructor && fd->this_active_func_var_idx < 0)
        fd->this_active_func_var_idx =
            add_var(ctx, fd, JS_ATOM_this_active_func);
      if (fd->has_home_object && fd->home_object_var_idx < 0)
        fd->home_object_var_idx = add_var(ctx, fd, JS_ATOM_home_object);
      has_this_binding = TRUE;
    }
    /* add 'arguments' if it was not previously added */
    if (!has_arguments_binding && fd->has_arguments_binding) {
      add_arguments_var(ctx, fd, JS_ATOM_arguments);
      has_arguments_binding = TRUE;
    }
    /* add function name */
    if (fd->is_func_expr && fd->func_name != JS_ATOM_NULL)
      add_func_var(ctx, fd, fd->func_name);

    /* add lexical variables */
    scope_idx = fd->scopes[scope_level].first;
    while (scope_idx >= 0) {
      vd = &fd->vars[scope_idx];
      vd->is_captured = 1;
      get_closure_var(ctx, s, fd, FALSE, scope_idx, vd->var_name, vd->is_const,
                      vd->is_lexical, static_cast<JSVarKindEnum>(vd->var_kind));
      scope_idx = vd->scope_next;
    }
    is_arg_scope = (scope_idx == ARG_SCOPE_END);
    if (!is_arg_scope) {
      /* add unscoped variables */
      for (i = 0; i < fd->arg_count; i++) {
        vd = &fd->args[i];
        if (vd->var_name != JS_ATOM_NULL) {
          get_closure_var(ctx, s, fd, TRUE, i, vd->var_name, FALSE,
                          vd->is_lexical, JS_VAR_NORMAL);
        }
      }
      for (i = 0; i < fd->var_count; i++) {
        vd = &fd->vars[i];
        /* do not close top level last result */
        if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_ &&
            vd->var_name != JS_ATOM_NULL) {
          get_closure_var(ctx, s, fd, FALSE, i, vd->var_name, FALSE,
                          vd->is_lexical, JS_VAR_NORMAL);
        }
      }
    } else {
      for (i = 0; i < fd->var_count; i++) {
        vd = &fd->vars[i];
        /* do not close top level last result */
        if (vd->scope_level == 0 && is_var_in_arg_scope(ctx, vd)) {
          get_closure_var(ctx, s, fd, FALSE, i, vd->var_name, FALSE,
                          vd->is_lexical, JS_VAR_NORMAL);
        }
      }
      if (fd->is_eval) {
        int idx;
        /* add direct eval variables (we are necessarily at the
          top level) */
        for (idx = 0; idx < fd->closure_var_count; idx++) {
          LEPUSClosureVar *cv = &fd->closure_var[idx];
          get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx, cv->var_name,
                           cv->is_const, cv->is_lexical,
                           static_cast<JSVarKindEnum>(cv->var_kind));
        }
      }
    }
  }
}

QJS_STATIC void set_closure_from_var(LEPUSContext *ctx, LEPUSClosureVar *cv,
                                     JSVarDef *vd, int var_idx) {
  cv->is_local = TRUE;
  cv->is_arg = FALSE;
  cv->is_const = vd->is_const;
  cv->is_lexical = vd->is_lexical;
  cv->var_kind = vd->var_kind;
  cv->var_idx = var_idx;
  cv->var_name =
      ctx->gc_enable ? vd->var_name : LEPUS_DupAtom(ctx, vd->var_name);
}

/* for direct eval compilation: add references to the variables of the
   calling function */
__exception int add_closure_variables(LEPUSContext *ctx, JSFunctionDef *s,
                                      LEPUSFunctionBytecode *b, int scope_idx) {
  int i, count;
  JSVarDef *vd;
  BOOL is_arg_scope;

  count = b->arg_count + b->var_count + b->closure_var_count;
  s->closure_var = NULL;
  s->closure_var_count = 0;
  s->closure_var_size = count;
  if (count == 0) return 0;
  s->closure_var = static_cast<LEPUSClosureVar *>(lepus_malloc(
      ctx, sizeof(s->closure_var[0]) * count, ALLOC_TAG_WITHOUT_PTR));
  if (!s->closure_var) return -1;
  /* Add lexical variables in scope at the point of evaluation */
  if (scope_idx == DEBUG_SCOPE_INDEX) {
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level > 0) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  } else {
    for (i = scope_idx; i >= 0;) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level > 0) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
      i = vd->scope_next;
    }
  }
  is_arg_scope = (i == ARG_SCOPE_END);
  if (!is_arg_scope) {
    /* Add argument variables */
    for (i = 0; i < b->arg_count; i++) {
      LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
      vd = &b->vardefs[i];
      cv->is_local = TRUE;
      cv->is_arg = TRUE;
      cv->is_const = FALSE;
      cv->is_lexical = FALSE;
      cv->var_kind = JS_VAR_NORMAL;
      cv->var_idx = i;
      cv->var_name =
          ctx->gc_enable ? vd->var_name : LEPUS_DupAtom(ctx, vd->var_name);
    }
    /* Add local non lexical variables */
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  } else {
    /* only add pseudo variables */
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level == 0 && is_var_in_arg_scope(ctx, vd)) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  }
  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv0 = &b->closure_var[i];
    LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
    cv->is_local = FALSE;
    cv->is_arg = cv0->is_arg;
    cv->is_const = cv0->is_const;
    cv->is_lexical = cv0->is_lexical;
    cv->var_kind = cv0->var_kind;
    cv->var_idx = i;
    cv->var_name =
        ctx->gc_enable ? cv0->var_name : LEPUS_DupAtom(ctx, cv0->var_name);
  }
  return 0;
}

typedef struct CodeContext {
  const uint8_t *bc_buf; /* code buffer */
  int bc_len;            /* length of the code buffer */
  int pos;               /* position past the matched code pattern */
  // <Primjs begin>
  int64_t line_num; /* last visited OP_line_num parameter or -1 */
  // <Primjs end>
  int op;
  int idx;
  int label;
  int val;
  JSAtom atom;
} CodeContext;

#define M2(op1, op2) ((op1) | ((op2) << 8))
#define M3(op1, op2, op3) ((op1) | ((op2) << 8) | ((op3) << 16))
#define M4(op1, op2, op3, op4) \
  ((op1) | ((op2) << 8) | ((op3) << 16) | ((op4) << 24))

QJS_STATIC BOOL code_match(CodeContext *s, int pos, ...) {
  const uint8_t *tab = s->bc_buf;
  // <Primjs begin>
  int op, len, op1, pos_next;
  int64_t line_num;
  // <Primjs end>
  va_list ap;
  BOOL ret = FALSE;

  line_num = -1;
  va_start(ap, pos);

  for (;;) {
    op1 = va_arg(ap, int);
    if (op1 == -1) {
      s->pos = pos;
      s->line_num = line_num;
      ret = TRUE;
      break;
    }
    for (;;) {
      if (pos >= s->bc_len) goto done;
      op = tab[pos];
      len = opcode_info[op].size;
      pos_next = pos + len;
      if (pos_next > s->bc_len) goto done;
      // <Primjs begin>
      if (op == OP_line_num) {
        line_num = get_u64(tab + pos + 1);
        pos = pos_next;
      }
      // <Primjs end>
      else {
        break;
      }
    }
    if (op != op1) {
      if (op1 == (uint8_t)op1 || !op) break;
      if (op != (uint8_t)op1 && op != (uint8_t)(op1 >> 8) &&
          op != (uint8_t)(op1 >> 16) && op != (uint8_t)(op1 >> 24)) {
        break;
      }
      s->op = op;
    }

    pos++;
    switch (opcode_info[op].fmt) {
      case OP_FMT_loc8:
      case OP_FMT_u8: {
        int idx = tab[pos];
        int arg = va_arg(ap, int);
        if (arg == -1) {
          s->idx = idx;
        } else {
          if (arg != idx) goto done;
        }
        break;
      }
      case OP_FMT_u16:
      case OP_FMT_npop:
      case OP_FMT_loc:
      case OP_FMT_arg:
      case OP_FMT_var_ref: {
        int idx = get_u16(tab + pos);
        int arg = va_arg(ap, int);
        if (arg == -1) {
          s->idx = idx;
        } else {
          if (arg != idx) goto done;
        }
        break;
      }
      case OP_FMT_i32:
      case OP_FMT_u32:
      case OP_FMT_label:
      case OP_FMT_const: {
        s->label = get_u32(tab + pos);
        break;
      }
      // <Primjs begin>
      case OP_FMT_u64: {
        s->label = get_u64(tab + pos);
        break;
      }
      // <Primjs end>
      case OP_FMT_label_u16: {
        s->label = get_u32(tab + pos);
        s->val = get_u16(tab + pos + 4);
        break;
      }
      case OP_FMT_atom: {
        s->atom = get_u32(tab + pos);
        break;
      }
      case OP_FMT_atom_u8: {
        s->atom = get_u32(tab + pos);
        s->val = get_u8(tab + pos + 4);
        break;
      }
      case OP_FMT_atom_u16: {
        s->atom = get_u32(tab + pos);
        s->val = get_u16(tab + pos + 4);
        break;
      }
      case OP_FMT_atom_label_u8: {
        s->atom = get_u32(tab + pos);
        s->label = get_u32(tab + pos + 4);
        s->val = get_u8(tab + pos + 8);
        break;
      }
      default:
        break;
    }
    pos = pos_next;
  }
done:
  va_end(ap);
  return ret;
}

QJS_STATIC void instantiate_hoisted_definitions(LEPUSContext *ctx,
                                                JSFunctionDef *s, DynBuf *bc) {
  int i, idx, var_idx, label_next;
  bool is_rc = !ctx->gc_enable;

  /* add the hoisted functions and variables */
  for (i = 0; i < s->arg_count; i++) {
    JSVarDef *vd = &s->args[i];
    if (vd->func_pool_idx >= 0) {
      dbuf_putc(bc, OP_fclosure);
      dbuf_put_u32(bc, vd->func_pool_idx);
      dbuf_putc(bc, OP_put_arg);
      dbuf_put_u16(bc, i);
    }
  }
  for (i = 0; i < s->var_count; i++) {
    JSVarDef *vd = &s->vars[i];
    if (vd->scope_level == 0 && vd->func_pool_idx >= 0) {
      dbuf_putc(bc, OP_fclosure);
      dbuf_put_u32(bc, vd->func_pool_idx);
      dbuf_putc(bc, OP_put_loc);
      dbuf_put_u16(bc, i);
    }
  }

  /* the module global variables must be initialized before
     evaluating the module so that the exported functions are
     visible if there are cyclic module references */
  if (s->module) {
    label_next = new_label_fd(s, -1);

    /* if 'this' is true, initialize the global variables and return */
    dbuf_putc(bc, OP_push_this);
    dbuf_putc(bc, OP_if_false);
    dbuf_put_u32(bc, label_next);
    update_label(s, label_next, 1);
    s->jump_size++;
  }
  /* add the global variables (only happens if s->is_global_var is
     true) */
  for (i = 0; i < s->hoisted_def_count; i++) {
    JSHoistedDef *hf = &s->hoisted_def[i];
    int has_closure = 0;
    BOOL force_init = hf->force_init;
    // if (s->is_global_var && hf->var_name != JS_ATOM_NULL) {
    /* we are in an eval, so the closure contains all the
       enclosing variables */
    /* If the outer function has a variable environment,
       create a property for the variable there */
    JSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
    HandleScope func_scope(ctx->rt);
    func_scope.PushLEPUSAtom(atom_arg_var);
    for (idx = 0; idx < s->closure_var_count; idx++) {
      LEPUSClosureVar *cv = &s->closure_var[idx];
      if (cv->var_name == hf->var_name) {
        has_closure = 2;
        force_init = FALSE;
        break;
      }
      if (cv->var_name == JS_ATOM__var_ || cv->var_name == atom_arg_var) {
        dbuf_putc(bc, OP_get_var_ref);
        dbuf_put_u16(bc, idx);
        has_closure = 1;
        force_init = TRUE;
        break;
      }
    }
    if (is_rc) LEPUS_FreeAtom(ctx, atom_arg_var);
    if (!has_closure) {
      int flags;

      flags = 0;
      if (s->eval_type != LEPUS_EVAL_TYPE_GLOBAL)
        flags |= LEPUS_PROP_CONFIGURABLE;
      if (hf->cpool_idx >= 0 && !hf->is_lexical) {
        /* global function definitions need a specific handling */
        dbuf_putc(bc, OP_fclosure);
        dbuf_put_u32(bc, hf->cpool_idx);

        dbuf_putc(bc, OP_define_func);
        if (is_rc) LEPUS_DupAtom(ctx, hf->var_name);
        dbuf_put_u32(bc, hf->var_name);
        dbuf_putc(bc, flags);

        goto done_hoisted_def;
      } else {
        if (hf->is_lexical) {
          flags |= DEFINE_GLOBAL_LEX_VAR;
          if (!hf->is_const) flags |= LEPUS_PROP_WRITABLE;
        }
        dbuf_putc(bc, OP_define_var);
        if (is_rc) LEPUS_DupAtom(ctx, hf->var_name);
        dbuf_put_u32(bc, hf->var_name);
        dbuf_putc(bc, flags);
      }
    }
    // }
    if (hf->cpool_idx >= 0 || force_init) {
      if (hf->cpool_idx >= 0) {
        dbuf_putc(bc, OP_fclosure);
        dbuf_put_u32(bc, hf->cpool_idx);
        if (hf->var_name == JS_ATOM__default_) {
          /* set default export function name */
          dbuf_putc(bc, OP_set_name);
          if (is_rc) LEPUS_DupAtom(ctx, JS_ATOM_default);
          dbuf_put_u32(bc, JS_ATOM_default);
        }
      } else {
        dbuf_putc(bc, OP_undefined);
      }
      // if (s->is_global_var) {
      if (has_closure == 2) {
        dbuf_putc(bc, OP_put_var_ref);
        dbuf_put_u16(bc, idx);
      } else if (has_closure == 1) {
        dbuf_putc(bc, OP_define_field);
        if (is_rc) LEPUS_DupAtom(ctx, hf->var_name);
        dbuf_put_u32(bc, hf->var_name);
        dbuf_putc(bc, OP_drop);
      } else {
        /* XXX: Check if variable is writable and enumerable */
        dbuf_putc(bc, OP_put_var);
        if (is_rc) LEPUS_DupAtom(ctx, hf->var_name);
        dbuf_put_u32(bc, hf->var_name);
      }
    }
  done_hoisted_def:
    if (is_rc) LEPUS_FreeAtom(ctx, hf->var_name);
  }
  if (s->module) {
    dbuf_putc(bc, OP_return_undef);

    dbuf_putc(bc, OP_label);
    dbuf_put_u32(bc, label_next);
    s->label_slots[label_next].pos2 = bc->size;
  }

  if (is_rc) lepus_free(ctx, s->hoisted_def);
  s->hoisted_def = NULL;
  s->hoisted_def_count = 0;
  s->hoisted_def_size = 0;
}

QJS_STATIC int skip_dead_code(
    JSFunctionDef *s, const uint8_t *bc_buf, int bc_len, int pos,
    /* Primjs begin */ int64_t *linep /*Primjs end*/) {
  int op, len, label;

  for (; pos < bc_len; pos += len) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    // <Primjs begin>
    if (op == OP_line_num) {
      *linep = get_u64(bc_buf + pos + 1);
    }
    // <Primjs end>
    else if (op == OP_label) {
      label = get_u32(bc_buf + pos + 1);
      if (update_label(s, label, 0) > 0) break;
#if 0
            if (s->label_slots[label].first_reloc) {
                printf("line %d: unreferenced label %d:%d has relocations\n",
                       *linep, label, s->label_slots[label].pos2);
            }
#endif
      assert(s->label_slots[label].first_reloc == NULL);
    } else {
      /* XXX: output a warning for unreachable code? */
      JSAtom atom;
      switch (opcode_info[op].fmt) {
        case OP_FMT_label:
        case OP_FMT_label_u16:
          label = get_u32(bc_buf + pos + 1);
          update_label(s, label, -1);
          break;
        case OP_FMT_atom_label_u8:
        case OP_FMT_atom_label_u16:
          label = get_u32(bc_buf + pos + 5);
          update_label(s, label, -1);
          /* fall thru */
        case OP_FMT_atom:
        case OP_FMT_atom_u8:
        case OP_FMT_atom_u16:
          atom = get_u32(bc_buf + pos + 1);
          if (!s->ctx->gc_enable) LEPUS_FreeAtom(s->ctx, atom);
          break;
        default:
          break;
      }
    }
  }
  return pos;
}

QJS_STATIC int get_label_pos(JSFunctionDef *s, int label) {
  int i, pos;
  for (i = 0; i < 20; i++) {
    pos = s->label_slots[label].pos;
    for (;;) {
      switch (s->byte_code.buf[pos]) {
        // <Primjs begin>
        case OP_line_num:
          pos += 9;
          continue;
        // <Primjs end>
        case OP_label:
          pos += 5;
          continue;
        case OP_goto:
          label = get_u32(s->byte_code.buf + pos + 1);
          break;
        default:
          return pos;
      }
      break;
    }
  }
  return pos;
}

/* convert global variable accesses to local variables or closure
   variables when necessary */
__exception int resolve_variables(LEPUSContext *ctx, JSFunctionDef *s) {
  // <Primjs begin>
  int pos, pos_next, bc_len, op, len, i, idx;
  int64_t line_num;
  // <Primjs end>

  uint8_t *bc_buf;
  JSAtom var_name;
  DynBuf bc_out;
  CodeContext cc;
  int scope;

  cc.bc_buf = bc_buf = s->byte_code.buf;
  cc.bc_len = bc_len = s->byte_code.size;
  js_dbuf_init(ctx, &bc_out);
  HandleScope func_scope(ctx, &bc_out.buf, HANDLE_TYPE_HEAP_OBJ);

  /* first pass for runtime checks (must be done before the
     variables are created) */
  JSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
  func_scope.PushLEPUSAtom(atom_arg_var);
  for (i = 0; i < s->hoisted_def_count; i++) {
    JSHoistedDef *hf = &s->hoisted_def[i];
    int flags;

    /* check if global variable (XXX: simplify) */
    for (idx = 0; idx < s->closure_var_count; idx++) {
      LEPUSClosureVar *cv = &s->closure_var[idx];
      if (cv->var_name == hf->var_name) {
        if (s->eval_type == LEPUS_EVAL_TYPE_DIRECT && cv->is_lexical) {
          /* Check if a lexical variable is
             redefined as 'var'. XXX: Could abort
             compilation here, but for consistency
             with the other checks, we delay the
             error generation. */
          dbuf_putc(&bc_out, OP_throw_var);
          if (!ctx->gc_enable) LEPUS_DupAtom(ctx, hf->var_name);
          dbuf_put_u32(&bc_out, hf->var_name);
          dbuf_putc(&bc_out, JS_THROW_VAR_REDECL);
        }
        goto next;
      }
      if (cv->var_name == JS_ATOM__var_ || cv->var_name == atom_arg_var)
        goto next;
    }

    dbuf_putc(&bc_out, OP_check_define_var);
    if (!ctx->gc_enable) LEPUS_DupAtom(ctx, hf->var_name);
    dbuf_put_u32(&bc_out, hf->var_name);
    flags = 0;
    if (hf->is_lexical) flags |= DEFINE_GLOBAL_LEX_VAR;
    if (hf->cpool_idx >= 0) flags |= DEFINE_GLOBAL_FUNC_VAR;
    dbuf_putc(&bc_out, flags);
  next:;
  }
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom_arg_var);

  line_num = 0; /* avoid warning */
  for (pos = 0; pos < bc_len; pos = pos_next) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    switch (op) {
      case OP_line_num:
        // <Primjs begin>
        line_num = get_u64(bc_buf + pos + 1);
        // <Primjs end>
        s->line_number_size++;
        goto no_change;

      case OP_eval: /* convert scope index to adjusted variable index */
        scope = get_u16(bc_buf + pos + 1);
        mark_eval_captured_variables(ctx, s, scope);
        dbuf_putc(&bc_out, op);
        dbuf_put_u16(&bc_out, s->scopes[scope].first + 1);
        break;
      case OP_scope_get_var_undef:
      case OP_scope_get_var:
      case OP_scope_put_var:
      case OP_scope_delete_var:
      case OP_scope_get_ref:
      case OP_scope_put_var_init:
        var_name = get_u32(bc_buf + pos + 1);
        scope = get_u16(bc_buf + pos + 5);
        pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out, NULL,
                                     NULL, pos_next);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, var_name);
        break;
      case OP_scope_make_ref: {
        int label;
        LabelSlot *ls;
        var_name = get_u32(bc_buf + pos + 1);
        label = get_u32(bc_buf + pos + 5);
        scope = get_u16(bc_buf + pos + 9);
        ls = &s->label_slots[label];
        ls->ref_count--; /* always remove label reference */
        pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
                                     bc_buf, ls, pos_next);
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, var_name);
      } break;
      case OP_scope_get_private_field:
      case OP_scope_get_private_field2:
      case OP_scope_put_private_field: {
        int ret;
        var_name = get_u32(bc_buf + pos + 1);
        scope = get_u16(bc_buf + pos + 5);
        ret = resolve_scope_private_field(ctx, s, var_name, scope, op, &bc_out);
        if (ret < 0) goto fail;
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, var_name);
      } break;
      case OP_gosub:
        s->jump_size++;
        if (OPTIMIZE) {
          /* remove calls to empty finalizers  */
          int label;
          LabelSlot *ls;

          label = get_u32(bc_buf + pos + 1);
          assert(label >= 0 && label < s->label_count);
          ls = &s->label_slots[label];
          if (code_match(&cc, ls->pos, OP_ret, -1)) {
            ls->ref_count--;
            break;
          }
        }
        goto no_change;
      case OP_drop:
        if (0) {
          /* remove drops before return_undef */
          /* do not perform this optimization in pass2 because
             it breaks patterns recognised in resolve_labels */
          int pos1 = pos_next;
          // <Primjs begin>
          int64_t line1 = line_num;
          // <Primjs end>
          while (code_match(&cc, pos1, OP_drop, -1)) {
            if (cc.line_num >= 0) line1 = cc.line_num;
            pos1 = cc.pos;
          }
          if (code_match(&cc, pos1, OP_return_undef, -1)) {
            pos_next = pos1;
            if (line1 != -1 && line1 != line_num) {
              line_num = line1;
              s->line_number_size++;
              dbuf_putc(&bc_out, OP_line_num);
              // <Primjs begin>
              dbuf_put_u64(&bc_out, line_num);
              // <Primjs end>
            }
            break;
          }
        }
        goto no_change;
      case OP_insert3:
        if (OPTIMIZE) {
          /* Transformation: insert3 put_array_el|put_ref_value drop ->
           * put_array_el|put_ref_value */
          if (code_match(&cc, pos_next, M2(OP_put_array_el, OP_put_ref_value),
                         OP_drop, -1)) {
            dbuf_putc(&bc_out, cc.op);
            pos_next = cc.pos;
            if (cc.line_num != -1 && cc.line_num != line_num) {
              line_num = cc.line_num;
              s->line_number_size++;
              dbuf_putc(&bc_out, OP_line_num);
              // <Primjs begin>
              dbuf_put_u64(&bc_out, line_num);
              // <Primjs end>
            }
            break;
          }
        }
        goto no_change;

      case OP_goto:
        s->jump_size++;
        /* fall thru */
      case OP_tail_call:
      case OP_tail_call_method:
      case OP_return:
      case OP_return_undef:
      case OP_throw:
      case OP_throw_var:
      case OP_ret:
        if (OPTIMIZE) {
          /* remove dead code */
          // <Primjs begin>
          int64_t line = -1;
          // <Primjs end>
          dbuf_put(&bc_out, bc_buf + pos, len);
          pos = skip_dead_code(s, bc_buf, bc_len, pos + len, &line);
          pos_next = pos;
          if (pos < bc_len && line >= 0 && line_num != line) {
            line_num = line;
            s->line_number_size++;
            dbuf_putc(&bc_out, OP_line_num);
            // <Primjs begin>
            dbuf_put_u64(&bc_out, line_num);
            // <Primjs end>
          }
          break;
        }
        goto no_change;

      case OP_label: {
        int label;
        LabelSlot *ls;

        label = get_u32(bc_buf + pos + 1);
        assert(label >= 0 && label < s->label_count);
        ls = &s->label_slots[label];
        ls->pos2 = bc_out.size + opcode_info[op].size;
      }
        goto no_change;

      case OP_enter_scope: {
        int scope_idx, scope = get_u16(bc_buf + pos + 1);

        if (scope == s->body_scope) {
          instantiate_hoisted_definitions(ctx, s, &bc_out);
        }

        for (scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
          JSVarDef *vd = &s->vars[scope_idx];
          if (vd->scope_level == scope) {
            if (scope_idx != s->arguments_arg_idx) {
              if (vd->var_kind == JS_VAR_FUNCTION_DECL ||
                  vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) {
                /* Initialize lexical variable upon entering scope */
                dbuf_putc(&bc_out, OP_fclosure);
                dbuf_put_u32(&bc_out, vd->func_pool_idx);
                dbuf_putc(&bc_out, OP_put_loc);
                dbuf_put_u16(&bc_out, scope_idx);
              } else {
                /* XXX: should check if variable can be used
                  before initialization */
                dbuf_putc(&bc_out, OP_set_loc_uninitialized);
                dbuf_put_u16(&bc_out, scope_idx);
              }
            }
            scope_idx = vd->scope_next;
          } else {
            break;
          }
        }
      } break;

      case OP_leave_scope: {
        int scope_idx, scope = get_u16(bc_buf + pos + 1);

        for (scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
          JSVarDef *vd = &s->vars[scope_idx];
          if (vd->scope_level == scope) {
            if (vd->is_captured) {
              dbuf_putc(&bc_out, OP_close_loc);
              dbuf_put_u16(&bc_out, scope_idx);
            }
            scope_idx = vd->scope_next;
          } else {
            break;
          }
        }
      } break;

      case OP_set_name: {
        /* remove dummy set_name opcodes */
        JSAtom name = get_u32(bc_buf + pos + 1);
        if (name == JS_ATOM_NULL) break;
      }
        goto no_change;

      case OP_if_false:
      case OP_if_true:
      case OP_catch:
        s->jump_size++;
        goto no_change;

      case OP_dup:
        if (OPTIMIZE) {
          /* Transformation: dup if_false(l1) drop, l1: if_false(l2) ->
           * if_false(l2) */
          /* Transformation: dup if_true(l1) drop, l1: if_true(l2) ->
           * if_true(l2) */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), OP_drop,
                         -1)) {
            int lab0, lab1, op1, pos1, line1, pos2;
            lab0 = lab1 = cc.label;
            assert(lab1 >= 0 && lab1 < s->label_count);
            op1 = cc.op;
            pos1 = cc.pos;
            line1 = cc.line_num;
            while (code_match(&cc, (pos2 = get_label_pos(s, lab1)), OP_dup, op1,
                              OP_drop, -1)) {
              lab1 = cc.label;
            }
            if (code_match(&cc, pos2, op1, -1)) {
              s->jump_size++;
              update_label(s, lab0, -1);
              update_label(s, cc.label, +1);
              dbuf_putc(&bc_out, op1);
              dbuf_put_u32(&bc_out, cc.label);
              pos_next = pos1;
              if (line1 != -1 && line1 != line_num) {
                line_num = line1;
                s->line_number_size++;
                dbuf_putc(&bc_out, OP_line_num);
                // <Primjs begin>
                dbuf_put_u64(&bc_out, line_num);
                // <Primjs end>
              }
              break;
            }
          }
        }
        goto no_change;

      case OP_nop:
        /* remove erased code */
        break;

      default:
      no_change:
        dbuf_put(&bc_out, bc_buf + pos, len);
        break;
    }
  }

  /* set the new byte code */
  if (!ctx->gc_enable) dbuf_free(&s->byte_code);
  s->byte_code = bc_out;
  if (dbuf_error(&s->byte_code)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return -1;
  }
  return 0;
fail:
  /* continue the copy to keep the atom refcounts consistent */
  /* XXX: find a better solution ? */
  for (; pos < bc_len; pos = pos_next) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    dbuf_put(&bc_out, bc_buf + pos, len);
  }
  if (!ctx->gc_enable) dbuf_free(&s->byte_code);
  s->byte_code = bc_out;
  return -1;
}

/* the pc2line table gives a line number for each PC value */
QJS_STATIC void add_pc2line_info(
    JSFunctionDef *s, uint32_t pc,
    /* <Primjs begin> */ int64_t line_num /* <Primjs end>*/) {
  if (s->line_number_slots != NULL &&
      s->line_number_count < s->line_number_size &&
      pc >= s->line_number_last_pc && line_num != s->line_number_last) {
    s->line_number_slots[s->line_number_count].pc = pc;
    s->line_number_slots[s->line_number_count].line_num = line_num;
    s->line_number_count++;
    s->line_number_last_pc = pc;
    s->line_number_last = line_num;
  }
}

QJS_STATIC void compute_pc2line_info(JSFunctionDef *s) {
  if (!(s->js_mode & JS_MODE_STRIP) && s->line_number_slots) {
    // <Primjs begin>
    int64_t last_line_num = s->line_num;
    // <Primjs end>
    uint32_t last_pc = 0;
    int i;

    js_dbuf_init(s->ctx, &s->pc2line);
    for (i = 0; i < s->line_number_count; i++) {
      uint32_t pc = s->line_number_slots[i].pc;
      // <Primjs begin>
      int64_t line_num = s->line_number_slots[i].line_num;
      int64_t diff_pc, diff_line;
      // <Primjs end>

      if (line_num < 0) continue;

      diff_pc = pc - last_pc;
      diff_line = line_num - last_line_num;
      if (diff_line == 0 || diff_pc < 0) continue;

      if (diff_line >= PC2LINE_BASE &&
          diff_line < PC2LINE_BASE + PC2LINE_RANGE &&
          diff_pc <= PC2LINE_DIFF_PC_MAX) {
        dbuf_putc(&s->pc2line, (diff_line - PC2LINE_BASE) +
                                   diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);
      } else {
        /* longer encoding */
        dbuf_putc(&s->pc2line, 0);
        // <Primjs begin>
        dbuf_put_leb128_u64(&s->pc2line, diff_pc);
        dbuf_put_sleb128_u64(&s->pc2line, diff_line);
        // <Primjs end>
      }
      last_pc = pc;
      last_line_num = line_num;
    }
  }
}

QJS_STATIC RelocEntry *add_reloc(LEPUSContext *ctx, LabelSlot *ls,
                                 uint32_t addr, int size) {
  RelocEntry *re;
  re = static_cast<RelocEntry *>(
      lepus_malloc(ctx, sizeof(*re), ALLOC_TAG_WITHOUT_PTR));
  if (!re) return NULL;
  re->addr = addr;
  re->size = size;
  re->next = ls->first_reloc;
  ls->first_reloc = re;
  return re;
}

QJS_STATIC BOOL code_has_label(CodeContext *s, int pos, int label) {
  while (pos < s->bc_len) {
    int op = s->bc_buf[pos];
    if (op == OP_line_num) {
      // <Primjs begin>
      pos += 9;
      // <Primjs end>
      continue;
    }
    if (op == OP_label) {
      int lab = get_u32(s->bc_buf + pos + 1);
      if (lab == label) return TRUE;
      pos += 5;
      continue;
    }
    if (op == OP_goto) {
      int lab = get_u32(s->bc_buf + pos + 1);
      if (lab == label) return TRUE;
    }
    break;
  }
  return FALSE;
}

/* return the target label, following the OP_goto jumps
   the first opcode at destination is stored in *pop
 */
QJS_STATIC int find_jump_target(
    JSFunctionDef *s, int label, int *pop,
    /* <Primjs begin> */ int64_t *pline /* <Primjs end>*/) {
  int i, pos, op;

  update_label(s, label, -1);
  for (i = 0; i < 10; i++) {
    assert(label >= 0 && label < s->label_count);
    pos = s->label_slots[label].pos2;
    for (;;) {
      switch (op = s->byte_code.buf[pos]) {
        case OP_line_num:
          // <Primjs begin>
          if (pline) *pline = get_u64(s->byte_code.buf + pos + 1);
          // <Primjs end>
          /* fall thru */
        case OP_label:
          pos += opcode_info[op].size;
          continue;
        case OP_goto:
          label = get_u32(s->byte_code.buf + pos + 1);
          break;
        case OP_drop:
          /* ignore drop opcodes if followed by OP_return_undef */
          while (s->byte_code.buf[++pos] == OP_drop) continue;
          if (s->byte_code.buf[pos] == OP_return_undef) op = OP_return_undef;
          /* fall thru */
        default:
          goto done;
      }
      break;
    }
  }
  /* cycle detected, could issue a warning */
done:
  *pop = op;
  update_label(s, label, +1);
  return label;
}

QJS_STATIC void push_short_int(DynBuf *bc_out, int val) {
#if SHORT_OPCODES
  if (val >= -1 && val <= 7) {
    dbuf_putc(bc_out, OP_push_0 + val);
    return;
  }
  if (val == (int8_t)val) {
    dbuf_putc(bc_out, OP_push_i8);
    dbuf_putc(bc_out, val);
    return;
  }
  if (val == (int16_t)val) {
    dbuf_putc(bc_out, OP_push_i16);
    dbuf_put_u16(bc_out, val);
    return;
  }
#endif
  dbuf_putc(bc_out, OP_push_i32);
  dbuf_put_u32(bc_out, val);
}

QJS_STATIC void put_short_code(DynBuf *bc_out, int op, int idx) {
#if SHORT_OPCODES
  if (idx < 4) {
    switch (op) {
      case OP_get_loc:
        dbuf_putc(bc_out, OP_get_loc0 + idx);
        return;
      case OP_put_loc:
        dbuf_putc(bc_out, OP_put_loc0 + idx);
        return;
      case OP_set_loc:
        dbuf_putc(bc_out, OP_set_loc0 + idx);
        return;
      case OP_get_arg:
        dbuf_putc(bc_out, OP_get_arg0 + idx);
        return;
      case OP_put_arg:
        dbuf_putc(bc_out, OP_put_arg0 + idx);
        return;
      case OP_set_arg:
        dbuf_putc(bc_out, OP_set_arg0 + idx);
        return;
      case OP_get_var_ref:
        dbuf_putc(bc_out, OP_get_var_ref0 + idx);
        return;
      case OP_put_var_ref:
        dbuf_putc(bc_out, OP_put_var_ref0 + idx);
        return;
      case OP_set_var_ref:
        dbuf_putc(bc_out, OP_set_var_ref0 + idx);
        return;
      case OP_call:
        dbuf_putc(bc_out, OP_call0 + idx);
        return;
    }
  }
  if (idx < 256) {
    switch (op) {
      case OP_get_loc:
        dbuf_putc(bc_out, OP_get_loc8);
        dbuf_putc(bc_out, idx);
        return;
      case OP_put_loc:
        dbuf_putc(bc_out, OP_put_loc8);
        dbuf_putc(bc_out, idx);
        return;
      case OP_set_loc:
        dbuf_putc(bc_out, OP_set_loc8);
        dbuf_putc(bc_out, idx);
        return;
    }
  }
#endif
  dbuf_putc(bc_out, op);
  dbuf_put_u16(bc_out, idx);
}

bool emit_name_str(JSParseState *s, const uint8_t *start, const uint8_t *end) {
  if (static_cast<int32_t>(end - start) < 0) return false;
  auto *cur_func = s->cur_func;
  if (cur_func->caller_count >= cur_func->caller_size) {
    // realloc.
    auto new_size = cur_func->caller_size ? 2 * cur_func->caller_size : 4;
    cur_func->caller_slots = static_cast<CallerStrSlot *>(
        lepus_realloc(s->ctx, cur_func->caller_slots,
                      new_size * sizeof(CallerStrSlot), ALLOC_TAG_WITHOUT_PTR));
    if (cur_func->caller_slots == nullptr) return false;
    cur_func->caller_size = new_size;
  }
  cur_func->caller_slots[cur_func->caller_count].pc = 0;
  cur_func->caller_slots[cur_func->caller_count].size = end - start;
  cur_func->caller_slots[cur_func->caller_count].is_str = false;
  cur_func->caller_slots[cur_func->caller_count].off =
      reinterpret_cast<const char *>(start) - cur_func->src_start;
  emit_op(s, OP_caller_str);
  cur_func->caller_count++;
  return true;
}

static void add_pc2name_info(JSFunctionDef *s, uint32_t pc) {
  if (s->should_add_slot) {
    s->caller_slots[s->resolve_caller_count++].pc = pc;
    s->should_add_slot = false;
  }
  return;
}

void get_caller_string(JSFunctionDef *s) {
  for (uint32_t i = 0, size = s->caller_count; i < size; ++i) {
    auto &slot = s->caller_slots[i];
    slot.str = lepus_strndup(s->ctx, s->src_start + slot.off, slot.size,
                             ALLOC_TAG_WITHOUT_PTR);
    slot.is_str = true;
  }
  return;
}

static void free_caller_slot(LEPUSRuntime *rt, CallerStrSlot *&slots,
                             uint32_t size) {
  for (uint32_t i = 0; i < size; ++i) {
    auto &slot = slots[i];
    if (slot.is_str) {
      lepus_free_rt(rt, (void *)slot.str);
    }
  }
  lepus_free_rt(rt, slots);
  slots = nullptr;
  return;
}

void find_name_info(const LEPUSFunctionBytecode *b, uint32_t pc, DynBuf *s) {
  if (!(b->has_debug && b->debug.caller_size)) return;

  for (uint32_t i = 0, size = b->debug.caller_size; i < size; ++i) {
    auto &slot = b->debug.caller_slots[i];
    if (slot.pc == pc) {
      if (slot.is_str)
        dbuf_putstr(s, slot.str);
      else
        dbuf_put(s,
                 reinterpret_cast<const uint8_t *>(b->debug.source + slot.off),
                 slot.size);
    } else if (slot.pc > pc)
      break;
  }
  dbuf_putc(s, '\0');
  return;
}

/* peephole optimizations and resolve goto/labels */
__exception int resolve_labels(LEPUSContext *ctx, JSFunctionDef *s) {
  // <Primjs begin>
  int pos, pos_next, bc_len, op, op1, len, i;
  int64_t line_num;
  // <Primjs end>
  const uint8_t *bc_buf;
  DynBuf bc_out;
  LabelSlot *label_slots, *ls;
  RelocEntry *re, *re_next;
  CodeContext cc;
  int label;
#if SHORT_OPCODES
  JumpSlot *jp;
#endif

  label_slots = s->label_slots;

  line_num = s->line_num;

  s->resolve_caller_count = 0;
  // encode line_num to line_col_num
  line_num =
      (uint64_t)((uint64_t)line_num | ((uint64_t)1 << LINE_NUMBER_BITS_COUNT) |
                 (uint64_t)1 << LINE_COLUMN_TYPE_SHIFT);

  cc.bc_buf = bc_buf = s->byte_code.buf;
  cc.bc_len = bc_len = s->byte_code.size;
  js_dbuf_init(ctx, &bc_out);
  HandleScope func_scope(ctx, &bc_out.buf, HANDLE_TYPE_HEAP_OBJ);

#if SHORT_OPCODES
  if (s->jump_size) {
    s->jump_slots = static_cast<JumpSlot *>(lepus_mallocz(
        s->ctx, sizeof(*s->jump_slots) * s->jump_size, ALLOC_TAG_WITHOUT_PTR));
    if (s->jump_slots == NULL) return -1;
  }
#endif
  /* XXX: Should skip this phase if not generating SHORT_OPCODES */
  if (s->line_number_size && !(s->js_mode & JS_MODE_STRIP)) {
    s->line_number_slots = static_cast<LineNumberSlot *>(lepus_mallocz(
        s->ctx, sizeof(*s->line_number_slots) * s->line_number_size,
        ALLOC_TAG_WITHOUT_PTR));
    if (s->line_number_slots == NULL) return -1;
    s->line_number_last = s->line_num;
    s->line_number_last_pc = 0;
  }

  /* initialize the 'home_object' variable if needed */
  if (s->home_object_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_HOME_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->home_object_var_idx);
  }
  /* initialize the 'this.active_func' variable if needed */
  if (s->this_active_func_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
    put_short_code(&bc_out, OP_put_loc, s->this_active_func_var_idx);
  }
  /* initialize the 'new.target' variable if needed */
  if (s->new_target_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_NEW_TARGET);
    put_short_code(&bc_out, OP_put_loc, s->new_target_var_idx);
  }
  /* initialize the 'this' variable if needed. In a derived class
     constructor, this is initially uninitialized. */
  if (s->this_var_idx >= 0) {
    if (s->is_derived_class_constructor) {
      dbuf_putc(&bc_out, OP_set_loc_uninitialized);
      dbuf_put_u16(&bc_out, s->this_var_idx);
    } else {
      dbuf_putc(&bc_out, OP_push_this);
      put_short_code(&bc_out, OP_put_loc, s->this_var_idx);
    }
  }
  /* initialize the 'arguments' variable if needed */
  if (s->arguments_var_idx >= 0) {
    if ((s->js_mode & JS_MODE_STRICT) || !s->has_simple_parameter_list) {
      dbuf_putc(&bc_out, OP_special_object);
      dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_ARGUMENTS);
    } else {
      dbuf_putc(&bc_out, OP_special_object);
      dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS);
    }
    if (s->arguments_arg_idx >= 0)
      put_short_code(&bc_out, OP_set_loc, s->arguments_arg_idx);
    put_short_code(&bc_out, OP_put_loc, s->arguments_var_idx);
  }
  /* initialize a reference to the current function if needed */
  if (s->func_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
    put_short_code(&bc_out, OP_put_loc, s->func_var_idx);
  }
  /* initialize the variable environment object if needed */
  if (s->var_object_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
  }

  if (s->arg_var_object_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->arg_var_object_idx);
  }

  for (pos = 0; pos < bc_len; pos = pos_next) {
    int val;
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    switch (op) {
      case OP_close_var_object: {
        if (s->var_object_idx >= 0) {
          /* close the var object and create a new one */
          add_pc2line_info(s, bc_out.size, line_num);
          dbuf_putc(&bc_out, OP_close_loc);
          dbuf_put_u16(&bc_out, s->var_object_idx);
          dbuf_putc(&bc_out, OP_special_object);
          dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
          put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
        }
      } break;

      case OP_line_num:
        /* line number info (for debug). We put it in a separate
           compressed table to reduce memory usage and get better
           performance */
        // <Primjs begin>
        line_num = get_u64(bc_buf + pos + 1);
        // <Primjs end>
        break;

      case OP_label: {
        label = get_u32(bc_buf + pos + 1);
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
        assert(ls->addr == -1);
        ls->addr = bc_out.size;
        /* resolve the relocation entries */
        for (re = ls->first_reloc; re != NULL; re = re_next) {
          int diff = ls->addr - re->addr;
          re_next = re->next;
          switch (re->size) {
            case 4:
              put_u32(bc_out.buf + re->addr, diff);
              break;
            case 2:
              assert(diff == (int16_t)diff);
              put_u16(bc_out.buf + re->addr, diff);
              break;
            case 1:
              assert(diff == (int8_t)diff);
              put_u8(bc_out.buf + re->addr, diff);
              break;
          }
          if (!ctx->gc_enable) lepus_free(ctx, re);
        }
        ls->first_reloc = NULL;
      } break;

      case OP_caller_str:
        s->should_add_slot = true;
        break;

      case OP_call_constructor:
        add_pc2line_info(s, bc_out.size, line_num);
        dbuf_put(&bc_out, bc_buf + pos, len);
        add_pc2name_info(s, bc_out.size);
        break;

      case OP_call:
      case OP_call_method: {
        /* detect and transform tail calls */
        int argc;
        argc = get_u16(bc_buf + pos + 1);
        if (code_match(&cc, pos_next, OP_return, -1)) {
          if (cc.line_num >= 0) line_num = cc.line_num;
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op + 1, argc);
          pos_next = skip_dead_code(s, bc_buf, bc_len, cc.pos, &line_num);
          add_pc2name_info(s, bc_out.size);
          break;
        }
        add_pc2line_info(s, bc_out.size, line_num);
        put_short_code(&bc_out, op, argc);
        add_pc2name_info(s, bc_out.size);
        break;
      }
        goto no_change;

      case OP_return:
      case OP_return_undef:
      case OP_return_async:
      case OP_throw:
      case OP_throw_var:
        pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
        goto no_change;

      case OP_goto:
        label = get_u32(bc_buf + pos + 1);
      has_goto:
        if (OPTIMIZE) {
          // <Primjs begin>
          int64_t line1 = -1;
          // <Primjs end>;
          /* Use custom matcher because multiple labels can follow */
          label = find_jump_target(s, label, &op1, &line1);
          if (code_has_label(&cc, pos_next, label)) {
            /* jump to next instruction: remove jump */
            update_label(s, label, -1);
            break;
          }
          if (op1 == OP_return || op1 == OP_return_undef || op1 == OP_throw) {
            /* jump to return/throw: remove jump, append return/throw */
            /* updating the line number obfuscates assembly listing */
            // if (line1 >= 0) line_num = line1;
            update_label(s, label, -1);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, op1);
            pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
            break;
          }
          /* XXX: should duplicate single instructions followed by goto or
           * return */
          /* For example, can match one of these followed by return:
             push_i32 / push_const / push_atom_value / get_var /
             undefined / null / push_false / push_true / get_ref_value /
             get_loc / get_arg / get_var_ref
           */
        }
        goto has_label;

      case OP_gosub:
        label = get_u32(bc_buf + pos + 1);
        if (0 && OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
          if (op1 == OP_ret) {
            update_label(s, label, -1);
            /* empty finally clause: remove gosub */
            break;
          }
        }
        goto has_label;

      case OP_catch:
        label = get_u32(bc_buf + pos + 1);
        goto has_label;

      case OP_if_true:
      case OP_if_false:
        label = get_u32(bc_buf + pos + 1);
        if (OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
          /* transform if_false/if_true(l1) label(l1) -> drop label(l1) */
          if (code_has_label(&cc, pos_next, label)) {
            update_label(s, label, -1);
            dbuf_putc(&bc_out, OP_drop);
            break;
          }
          /* transform if_false(l1) goto(l2) label(l1) -> if_false(l2) label(l1)
           */
          if (code_match(&cc, pos_next, OP_goto, -1)) {
            int pos1 = cc.pos;
            // <Primjs begin>
            int64_t line1 = cc.line_num;
            // <Primjs end>;
            if (code_has_label(&cc, pos1, label)) {
              if (line1 >= 0) line_num = line1;
              pos_next = pos1;
              update_label(s, label, -1);
              label = cc.label;
              op ^= OP_if_true ^ OP_if_false;
            }
          }
        }
      has_label:
        add_pc2line_info(s, bc_out.size, line_num);
        if (op == OP_goto) {
          pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
        }
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
#if SHORT_OPCODES
        jp = &s->jump_slots[s->jump_count++];
        jp->op = op;
        jp->size = 4;
        jp->pos = bc_out.size + 1;
        jp->label = label;

        if (ls->addr == -1) {
          int diff = ls->pos2 - pos - 1;
          if (diff < 128 &&
              (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
            jp->size = 1;
            jp->op = OP_if_false8 + (op - OP_if_false);
            dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
            dbuf_putc(&bc_out, 0);
            if (!add_reloc(ctx, ls, bc_out.size - 1, 1)) goto fail;
            break;
          }
          if (diff < 32768 && op == OP_goto) {
            jp->size = 2;
            jp->op = OP_goto16;
            dbuf_putc(&bc_out, OP_goto16);
            dbuf_put_u16(&bc_out, 0);
            if (!add_reloc(ctx, ls, bc_out.size - 2, 2)) goto fail;
            break;
          }
        } else {
          int diff = ls->addr - bc_out.size - 1;
          if (diff == (int8_t)diff &&
              (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
            jp->size = 1;
            jp->op = OP_if_false8 + (op - OP_if_false);
            dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
            dbuf_putc(&bc_out, diff);
            break;
          }
          if (diff == (int16_t)diff && op == OP_goto) {
            jp->size = 2;
            jp->op = OP_goto16;
            dbuf_putc(&bc_out, OP_goto16);
            dbuf_put_u16(&bc_out, diff);
            break;
          }
        }
#endif
        dbuf_putc(&bc_out, op);
        dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
        if (ls->addr == -1) {
          /* unresolved yet: create a new relocation entry */
          if (!add_reloc(ctx, ls, bc_out.size - 4, 4)) goto fail;
        }
        break;
      case OP_with_get_var:
      case OP_with_put_var:
      case OP_with_delete_var:
      case OP_with_make_ref:
      case OP_with_get_ref:
      case OP_with_get_ref_undef: {
        JSAtom atom;
        int is_with;

        atom = get_u32(bc_buf + pos + 1);
        label = get_u32(bc_buf + pos + 5);
        is_with = bc_buf[pos + 9];
        if (OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
        }
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
        add_pc2line_info(s, bc_out.size, line_num);
#if SHORT_OPCODES
        jp = &s->jump_slots[s->jump_count++];
        jp->op = op;
        jp->size = 4;
        jp->pos = bc_out.size + 5;
        jp->label = label;
#endif
        dbuf_putc(&bc_out, op);
        dbuf_put_u32(&bc_out, atom);
        dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
        if (ls->addr == -1) {
          /* unresolved yet: create a new relocation entry */
          if (!add_reloc(ctx, ls, bc_out.size - 4, 4)) goto fail;
        }
        dbuf_putc(&bc_out, is_with);
      } break;

      case OP_drop:
        if (OPTIMIZE) {
          /* remove useless drops before return */
          if (code_match(&cc, pos_next, OP_return_undef, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            break;
          }
        }
        goto no_change;

      case OP_null:
#if SHORT_OPCODES
        if (OPTIMIZE) {
          /* transform null strict_eq into is_null */
          if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_null);
            pos_next = cc.pos;
            break;
          }
          /* transform null strict_neq if_false/if_true -> is_null
           * if_true/if_false */
          if (code_match(&cc, pos_next, OP_strict_neq,
                         M2(OP_if_false, OP_if_true), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_null);
            pos_next = cc.pos;
            label = cc.label;
            op = cc.op ^ OP_if_false ^ OP_if_true;
            goto has_label;
          }
        }
#endif
        /* fall thru */
      case OP_push_false:
      case OP_push_true:
        if (OPTIMIZE) {
          val = (op == OP_push_true);
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
          has_constant_test:
            if (cc.line_num >= 0) line_num = cc.line_num;
            if (val == cc.op - OP_if_false) {
              /* transform null if_false(l1) -> goto l1 */
              /* transform false if_false(l1) -> goto l1 */
              /* transform true if_true(l1) -> goto l1 */
              pos_next = cc.pos;
              op = OP_goto;
              label = cc.label;
              goto has_goto;
            } else {
              /* transform null if_true(l1) -> nop */
              /* transform false if_true(l1) -> nop */
              /* transform true if_false(l1) -> nop */
              pos_next = cc.pos;
              update_label(s, cc.label, -1);
              break;
            }
          }
        }
        goto no_change;

      case OP_push_i32:
        if (OPTIMIZE) {
          /* transform i32(val) neg -> i32(-val) */
          val = get_i32(bc_buf + pos + 1);
          if ((val != INT32_MIN && val != 0) &&
              code_match(&cc, pos_next, OP_neg, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            if (code_match(&cc, cc.pos, OP_drop, -1)) {
              if (cc.line_num >= 0) line_num = cc.line_num;
            } else {
              add_pc2line_info(s, bc_out.size, line_num);
              push_short_int(&bc_out, -val);
            }
            pos_next = cc.pos;
            break;
          }
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
          /* Optimize constant tests: `if (0)`, `if (1)`, `if (!0)`... */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
            val = (val != 0);
            goto has_constant_test;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          push_short_int(&bc_out, val);
          break;
        }
        goto no_change;

#if SHORT_OPCODES
      case OP_push_const:
      case OP_fclosure:
        if (OPTIMIZE) {
          int idx = get_u32(bc_buf + pos + 1);
          if (idx < 256) {
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_push_const8 + op - OP_push_const);
            dbuf_putc(&bc_out, idx);
            break;
          }
        }
        goto no_change;

      case OP_get_field:
        if (OPTIMIZE) {
          JSAtom atom = get_u32(bc_buf + pos + 1);
          if (atom == JS_ATOM_length) {
            if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_get_length);
            break;
          }
        }
        goto no_change;
#endif
      case OP_push_atom_value:
        if (OPTIMIZE) {
          JSAtom atom = get_u32(bc_buf + pos + 1);
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
#if SHORT_OPCODES
          if (atom == JS_ATOM_empty_string) {
            if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_push_empty_string);
            break;
          }
#endif
        }
        goto no_change;

      case OP_to_propkey:
      case OP_to_propkey2:
        if (OPTIMIZE) {
          /* remove redundant to_propkey/to_propkey2 opcodes when storing simple
           * data */
          if (code_match(&cc, pos_next,
                         M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1,
                         OP_put_array_el, -1) ||
              code_match(&cc, pos_next,
                         M3(OP_push_i32, OP_push_const, OP_push_atom_value),
                         OP_put_array_el, -1) ||
              code_match(&cc, pos_next,
                         M4(OP_undefined, OP_null, OP_push_true, OP_push_false),
                         OP_put_array_el, -1)) {
            break;
          }
        }
        goto no_change;

      case OP_undefined:
        if (OPTIMIZE) {
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
          /* transform undefined return -> return_undefined */
          if (code_match(&cc, pos_next, OP_return, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_return_undef);
            pos_next = cc.pos;
            break;
          }
          /* transform undefined if_true(l1)/if_false(l1) -> nop/goto(l1) */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
            val = 0;
            goto has_constant_test;
          }
#if SHORT_OPCODES
          /* transform undefined strict_eq -> is_undefined */
          if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_undefined);
            pos_next = cc.pos;
            break;
          }
          /* transform undefined strict_neq if_false/if_true -> is_undefined
           * if_true/if_false */
          if (code_match(&cc, pos_next, OP_strict_neq,
                         M2(OP_if_false, OP_if_true), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_undefined);
            pos_next = cc.pos;
            label = cc.label;
            op = cc.op ^ OP_if_false ^ OP_if_true;
            goto has_label;
          }
#endif
        }
        goto no_change;

      case OP_insert2:
        if (OPTIMIZE) {
          /* Transformation:
             insert2 put_field(a) drop -> put_field(a)
             insert2 put_var_strict(a) drop -> put_var_strict(a)
          */
          if (code_match(&cc, pos_next, M2(OP_put_field, OP_put_var_strict),
                         OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, cc.op);
            dbuf_put_u32(&bc_out, cc.atom);
            pos_next = cc.pos;
            break;
          }
        }
        goto no_change;

      case OP_dup:
        if (OPTIMIZE) {
          /* Transformation: dup put_x(n) drop -> put_x(n) */
          // <Primjs begin>
          int op1 = -1;
          int64_t line2 = -1;
          // <Primjs end>
          /* Transformation: dup put_x(n) -> set_x(n) */
          if (code_match(&cc, pos_next,
                         M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            op1 = cc.op + 1; /* put_x -> set_x */
            pos_next = cc.pos;
            if (code_match(&cc, cc.pos, OP_drop, -1)) {
              if (cc.line_num >= 0) line_num = cc.line_num;
              op1 -= 1; /* set_x drop -> put_x */
              pos_next = cc.pos;
              if (code_match(&cc, cc.pos, op1 - 1, cc.idx, -1)) {
                line2 = cc.line_num; /* delay line number update */
                op1 += 1;            /* put_x(n) get_x(n) -> set_x(n) */
                pos_next = cc.pos;
              }
            }
            add_pc2line_info(s, bc_out.size, line_num);
            put_short_code(&bc_out, op1, cc.idx);
            if (line2 >= 0) line_num = line2;
            break;
          }
        }
        goto no_change;

      case OP_get_loc:
        if (OPTIMIZE) {
          /* transformation:
             get_loc(n) post_dec put_loc(n) drop -> dec_loc(n)
             get_loc(n) post_inc put_loc(n) drop -> inc_loc(n)
             get_loc(n) dec dup put_loc(n) drop -> dec_loc(n)
             get_loc(n) inc dup put_loc(n) drop -> inc_loc(n)
           */
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          if (idx >= 256) goto no_change;
          if (code_match(&cc, pos_next, M2(OP_post_dec, OP_post_inc),
                         OP_put_loc, idx, OP_drop, -1) ||
              code_match(&cc, pos_next, M2(OP_dec, OP_inc), OP_dup, OP_put_loc,
                         idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, (cc.op == OP_inc || cc.op == OP_post_inc)
                                   ? OP_inc_loc
                                   : OP_dec_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation:
             get_loc(n) push_atom_value(x) add dup put_loc(n) drop ->
             push_atom_value(x) add_loc(n)
           */
          if (code_match(&cc, pos_next, OP_push_atom_value, OP_add, OP_dup,
                         OP_put_loc, idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
#if SHORT_OPCODES
            if (cc.atom == JS_ATOM_empty_string) {
              if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, cc.atom);
              dbuf_putc(&bc_out, OP_push_empty_string);
            } else
#endif
            {
              dbuf_putc(&bc_out, OP_push_atom_value);
              dbuf_put_u32(&bc_out, cc.atom);
            }
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation:
             get_loc(n) push_i32(x) add dup put_loc(n) drop -> push_i32(x)
             add_loc(n)
           */
          if (code_match(&cc, pos_next, OP_push_i32, OP_add, OP_dup, OP_put_loc,
                         idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            push_short_int(&bc_out, cc.label);
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation: XXX: also do these:
             get_loc(n) get_loc(x) add dup put_loc(n) drop -> get_loc(x)
             add_loc(n) get_loc(n) get_arg(x) add dup put_loc(n) drop ->
             get_arg(x) add_loc(n) get_loc(n) get_var_ref(x) add dup put_loc(n)
             drop -> get_var_ref(x) add_loc(n)
           */
          if (code_match(&cc, pos_next,
                         M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_add,
                         OP_dup, OP_put_loc, idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            put_short_code(&bc_out, cc.op, cc.idx);
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;
#if SHORT_OPCODES
      case OP_get_arg:
      case OP_get_var_ref:
        if (OPTIMIZE) {
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;
#endif
      case OP_put_loc:
      case OP_put_arg:
      case OP_put_var_ref:
        if (OPTIMIZE) {
          /* transformation: put_x(n) get_x(n) -> set_x(n) */
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          if (code_match(&cc, pos_next, op - 1, idx, -1)) {
            add_pc2line_info(s, bc_out.size, line_num);
            if (cc.line_num >= 0) line_num = cc.line_num;
            put_short_code(&bc_out, op + 1, idx);
            pos_next = cc.pos;
            break;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;

      case OP_post_inc:
      case OP_post_dec:
        if (OPTIMIZE) {
          /* transformation:
             post_inc put_x drop -> inc put_x
             post_inc perm3 put_field drop -> inc put_field
             post_inc perm3 put_var_strict drop -> inc put_var_strict
             post_inc perm4 put_array_el drop -> inc put_array_el
           */
          int op1, idx;
          if (code_match(&cc, pos_next,
                         M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1,
                         OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            op1 = cc.op;
            idx = cc.idx;
            pos_next = cc.pos;
            if (code_match(&cc, cc.pos, op1 - 1, idx, -1)) {
              op1 += 1; /* put_x(n) get_x(n) -> set_x(n) */
              pos_next = cc.pos;
              add_pc2line_info(s, bc_out.size, line_num);
              if (cc.line_num >= 0) line_num = cc.line_num;
            } else {
              add_pc2line_info(s, bc_out.size, line_num);
            }
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            put_short_code(&bc_out, op1, idx);
            break;
          }
          if (code_match(&cc, pos_next, OP_perm3,
                         M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            dbuf_putc(&bc_out, cc.op);
            dbuf_put_u32(&bc_out, cc.atom);

            pos_next = cc.pos;
            break;
          }
          if (code_match(&cc, pos_next, OP_perm4, OP_put_array_el, OP_drop,
                         -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            dbuf_putc(&bc_out, OP_put_array_el);
            pos_next = cc.pos;
            break;
          }
        }
        goto no_change;

      case OP_typeof:
        if (OPTIMIZE) {
          /* simplify typeof tests */
          if (code_match(&cc, pos_next, OP_push_atom_value,
                         M4(OP_strict_eq, OP_strict_neq, OP_eq, OP_neq), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            int op1 = (cc.op == OP_strict_eq || cc.op == OP_eq) ? OP_strict_eq
                                                                : OP_strict_neq;
#if SHORT_OPCODES
            int op2 = -1;
            switch (cc.atom) {
              case JS_ATOM_undefined:
                op2 = OP_is_undefined;
                break;
              case JS_ATOM_function:
                op2 = OP_is_function;
                break;
            }
            if (op2 >= 0) {
              /* transform typeof(s) == "<type>" into is_<type> */
              if (op1 == OP_strict_eq) {
                add_pc2line_info(s, bc_out.size, line_num);
                dbuf_putc(&bc_out, op2);
                if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, cc.atom);
                pos_next = cc.pos;
                break;
              }
              if (op1 == OP_strict_neq &&
                  code_match(&cc, cc.pos, OP_if_false, -1)) {
                /* transform typeof(s) != "<type>" if_false into is_<type>
                 * if_true */
                if (cc.line_num >= 0) line_num = cc.line_num;
                add_pc2line_info(s, bc_out.size, line_num);
                dbuf_putc(&bc_out, op2);
                if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, cc.atom);
                pos_next = cc.pos;
                label = cc.label;
                op = OP_if_true;
                goto has_label;
              }
            }
#endif
            if (cc.atom == JS_ATOM_undefined) {
              /* transform typeof(s) == "undefined" into s === void 0 */
              add_pc2line_info(s, bc_out.size, line_num);
              dbuf_putc(&bc_out, OP_undefined);
              dbuf_putc(&bc_out, op1);
              if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, cc.atom);
              pos_next = cc.pos;
              break;
            }
          }
        }
        goto no_change;

      default:
      no_change:
        add_pc2line_info(s, bc_out.size, line_num);
        dbuf_put(&bc_out, bc_buf + pos, len);
        break;
    }
  }

  /* check that there were no missing labels */
  for (i = 0; i < s->label_count; i++) {
    assert(label_slots[i].first_reloc == NULL);
  }
#if SHORT_OPCODES
  if (OPTIMIZE) {
    /* more jump optimizations */
    int patch_offsets = 0;
    for (i = 0, jp = s->jump_slots; i < s->jump_count; i++, jp++) {
      LabelSlot *ls;
      JumpSlot *jp1;
      int j, pos, diff, delta;

      delta = 3;
      switch (op = jp->op) {
        case OP_goto16:
          delta = 1;
          /* fall thru */
        case OP_if_false:
        case OP_if_true:
        case OP_goto:
          pos = jp->pos;
          diff = s->label_slots[jp->label].addr - pos;
          if (diff >= -128 && diff <= 127 + delta) {
            jp->size = 1;
            if (op == OP_goto16) {
              bc_out.buf[pos - 1] = jp->op = OP_goto8;
            } else {
              bc_out.buf[pos - 1] = jp->op = OP_if_false8 + (op - OP_if_false);
            }
            goto shrink;
          } else if (diff == (int16_t)diff && op == OP_goto) {
            jp->size = 2;
            delta = 2;
            bc_out.buf[pos - 1] = jp->op = OP_goto16;
          shrink:
            /* XXX: should reduce complexity, using 2 finger copy scheme */
            memmove(bc_out.buf + pos + jp->size,
                    bc_out.buf + pos + jp->size + delta,
                    bc_out.size - pos - jp->size - delta);
            bc_out.size -= delta;
            patch_offsets++;
            for (j = 0, ls = s->label_slots; j < s->label_count; j++, ls++) {
              if (ls->addr > pos) ls->addr -= delta;
            }
            for (j = i + 1, jp1 = jp + 1; j < s->jump_count; j++, jp1++) {
              if (jp1->pos > pos) jp1->pos -= delta;
            }
            for (j = 0; j < s->line_number_count; j++) {
              if (s->line_number_slots[j].pc > pos)
                s->line_number_slots[j].pc -= delta;
            }

            for (j = 0; j < s->caller_count; ++j) {
              if (s->caller_slots[j].pc > pos) {
                s->caller_slots[j].pc -= delta;
              }
            }
            continue;
          }
          break;
      }
    }
    if (patch_offsets) {
      JumpSlot *jp1;
      int j;
      for (j = 0, jp1 = s->jump_slots; j < s->jump_count; j++, jp1++) {
        int diff1 = s->label_slots[jp1->label].addr - jp1->pos;
        switch (jp1->size) {
          case 1:
            put_u8(bc_out.buf + jp1->pos, diff1);
            break;
          case 2:
            put_u16(bc_out.buf + jp1->pos, diff1);
            break;
          case 4:
            put_u32(bc_out.buf + jp1->pos, diff1);
            break;
        }
      }
    }
  }
  if (!ctx->gc_enable) lepus_free(ctx, s->jump_slots);
  s->jump_slots = NULL;
#endif
  if (!ctx->gc_enable) lepus_free(ctx, s->label_slots);
  s->label_slots = NULL;
  /* XXX: should delay until copying to runtime bytecode function */
  compute_pc2line_info(s);
  if (!ctx->gc_enable) {
    lepus_free(ctx, s->line_number_slots);
    dbuf_free(&s->byte_code);
  }
  s->line_number_slots = NULL;
  /* set the new byte code */
  s->byte_code = bc_out;
  s->use_short_opcodes = TRUE;
  if (dbuf_error(&s->byte_code)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return -1;
  }
  return 0;
fail:
  /* XXX: not safe */
  if (!ctx->gc_enable) dbuf_free(&bc_out);
  return -1;
}

/* compute the maximum stack size needed by the function */

typedef struct StackSizeState {
  int stack_len_max;
  uint16_t *stack_level_tab;
} StackSizeState;

QJS_STATIC __exception int compute_stack_size_rec(LEPUSContext *ctx,
                                                  JSFunctionDef *fd,
                                                  StackSizeState *s, int pos,
                                                  int op, int stack_len) {
  int bc_len, diff, n_pop, pos_next;
  const JSOpCode *oi;
  const uint8_t *bc_buf;

  if (stack_len > s->stack_len_max) {
    s->stack_len_max = stack_len;
    if (s->stack_len_max > JS_STACK_SIZE_MAX) goto stack_overflow;
  }
  bc_buf = fd->byte_code.buf;
  bc_len = fd->byte_code.size;
  for (;;) {
    if ((unsigned)pos >= bc_len) goto buf_overflow;
#if 0
        printf("%5d: %d\n", pos, stack_len);
#endif
    if (s->stack_level_tab[pos] != 0xffff) {
      /* already explored: check that the stack size is consistent */
      if (s->stack_level_tab[pos] != stack_len) {
        if (!ctx->rt->settings_option.disable_adjust_stacksize) {
          s->stack_level_tab[pos] = max_int(stack_len, s->stack_level_tab[pos]);
        } else {
          LEPUS_ThrowInternalError(ctx,
                                   "unconsistent stack size: %d %d (pc=%d)",
                                   s->stack_level_tab[pos], stack_len, pos);
          return -1;
        }
      } else {
        return 0;
      }
    } else {
      s->stack_level_tab[pos] = stack_len;
    }

    op = bc_buf[pos];
    if (op == 0 || op >= OP_COUNT) {
      LEPUS_ThrowInternalError(ctx, "invalid opcode (op=%d, pc=%d)", op, pos);
      return -1;
    }
    oi = &short_opcode_info(op);
    pos_next = pos + oi->size;
    if (pos_next > bc_len) {
    buf_overflow:
      LEPUS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)",
                               op, pos);
      return -1;
    }
    n_pop = oi->n_pop;
    /* call pops a variable number of arguments */
    if (oi->fmt == OP_FMT_npop) {
      n_pop += get_u16(bc_buf + pos + 1);
    } else {
#if SHORT_OPCODES
      if (oi->fmt == OP_FMT_npopx) {
        n_pop += op - OP_call0;
      }
#endif
    }

    if (stack_len < n_pop) {
      LEPUS_ThrowInternalError(ctx, "stack underflow (op=%d, pc=%d)", op, pos);
      return -1;
    }
    stack_len += oi->n_push - n_pop;
    if (stack_len > s->stack_len_max) {
      s->stack_len_max = stack_len;
      if (s->stack_len_max > JS_STACK_SIZE_MAX) goto stack_overflow;
    }
    switch (op) {
      case OP_tail_call:
      case OP_tail_call_method:
      case OP_return:
      case OP_return_undef:
      case OP_return_async:
      case OP_throw:
      case OP_throw_var:
      case OP_ret:
        goto done;
      case OP_goto:
        diff = get_u32(bc_buf + pos + 1);
        pos_next = pos + 1 + diff;
        break;
#if SHORT_OPCODES
      case OP_goto16:
        diff = (int16_t)get_u16(bc_buf + pos + 1);
        pos_next = pos + 1 + diff;
        break;
      case OP_goto8:
        diff = (int8_t)bc_buf[pos + 1];
        pos_next = pos + 1 + diff;
        break;
      case OP_if_true8:
      case OP_if_false8:
        diff = (int8_t)bc_buf[pos + 1];
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
          return -1;
        break;
#endif
      case OP_if_true:
      case OP_if_false:
      case OP_catch:
        diff = get_u32(bc_buf + pos + 1);
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
          return -1;
        break;
      case OP_gosub:
        diff = get_u32(bc_buf + pos + 1);
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op,
                                   stack_len + 1))
          return -1;
        break;
      case OP_with_get_var:
      case OP_with_delete_var:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len + 1))
          return -1;
        break;
      case OP_with_make_ref:
      case OP_with_get_ref:
      case OP_with_get_ref_undef:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len + 2))
          return -1;
        break;
      case OP_with_put_var:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len - 1))
          return -1;
        break;

      default:
        break;
    }
    pos = pos_next;
  }
done:
  return 0;

stack_overflow:
  LEPUS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
  return -1;
}

QJS_STATIC __exception int compute_stack_size(LEPUSContext *ctx,
                                              JSFunctionDef *fd,
                                              int *pstack_size) {
  StackSizeState s_s, *s = &s_s;
  int bc_len, i, ret;

  bc_len = fd->byte_code.size;
  /* bc_len > 0 */
  s->stack_level_tab = static_cast<uint16_t *>(
      system_malloc(sizeof(s->stack_level_tab[0]) * bc_len));
  if (!s->stack_level_tab) return -1;
  for (i = 0; i < bc_len; i++) s->stack_level_tab[i] = 0xffff;
  s->stack_len_max = 0;
  ret = compute_stack_size_rec(ctx, fd, s, 0, OP_invalid, 0);
  system_free(s->stack_level_tab);
  *pstack_size = s->stack_len_max;
  return ret;
}

QJS_STATIC int add_module_variables(LEPUSContext *ctx, JSFunctionDef *fd) {
  int i, idx;
  LEPUSModuleDef *m = fd->module;
  JSExportEntry *me;
  JSHoistedDef *hf;

  /* The imported global variables were added as closure variables
     in js_parse_import(). We add here the module global
     variables. */

  for (i = 0; i < fd->hoisted_def_count; i++) {
    hf = &fd->hoisted_def[i];
    if (add_closure_var(ctx, fd, TRUE, FALSE, i, hf->var_name, hf->is_const,
                        hf->is_lexical, static_cast<JSVarKindEnum>(FALSE)) < 0)
      return -1;
  }

  /* resolve the variable names of the local exports */
  for (i = 0; i < m->export_entries_count; i++) {
    me = &m->export_entries[i];
    if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
      idx = find_closure_var(ctx, fd, me->local_name);
      if (idx < 0) {
        JS_ThrowSyntaxErrorAtom(ctx, "exported variable '%s' does not exist",
                                me->local_name);
        return -1;
      }
      me->u.local.var_idx = idx;
    }
  }
  return 0;
}

#ifdef TEST_BYTECODE_REWRITE
// Test only function.
static LEPUSValue force_read_from_snapshot(LEPUSContext *ctx,
                                           LEPUSFunctionBytecode *b) {
  LEPUSValue b_v = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
  size_t out_buf_len;
  uint8_t *out_buf =
      LEPUS_WriteObject(ctx, &out_buf_len, b_v, LEPUS_WRITE_OBJ_BYTECODE);
  LEPUS_FreeValue(ctx, b_v);
  b_v = LEPUS_ReadObject(ctx, out_buf, out_buf_len, LEPUS_READ_OBJ_BYTECODE);
  lepus_free(ctx, out_buf);
  return b_v;
}
#endif

// <primjs end>

/* create a function object from a function definition. The function
   definition is freed. All the child functions are also created. It
   must be done this way to resolve all the variables. */
LEPUSValue js_create_function(LEPUSContext *ctx, JSFunctionDef *fd) {
  LEPUSValue func_obj;
  LEPUSFunctionBytecode *b;
  struct list_head *el, *el1;
  int stack_size, scope, idx;
  int function_size, byte_code_offset, cpool_offset;
  int closure_var_offset, vardefs_offset;
  bool is_gc = ctx->gc_enable;
  HandleScope func_scope(ctx);

  /* recompute scope linkage */
  for (scope = 0; scope < fd->scope_count; scope++) {
    fd->scopes[scope].first = -1;
  }
  if (fd->has_parameter_expressions) {
    /* special end of variable list marker for the argument scope */
    fd->scopes[ARG_SCOPE_INDEX].first = ARG_SCOPE_END;
  }
  for (idx = 0; idx < fd->var_count; idx++) {
    JSVarDef *vd = &fd->vars[idx];
    vd->scope_next = fd->scopes[vd->scope_level].first;
    fd->scopes[vd->scope_level].first = idx;
  }
  for (scope = 2; scope < fd->scope_count; scope++) {
    JSVarScope *sd = &fd->scopes[scope];
    if (sd->first < 0) sd->first = fd->scopes[sd->parent].first;
  }
  for (idx = 0; idx < fd->var_count; idx++) {
    JSVarDef *vd = &fd->vars[idx];
    if (vd->scope_next < 0 && vd->scope_level > 1) {
      scope = fd->scopes[vd->scope_level].parent;
      vd->scope_next = fd->scopes[scope].first;
    }
  }

  /* if the function contains an eval call, the closure variables
     are used to compile the eval and they must be ordered by scope,
     so it is necessary to create the closure variables before any
     other variable lookup is done. */
  if (fd->has_eval_call) add_eval_variables(ctx, fd);

  /* add the module global variables in the closure */
  if (fd->module) {
    if (add_module_variables(ctx, fd)) goto fail;
  }

  /* first create all the child functions */
  list_for_each_safe(el, el1, &fd->child_list) {
    JSFunctionDef *fd1;
    int cpool_idx;

    fd1 = list_entry(el, JSFunctionDef, link);
    cpool_idx = fd1->parent_cpool_idx;
    func_obj = js_create_function(ctx, fd1);
    if (LEPUS_IsException(func_obj)) goto fail;
    /* save it in the constant pool */
    assert(cpool_idx >= 0);
    fd->cpool[cpool_idx] = func_obj;
  }

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 4)
  if (!(fd->js_mode & JS_MODE_STRIP)) {
    printf("pass 1\n");
    dump_byte_code(ctx, 1, fd->byte_code.buf, fd->byte_code.size, fd->args,
                   fd->arg_count, fd->vars, fd->var_count, fd->closure_var,
                   fd->closure_var_count, fd->cpool, fd->cpool_count,
                   fd->source, fd->line_num, fd->label_slots, NULL);
    printf("\n");
  }
#endif

  if (resolve_variables(ctx, fd)) goto fail;

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 2)
  if (!(fd->js_mode & JS_MODE_STRIP)) {
    printf("pass 2\n");
    dump_byte_code(ctx, 2, fd->byte_code.buf, fd->byte_code.size, fd->args,
                   fd->arg_count, fd->vars, fd->var_count, fd->closure_var,
                   fd->closure_var_count, fd->cpool, fd->cpool_count,
                   fd->source, fd->line_num, fd->label_slots, NULL);
    printf("\n");
  }
#endif

  if (resolve_labels(ctx, fd)) goto fail;

  if (compute_stack_size(ctx, fd, &stack_size) < 0) goto fail;

  if (fd->js_mode & JS_MODE_STRIP) {
    function_size = offsetof(LEPUSFunctionBytecode, debug);
  } else {
    function_size = sizeof(*b);
  }
  cpool_offset = function_size;
  function_size += fd->cpool_count * sizeof(*fd->cpool);
  vardefs_offset = function_size;
  if (!(fd->js_mode & JS_MODE_STRIP) || fd->has_eval_call) {
    function_size += (fd->arg_count + fd->var_count) * sizeof(*b->vardefs);
  }
  closure_var_offset = function_size;
  function_size += fd->closure_var_count * sizeof(*fd->closure_var);
  byte_code_offset = function_size;
  function_size += fd->byte_code.size;

  b = static_cast<LEPUSFunctionBytecode *>(
      lepus_mallocz(ctx, function_size, ALLOC_TAG_LEPUSFunctionBytecode));
  if (!b) goto fail;
  func_scope.PushHandle(b, HANDLE_TYPE_DIR_HEAP_OBJ);
#ifdef ENABLE_QUICKJS_DEBUGGER
  BOOL is_debug_mode;
  is_debug_mode = ctx->debugger_mode;
#endif
  b->function_id = 0;
  if (ctx->debuginfo_outside == 1) {
    b->function_id = ctx->next_function_id++;
  }
  b->header.ref_count = 1;
  b->gc_header.mark = 0;

  b->byte_code_buf = (uint8_t *)b + byte_code_offset;
  b->byte_code_len = fd->byte_code.size;
  memcpy(b->byte_code_buf, fd->byte_code.buf, fd->byte_code.size);

  if (!is_gc) {
    lepus_free(ctx, fd->byte_code.buf);
    fd->byte_code.buf = NULL;
  }

  b->func_name = fd->func_name;
  if (fd->arg_count + fd->var_count > 0) {
    if ((fd->js_mode & JS_MODE_STRIP) && !fd->has_eval_call) {
      /* Strip variable definitions not needed at runtime */
      int i;
      if (is_gc) {
        for (i = 0; i < fd->closure_var_count; i++) {
          fd->closure_var[i].var_name = JS_ATOM_NULL;
        }
      } else {
        for (i = 0; i < fd->var_count; i++) {
          LEPUS_FreeAtom(ctx, fd->vars[i].var_name);
        }
        for (i = 0; i < fd->arg_count; i++) {
          LEPUS_FreeAtom(ctx, fd->args[i].var_name);
        }
        for (i = 0; i < fd->closure_var_count; i++) {
          LEPUS_FreeAtom(ctx, fd->closure_var[i].var_name);
          fd->closure_var[i].var_name = JS_ATOM_NULL;
        }
      }
    } else {
      b->vardefs = (JSVarDef *)((uint8_t *)b + vardefs_offset);
      memcpy(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));
      memcpy(b->vardefs + fd->arg_count, fd->vars,
             fd->var_count * sizeof(fd->vars[0]));
    }
    b->var_count = fd->var_count;
    b->arg_count = fd->arg_count;
    b->defined_arg_count = fd->defined_arg_count;
    if (!is_gc) {
      lepus_free(ctx, fd->args);
      lepus_free(ctx, fd->vars);
    }
  }
  b->cpool_count = fd->cpool_count;
  if (b->cpool_count) {
    b->cpool = (LEPUSValue *)((uint8_t *)b + cpool_offset);
    memcpy(b->cpool, fd->cpool, b->cpool_count * sizeof(*b->cpool));
  }
  if (!is_gc) {
    lepus_free(ctx, fd->cpool);
    fd->cpool = NULL;
  }

  b->stack_size = stack_size;

  if (fd->js_mode & JS_MODE_STRIP) {
    if (!is_gc) {
      LEPUS_FreeAtom(ctx, fd->filename);
      dbuf_free(&fd->pc2line);  // probably useless
      if (fd->caller_slots)
        free_caller_slot(ctx->rt, fd->caller_slots, fd->caller_count);
    }
  } else {
    /* XXX: source and pc2line info should be packed at the end of the
       LEPUSFunctionBytecode structure, avoiding allocation overhead
     */
    b->has_debug = 1;
    b->debug.filename = fd->filename;
    b->debug.line_num = fd->line_num;
#ifdef ENABLE_QUICKJS_DEBUGGER
    int64_t line_col = fd->column_num;
    int32_t line = -1;
    int64_t column = -1;
    ComputeLineCol(line_col, &line, &column);
    b->debug.column_num = column;
#endif

    b->debug.pc2line_buf = static_cast<uint8_t *>(lepus_realloc(
        ctx, fd->pc2line.buf, fd->pc2line.size, ALLOC_TAG_WITHOUT_PTR));
    if (!b->debug.pc2line_buf) b->debug.pc2line_buf = fd->pc2line.buf;
    b->debug.pc2line_len = fd->pc2line.size;
    b->debug.source = fd->source;
    fd->source = nullptr;
    b->debug.source_len = fd->source_len;

    // free excess memory
    b->debug.caller_slots = static_cast<CallerStrSlot *>(lepus_realloc(
        ctx, fd->caller_slots, sizeof(CallerStrSlot) * fd->caller_count,
        ALLOC_TAG_WITHOUT_PTR));
    b->debug.caller_size = fd->caller_count;
    fd->caller_slots = nullptr;
#ifdef ENABLE_QUICKJS_DEBUGGER
    b->debug.file_name = ctx->rt->atom_array[b->debug.filename];
#endif
  }
  if (fd->scopes != fd->def_scope_array && !is_gc) lepus_free(ctx, fd->scopes);

  b->closure_var_count = fd->closure_var_count;
  if (b->closure_var_count) {
    b->closure_var = (LEPUSClosureVar *)((uint8_t *)b + closure_var_offset);
    memcpy(b->closure_var, fd->closure_var,
           b->closure_var_count * sizeof(*b->closure_var));
  }
  if (!is_gc) {
    lepus_free(ctx, fd->closure_var);
    fd->closure_var = NULL;
  }

  b->has_prototype = fd->has_prototype;
  b->has_simple_parameter_list = fd->has_simple_parameter_list;
  b->js_mode = fd->js_mode;
  b->is_derived_class_constructor = fd->is_derived_class_constructor;
  b->func_kind = fd->func_kind;
  b->need_home_object = (fd->home_object_var_idx >= 0 || fd->need_home_object);
  b->new_target_allowed = fd->new_target_allowed;
  b->super_call_allowed = fd->super_call_allowed;
  b->super_allowed = fd->super_allowed;
  b->arguments_allowed = fd->arguments_allowed;

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
  if (!(fd->js_mode & JS_MODE_STRIP)) {
    js_dump_function_bytecode(ctx, b);
  }
#endif

  if (fd->parent && !is_gc) {
    /* remove from parent list */
    list_del(&fd->link);
  }

#ifdef ENABLE_QUICKJS_DEBUGGER
  b->func_level_state = NO_DEBUGGER;
  b->bp_num = 0;
  if (ctx->debugger_info && (is_debug_mode || ctx->debugger_parse_script)) {
    DebuggerSetFunctionBytecodeScript(ctx, fd, b);
  }
#endif

  if (!is_gc) lepus_free(ctx, fd);
#ifdef TEST_BYTECODE_REWRITE
  return force_read_from_snapshot(ctx, b);
#else
  return LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
#endif
fail:
  if (!is_gc) js_free_function_def(ctx, fd);
  return LEPUS_EXCEPTION;
}
#endif

QJS_STATIC void free_function_bytecode(LEPUSRuntime *rt,
                                       LEPUSFunctionBytecode *b) {
  int i;

#if 0
    {
        char buf[ATOM_GET_STR_BUF_SIZE];
        printf("freeing %s\n",
               JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
    }
#endif
  free_bytecode_atoms(rt, b->byte_code_buf, b->byte_code_len, TRUE);

  if (b->vardefs) {
    for (i = 0; i < b->arg_count + b->var_count; i++) {
      LEPUS_FreeAtomRT(rt, b->vardefs[i].var_name);
    }
  }
  if (b->cpool) {
    for (i = 0; i < b->cpool_count; i++) LEPUS_FreeValueRT(rt, b->cpool[i]);
  }

  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv = &b->closure_var[i];
    LEPUS_FreeAtomRT(rt, cv->var_name);
  }

  LEPUS_FreeAtomRT(rt, b->func_name);

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (b->func_level_state != NO_DEBUGGER && b->link.next && b->link.prev) {
    list_del(&b->link);
  }
#endif

  if (b->has_debug) {
    LEPUS_FreeAtomRT(rt, b->debug.filename);
    lepus_free_rt(rt, b->debug.pc2line_buf);
    if (b->debug.caller_size)
      free_caller_slot(rt, b->debug.caller_slots, b->debug.caller_size);

#ifdef ENABLE_QUICKJS_DEBUGGER
    if (b->func_level_state != DEBUGGER_TOP_LEVEL_FUNCTION) {
      system_free(b->debug.source);
    }

    if (b->debug.func_name) {
      js_free_string(rt, b->debug.func_name);
    }
#else
    system_free(b->debug.source);
#endif
  }
  lepus_free_rt(rt, b);
}

#ifndef NO_QUICKJS_COMPILER
__exception int js_parse_directives(JSParseState *s) {
  char str[20];
  JSParsePos pos;
  BOOL has_semi;

  if (s->token.val != TOK_STRING) return 0;

  js_parse_get_pos(s, &pos);

  while (s->token.val == TOK_STRING) {
    /* Copy actual source string representation */
    snprintf(str, sizeof str, "%.*s", (int)(s->buf_ptr - s->token.ptr - 2),
             s->token.ptr + 1);

    if (next_token(s)) return -1;

    has_semi = FALSE;
    switch (s->token.val) {
      case ';':
        if (next_token(s)) return -1;
        has_semi = TRUE;
        break;
      case '}':
      case TOK_EOF:
        has_semi = TRUE;
        break;
      case TOK_NUMBER:
      case TOK_STRING:
      case TOK_TEMPLATE:
      case TOK_IDENT:
      case TOK_REGEXP:
      case TOK_DEC:
      case TOK_INC:
      case TOK_NULL:
      case TOK_FALSE:
      case TOK_TRUE:
      case TOK_IF:
      case TOK_RETURN:
      case TOK_VAR:
      case TOK_THIS:
      case TOK_DELETE:
      case TOK_TYPEOF:
      case TOK_NEW:
      case TOK_DO:
      case TOK_WHILE:
      case TOK_FOR:
      case TOK_SWITCH:
      case TOK_THROW:
      case TOK_TRY:
      case TOK_FUNCTION:
      case TOK_DEBUGGER:
      case TOK_WITH:
      case TOK_CLASS:
      case TOK_CONST:
      case TOK_ENUM:
      case TOK_EXPORT:
      case TOK_IMPORT:
      case TOK_SUPER:
      case TOK_INTERFACE:
      case TOK_LET:
      case TOK_PACKAGE:
      case TOK_PRIVATE:
      case TOK_PROTECTED:
      case TOK_PUBLIC:
      case TOK_STATIC:
        /* automatic insertion of ';' */
        if (s->got_lf) has_semi = TRUE;
        break;
      default:
        break;
    }
    if (!has_semi) break;
    if (!strcmp(str, "use strict")) {
      s->cur_func->has_use_strict = TRUE;
      s->cur_func->js_mode |= JS_MODE_STRICT;
    }
#if !defined(DUMP_BYTECODE) || !(DUMP_BYTECODE & 8)
    else if (!strcmp(str, "use strip")) {
      s->cur_func->js_mode |= JS_MODE_STRIP;
    }
#endif
#ifdef CONFIG_BIGNUM
    else if (!strcmp(str, "use bigint")) {
      s->cur_func->js_mode |= JS_MODE_BIGINT;
    } else if (!strcmp(str, "use math")) {
      s->cur_func->js_mode |= JS_MODE_BIGINT | JS_MODE_MATH;
    }
#endif
  }
  return js_parse_seek_token(s, &pos);
}

int js_parse_function_check_names(JSParseState *s, JSFunctionDef *fd,
                                  JSAtom func_name) {
  JSAtom name;
  int i, idx;

  if (fd->js_mode & JS_MODE_STRICT) {
    if (!fd->has_simple_parameter_list && fd->has_use_strict) {
      return js_parse_error(s,
                            "\"use strict\" not allowed in function with "
                            "default or destructuring parameter");
    }
    if (func_name == JS_ATOM_eval || func_name == JS_ATOM_arguments) {
      return js_parse_error(s, "invalid function name in strict code");
    }
    for (idx = 0; idx < fd->arg_count; idx++) {
      name = fd->args[idx].var_name;

      if (name == JS_ATOM_eval || name == JS_ATOM_arguments) {
        return js_parse_error(s, "invalid argument name in strict code");
      }
    }
  }
  /* check async_generator case */
  if ((fd->js_mode & JS_MODE_STRICT) || !fd->has_simple_parameter_list ||
      (fd->func_type == JS_PARSE_FUNC_METHOD &&
       fd->func_kind == JS_FUNC_ASYNC) ||
      fd->func_type == JS_PARSE_FUNC_ARROW ||
      fd->func_type == JS_PARSE_FUNC_METHOD) {
    for (idx = 0; idx < fd->arg_count; idx++) {
      name = fd->args[idx].var_name;
      if (name != JS_ATOM_NULL) {
        for (i = 0; i < idx; i++) {
          if (fd->args[i].var_name == name) goto duplicate;
        }
        /* Check if argument name duplicates a destructuring parameter */
        /* XXX: should have a flag for such variables */
        for (i = 0; i < fd->var_count; i++) {
          if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0)
            goto duplicate;
        }
      }
    }
  }
  return 0;

duplicate:
  return js_parse_error(s,
                        "duplicate argument names not allowed in this context");
}

/* create a function to initialize class fields */
QJS_STATIC JSFunctionDef *js_parse_function_class_fields_init(JSParseState *s) {
  JSFunctionDef *fd;
#ifdef ENABLE_COMPATIBLE_MM
  if (s->ctx->gc_enable)
    fd = js_new_function_def_GC(s->ctx, s->cur_func, FALSE, FALSE, s->filename,
                                0);
  else
#endif
    fd = js_new_function_def(s->ctx, s->cur_func, FALSE, FALSE, s->filename, 0);
  if (!fd) return NULL;
#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = compute_column(s, 0);
#endif
  fd->func_name = JS_ATOM_NULL;
  fd->has_prototype = FALSE;
  fd->has_home_object = TRUE;

  fd->has_arguments_binding = FALSE;
  fd->has_this_binding = TRUE;
  fd->is_derived_class_constructor = FALSE;
  fd->new_target_allowed = TRUE;
  fd->super_call_allowed = FALSE;
  fd->super_allowed = fd->has_home_object;
  fd->arguments_allowed = FALSE;

  fd->func_kind = JS_FUNC_NORMAL;
  fd->func_type = JS_PARSE_FUNC_METHOD;
  return fd;
}

/* func_name must be JS_ATOM_NULL for JS_PARSE_FUNC_STATEMENT and
   JS_PARSE_FUNC_EXPR, JS_PARSE_FUNC_ARROW and JS_PARSE_FUNC_VAR */
QJS_STATIC __exception int js_parse_function_decl2(
    JSParseState *s, JSParseFunctionEnum func_type,
    JSFunctionKindEnum func_kind, JSAtom func_name, const uint8_t *ptr,
    int function_line_num, JSParseExportEnum export_flag, JSFunctionDef **pfd) {
  CallGCParserFunc(js_parse_function_decl2_GC, s, func_type, func_kind,
                   func_name, ptr, function_line_num, export_flag, pfd);
  LEPUSContext *ctx = s->ctx;
  JSFunctionDef *fd = s->cur_func;
  BOOL is_expr;
  int func_idx, lexical_func_idx = -1;
  BOOL has_opt_arg;
  BOOL create_func_var = FALSE;

  is_expr =
      (func_type != JS_PARSE_FUNC_STATEMENT && func_type != JS_PARSE_FUNC_VAR);

  if (func_type == JS_PARSE_FUNC_STATEMENT || func_type == JS_PARSE_FUNC_VAR ||
      func_type == JS_PARSE_FUNC_EXPR) {
    if (func_kind == JS_FUNC_NORMAL &&
        token_is_pseudo_keyword(s, JS_ATOM_async) &&
        peek_token(s, TRUE) != '\n') {
      if (next_token(s)) return -1;
      func_kind = JS_FUNC_ASYNC;
    }
    if (next_token(s)) return -1;
    if (s->token.val == '*') {
      if (next_token(s)) return -1;
      func_kind =
          static_cast<JSFunctionKindEnum>(func_kind | JS_FUNC_GENERATOR);
    }

    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved ||
          (s->token.u.ident.atom == JS_ATOM_yield &&
           func_type == JS_PARSE_FUNC_EXPR &&
           (func_kind & JS_FUNC_GENERATOR)) ||
          (s->token.u.ident.atom == JS_ATOM_await &&
           func_type == JS_PARSE_FUNC_EXPR && (func_kind & JS_FUNC_ASYNC))) {
        return js_parse_error_reserved_identifier(s);
      }
    }
    if (s->token.val == TOK_IDENT ||
        (((s->token.val == TOK_YIELD && !(fd->js_mode & JS_MODE_STRICT)) ||
          (s->token.val == TOK_AWAIT && !s->is_module)) &&
         func_type == JS_PARSE_FUNC_EXPR)) {
      func_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      if (next_token(s)) {
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    } else {
      if (func_type != JS_PARSE_FUNC_EXPR &&
          export_flag != JS_PARSE_EXPORT_DEFAULT) {
        return js_parse_error(s, "function name expected");
      }
    }
  } else if (func_type != JS_PARSE_FUNC_ARROW) {
    func_name = LEPUS_DupAtom(ctx, func_name);
  }

  if (fd->is_eval && fd->eval_type == LEPUS_EVAL_TYPE_MODULE &&
      (func_type == JS_PARSE_FUNC_STATEMENT ||
       func_type == JS_PARSE_FUNC_VAR)) {
    JSHoistedDef *hf;
    hf = find_hoisted_def(fd, func_name);
    /* XXX: should check scope chain */
    if (hf && hf->scope_level == fd->scope_level) {
      js_parse_error(
          s, "invalid redefinition of global identifier in module code");
      LEPUS_FreeAtom(ctx, func_name);
      return -1;
    }
  }

  if (func_type == JS_PARSE_FUNC_VAR) {
    /* Create lexical name here so function closure contains it */
    if (!(fd->js_mode & JS_MODE_STRICT) && func_kind == JS_FUNC_NORMAL &&
        find_lexical_decl(ctx, fd, func_name, fd->scope_first, FALSE) < 0 &&
        !((func_idx = find_var(ctx, fd, func_name)) >= 0 &&
          (func_idx & ARGUMENT_VAR_OFFSET)) &&
        !(func_name == JS_ATOM_arguments && fd->has_arguments_binding)) {
      create_func_var = TRUE;
    }
    if (fd->is_eval &&
        (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
         fd->eval_type == LEPUS_EVAL_TYPE_MODULE) &&
        fd->scope_level == fd->body_scope) {
      /* avoid creating a lexical variable in the global
         scope. XXX: check annex B */
      JSHoistedDef *hf;
      hf = find_hoisted_def(fd, func_name);
      /* XXX: should check scope chain */
      if (hf && hf->scope_level == fd->scope_level) {
        js_parse_error(s, "invalid redefinition of global identifier");
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    } else {
      /* Always create a lexical name, fail if at the same scope as
         existing name */
      /* Lexical variable will be initialized upon entering scope */
      lexical_func_idx =
          define_var(s, fd, func_name,
                     func_kind != JS_FUNC_NORMAL ? JS_VAR_DEF_NEW_FUNCTION_DECL
                                                 : JS_VAR_DEF_FUNCTION_DECL);
      if (lexical_func_idx < 0) {
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    }
  }

  fd = js_new_function_def(ctx, fd, FALSE, is_expr, s->filename,
                           function_line_num);
  if (!fd) {
    LEPUS_FreeAtom(ctx, func_name);
    return -1;
  }
#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = compute_column(s, 0);
#endif
  if (pfd) *pfd = fd;
  s->cur_func = fd;
  fd->func_name = func_name;
  /* XXX: test !fd->is_generator is always false */
  fd->has_prototype =
      (func_type == JS_PARSE_FUNC_STATEMENT || func_type == JS_PARSE_FUNC_VAR ||
       func_type == JS_PARSE_FUNC_EXPR) &&
      func_kind == JS_FUNC_NORMAL;
  fd->has_home_object =
      (func_type == JS_PARSE_FUNC_METHOD || func_type == JS_PARSE_FUNC_GETTER ||
       func_type == JS_PARSE_FUNC_SETTER ||
       func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
       func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
  fd->has_arguments_binding = (func_type != JS_PARSE_FUNC_ARROW);
  fd->has_this_binding = fd->has_arguments_binding;
  fd->is_derived_class_constructor =
      (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
  if (func_type == JS_PARSE_FUNC_ARROW) {
    fd->new_target_allowed = fd->parent->new_target_allowed;
    fd->super_call_allowed = fd->parent->super_call_allowed;
    fd->super_allowed = fd->parent->super_allowed;
    fd->arguments_allowed = fd->parent->arguments_allowed;
  } else {
    fd->new_target_allowed = TRUE;
    fd->super_call_allowed = fd->is_derived_class_constructor;
    fd->super_allowed = fd->has_home_object;
    fd->arguments_allowed = TRUE;
  }

  /* fd->in_function_body == FALSE prevents yield/await during the parsing
     of the arguments in generator/async functions. They are parsed as
     regular identifiers for other function kinds. */
  fd->func_kind = func_kind;
  fd->func_type = func_type;
  fd->src_start = (const char *)ptr;

  if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
      func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
    /* error if not invoked as a constructor */
    emit_op(s, OP_check_ctor);
  }

  if (func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
    emit_class_field_init(s);
  }

  /* parse arguments */
  fd->has_simple_parameter_list = TRUE;
  fd->has_parameter_expressions = FALSE;
  has_opt_arg = FALSE;
  if (func_type == JS_PARSE_FUNC_ARROW && s->token.val == TOK_IDENT) {
    JSAtom name;
    if (s->token.u.ident.is_reserved) {
      js_parse_error_reserved_identifier(s);
      goto fail;
    }
    name = s->token.u.ident.atom;
    if (add_arg(ctx, fd, name) < 0) goto fail;
    fd->defined_arg_count = 1;
  } else {
    if (s->token.val == '(') {
      int skip_bits;
      BOOL has_ellipsis = FALSE;
      js_parse_skip_parens_token(s, &skip_bits, FALSE, &has_ellipsis);
      // rest parameters can not be used in setters
      // https://262.ecma-international.org/6.0/#sec-function-definitions
      if (has_ellipsis == TRUE && func_type == JS_PARSE_FUNC_SETTER) {
        LEPUS_ThrowSyntaxError(
            ctx, "Setter function argument must not be a rest parameter");
        goto fail;
      }
      if (skip_bits & SKIP_HAS_ASSIGNMENT) fd->has_parameter_expressions = TRUE;
      if (next_token(s)) goto fail;
    } else {
      if (js_parse_expect(s, '(')) goto fail;
    }

    if (fd->has_parameter_expressions) {
      fd->scope_level = -1; /* force no parent scope */
      if (push_scope(s) < 0) return -1;
    }

    while (s->token.val != ')') {
      JSAtom name;
      BOOL rest = FALSE;
      int idx, has_initializer;

      if (s->token.val == TOK_ELLIPSIS) {
        fd->has_simple_parameter_list = FALSE;
        rest = TRUE;
        if (next_token(s)) goto fail;
      }
      if (s->token.val == '[' || s->token.val == '{') {
        fd->has_simple_parameter_list = FALSE;
        if (rest) {
          emit_op(s, OP_rest);
          emit_u16(s, fd->arg_count);
        } else {
          /* unnamed arg for destructuring */
          idx = add_arg(ctx, fd, JS_ATOM_NULL);
          emit_op(s, OP_get_arg);
          emit_u16(s, idx);
        }
        has_initializer = js_parse_destructing_element(
            s, fd->has_parameter_expressions ? TOK_LET : TOK_VAR, 1, TRUE, -1,
            TRUE);
        if (has_initializer < 0) goto fail;
        if (has_initializer) has_opt_arg = TRUE;
        if (!has_opt_arg) fd->defined_arg_count++;
      } else if (s->token.val == TOK_IDENT) {
        if (s->token.u.ident.is_reserved) {
          js_parse_error_reserved_identifier(s);
          goto fail;
        }
        name = s->token.u.ident.atom;
        if (name == JS_ATOM_yield && fd->func_kind == JS_FUNC_GENERATOR) {
          js_parse_error_reserved_identifier(s);
          goto fail;
        }
        if (fd->has_parameter_expressions) {
          if (define_var(s, fd, name, JS_VAR_DEF_LET) < 0) goto fail;
        }
        idx = add_arg(ctx, fd, name);
        if (idx < 0) goto fail;
        if (next_token(s)) goto fail;
        if (rest) {
          emit_op(s, OP_rest);
          emit_u16(s, idx);
          if (fd->has_parameter_expressions) {
            emit_op(s, OP_dup);
            emit_op(s, OP_scope_put_var_init);
            emit_atom(s, name);
            emit_u16(s, fd->scope_level);
          }
          emit_op(s, OP_put_arg);
          emit_u16(s, idx);
          fd->has_simple_parameter_list = FALSE;
          has_opt_arg = TRUE;
        } else if (s->token.val == '=') {
          fd->has_simple_parameter_list = FALSE;
          has_opt_arg = TRUE;

          if (next_token(s)) goto fail;

#if 0
                    /* XXX: not correct for eval code */
                    /* Check for a default value of `undefined`
                       to omit default argument processing */
                    if (s->token.val == TOK_IDENT &&
                        s->token.u.ident.atom == JS_ATOM_undefined &&
                        fd->parent == NULL &&
                        ((tok = peek_token(s, FALSE)) == ',' || tok == ')')) {
                        if (next_token(s))  /* ignore undefined token */
                            goto fail;
                    } else
#endif

          int label = new_label(s);
          emit_op(s, OP_get_arg);
          emit_u16(s, idx);
          emit_op(s, OP_dup);
          emit_op(s, OP_undefined);
          emit_op(s, OP_strict_eq);
          emit_goto(s, OP_if_false, label);
          emit_op(s, OP_drop);
          if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
          set_object_name(s, name);
          emit_op(s, OP_dup);
          emit_op(s, OP_put_arg);
          emit_u16(s, idx);
          emit_label(s, label);
          emit_op(s, OP_scope_put_var_init);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        } else {
          if (!has_opt_arg) {
            fd->defined_arg_count++;
          }
          if (fd->has_parameter_expressions) {
            /* copy the argument to the argument scope */
            emit_op(s, OP_get_arg);
            emit_u16(s, idx);
            emit_op(s, OP_scope_put_var_init);
            emit_atom(s, name);
            emit_u16(s, fd->scope_level);
          }
        }
      } else {
        js_parse_error(s, "missing formal parameter");
        goto fail;
      }
      if (rest && s->token.val != ')') {
        js_parse_expect(s, ')');
        goto fail;
      }
      if (s->token.val == ')') break;
      if (js_parse_expect(s, ',')) goto fail;
    }
    if ((func_type == JS_PARSE_FUNC_GETTER && fd->arg_count != 0) ||
        (func_type == JS_PARSE_FUNC_SETTER && fd->arg_count != 1)) {
      js_parse_error(s, "invalid number of arguments for getter or setter");
      goto fail;
    }
  }

  if (fd->has_parameter_expressions) {
    int idx;

    /* Copy the variables in the argument scope to the variable
       scope (see FunctionDeclarationInstantiation() in spec). The
       normal arguments are already present, so no need to copy
       them. */
    idx = fd->scopes[fd->scope_level].first;
    while (idx >= 0) {
      JSVarDef *vd = &fd->vars[idx];
      if (vd->scope_level != fd->scope_level) break;
      if (find_var(ctx, fd, vd->var_name) < 0) {
        if (add_var(ctx, fd, vd->var_name) < 0) goto fail;
        vd = &fd->vars[idx]; /* fd->vars may have been reallocated */
        emit_op(s, OP_scope_get_var);
        emit_atom(s, vd->var_name);
        emit_u16(s, fd->scope_level);
        emit_op(s, OP_scope_put_var);
        emit_atom(s, vd->var_name);
        emit_u16(s, 0);
      }
      idx = vd->scope_next;
    }

    /* the argument scope has no parent, hence we don't use pop_scope(s) */
    emit_op(s, OP_leave_scope);
    emit_u16(s, fd->scope_level);

    /* set the variable scope as the current scope */
    fd->scope_level = 0;
    fd->scope_first = fd->scopes[fd->scope_level].first;
  }

  if (next_token(s)) goto fail;

  /* generator function: yield after the parameters are evaluated */
  if (func_kind == JS_FUNC_GENERATOR || func_kind == JS_FUNC_ASYNC_GENERATOR)
    emit_op(s, OP_initial_yield);

  /* in generators, yield expression is forbidden during the parsing
     of the arguments */
  fd->in_function_body = TRUE;
  push_scope(s); /* enter body scope: fd->scope_level = 1 */
  fd->body_scope = fd->scope_level;

  if (s->token.val == TOK_ARROW) {
    if (next_token(s)) goto fail;

    if (s->token.val != '{') {
      if (js_parse_function_check_names(s, fd, func_name)) goto fail;

      if (js_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;

      if (func_kind != JS_FUNC_NORMAL)
        emit_op(s, OP_return_async);
      else
        emit_op(s, OP_return);

      if (!(fd->js_mode & JS_MODE_STRIP)) {
        /* save the function source code */
        /* the end of the function source code is after the last
           token of the function source stored into s->last_ptr */
        fd->source_len = s->last_ptr - ptr;
        fd->source = js_strmalloc((const char *)ptr, fd->source_len);
        if (!fd->source) goto fail;
      }
      goto done;
    }
  }

  if (js_parse_expect(s, '{')) goto fail;

  if (js_parse_directives(s)) goto fail;

  /* in strict_mode, check function and argument names */
  if (js_parse_function_check_names(s, fd, func_name)) goto fail;

  while (s->token.val != '}') {
    if (js_parse_source_element(s)) goto fail;
  }
  if (!(fd->js_mode & JS_MODE_STRIP)) {
    /* save the function source code */
    fd->source_len = s->buf_ptr - ptr;
    fd->source = js_strmalloc((const char *)ptr, fd->source_len);
    if (!fd->source) goto fail;
  }

  if (next_token(s)) {
    /* consume the '}' */
    goto fail;
  }

  /* in case there is no return, add one */
  if (js_is_live_code(s)) {
    emit_return(s, FALSE);
  }
done:
  s->cur_func = fd->parent;

  /* create the function object */
  {
    int idx;
    JSAtom func_name = fd->func_name;

    /* the real object will be set at the end of the compilation */
    idx = cpool_add(s, LEPUS_NULL);
    fd->parent_cpool_idx = idx;

    if (is_expr) {
      /* for constructors, no code needs to be generated here */
      if (func_type != JS_PARSE_FUNC_CLASS_CONSTRUCTOR &&
          func_type != JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
        /* OP_fclosure creates the function object from the bytecode
           and adds the scope information */
        emit_op(s, OP_fclosure);
        emit_u32(s, idx);
        if (func_name == JS_ATOM_NULL) {
          emit_op(s, OP_set_name);
          emit_u32(s, JS_ATOM_NULL);
        }
      }
    } else if (func_type == JS_PARSE_FUNC_VAR) {
      emit_op(s, OP_fclosure);
      emit_u32(s, idx);
      if (create_func_var) {
        if (s->cur_func->is_global_var) {
          JSHoistedDef *hf;
          /* the global variable must be defined at the start of the
             function */
          hf = add_hoisted_def(ctx, s->cur_func, -1, func_name, -1, FALSE);
          if (!hf) goto fail;
          hf->scope_level = 0;
          hf->force_init = ((s->cur_func->js_mode & JS_MODE_STRICT) != 0);
          /* store directly into global var, bypass lexical scope */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_put_var);
          emit_atom(s, func_name);
          emit_u16(s, 0);
        } else {
          /* do not call define_var to bypass lexical scope check */
          func_idx = find_var(ctx, s->cur_func, func_name);
          if (func_idx < 0) {
            func_idx = add_var(ctx, s->cur_func, func_name);
            if (func_idx < 0) goto fail;
          }
          /* store directly into local var, bypass lexical catch scope */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_put_var);
          emit_atom(s, func_name);
          emit_u16(s, 0);
        }
      }
      if (lexical_func_idx >= 0) {
        /* lexical variable will be initialized upon entering scope */
        s->cur_func->vars[lexical_func_idx].func_pool_idx = idx;
        emit_op(s, OP_drop);
      } else {
        /* store function object into its lexical name */
        /* XXX: could use OP_put_loc directly */
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, func_name);
        emit_u16(s, s->cur_func->scope_level);
      }
    } else {
      if (!s->cur_func->is_global_var) {
        int var_idx = define_var(s, s->cur_func, func_name, JS_VAR_DEF_VAR);

        if (var_idx < 0) goto fail;
        /* the variable will be assigned at the top of the function */
        if (var_idx & ARGUMENT_VAR_OFFSET) {
          s->cur_func->args[var_idx - ARGUMENT_VAR_OFFSET].func_pool_idx = idx;
        } else {
          s->cur_func->vars[var_idx].func_pool_idx = idx;
        }
      } else {
        JSAtom func_var_name;
        JSHoistedDef *hf;
        if (func_name == JS_ATOM_NULL)
          func_var_name = JS_ATOM__default_; /* export default */
        else
          func_var_name = func_name;
        /* the variable will be assigned at the top of the function */
        hf = add_hoisted_def(ctx, s->cur_func, idx, func_var_name, -1, FALSE);
        if (!hf) goto fail;
        hf->cpool_idx = idx;
        if (export_flag != JS_PARSE_EXPORT_NONE) {
          if (!add_export_entry(s, s->cur_func->module, func_var_name,
                                export_flag == JS_PARSE_EXPORT_NAMED
                                    ? func_var_name
                                    : JS_ATOM_default,
                                JS_EXPORT_TYPE_LOCAL))
            goto fail;
        }
      }
    }
  }
  return 0;
fail:
  s->cur_func = fd->parent;
  js_free_function_def(ctx, fd);
  if (pfd) *pfd = NULL;
  return -1;
}

QJS_STATIC __exception int js_parse_function_decl(JSParseState *s,
                                                  JSParseFunctionEnum func_type,
                                                  JSFunctionKindEnum func_kind,
                                                  JSAtom func_name,
                                                  const uint8_t *ptr,
                                                  int function_line_num) {
  return js_parse_function_decl2(s, func_type, func_kind, func_name, ptr,
                                 function_line_num, JS_PARSE_EXPORT_NONE, NULL);
}

QJS_STATIC __exception int js_parse_program(JSParseState *s) {
  JSFunctionDef *fd = s->cur_func;
  int idx;
  fd->src_start = reinterpret_cast<const char *>(s->buf_ptr);

  if (next_token(s)) return -1;

  if (js_parse_directives(s)) return -1;

  fd->is_global_var = (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL) ||
                      (fd->eval_type == LEPUS_EVAL_TYPE_MODULE) ||
                      !(fd->js_mode & JS_MODE_STRICT);

  if (!s->is_module) {
    /* hidden variable for the return value */
    fd->eval_ret_idx = idx = add_var(s->ctx, fd, JS_ATOM__ret_);
    if (idx < 0) return -1;
  }

  while (s->token.val != TOK_EOF) {
    if (js_parse_source_element(s)) return -1;
  }

  if (!s->is_module) {
    /* return the value of the hidden variable eval_ret_idx  */
    emit_op(s, OP_get_loc);
    emit_u16(s, fd->eval_ret_idx);

    emit_op(s, OP_return);
  } else {
    emit_op(s, OP_return_undef);
  }

  get_caller_string(fd);
  return 0;
}

void js_parse_init(LEPUSContext *ctx, JSParseState *s, const char *input,
                   size_t input_len, const char *filename) {
  memset(s, 0, sizeof(*s));
  s->ctx = ctx;
  s->filename = filename;
  s->line_num = 1;
  s->buf_ptr = (const uint8_t *)input;
  s->buf_end = s->buf_ptr + input_len;
  s->token.val = ' ';
  s->token.line_num = 1;

  // <Primjs begin>
  s->last_line_begin_ptr = (const uint8_t *)input;
  s->line_begin_ptr = (const uint8_t *)input;
  s->cur_func = NULL;
  s->last_emit_ptr = (const uint8_t *)input;
  s->utf8_parse_front = (const uint8_t *)input;
  s->func_call_ptr = NULL;
  s->utf8_adapte_size = 0;
  s->func_call_adapte_size = -1;
  s->last_utf8_adapte_size = 0;
  // <Primjs end>
}
#endif

QJS_STATIC LEPUSValue JS_EvalFunctionInternal(LEPUSContext *ctx,
                                              LEPUSValue fun_obj,
                                              LEPUSValueConst this_obj,
                                              JSVarRef **var_refs,
                                              LEPUSStackFrame *sf) {
  LEPUSValue ret_val;

  if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(fun_obj)) {
    fun_obj = js_closure(ctx, fun_obj, var_refs, sf);
    ret_val = JS_CallFree(ctx, fun_obj, this_obj, 0, NULL);
  } else if (LEPUS_VALUE_IS_MODULE(fun_obj)) {
#ifndef NO_QUICKJS_COMPILER
    LEPUSModuleDef *m;
    m = static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(fun_obj));
    /* the module refcount should be >= 2 */
    LEPUS_FreeValue(ctx, fun_obj);
    if (js_link_module(ctx, m) < 0) goto fail;
    ret_val = js_evaluate_module(ctx, m);
    if (LEPUS_IsException(ret_val)) {
    fail:
      js_free_modules(ctx, JS_FREE_MODULE_NOT_EVALUATED);
      return LEPUS_EXCEPTION;
    }
#else
    return LEPUS_EXCEPTION;
#endif
  } else {
    LEPUS_FreeValue(ctx, fun_obj);
    ret_val = LEPUS_ThrowTypeError(ctx, "bytecode function expected");
  }
  return ret_val;
}

LEPUSValue LEPUS_EvalFunction(LEPUSContext *ctx, LEPUSValue fun_obj,
                              LEPUSValueConst this_obj) {
  CallGCFunc(JS_EvalFunction_GC, ctx, fun_obj, this_obj);
  return JS_EvalFunctionInternal(ctx, fun_obj, this_obj, NULL, NULL);
}

#ifndef NO_QUICKJS_COMPILER
void skip_shebang(JSParseState *s) {
  const uint8_t *p = s->buf_ptr;
  int c;

  if (p[0] == '#' && p[1] == '!') {
    p += 2;
    while (p < s->buf_end) {
      if (*p == '\n' || *p == '\r') {
        break;
      } else if (*p >= 0x80) {
        c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
        if (c == CP_LS || c == CP_PS) {
          break;
        } else if (c == -1) {
          p++;
        }
      } else {
        p++;
      }
    }
    s->buf_ptr = p;
  }
}

/* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
QJS_STATIC LEPUSValue __JS_EvalInternal(LEPUSContext *ctx,
                                        LEPUSValueConst this_obj,
                                        const char *input, size_t input_len,
                                        const char *filename, int flags,
                                        int scope_idx, bool debugger_eval,
                                        LEPUSStackFrame *debugger_frame) {
  JSParseState s1, *s = &s1;
  int err, js_mode, eval_type;
  LEPUSValue fun_obj, ret_val;
  LEPUSStackFrame *sf;
  JSVarRef **var_refs;
  LEPUSFunctionBytecode *b;
  JSFunctionDef *fd;
  LEPUSModuleDef *m;
  LEPUSScriptSource *script = nullptr;

  js_parse_init(ctx, s, input, input_len, filename);
  skip_shebang(s);

  eval_type =
      debugger_eval ? LEPUS_EVAL_TYPE_DIRECT : (flags & LEPUS_EVAL_TYPE_MASK);
  m = NULL;
  if (eval_type == LEPUS_EVAL_TYPE_DIRECT) {
    LEPUSObject *p;
    sf = debugger_eval ? debugger_frame : ctx->rt->current_stack_frame;
    assert(sf != NULL);
    assert(LEPUS_VALUE_IS_OBJECT(sf->cur_func));
    p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    assert(lepus_class_has_bytecode(p->class_id));
    b = p->u.func.function_bytecode;
    var_refs = p->u.func.var_refs;
    js_mode = b->js_mode;
  } else {
    sf = NULL;
    b = NULL;
    var_refs = NULL;
    js_mode = 0;
    if (flags & LEPUS_EVAL_FLAG_STRICT) js_mode |= JS_MODE_STRICT;
    if (flags & LEPUS_EVAL_FLAG_STRIP) js_mode |= JS_MODE_STRIP;
    if (eval_type == LEPUS_EVAL_TYPE_MODULE) {
      JSAtom module_name = LEPUS_NewAtom(ctx, filename);
      if (module_name == JS_ATOM_NULL) return LEPUS_EXCEPTION;
      m = js_new_module_def(ctx, module_name);
      if (!m) return LEPUS_EXCEPTION;
      js_mode |= JS_MODE_STRICT;
    }
  }
  fd = js_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);

#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = 0;
#endif

  if (!fd) goto fail1;
  s->cur_func = fd;
  fd->eval_type = eval_type;
  fd->has_this_binding = (eval_type != LEPUS_EVAL_TYPE_DIRECT);
  if (eval_type == LEPUS_EVAL_TYPE_DIRECT) {
    fd->new_target_allowed = b->new_target_allowed;
    fd->super_call_allowed = b->super_call_allowed;
    fd->super_allowed = b->super_allowed;
    fd->arguments_allowed = b->arguments_allowed;
  } else {
    fd->new_target_allowed = FALSE;
    fd->super_call_allowed = FALSE;
    fd->super_allowed = FALSE;
    fd->arguments_allowed = TRUE;
  }
  fd->js_mode = js_mode;
  fd->func_name = LEPUS_DupAtom(ctx, JS_ATOM__eval_);
  if (b) {
    if (debugger_eval) {
      // use DEBUG_SCOPE_INDEX to add all lexical variables to debug eval
      // closure.
      int32_t idx = b->var_count ? DEBUG_SCOPE_INDEX : -1;
      if (add_closure_variables(ctx, fd, b, idx)) goto fail;
    } else {
      if (add_closure_variables(ctx, fd, b, scope_idx)) goto fail;
    }
  }
  fd->module = m;
  s->is_module = (m != NULL);
  s->allow_html_comments = !s->is_module;

  push_scope(s); /* body scope */
  fd->body_scope = fd->scope_level;

  err = js_parse_program(s);
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (!debugger_eval && (ctx->debugger_parse_script || ctx->debugger_mode) &&
      !(flags & LEPUS_DEBUGGER_NO_PERSIST_SCRIPT)) {
    DebuggerParseScript(ctx, input, input_len, fd, filename, s->line_num, err);
    script = fd->script;
  }
#endif

  if (err) {
  fail:
    free_token(s, &s->token);
    js_free_function_def(ctx, fd);
    goto fail1;
  }

  /* create the function object and all the enclosed functions */
  fun_obj = js_create_function(ctx, fd);

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (script && ctx->debugger_mode) {
    // adjust breakpoint which pc is null(script_id = -1)
    AdjustBreakpoints(ctx, script);
  }
#endif

  if (LEPUS_IsException(fun_obj)) goto fail1;
  /* Could add a flag to avoid resolution if necessary */
  if (m) {
    m->func_obj = fun_obj;
    if (js_resolve_module(ctx, m) < 0) goto fail1;
    fun_obj = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  }
  if (flags & LEPUS_EVAL_FLAG_COMPILE_ONLY) {
    ret_val = fun_obj;
  } else {
    ret_val = JS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);
  }
  return ret_val;
fail1:
  /* XXX: should free all the unresolved dependencies */
  if (m) js_free_module_def(ctx, m);
  return LEPUS_EXCEPTION;
}

/* the indirection is needed to make 'eval' optional */
QJS_HIDE LEPUSValue JS_EvalInternal(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                    const char *input, size_t input_len,
                                    const char *filename, int flags,
                                    int scope_idx, bool debugger_eval,
                                    LEPUSStackFrame *sf) {
  if (unlikely(!ctx->eval_internal)) {
    return LEPUS_ThrowTypeError(ctx, "eval is not supported");
  }
  return ctx->eval_internal(ctx, this_obj, input, input_len, filename, flags,
                            scope_idx, debugger_eval, sf);
}
#endif

LEPUSValue JS_EvalObject(LEPUSContext *ctx, LEPUSValueConst this_obj,
                         LEPUSValueConst val, int flags, int scope_idx) {
#ifndef NO_QUICKJS_COMPILER
  LEPUSValue ret;
  const char *str;
  size_t len;

  if (!LEPUS_IsString(val)) return LEPUS_DupValue(ctx, val);
  str = JS_ToCStringLen2_RC(ctx, &len, val, 0);
  if (!str) return LEPUS_EXCEPTION;
  ret = JS_EvalInternal(ctx, this_obj, str, len, "<input>", flags, scope_idx);
  LEPUS_FreeCString(ctx, str);
  return ret;
#else
  return LEPUS_UNDEFINED;
#endif
}

LEPUSValue LEPUS_Eval(LEPUSContext *ctx, const char *input, size_t input_len,
                      const char *filename, int eval_flags) {
  CallGCFunc(JS_Eval_GC, ctx, input, input_len, filename, eval_flags);
#ifndef NO_QUICKJS_COMPILER
  int eval_type = eval_flags & LEPUS_EVAL_TYPE_MASK;
  LEPUSValue ret;

  assert(eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
         eval_type == LEPUS_EVAL_TYPE_MODULE);
  ret = JS_EvalInternal(ctx, ctx->global_obj, input, input_len, filename,
                        eval_flags, -1);
  return ret;
#else
  return LEPUS_UNDEFINED;
#endif
}

LEPUSValue LEPUS_EvalBinary(LEPUSContext *ctx, const uint8_t *buf,
                            size_t buf_len, int flags) {
  CallGCFunc(JS_EvalBinary_GC, ctx, buf, buf_len, flags);
  LEPUSValue obj;
  obj = LEPUS_ReadObject(ctx, buf, buf_len, LEPUS_READ_OBJ_BYTECODE);
  if (LEPUS_IsException(obj)) return obj;
  if (flags & LEPUS_EVAL_BINARY_LOAD_ONLY) {
    return obj;
  } else {
    /* if a module, we load the dependencies here */

#ifndef NO_QUICKJS_COMPILER
    if (LEPUS_VALUE_IS_MODULE(obj)) {
      LEPUSModuleDef *m =
          static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(obj));
      if (js_resolve_module(ctx, m) < 0) {
        LEPUS_FreeValue(ctx, obj);
        js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
        return LEPUS_EXCEPTION;
      }
    }
#endif

    return LEPUS_EvalFunction(ctx, obj, ctx->global_obj);
  }
}

/*******************************************************************/
/* binary object writer & reader */
typedef enum BCTagEnum {
  BC_TAG_NULL = 1,
  BC_TAG_UNDEFINED,
  BC_TAG_BOOL_FALSE,
  BC_TAG_BOOL_TRUE,
  BC_TAG_INT32,
  BC_TAG_FLOAT64,
  BC_TAG_STRING,
  BC_TAG_OBJECT,
  BC_TAG_ARRAY,
  BC_TAG_BIG_INT,
  BC_TAG_BIG_FLOAT,
  BC_TAG_TEMPLATE_OBJECT,
  BC_TAG_FUNCTION_BYTECODE,
  BC_TAG_MODULE,
#ifdef ENABLE_BUILTIN_SERIALIZE
  BC_TAG_TYPED_ARRAY,
  BC_TAG_ARRAY_BUFFER,
  BC_TAG_DATE,
  BC_TAG_OBJECT_VALUE,
  BC_TAG_DATAVIEW,
  BC_TAG_ERROR,
  BC_TAG_REGEXP,
  BC_TAG_MAP
#endif
} BCTagEnum;

#ifdef CONFIG_BIGNUM
#define BC_BASE_VERSION 2
#else
#define BC_BASE_VERSION 1
#endif
#define BC_BE_VERSION 0x40
#ifdef WORDS_BIGENDIAN
#define BC_VERSION (BC_BASE_VERSION | BC_BE_VERSION)
#else
#define BC_VERSION BC_BASE_VERSION
#endif

#ifndef NO_QUICKJS_COMPILER
#define MAGIC_SET (1 << 0)
#define MAGIC_WEAK (1 << 1)
typedef struct BCWriterState {
  LEPUSContext *ctx;
  DynBuf dbuf;
  BOOL byte_swap;
  BOOL allow_bytecode;
  uint32_t first_atom;
  uint32_t *atom_to_idx;
  int atom_to_idx_size;
  JSAtom *idx_to_atom;
  int idx_to_atom_count;
  int idx_to_atom_size;
} BCWriterState;

#ifdef DUMP_READ_OBJECT
static const char *const bc_tag_str[] = {
    "invalid", "null",      "undefined", "false",    "true",
    "int32",   "float64",   "string",    "object",   "array",
    "big_int", "big_float", "template",  "function", "module",
};
#endif

QJS_STATIC void bc_put_u8(BCWriterState *s, uint8_t v) {
  dbuf_putc(&s->dbuf, v);
}

QJS_STATIC void bc_put_u16(BCWriterState *s, uint16_t v) {
  if (s->byte_swap) v = bswap16(v);
  dbuf_put_u16(&s->dbuf, v);
}

QJS_STATIC __attribute__((unused)) void bc_put_u32(BCWriterState *s,
                                                   uint32_t v) {
  if (s->byte_swap) v = bswap32(v);
  dbuf_put_u32(&s->dbuf, v);
}

QJS_STATIC void bc_put_u64(BCWriterState *s, uint64_t v) {
  if (s->byte_swap) v = bswap64(v);
  dbuf_put(&s->dbuf, (uint8_t *)&v, sizeof(v));
}

QJS_STATIC void bc_put_leb128(BCWriterState *s, uint32_t v) {
  dbuf_put_leb128(&s->dbuf, v);
}

QJS_STATIC void bc_put_sleb128(BCWriterState *s, int32_t v) {
  dbuf_put_sleb128(&s->dbuf, v);
}

QJS_STATIC void bc_set_flags(uint32_t *pflags, int *pidx, uint32_t val, int n) {
  *pflags = *pflags | (val << *pidx);
  *pidx += n;
}

QJS_STATIC int bc_atom_to_idx(BCWriterState *s, uint32_t *pres, JSAtom atom) {
  uint32_t v;

  if (atom < s->first_atom || __JS_AtomIsTaggedInt(atom)) {
    *pres = atom;
    return 0;
  }
  atom -= s->first_atom;
  if (atom < s->atom_to_idx_size && s->atom_to_idx[atom] != 0) {
    *pres = s->atom_to_idx[atom];
    return 0;
  }
  if (atom >= s->atom_to_idx_size) {
    size_t new_size, i, slack;
    uint32_t *new_tab;
    /* XXX: potential arithmetic overflow */
    new_size = s->atom_to_idx_size * 3 / 2;
    if ((atom + 1) > new_size) new_size = atom + 1;
    new_tab = static_cast<uint32_t *>(lepus_realloc2(
        s->ctx, s->atom_to_idx, new_size * sizeof(s->atom_to_idx[0]), &slack));
    if (!new_tab) goto fail;
    new_size += slack / sizeof(*new_tab);
    for (i = s->atom_to_idx_size; i < new_size; i++) new_tab[i] = 0;
    s->atom_to_idx = new_tab;
    s->atom_to_idx_size = new_size;
  }
  if ((s->idx_to_atom_count + 1) > s->idx_to_atom_size) {
    size_t new_size, slack;
    JSAtom *new_tab;
    new_size = s->idx_to_atom_size * 3 / 2;
    if ((s->idx_to_atom_count + 1) > new_size)
      new_size = s->idx_to_atom_count + 1;
    new_tab = static_cast<JSAtom *>(lepus_realloc2(
        s->ctx, s->idx_to_atom, new_size * sizeof(s->idx_to_atom[0]), &slack));
    if (!new_tab) goto fail;
    new_size += slack / sizeof(*new_tab);
    s->idx_to_atom = new_tab;
    s->idx_to_atom_size = new_size;
  }

  v = s->idx_to_atom_count++;
  s->idx_to_atom[v] = atom + s->first_atom;
  v += s->first_atom;
  s->atom_to_idx[atom] = v;
  *pres = v;
  return 0;
fail:
  *pres = 0;
  return -1;
}

QJS_STATIC int bc_put_atom(BCWriterState *s, JSAtom atom) {
  uint32_t v;

  if (__JS_AtomIsTaggedInt(atom)) {
    v = (__JS_AtomToUInt32(atom) << 1) | 1;
  } else {
    if (bc_atom_to_idx(s, &v, atom)) return -1;
    v <<= 1;
  }
  bc_put_leb128(s, v);
  return 0;
}

QJS_STATIC void bc_byte_swap(uint8_t *bc_buf, int bc_len) {
  int pos, len, op, fmt;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    len = short_opcode_info(op).size;
    fmt = short_opcode_info(op).fmt;
    switch (fmt) {
      case OP_FMT_u16:
      case OP_FMT_i16:
      case OP_FMT_label16:
      case OP_FMT_npop:
      case OP_FMT_loc:
      case OP_FMT_arg:
      case OP_FMT_var_ref:
        put_u16(bc_buf + pos + 1, bswap16(get_u16(bc_buf + pos + 1)));
        break;
      case OP_FMT_i32:
      case OP_FMT_u32:
      case OP_FMT_const:
      case OP_FMT_label:
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        break;
      // <Primjs begin>
      case OP_FMT_u64:
        put_u64(bc_buf + pos + 1, bswap64(get_u64(bc_buf) + pos + 1));
        break;
      // <Primjs end>
      case OP_FMT_atom_u16:
      case OP_FMT_label_u16:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        put_u16(bc_buf + pos + 1 + 4, bswap16(get_u16(bc_buf + pos + 1 + 4)));
        break;
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        put_u32(bc_buf + pos + 1 + 4, bswap32(get_u32(bc_buf + pos + 1 + 4)));
        if (fmt == OP_FMT_atom_label_u16) {
          put_u16(bc_buf + pos + 1 + 4 + 4,
                  bswap16(get_u16(bc_buf + pos + 1 + 4 + 4)));
        }
        break;
      default:
        break;
    }
    pos += len;
  }
}

QJS_STATIC int JS_WriteFunctionBytecode(BCWriterState *s,
                                        LEPUSFunctionBytecode *b,
                                        const uint8_t *bc_buf1, int bc_len) {
  int pos, len, op;
  JSAtom atom;
  uint8_t *bc_buf;
  uint32_t val;

  bc_buf = static_cast<uint8_t *>(lepus_malloc(s->ctx, bc_len));
  if (!bc_buf) return -1;
  HandleScope func_scope(s->ctx, bc_buf, HANDLE_TYPE_DIR_HEAP_OBJ);
  memcpy(bc_buf, bc_buf1, bc_len);

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    len = short_opcode_info(op).size;
    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        atom = get_u32(bc_buf + pos + 1);
        if (bc_atom_to_idx(s, &val, atom)) goto fail;
        put_u32(bc_buf + pos + 1, val);
        break;
      default:
        break;
    }
    pos += len;
  }

  if (s->byte_swap) bc_byte_swap(bc_buf, bc_len);

  dbuf_put(&s->dbuf, bc_buf, bc_len);

  if (!s->ctx->gc_enable) lepus_free(s->ctx, bc_buf);
  return 0;
fail:
  if (!s->ctx->gc_enable) lepus_free(s->ctx, bc_buf);
  return -1;
}

QJS_STATIC void JS_WriteString(BCWriterState *s, JSString *p) {
  int i;
  bc_put_leb128(s, ((uint32_t)p->len << 1) | p->is_wide_char);
  if (p->is_wide_char) {
    for (i = 0; i < p->len; i++) bc_put_u16(s, p->u.str16[i]);
  } else {
    dbuf_put(&s->dbuf, p->u.str8, p->len);
  }
}

QJS_STATIC int JS_WriteObjectRec(BCWriterState *s, LEPUSValueConst obj);
static int JS_WriteArray(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, len;
  LEPUSValue val;
  int ret;
  BOOL is_template;

  if (s->allow_bytecode && !p->extensible) {
    /* not extensible array: we consider it is a
       template when we are saving bytecode */
    bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);
    is_template = TRUE;
  } else {
    bc_put_u8(s, BC_TAG_ARRAY);
    is_template = FALSE;
  }
  if (lepus_get_length32(s->ctx, &len, obj)) goto fail1;
  bc_put_leb128(s, len);
  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(s->ctx, obj, i);
    if (LEPUS_IsException(val)) goto fail1;
    ret = JS_WriteObjectRec(s, val);
    if (!s->ctx->gc_enable) LEPUS_FreeValue(s->ctx, val);
    if (ret) goto fail1;
  }
  if (is_template) {
    val = LEPUS_GetPropertyInternal(s->ctx, obj, JS_ATOM_raw, obj, 0);
    if (LEPUS_IsException(val)) goto fail1;
    ret = JS_WriteObjectRec(s, val);
    if (!s->ctx->gc_enable) LEPUS_FreeValue(s->ctx, val);
    if (ret) goto fail1;
  }
  return 0;
fail1:
  return -1;
}

#ifdef ENABLE_BUILTIN_SERIALIZE
static int JS_WriteTypedArray(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  JSTypedArray *ta = p->u.typed_array;

  bc_put_u8(s, BC_TAG_TYPED_ARRAY);
  bc_put_u8(s, p->class_id - JS_CLASS_UINT8C_ARRAY);
  bc_put_leb128(s, p->u.array.count);
  bc_put_leb128(s, ta->offset);
  if (JS_WriteObjectRec(s, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer)))
    return -1;
  return 0;
}

static int JS_WriteDataView(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  JSTypedArray *ta = p->u.typed_array;

  bc_put_u8(s, BC_TAG_DATAVIEW);
  bc_put_leb128(s, ta->length);
  bc_put_leb128(s, ta->offset);
  if (JS_WriteObjectRec(s, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer)))
    return -1;
  return 0;
}

static int JS_WriteError(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_ERROR);
  LEPUSObject *proto = p->shape->proto;
  LEPUSValue name = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_name, obj, 0);
  const char *str = LEPUS_ToCStringLen2(ctx, NULL, name, 0);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, name);
  int8_t magic = -1;
  for (int i = 0; i < JS_NATIVE_ERROR_COUNT; ++i) {
    if (strcmp(str, native_error_name[i]) == 0) {
      magic = i;
      break;
    }
  }
  if (!ctx->gc_enable) LEPUS_FreeCString(ctx, str);
  bc_put_u8(s, magic);

  LEPUSValue message =
      LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_message, obj, 0);
  if (unlikely(JS_WriteObjectRec(s, message))) return -1;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, message);

  LEPUSValue stack = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_stack, obj, 0);
  if (unlikely(JS_WriteObjectRec(s, stack))) return -1;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, stack);

  if (magic == JS_AGGREGATE_ERROR) {
    LEPUSValue error_list = LEPUS_GetPropertyStr(ctx, obj, "errors");
    if (unlikely(JS_WriteObjectRec(s, error_list))) {
      if (!ctx->gc_enable) LEPUS_FreeValue(ctx, error_list);
      return -1;
    }
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, error_list);
  }
  return 0;
}

static int JS_WriteRegExp(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_REGEXP);
  LEPUSValue pat, bc;
  pat = LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.pattern);
  bc = LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.bytecode);
  if (unlikely(JS_WriteObjectRec(s, pat))) return -1;
  if (unlikely(JS_WriteObjectRec(s, bc))) return -1;
  return 0;
}

static int JS_WriteMap(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_MAP);
  uint8_t magic = p->class_id - JS_CLASS_MAP;
  bc_put_u8(s, magic);
  bool is_set = magic & MAGIC_SET;
  JSMapState *ms = static_cast<JSMapState *>(p->u.opaque);
  bc_put_u32(s, ms->record_count);
  list_head *el;
  JSMapRecord *rec;
  list_for_each(el, &ms->records) {
    rec = list_entry(el, JSMapRecord, link);
    if (rec->empty) continue;
    if (unlikely(JS_WriteObjectRec(s, rec->key))) return -1;
    if (!is_set)
      if (unlikely(JS_WriteObjectRec(s, rec->value))) goto fail;
  }
  return 0;
fail:
  return -1;
}

static int JS_WriteArrayBuffer(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  JSArrayBuffer *abuf = p->u.array_buffer;
  if (abuf->detached) {
    JS_ThrowTypeErrorDetachedArrayBuffer(s->ctx);
    return -1;
  }
  bc_put_u8(s, BC_TAG_ARRAY_BUFFER);
  bc_put_leb128(s, abuf->byte_length);
  dbuf_put(&s->dbuf, abuf->data, abuf->byte_length);
  return 0;
}
#endif

static int JS_WriteObjectTag(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, prop_count;
  JSShape *sh;
  JSShapeProperty *pr;
  int pass;
  JSAtom atom;

  bc_put_u8(s, BC_TAG_OBJECT);
  prop_count = 0;
  sh = p->shape;
  for (pass = 0; pass < 2; pass++) {
    if (pass == 1) bc_put_leb128(s, prop_count);
    for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
      atom = pr->atom;
      if (atom != JS_ATOM_NULL && JS_AtomIsString(s->ctx, atom) &&
          (pr->flags & LEPUS_PROP_ENUMERABLE)) {
        if (pr->flags & LEPUS_PROP_TMASK) {
          LEPUS_ThrowTypeError(s->ctx, "only value properties are supported");
          goto fail;
        }
        if (pass == 0) {
          prop_count++;
        } else {
          bc_put_atom(s, atom);
          if (JS_WriteObjectRec(s, p->prop[i].u.value)) goto fail;
        }
      }
    }
  }
  return 0;
fail:
  return -1;
}

static int JS_WriteFunction(BCWriterState *s, LEPUSValueConst obj) {
  uint8_t debuginfo_outside = s->ctx->debuginfo_outside;
  LEPUSFunctionBytecode *b =
      static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
  uint32_t flags;
  int idx, i;

  if (!s->allow_bytecode) goto fail;
  bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
  flags = idx = 0;
  bc_set_flags(&flags, &idx, b->has_prototype, 1);
  bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);
  bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);
  bc_set_flags(&flags, &idx, b->need_home_object, 1);
  bc_set_flags(&flags, &idx, b->func_kind, 2);
  bc_set_flags(&flags, &idx, b->new_target_allowed, 1);
  bc_set_flags(&flags, &idx, b->super_call_allowed, 1);
  bc_set_flags(&flags, &idx, b->super_allowed, 1);
  bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
  bc_set_flags(&flags, &idx, b->has_debug, 1);
  assert(idx <= 16);
  bc_put_u16(s, flags);
  bc_put_u8(s, b->js_mode);
  bc_put_atom(s, b->func_name);

  bc_put_leb128(s, b->arg_count);
  bc_put_leb128(s, b->var_count);
  bc_put_leb128(s, b->defined_arg_count);
  bc_put_leb128(s, b->stack_size);
  bc_put_leb128(s, b->closure_var_count);
  bc_put_leb128(s, b->cpool_count);
  bc_put_leb128(s, b->byte_code_len);
  if (b->vardefs) {
    bc_put_leb128(s, b->arg_count + b->var_count);
    for (i = 0; i < b->arg_count + b->var_count; i++) {
      JSVarDef *vd = &b->vardefs[i];
      bc_put_atom(s, vd->var_name);
      bc_put_leb128(s, vd->scope_level);
      bc_put_leb128(s, vd->scope_next + 1);
      flags = idx = 0;
      bc_set_flags(&flags, &idx, vd->var_kind, 4);
      bc_set_flags(&flags, &idx, vd->is_const, 1);
      bc_set_flags(&flags, &idx, vd->is_lexical, 1);
      bc_set_flags(&flags, &idx, vd->is_captured, 1);
      assert(idx <= 8);
      bc_put_u8(s, flags);
    }
  } else {
    bc_put_leb128(s, 0);
  }

  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv = &b->closure_var[i];
    bc_put_atom(s, cv->var_name);
    bc_put_leb128(s, cv->var_idx);
    flags = idx = 0;
    bc_set_flags(&flags, &idx, cv->is_local, 1);
    bc_set_flags(&flags, &idx, cv->is_arg, 1);
    bc_set_flags(&flags, &idx, cv->is_const, 1);
    bc_set_flags(&flags, &idx, cv->is_lexical, 1);
    bc_set_flags(&flags, &idx, cv->var_kind, 4);
    assert(idx <= 8);
    bc_put_u8(s, flags);
  }

  if (JS_WriteFunctionBytecode(s, b, b->byte_code_buf, b->byte_code_len))
    goto fail;

  // in lepusng debug mode, info related b->debug is saved in
  // debug-info.json. do not need to save in template.js
  if (b->has_debug) {
    if (debuginfo_outside == 1) {
      if (s->ctx->lynx_target_sdk_version &&
          IsHigherOrEqual(s->ctx->lynx_target_sdk_version,
                          PRIMJS_ADD_VERSION_CODE)) {
        bc_put_atom(s, b->debug.filename);
      } else {
        // b->debug.filename: magic string
        // b->debug.line_num: b->function_id. for debug
        // b->debug.pc2line_len: 0
        JSAtom magic_atom = LEPUS_NewAtom(s->ctx, lepusng_functionid_str);
        bc_put_atom(s, magic_atom);
      }
      bc_put_leb128(s, b->function_id);
      bc_put_leb128(s, 0);
    } else {
      bc_put_atom(s, b->debug.filename);
      bc_put_leb128(s, b->debug.line_num);
      bc_put_leb128(s, b->debug.pc2line_len);
      dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
    }
  }

  for (i = 0; i < b->cpool_count; i++) {
    if (JS_WriteObjectRec(s, b->cpool[i])) goto fail;
  }
  return 0;
fail:
  return -1;
}

static int JS_WriteModule(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSModuleDef *m = static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(obj));
  int i;

  if (!s->allow_bytecode) goto fail;
  bc_put_u8(s, BC_TAG_MODULE);
  bc_put_atom(s, m->module_name);

  bc_put_leb128(s, m->req_module_entries_count);
  for (i = 0; i < m->req_module_entries_count; i++) {
    JSReqModuleEntry *rme = &m->req_module_entries[i];
    bc_put_atom(s, rme->module_name);
  }

  bc_put_leb128(s, m->export_entries_count);
  for (i = 0; i < m->export_entries_count; i++) {
    JSExportEntry *me = &m->export_entries[i];
    bc_put_u8(s, me->export_type);
    if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
      bc_put_leb128(s, me->u.local.var_idx);
    } else {
      bc_put_leb128(s, me->u.req_module_idx);
      bc_put_atom(s, me->local_name);
    }
    bc_put_atom(s, me->export_name);
  }

  bc_put_leb128(s, m->star_export_entries_count);
  for (i = 0; i < m->star_export_entries_count; i++) {
    JSStarExportEntry *se = &m->star_export_entries[i];
    bc_put_leb128(s, se->req_module_idx);
  }

  bc_put_leb128(s, m->import_entries_count);
  for (i = 0; i < m->import_entries_count; i++) {
    JSImportEntry *mi = &m->import_entries[i];
    bc_put_leb128(s, mi->var_idx);
    bc_put_atom(s, mi->import_name);
    bc_put_leb128(s, mi->req_module_idx);
  }

  if (JS_WriteObjectRec(s, m->func_obj)) goto fail;
  return 0;
fail:
  return -1;
}
__exception QJS_STATIC int JS_WriteObjectRec(BCWriterState *s,
                                             LEPUSValueConst obj) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(obj);
  uint8_t debuginfo_outside = s->ctx->debuginfo_outside;

  switch (tag) {
    case LEPUS_TAG_NULL:
      bc_put_u8(s, BC_TAG_NULL);
      break;
    case LEPUS_TAG_UNDEFINED:
      bc_put_u8(s, BC_TAG_UNDEFINED);
      break;
    case LEPUS_TAG_BOOL:
      bc_put_u8(s, BC_TAG_BOOL_FALSE + LEPUS_VALUE_GET_BOOL(obj));
      break;
    case LEPUS_TAG_INT:
      bc_put_u8(s, BC_TAG_INT32);
      bc_put_sleb128(s, LEPUS_VALUE_GET_INT(obj));
      break;
    case LEPUS_TAG_FLOAT64: {
      JSFloat64Union u;
      bc_put_u8(s, BC_TAG_FLOAT64);
      u.d = LEPUS_VALUE_GET_FLOAT64(obj);
      bc_put_u64(s, u.u64);
    } break;
    case LEPUS_TAG_STRING: {
      JSString *p = LEPUS_VALUE_GET_STRING(obj);
      bc_put_u8(s, BC_TAG_STRING);
      JS_WriteString(s, p);
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      if (JS_WriteFunction(s, obj)) goto fail;
    } break;
    case LEPUS_TAG_MODULE: {
      if (JS_WriteModule(s, obj)) goto fail;
    } break;
    case LEPUS_TAG_OBJECT: {
      HandleScope block_scope(s->ctx->rt);
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
      uint32_t i, prop_count, len;
      JSShape *sh;
      JSShapeProperty *pr;
      LEPUSValue val = LEPUS_UNDEFINED;
      block_scope.PushHandle(&val, HANDLE_TYPE_LEPUS_VALUE);
      int ret, pass;
      BOOL is_template;
      JSAtom atom;

      if (p->tmp_mark) {
        LEPUS_ThrowTypeError(s->ctx, "circular reference");
        goto fail;
      }
      p->tmp_mark = 1;
      switch (p->class_id) {
        case JS_CLASS_ARRAY:
          ret = JS_WriteArray(s, obj);
          break;
        case JS_CLASS_OBJECT:
          ret = JS_WriteObjectTag(s, obj);
          break;
#ifdef ENABLE_BUILTIN_SERIALIZE
        case JS_CLASS_ARRAY_BUFFER:
          ret = JS_WriteArrayBuffer(s, obj);
          break;
        case JS_CLASS_DATE:
          bc_put_u8(s, BC_TAG_DATE);
          ret = JS_WriteObjectRec(s, p->u.object_data);
          break;
        case JS_CLASS_UINT8C_ARRAY ... JS_CLASS_FLOAT64_ARRAY:
          ret = JS_WriteTypedArray(s, obj);
          break;
        case JS_CLASS_DATAVIEW:
          ret = JS_WriteDataView(s, obj);
          break;
        case JS_CLASS_ERROR:
          ret = JS_WriteError(s, obj);
          break;
        case JS_CLASS_REGEXP:
          ret = JS_WriteRegExp(s, obj);
          break;
        case JS_CLASS_MAP ... JS_CLASS_SET:
          ret = JS_WriteMap(s, obj);
          break;
        case JS_CLASS_NUMBER:
        case JS_CLASS_STRING:
        case JS_CLASS_BOOLEAN:
#ifdef CONFIG_BIGNUM
        case JS_CLASS_BIG_INT:
        case JS_CLASS_BIG_FLOAT:
#endif
          bc_put_u8(s, BC_TAG_OBJECT_VALUE);
          ret = JS_WriteObjectRec(s, p->u.object_data);
          break;
#endif  // ENABLE_BUILTIN_SERIALIZE
        default:
          LEPUS_ThrowTypeError(s->ctx, "unsupported object class");
          p->tmp_mark = 0;
          goto fail;
      }
      p->tmp_mark = 0;
      if (ret) goto fail;
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      int32_t e;
      JSBigFloat *bf = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(obj));
      bf_t *a = &bf->num;
      size_t len, i, n1, j;
      limb_t v;

      bc_put_u8(s,
                tag == LEPUS_TAG_BIG_INT ? BC_TAG_BIG_INT : BC_TAG_BIG_FLOAT);
      if (a->len != 0) {
        i = 0;
        while (i < a->len && a->tab[i] == 0) i++;
        assert(i < a->len);
        v = a->tab[i];
        n1 = sizeof(limb_t);
        while ((v & 0xff) == 0) {
          n1--;
          v >>= 8;
        }
        i++;
        len = (a->len - i) * sizeof(limb_t) + n1;
        if (len > INT32_MAX) {
          LEPUS_ThrowInternalError(s->ctx, "bignum is too large");
          goto fail;
        }
        /* XXX: it would be slightly more efficient to put the
           sign in the MSB of the mantissa */
        bc_put_leb128(s, len * 2 + a->sign);
        /* always saved in byte based little endian representation */
        for (j = 0; j < n1; j++) {
          dbuf_putc(&s->dbuf, v >> (j * 8));
        }
        for (; i < a->len; i++) {
          limb_t v = a->tab[i];
#if LIMB_BITS == 32
#ifdef WORDS_BIGENDIAN
          v = bswap32(v);
#endif
          dbuf_put_u32(&s->dbuf, v);
#else
#ifdef WORDS_BIGENDIAN
          v = bswap64(v);
#endif
          dbuf_put_u64(&s->dbuf, v);
#endif
        }
#if LIMB_BITS != 32
        if (a->expn <= INT32_MIN || a->expn >= (INT32_MAX - 1)) {
          LEPUS_ThrowInternalError(s->ctx, "bignum exponent is too large");
          goto fail;
        }
#endif
        bc_put_sleb128(s, a->expn);
      } else {
        bc_put_leb128(s, a->sign); /* length + sign */
        if (tag == LEPUS_TAG_BIG_FLOAT) {
          /* special numbers */
          if (a->expn == BF_EXP_ZERO) {
            e = 0;
          } else if (a->expn == BF_EXP_INF) {
            e = 1;
          } else {
            e = 2;
          }
          bc_put_u8(s, e);
        }
      }
    } break;
#endif
    default:
#if defined(__aarch64__) && !defined(OS_WIN) && !defined(CONFIG_BIGNUM) && \
    !DISABLE_NANBOX
      LEPUS_ThrowInternalError(s->ctx, "unsupported tag (%p)", (void *)tag);
#else
      LEPUS_ThrowInternalError(s->ctx, "unsupported tag (%" PRId64 ")", tag);
#endif
      goto fail;
  }
  return 0;

fail:
  return -1;
}

bool JS_IsNewVersion(LEPUSContext *ctx) {
  const char *lynxVersion = ctx->lynx_target_sdk_version;
  if (!lynxVersion || strcmp(lynxVersion, "") == 0 ||
      strcmp(lynxVersion, "null") == 0) {
    return false;
  }
  return IsHigherOrEqual(lynxVersion, PRIMJS_ADD_VERSION_CODE);
}

/* create the atom table */
QJS_STATIC int JS_WriteObjectAtoms(BCWriterState *s) {
  LEPUSRuntime *rt = s->ctx->rt;
  DynBuf dbuf1;
  int i, atoms_size;
  uint8_t version;
  uint64_t primjs_version;

  dbuf1 = s->dbuf;
  HandleScope func_scope(s->ctx, &dbuf1.buf, HANDLE_TYPE_HEAP_OBJ);
  js_dbuf_init(s->ctx, &s->dbuf);

  if (!JS_IsNewVersion(s->ctx)) {
    version = BC_VERSION;
  } else {
    version = BC_VERSION + BC_NEW_PREFIX;
  }
  if (s->byte_swap) version ^= BC_BE_VERSION;
  bc_put_u8(s, version);

  if (JS_IsNewVersion(s->ctx)) {
    primjs_version = LEPUS_GetPrimjsVersion();
    if (s->ctx->debuginfo_outside) {
      primjs_version |= NEW_DEBUGINFO_FLAG;
    }
    bc_put_u64(s, primjs_version);
  }

  bc_put_leb128(s, s->idx_to_atom_count);
  for (i = 0; i < s->idx_to_atom_count; i++) {
    JSAtomStruct *p = rt->atom_array[s->idx_to_atom[i]];
    JS_WriteString(s, p);
  }
  /* XXX: should check for OOM in above phase */

  /* move the atoms at the start */
  /* XXX: could just append dbuf1 data, but it uses more memory if
     dbuf1 is larger than dbuf */
  atoms_size = s->dbuf.size;
  if (dbuf_realloc(&dbuf1, dbuf1.size + atoms_size)) goto fail;
  memmove(dbuf1.buf + atoms_size, dbuf1.buf, dbuf1.size);
  memcpy(dbuf1.buf, s->dbuf.buf, atoms_size);
  dbuf1.size += atoms_size;
  if (!s->ctx->gc_enable) dbuf_free(&s->dbuf);
  s->dbuf = dbuf1;
  return 0;
fail:
  if (!s->ctx->gc_enable) dbuf_free(&dbuf1);
  return -1;
}

/**
 * version code
 * 63     reserve       32  debuginfo 31     opnum + atom_num          0
 *  |************************|********|********************************|
 */
uint64_t LEPUS_GetPrimjsVersion() {
  uint64_t op_num = OP_COUNT + (OP_TEMP_END - OP_TEMP_START);
  uint64_t atom_num = JS_ATOM_END - 1;
  uint64_t primjs_version = op_num + atom_num;
  primjs_version |= VERSION_PLACEHOLDER;
  return primjs_version;
}

uint8_t *LEPUS_WriteObject(LEPUSContext *ctx, size_t *psize,
                           LEPUSValueConst obj, int flags) {
  BCWriterState ss, *s = &ss;

  memset(s, 0, sizeof(*s));
  HandleScope func_scope(ctx, &s->atom_to_idx, HANDLE_TYPE_HEAP_OBJ);
  func_scope.PushHandle(&s->idx_to_atom, HANDLE_TYPE_HEAP_OBJ);
  s->ctx = ctx;
  /* XXX: byte swapped output is untested */
  s->byte_swap = ((flags & LEPUS_WRITE_OBJ_BSWAP) != 0);
  s->allow_bytecode = ((flags & LEPUS_WRITE_OBJ_BYTECODE) != 0);
  /* XXX: could use a different version when bytecode is included */
  if (s->allow_bytecode)
    s->first_atom = JS_ATOM_END;
  else
    s->first_atom = 1;
  js_dbuf_init(ctx, &s->dbuf);
  func_scope.PushHandle(&s->dbuf.buf, HANDLE_TYPE_HEAP_OBJ);

  if (JS_WriteObjectRec(s, obj)) goto fail;
  if (JS_WriteObjectAtoms(s)) goto fail;
  if (!ctx->gc_enable) {
    lepus_free(ctx, s->atom_to_idx);
    lepus_free(ctx, s->idx_to_atom);
  }
  *psize = s->dbuf.size;
  return s->dbuf.buf;
fail:
  if (!ctx->gc_enable) {
    lepus_free(ctx, s->atom_to_idx);
    lepus_free(ctx, s->idx_to_atom);
    dbuf_free(&s->dbuf);
  }
  *psize = 0;
  return NULL;
}
#endif

typedef struct BCReaderState {
  LEPUSContext *ctx;
  const uint8_t *buf_start, *ptr, *buf_end;
  uint32_t first_atom;
  uint32_t idx_to_atom_count;
  JSAtom *idx_to_atom;
  int error_state;
  BOOL allow_bytecode;
  BOOL is_rom_data;
#ifdef DUMP_READ_OBJECT
  const uint8_t *ptr_last;
  int level;
#endif
} BCReaderState;

#ifdef DUMP_READ_OBJECT
static void __attribute__((format(printf, 2, 3)))
bc_read_trace(BCReaderState *s, const char *fmt, ...) {
  va_list ap;
  int i, n, n0;

  if (!s->ptr_last) s->ptr_last = s->buf_start;

  n = n0 = 0;
  if (s->ptr > s->ptr_last || s->ptr == s->buf_start) {
    n0 = printf("%04x: ", (int)(s->ptr_last - s->buf_start));
    n += n0;
  }
  for (i = 0; s->ptr_last < s->ptr; i++) {
    if ((i & 7) == 0 && i > 0) {
      printf("\n%*s", n0, "");
      n = n0;
    }
    n += printf(" %02x", *s->ptr_last++);
  }
  if (*fmt == '}') s->level--;
  if (n < 32 + s->level * 2) {
    printf("%*s", 32 + s->level * 2 - n, "");
  }
  va_start(ap, fmt);
  vfprintf(stdout, fmt, ap);
  va_end(ap);
  if (strchr(fmt, '{')) s->level++;
}
#else
#define bc_read_trace(...)
#endif

QJS_STATIC int bc_read_error_end(BCReaderState *s) {
  if (!s->error_state) {
    LEPUS_ThrowSyntaxError(s->ctx, "read after the end of the buffer");
  }
  return s->error_state = -1;
}

QJS_STATIC int bc_get_u8(BCReaderState *s, uint8_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 1)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = *s->ptr++;
  return 0;
}

QJS_STATIC int bc_get_u16(BCReaderState *s, uint16_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 2)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u16(s->ptr);
  s->ptr += 2;
  return 0;
}

QJS_STATIC __attribute__((unused)) int bc_get_u32(BCReaderState *s,
                                                  uint32_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 4)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u32(s->ptr);
  s->ptr += 4;
  return 0;
}

QJS_STATIC int bc_get_u64(BCReaderState *s, uint64_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 8)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u64(s->ptr);
  s->ptr += 8;
  return 0;
}

QJS_STATIC int bc_get_leb128(BCReaderState *s, uint32_t *pval) {
  int ret;
  ret = get_leb128(pval, s->ptr, s->buf_end);
  if (unlikely(ret < 0)) return bc_read_error_end(s);
  s->ptr += ret;
  return 0;
}

QJS_STATIC int bc_get_sleb128(BCReaderState *s, int32_t *pval) {
  int ret;
  ret = get_sleb128(pval, s->ptr, s->buf_end);
  if (unlikely(ret < 0)) return bc_read_error_end(s);
  s->ptr += ret;
  return 0;
}

/* XXX: used to read an `int` with a positive value */
QJS_STATIC int bc_get_leb128_int(BCReaderState *s, int *pval) {
  return bc_get_leb128(s, (uint32_t *)pval);
}

QJS_STATIC int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval) {
  uint32_t val;
  if (bc_get_leb128(s, &val)) {
    *pval = 0;
    return -1;
  }
  *pval = val;
  return 0;
}

QJS_STATIC int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len) {
  if (buf_len != 0) {
    if (unlikely(!buf || s->buf_end - s->ptr < buf_len))
      return bc_read_error_end(s);
    memcpy(buf, s->ptr, buf_len);
    s->ptr += buf_len;
  }
  return 0;
}

QJS_STATIC int bc_idx_to_atom(BCReaderState *s, JSAtom *patom, uint32_t idx) {
  JSAtom atom;

  if (__JS_AtomIsTaggedInt(idx)) {
    atom = idx;
  } else if (idx < s->first_atom) {
    atom = LEPUS_DupAtom(s->ctx, idx);
  } else {
    idx -= s->first_atom;
    if (idx >= s->idx_to_atom_count) {
      LEPUS_ThrowSyntaxError(s->ctx, "invalid atom index (pos=%u)",
                             (unsigned int)(s->ptr - s->buf_start));
      *patom = JS_ATOM_NULL;
      return s->error_state = -1;
    }
    atom = LEPUS_DupAtom(s->ctx, s->idx_to_atom[idx]);
  }
  *patom = atom;
  return 0;
}

QJS_STATIC int bc_get_atom(BCReaderState *s, JSAtom *patom) {
  uint32_t v;
  if (bc_get_leb128(s, &v)) return -1;
  if (v & 1) {
    *patom = __JS_AtomFromUInt32(v >> 1);
    return 0;
  } else {
    return bc_idx_to_atom(s, patom, v >> 1);
  }
}

QJS_STATIC JSString *JS_ReadString(BCReaderState *s) {
  uint32_t len;
  size_t size;
  BOOL is_wide_char;
  JSString *p;

  if (bc_get_leb128(s, &len)) return NULL;
  is_wide_char = len & 1;
  len >>= 1;
  p = js_alloc_string(s->ctx, len, is_wide_char);
  if (!p) {
    s->error_state = -1;
    return NULL;
  }
  size = (size_t)len << is_wide_char;
  if ((s->buf_end - s->ptr) < size) {
    bc_read_error_end(s);
    if (!s->ctx->gc_enable) js_free_string(s->ctx->rt, p);
    return NULL;
  }
  memcpy(p->u.str8, s->ptr, size);
  s->ptr += size;
  if (!is_wide_char) {
    p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
  }
#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "string: ");
  JS_DumpString(s->ctx->rt, p);
  printf("\n");
#endif
  return p;
}

QJS_STATIC uint32_t bc_get_flags(uint32_t flags, int *pidx, int n) {
  uint32_t val;
  /* XXX: this does not work for n == 32 */
  val = (flags >> *pidx) & ((1U << n) - 1);
  *pidx += n;
  return val;
}

QJS_STATIC int JS_ReadFunctionBytecode(LEPUSContext *ctx, BCReaderState *s,
                                       LEPUSFunctionBytecode *&b,
                                       int byte_code_offset, uint32_t bc_len) {
  uint8_t *bc_buf;
  int pos, len, op;
  JSAtom atom;
  uint32_t idx;

  if (s->is_rom_data) {
    /* directly use the input buffer */
    if (unlikely(s->buf_end - s->ptr < bc_len)) return bc_read_error_end(s);
    bc_buf = (uint8_t *)s->ptr;
    s->ptr += bc_len;
  } else {
    bc_buf = (uint8_t *)b + byte_code_offset;
    if (bc_get_buf(s, bc_buf, bc_len)) return -1;
  }
  b->byte_code_buf = bc_buf;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    len = short_opcode_info(op).size;
    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        idx = get_u32(bc_buf + pos + 1);
        if (s->is_rom_data) {
          /* just increment the reference count of the atom */
          LEPUS_DupAtom(s->ctx, (JSAtom)idx);
        } else {
          if (bc_idx_to_atom(s, &atom, idx)) {
            /* Note: the atoms will be freed up to this position */
            b->byte_code_len = pos;
            return -1;
          }
          put_u32(bc_buf + pos + 1, atom);
#ifdef DUMP_READ_OBJECT
          bc_read_trace(s, "at %d, fixup atom: ", pos + 1);
          print_atom(s->ctx, atom);
          printf("\n");
#endif
        }
        break;
      default:
        break;
    }
    pos += len;
  }
  return 0;
}

QJS_STATIC LEPUSValue JS_ReadFunction(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  HandleScope func_scope(ctx);
  LEPUSValue obj = LEPUS_UNDEFINED;
  LEPUSFunctionBytecode bc, *b;
  uint16_t v16;
  uint8_t v8;
  int idx, i, local_count;
  int function_size, cpool_offset, byte_code_offset;
  int closure_var_offset, vardefs_offset;

  if (!s->allow_bytecode) goto fail;
  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  memset(&bc, 0, sizeof(bc));
  if (!ctx->gc_enable) bc.header.ref_count = 1;

  if (bc_get_u16(s, &v16)) goto fail;
  idx = 0;
  bc.has_prototype = bc_get_flags(v16, &idx, 1);
  bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);
  bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);
  bc.need_home_object = bc_get_flags(v16, &idx, 1);
  bc.func_kind = bc_get_flags(v16, &idx, 2);
  bc.new_target_allowed = bc_get_flags(v16, &idx, 1);
  bc.super_call_allowed = bc_get_flags(v16, &idx, 1);
  bc.super_allowed = bc_get_flags(v16, &idx, 1);
  bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
  bc.has_debug = bc_get_flags(v16, &idx, 1);
  bc.read_only_bytecode = s->is_rom_data;
  if (bc_get_u8(s, &v8)) goto fail;
  bc.js_mode = v8;
  if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure
    goto fail;
  if (bc_get_leb128_u16(s, &bc.arg_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.var_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.defined_arg_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.stack_size)) goto fail;
  if (bc_get_leb128_int(s, &bc.closure_var_count)) goto fail;
  if (bc_get_leb128_int(s, &bc.cpool_count)) goto fail;
  if (bc_get_leb128_int(s, &bc.byte_code_len)) goto fail;
  if (bc_get_leb128_int(s, &local_count)) goto fail;

  if (bc.has_debug) {
    function_size = sizeof(*b);
  } else {
    function_size = offsetof(LEPUSFunctionBytecode, debug);
  }
  cpool_offset = function_size;
  function_size += bc.cpool_count * sizeof(*bc.cpool);
  vardefs_offset = function_size;
  function_size += local_count * sizeof(*bc.vardefs);
  closure_var_offset = function_size;
  function_size += bc.closure_var_count * sizeof(*bc.closure_var);
  byte_code_offset = function_size;
  if (!bc.read_only_bytecode) {
    function_size += bc.byte_code_len;
  }

  b = static_cast<LEPUSFunctionBytecode *>(
      lepus_mallocz(ctx, function_size, ALLOC_TAG_LEPUSFunctionBytecode));
  if (!b) return LEPUS_EXCEPTION;
  func_scope.PushHandle(b, HANDLE_TYPE_DIR_HEAP_OBJ);

  memcpy(b, &bc, offsetof(LEPUSFunctionBytecode, debug));
  // obj = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);

#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "name: ");
  print_atom(s->ctx, b->func_name);
  printf("\n");
#endif
  bc_read_trace(s, "args=%d vars=%d defargs=%d closures=%d cpool=%d\n",
                b->arg_count, b->var_count, b->defined_arg_count,
                b->closure_var_count, b->cpool_count);
  bc_read_trace(s, "stack=%d bclen=%d locals=%d\n", b->stack_size,
                b->byte_code_len, local_count);

  if (local_count != 0) {
    bc_read_trace(s, "vars {\n");
    b->vardefs = (JSVarDef *)((uint8_t *)b + vardefs_offset);
    for (i = 0; i < local_count; i++) {
      JSVarDef *vd = &b->vardefs[i];
      if (bc_get_atom(s, &vd->var_name)) goto fail;
      if (bc_get_leb128_int(s, &vd->scope_level)) goto fail;
      if (bc_get_leb128_int(s, &vd->scope_next)) goto fail;
      vd->scope_next--;
      if (bc_get_u8(s, &v8)) goto fail;
      idx = 0;
      vd->var_kind = bc_get_flags(v8, &idx, 4);
      vd->is_const = bc_get_flags(v8, &idx, 1);
      vd->is_lexical = bc_get_flags(v8, &idx, 1);
      vd->is_captured = bc_get_flags(v8, &idx, 1);
#ifdef DUMP_READ_OBJECT
      bc_read_trace(s, "name: ");
      print_atom(s->ctx, vd->var_name);
      printf("\n");
#endif
    }
    bc_read_trace(s, "}\n");
  }
  if (b->closure_var_count != 0) {
    bc_read_trace(s, "closure vars {\n");
    b->closure_var = (LEPUSClosureVar *)((uint8_t *)b + closure_var_offset);
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      int var_idx;
      if (bc_get_atom(s, &cv->var_name)) goto fail;
      if (bc_get_leb128_int(s, &var_idx)) goto fail;
      cv->var_idx = var_idx;
      if (bc_get_u8(s, &v8)) goto fail;
      idx = 0;
      cv->is_local = bc_get_flags(v8, &idx, 1);
      cv->is_arg = bc_get_flags(v8, &idx, 1);
      cv->is_const = bc_get_flags(v8, &idx, 1);
      cv->is_lexical = bc_get_flags(v8, &idx, 1);
      cv->var_kind = bc_get_flags(v8, &idx, 4);
#ifdef DUMP_READ_OBJECT
      bc_read_trace(s, "name: ");
      print_atom(s->ctx, cv->var_name);
      printf("\n");
#endif
    }
    bc_read_trace(s, "}\n");
  }
  {
    bc_read_trace(s, "bytecode {\n");
    if (JS_ReadFunctionBytecode(ctx, s, b, byte_code_offset, b->byte_code_len))
      goto fail;
    obj = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
    // < primjs end>
    bc_read_trace(s, "}\n");
  }
  if (b->has_debug) {
    /* read optional debug information */
    bc_read_trace(s, "debug {\n");
    if (bc_get_atom(s, &b->debug.filename)) goto fail;
    if (bc_get_leb128_int(s, &b->debug.line_num)) goto fail;

    if (ctx->debuginfo_outside == 1) {
      if (!(ctx->binary_version & NEW_DEBUGINFO_FLAG)) {
        // when target sdk version < 2.13, to be compatible with older products,
        // function's filename field is "lepus.js".
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, b->debug.filename);
        b->debug.filename = LEPUS_NewAtom(ctx, lepusjs_filename);
      }
      b->function_id = b->debug.line_num + 1;
    } else if (ctx->debuginfo_outside == 2) {
      // if ctx->debuginfo_outside == 2,
      // then the binary product must be an older version.
      const char *str = LEPUS_AtomToCString(ctx, b->debug.filename);
      if (str && !strcmp(str, lepusng_functionid_str)) {
        ctx->debuginfo_outside = 1;
        if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, b->debug.filename);
        b->debug.filename = LEPUS_NewAtom(ctx, lepusjs_filename);
        b->function_id = b->debug.line_num + 1;
      } else {
        ctx->debuginfo_outside = 0;
      }
      if (!ctx->gc_enable) LEPUS_FreeCString(ctx, str);
    }

    if (bc_get_leb128_int(s, &b->debug.pc2line_len)) goto fail;
    if (b->debug.pc2line_len) {
      b->debug.pc2line_buf = static_cast<uint8_t *>(
          lepus_mallocz(ctx, b->debug.pc2line_len, ALLOC_TAG_WITHOUT_PTR));
      if (!b->debug.pc2line_buf) goto fail;
      if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len)) goto fail;
    }
#ifdef ENABLE_QUICKJS_DEBUGGER
    b->debug.file_name = ctx->rt->atom_array[b->debug.filename];
#endif

#ifdef DUMP_READ_OBJECT
    bc_read_trace(s, "filename: ");
    print_atom(s->ctx, b->debug.filename);
    printf("\n");
#endif
    bc_read_trace(s, "}\n");
  }
  if (b->cpool_count != 0) {
    bc_read_trace(s, "cpool {\n");
    b->cpool = (LEPUSValue *)((uint8_t *)b + cpool_offset);
    for (i = 0; i < b->cpool_count; i++) {
      LEPUSValue val;
      val = JS_ReadObjectRec(s);
      if (LEPUS_IsException(val)) goto fail;
      b->cpool[i] = val;
    }
    bc_read_trace(s, "}\n");
  }
  bc_read_trace(s, "}\n");

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
  if (!(b->js_mode & JS_MODE_STRIP)) {
    js_dump_function_bytecode(ctx, b);
  }
#endif
  return obj;
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue JS_ReadModule(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  HandleScope func_scope(ctx);
  LEPUSModuleDef *m = NULL;
  LEPUSValue obj = LEPUS_UNDEFINED;
  JSAtom module_name;
  int i;
  uint8_t v8;

  if (!s->allow_bytecode) goto fail;
  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
  if (bc_get_atom(s, &module_name)) goto fail;
  func_scope.PushLEPUSAtom(module_name);
#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "name: ");
  print_atom(s->ctx, module_name);
  printf("\n");
#endif
  m = js_new_module_def(ctx, module_name);
  if (!m) goto fail;
  func_scope.PushHandle(m, HANDLE_TYPE_DIR_HEAP_OBJ);
  obj = ctx->gc_enable ? LEPUS_MKPTR(LEPUS_TAG_MODULE, m)
                       : LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  if (bc_get_leb128_int(s, &m->req_module_entries_count)) goto fail;
  if (m->req_module_entries_count != 0) {
    m->req_module_entries_size = m->req_module_entries_count;
    m->req_module_entries = static_cast<JSReqModuleEntry *>(lepus_mallocz(
        ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size,
        ALLOC_TAG_WITHOUT_PTR));
    if (!m->req_module_entries) goto fail;
    for (i = 0; i < m->req_module_entries_count; i++) {
      JSReqModuleEntry *rme = &m->req_module_entries[i];
      if (bc_get_atom(s, &rme->module_name)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->export_entries_count)) goto fail;
  if (m->export_entries_count != 0) {
    m->export_entries_size = m->export_entries_count;
    m->export_entries = static_cast<JSExportEntry *>(lepus_mallocz(
        ctx, sizeof(m->export_entries[0]) * m->export_entries_size,
        ALLOC_TAG_WITHOUT_PTR));
    if (!m->export_entries) goto fail;
    for (i = 0; i < m->export_entries_count; i++) {
      JSExportEntry *me = &m->export_entries[i];
      if (bc_get_u8(s, &v8)) goto fail;
      me->export_type = static_cast<JSExportTypeEnum>(v8);
      if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
        if (bc_get_leb128_int(s, &me->u.local.var_idx)) goto fail;
      } else {
        if (bc_get_leb128_int(s, &me->u.req_module_idx)) goto fail;
        if (bc_get_atom(s, &me->local_name)) goto fail;
      }
      if (bc_get_atom(s, &me->export_name)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->star_export_entries_count)) goto fail;
  if (m->star_export_entries_count != 0) {
    m->star_export_entries_size = m->star_export_entries_count;
    m->star_export_entries = static_cast<JSStarExportEntry *>(lepus_mallocz(
        ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size,
        ALLOC_TAG_WITHOUT_PTR));
    if (!m->star_export_entries) goto fail;
    for (i = 0; i < m->star_export_entries_count; i++) {
      JSStarExportEntry *se = &m->star_export_entries[i];
      if (bc_get_leb128_int(s, &se->req_module_idx)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->import_entries_count)) goto fail;
  if (m->import_entries_count != 0) {
    m->import_entries_size = m->import_entries_count;
    m->import_entries = static_cast<JSImportEntry *>(lepus_mallocz(
        ctx, sizeof(m->import_entries[0]) * m->import_entries_size,
        ALLOC_TAG_WITHOUT_PTR));
    if (!m->import_entries) goto fail;
    for (i = 0; i < m->import_entries_count; i++) {
      JSImportEntry *mi = &m->import_entries[i];
      if (bc_get_leb128_int(s, &mi->var_idx)) goto fail;
      if (bc_get_atom(s, &mi->import_name)) goto fail;
      if (bc_get_leb128_int(s, &mi->req_module_idx)) goto fail;
    }
  }

  m->func_obj = JS_ReadObjectRec(s);
  if (LEPUS_IsException(m->func_obj)) goto fail;
  bc_read_trace(s, "}\n");
  return obj;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, obj);
    if (m) {
      js_free_module_def(ctx, m);
    }
  }
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue JS_ReadObjectTag(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj;
  uint32_t prop_count, i;
  JSAtom atom;
  LEPUSValue val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  int ret;

  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  obj = LEPUS_NewObject(ctx);
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  if (bc_get_leb128(s, &prop_count)) goto fail;
  for (i = 0; i < prop_count; i++) {
    if (bc_get_atom(s, &atom)) goto fail;
    HandleScope block_scope(ctx->rt);
    block_scope.PushLEPUSAtom(atom);
#ifdef DUMP_READ_OBJECT
    bc_read_trace(s, "propname: ");
    print_atom(s->ctx, atom);
    printf("\n");
#endif
    val = JS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) {
      if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
      goto fail;
    }
    ret = LEPUS_DefinePropertyValue(ctx, obj, atom, val, LEPUS_PROP_C_W_E);
    if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
    if (ret < 0) goto fail;
  }
  bc_read_trace(s, "}\n");
  return obj;
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_ReadArray(BCReaderState *s, int tag) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj;
  uint32_t len, i;
  LEPUSValue val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  int ret, prop_flags;
  BOOL is_template;

  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  obj = LEPUS_NewArray(ctx);
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  is_template = (tag == BC_TAG_TEMPLATE_OBJECT);
  if (bc_get_leb128(s, &len)) goto fail;
  for (i = 0; i < len; i++) {
    val = JS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) goto fail;
    if (is_template)
      prop_flags = LEPUS_PROP_ENUMERABLE;
    else
      prop_flags = LEPUS_PROP_C_W_E;
    ret = LEPUS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags);
    if (ret < 0) goto fail;
  }
  if (is_template) {
    val = JS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) goto fail;
    if (!LEPUS_IsUndefined(val)) {
      ret = LEPUS_DefinePropertyValue(ctx, obj, JS_ATOM_raw, val, 0);
      if (ret < 0) goto fail;
    }
    seal_template_obj(ctx, obj);
    LEPUS_PreventExtensions(ctx, obj);
  }
  bc_read_trace(s, "}\n");
  return obj;
fail:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
#ifdef ENABLE_BUILTIN_SERIALIZE
QJS_STATIC LEPUSValue js_typed_array_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int classid);
QJS_STATIC LEPUSValue JS_ReadTypedArray(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, array_buffer = LEPUS_UNDEFINED;
  uint8_t array_tag;
  HandleScope func_scope(ctx);
  LEPUSValueConst args[3];
  func_scope.PushLEPUSValueArrayHandle(args, 3);
  uint32_t offset, len, idx;

  if (bc_get_u8(s, &array_tag)) return LEPUS_EXCEPTION;
  if (array_tag >= JS_TYPED_ARRAY_COUNT)
    return LEPUS_ThrowTypeError(ctx, "invalid typed array");
  if (bc_get_leb128(s, &len)) return LEPUS_EXCEPTION;
  if (bc_get_leb128(s, &offset)) return LEPUS_EXCEPTION;
  array_buffer = JS_ReadObjectRec(s);
  if (LEPUS_IsException(array_buffer)) return LEPUS_EXCEPTION;
  if (!js_get_array_buffer(ctx, array_buffer)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, array_buffer);
    return LEPUS_EXCEPTION;
  }
  args[0] = array_buffer;
  args[1] = LEPUS_NewInt64(ctx, offset);
  args[2] = LEPUS_NewInt64(ctx, len);
  obj = js_typed_array_constructor(ctx, LEPUS_UNDEFINED, 3, args,
                                   JS_CLASS_UINT8C_ARRAY + array_tag);
  if (LEPUS_IsException(obj)) goto fail;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, array_buffer);
  return obj;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, array_buffer);
    LEPUS_FreeValue(ctx, obj);
  }
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue js_map_constructor(LEPUSContext *ctx,
                                         LEPUSValueConst new_target, int argc,
                                         LEPUSValueConst *argv, int magic);
QJS_HIDE LEPUSValue js_dataview_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv);
QJS_STATIC LEPUSValue JS_ReadDataView(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, array_buffer = LEPUS_UNDEFINED;
  LEPUSValueConst args[3];
  HandleScope func_scope(ctx);
  func_scope.PushLEPUSValueArrayHandle(args, 3);
  uint32_t offset, len, idx;

  if (bc_get_leb128(s, &len)) return LEPUS_EXCEPTION;
  if (bc_get_leb128(s, &offset)) return LEPUS_EXCEPTION;
  array_buffer = JS_ReadObjectRec(s);
  if (LEPUS_IsException(array_buffer)) return LEPUS_EXCEPTION;
  if (!js_get_array_buffer(ctx, array_buffer)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, array_buffer);
    return LEPUS_EXCEPTION;
  }
  args[0] = array_buffer;
  args[1] = LEPUS_NewInt64(ctx, offset);
  args[2] = LEPUS_NewInt64(ctx, len);
  obj = js_dataview_constructor(ctx, LEPUS_UNDEFINED, 3, args);
  if (LEPUS_IsException(obj)) goto fail;
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, array_buffer);
  return obj;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, array_buffer);
    LEPUS_FreeValue(ctx, obj);
  }
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_ReadError(BCReaderState *s) {
#ifdef ENABLE_COMPATIBLE_MM
  if (s->ctx->gc_enable) return JS_ReadError_GC(s);
#endif
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, msg = LEPUS_UNDEFINED,
             proto = LEPUS_UNDEFINED, stack = LEPUS_UNDEFINED;
  int8_t magic;
  if (bc_get_u8(s, (uint8_t *)&magic)) goto fail;
  msg = JS_ToStringFree(ctx, JS_ReadObjectRec(s));
  if (LEPUS_IsException(msg)) goto fail;
  stack = JS_ToStringFree(ctx, JS_ReadObjectRec(s));
  if (LEPUS_IsException(stack)) goto fail;
  if (magic < 0) {
    proto = ctx->class_proto[JS_CLASS_ERROR];
  } else {
    proto = ctx->native_error_proto[magic];
  }
  obj = JS_NewObjectProtoClass_RC(ctx, proto, JS_CLASS_ERROR);
  if (LEPUS_IsException(obj)) goto fail;
  JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_message, msg,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_stack, stack,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  if (magic == JS_AGGREGATE_ERROR) {
    LEPUSValue error_list = JS_ReadObjectRec(s);
    if (LEPUS_IsException(error_list)) {
      LEPUS_FreeValue(ctx, error_list);
      goto fail;
    }
    JSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
    JS_DefinePropertyValue_RC(ctx, obj, atom_errors, error_list,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, msg);
  LEPUS_FreeValue(ctx, stack);
  return LEPUS_EXCEPTION;
}

LEPUSValue JS_ReadRegExp(BCReaderState *s) {
#ifdef ENABLE_COMPATIBLE_MM
  if (s->ctx->gc_enable) return JS_ReadRegExp_GC(s);
#endif
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj, pattern, bc;
  pattern = JS_ReadObjectRec(s);
  bc = JS_ReadObjectRec(s);
  obj = js_regexp_constructor_internal(ctx, LEPUS_UNDEFINED, pattern, bc);
  return obj;
}

static LEPUSValue JS_ReadMap(BCReaderState *s) {
#ifdef ENABLE_COMPATIBLE_MM
  if (s->ctx->gc_enable) return JS_ReadMap_GC(s);
#endif
  LEPUSContext *ctx = s->ctx;
  uint8_t magic;
  bc_get_u8(s, &magic);
  const bool is_set = magic & MAGIC_SET;
  LEPUSValue obj = js_map_constructor(ctx, LEPUS_UNDEFINED, 0, NULL, magic);
  uint32_t count;
  bc_get_u32(s, &count);
  LEPUSValue adder = JS_GetPropertyInternal_RC(
      ctx, obj, is_set ? JS_ATOM_add : JS_ATOM_set, obj, 0);
  if (unlikely(LEPUS_IsException(adder))) goto fail;
  if (unlikely(!LEPUS_IsFunction(ctx, adder))) {
    LEPUS_ThrowTypeError(ctx, "set/add is not a function");
    goto fail;
  }
  for (uint32_t cnt = 0; cnt < count; ++cnt) {
    LEPUSValue key = JS_ReadObjectRec(s);
    LEPUSValue value = LEPUS_UNDEFINED;
    LEPUSValue ret;
    if (!is_set) {
      LEPUSValue args[2];
      args[0] = key;
      value = JS_ReadObjectRec(s);
      args[1] = value;

      ret = JS_Call_RC(ctx, adder, obj, 2, args);
      LEPUS_FreeValue(ctx, value);
    } else {
      ret = JS_Call_RC(ctx, adder, obj, 1, &key);
    }
    LEPUS_FreeValue(ctx, key);
    if (unlikely(LEPUS_IsException(ret))) goto fail;
    LEPUS_FreeValue(ctx, ret);
  }
  LEPUS_FreeValue(ctx, adder);
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, adder);
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue JS_ReadArrayBuffer(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  uint32_t byte_length;
  LEPUSValue obj;

  if (bc_get_leb128(s, &byte_length)) return LEPUS_EXCEPTION;
  if (unlikely(s->buf_end - s->ptr < byte_length)) {
    bc_read_error_end(s);
    return LEPUS_EXCEPTION;
  }
  obj = LEPUS_NewArrayBufferCopy(ctx, s->ptr, byte_length);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s->ptr += byte_length;
  return obj;
}

QJS_STATIC LEPUSValue JS_ReadDate(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val, obj = LEPUS_UNDEFINED;
  val = JS_ReadObjectRec(s);
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
  if (!LEPUS_IsNumber(val)) {
    LEPUS_ThrowTypeError(ctx, "Number tag expected for date");
    goto fail;
  }
  obj = LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_DATE],
                                  JS_CLASS_DATE);
  if (LEPUS_IsException(obj)) goto fail;
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  JS_SetObjectData(ctx, obj, val);
  return obj;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, val);
    LEPUS_FreeValue(ctx, obj);
  }
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_ReadObjectValue(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val, obj = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx);
  val = JS_ReadObjectRec(s);
  if (LEPUS_IsException(val)) goto fail;
  func_scope.PushHandle(&val, HANDLE_TYPE_LEPUS_VALUE);
  obj = LEPUS_ToObject(ctx, val);
  if (LEPUS_IsException(obj)) goto fail;
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, val);
  return obj;
fail:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, val);
    LEPUS_FreeValue(ctx, obj);
  }
  return LEPUS_EXCEPTION;
}
#endif  // ENABLE_BUILTIN_SERIALIZE

LEPUSValue JS_ReadObjectRec(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  uint8_t tag;
  LEPUSValue obj = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &obj, HANDLE_TYPE_LEPUS_VALUE);

  if (bc_get_u8(s, &tag)) return LEPUS_EXCEPTION;

  switch (tag) {
    case BC_TAG_NULL:
      bc_read_trace(s, "null\n");
      obj = LEPUS_NULL;
      break;
    case BC_TAG_UNDEFINED:
      bc_read_trace(s, "undefined\n");
      obj = LEPUS_UNDEFINED;
      break;
    case BC_TAG_BOOL_FALSE:
    case BC_TAG_BOOL_TRUE:
      bc_read_trace(s, "%s\n", bc_tag_str[tag]);
      obj = LEPUS_NewBool(ctx, tag - BC_TAG_BOOL_FALSE);
      break;
    case BC_TAG_INT32: {
      int32_t val;
      if (bc_get_sleb128(s, &val)) return LEPUS_EXCEPTION;
      bc_read_trace(s, "int32 %d\n", val);
      obj = LEPUS_NewInt32(ctx, val);
    } break;
    case BC_TAG_FLOAT64: {
      JSFloat64Union u;
      if (bc_get_u64(s, &u.u64)) return LEPUS_EXCEPTION;
      bc_read_trace(s, "float64 %g\n", u.d);
      obj = __JS_NewFloat64(ctx, u.d);
    } break;
    case BC_TAG_STRING: {
      JSString *p;
      p = JS_ReadString(s);
      if (!p) return LEPUS_EXCEPTION;
      obj = LEPUS_MKPTR(LEPUS_TAG_STRING, p);
    } break;
    case BC_TAG_FUNCTION_BYTECODE: {
      obj = JS_ReadFunction(s);
    } break;
    case BC_TAG_MODULE: {
      obj = JS_ReadModule(s);
    } break;
    case BC_TAG_OBJECT: {
      obj = JS_ReadObjectTag(s);
    } break;
    case BC_TAG_ARRAY:
    case BC_TAG_TEMPLATE_OBJECT: {
      obj = JS_ReadArray(s, tag);
    } break;
#ifdef ENABLE_BUILTIN_SERIALIZE
    case BC_TAG_TYPED_ARRAY:
      obj = JS_ReadTypedArray(s);
      break;
    case BC_TAG_ARRAY_BUFFER:
      obj = JS_ReadArrayBuffer(s);
      break;
    case BC_TAG_DATE:
      obj = JS_ReadDate(s);
      break;
    case BC_TAG_OBJECT_VALUE:
      obj = JS_ReadObjectValue(s);
      break;
    case BC_TAG_DATAVIEW:
      obj = JS_ReadDataView(s);
      break;
    case BC_TAG_ERROR:
      obj = JS_ReadError(s);
      break;
    case BC_TAG_REGEXP:
      obj = JS_ReadRegExp(s);
      break;
    case BC_TAG_MAP:
      obj = JS_ReadMap(s);
      break;
#endif
#ifdef CONFIG_BIGNUM
    case BC_TAG_BIG_INT:
    case BC_TAG_BIG_FLOAT: {
      uint8_t sign, v8;
      int32_t e;
      uint32_t len;
      limb_t l, i, n;
      JSBigFloat *p;
      bf_t *a;

      bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

      if (bc_get_leb128(s, &len)) goto fail;
      sign = len & 1;
      len >>= 1;
      p = js_new_bf(s->ctx);
      if (!p) goto fail;
      if (tag == BC_TAG_BIG_INT)
        obj = LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
      else
        obj = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
      l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);
      a = &p->num;
      bf_resize(a, l);
      a->sign = sign;
      if (len == 0) {
        if (tag == BC_TAG_BIG_INT) {
          a->expn = BF_EXP_ZERO;
        } else {
          if (bc_get_u8(s, &v8)) goto fail;
          switch (v8) {
            case 0:
              a->expn = BF_EXP_ZERO;
              break;
            case 1:
              a->expn = BF_EXP_INF;
              break;
            default:
            case 2:
              a->expn = BF_EXP_NAN;
              break;
          }
        }
      } else {
        n = len & (sizeof(limb_t) - 1);
        if (n != 0) {
          limb_t v;
          v = 0;
          for (i = 0; i < n; i++) {
            if (bc_get_u8(s, &v8)) goto fail;
            v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
          }
          a->tab[0] = v;
          i = 1;
        } else {
          i = 0;
        }
        for (; i < l; i++) {
          limb_t v;
#if LIMB_BITS == 32
          if (bc_get_u32(s, &v)) goto fail;
#ifdef WORDS_BIGENDIAN
          v = bswap32(v);
#endif
#else
          if (bc_get_u64(s, &v)) goto fail;
#ifdef WORDS_BIGENDIAN
          v = bswap64(v);
#endif
#endif
          a->tab[i] = v;
        }
        if (bc_get_sleb128(s, &e)) goto fail;
        a->expn = e;
      }
      bc_read_trace(s, "}\n");
    } break;
#endif
    default:
      return LEPUS_ThrowSyntaxError(ctx, "invalid tag (tag=%d pos=%u)", tag,
                                    (unsigned int)(s->ptr - s->buf_start));
  }
  return obj;
#ifdef CONFIG_BIGNUM
fail:
#endif
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

bool JS_CheckBytecodeVersion(uint64_t v64) {
  constexpr int32_t version_mask = -1;
  uint32_t binVersion = v64 & version_mask;
  uint32_t nowVersion = LEPUS_GetPrimjsVersion() & version_mask;
  return binVersion > nowVersion;
}

QJS_STATIC int JS_ReadObjectAtoms(BCReaderState *s) {
  uint8_t v8;
  uint64_t v64;
  JSString *p = nullptr;
#ifdef ENABLE_COMPATIBLE_MM
  HandleScope func_scope(s->ctx, &p, HANDLE_TYPE_HEAP_OBJ);
#endif
  int i;
  JSAtom atom;

  if (bc_get_u8(s, &v8)) return -1;
  /* XXX: could support byte swapped input */
  if (v8 != BC_VERSION) {
    if (v8 == BC_VERSION + BC_NEW_PREFIX) {
      if (bc_get_u64(s, &v64)) return -1;
      if (JS_CheckBytecodeVersion(v64)) {
        LEPUS_ThrowInternalError(s->ctx,
                                 "the binary version is higher than runtime");
        return -1;
      }
      s->ctx->binary_version = v64;
      if (v64 & NEW_DEBUGINFO_FLAG) {
        s->ctx->debuginfo_outside = 1;
      }
    } else {
      LEPUS_ThrowSyntaxError(s->ctx, "invalid version (%d expected=%d)", v8,
                             BC_VERSION);
      return -1;
    }
  }
  if (bc_get_leb128(s, &s->idx_to_atom_count)) return -1;

  bc_read_trace(s, "%d atom indexes {\n", s->idx_to_atom_count);

  if (s->idx_to_atom_count != 0) {
    s->idx_to_atom = static_cast<JSAtom *>(
        lepus_mallocz(s->ctx, s->idx_to_atom_count * sizeof(s->idx_to_atom[0]),
                      ALLOC_TAG_WITHOUT_PTR));
    if (!s->idx_to_atom) return s->error_state = -1;
  }
  for (i = 0; i < s->idx_to_atom_count; i++) {
    p = JS_ReadString(s);
    if (!p) return -1;
    atom = JS_NewAtomStr(s->ctx, p);
    if (atom == JS_ATOM_NULL) return s->error_state = -1;
    s->idx_to_atom[i] = atom;
    if (s->is_rom_data && (atom != (i + s->first_atom)))
      s->is_rom_data = FALSE; /* atoms must be relocated */
  }
  bc_read_trace(s, "}\n");
  return 0;
}

QJS_STATIC void bc_reader_free(BCReaderState *s) {
  int i;
  if (s->idx_to_atom) {
    for (i = 0; i < s->idx_to_atom_count; i++) {
      LEPUS_FreeAtom(s->ctx, s->idx_to_atom[i]);
    }
    lepus_free(s->ctx, s->idx_to_atom);
  }
}

LEPUSValue LEPUS_ReadObject(LEPUSContext *ctx, const uint8_t *buf,
                            size_t buf_len, int flags) {
  BCReaderState ss, *s = &ss;
  LEPUSValue obj;

  ctx->binary_object_count += 1;
  ctx->binary_object_size += buf_len;

  memset(s, 0, sizeof(*s));
  HandleScope func_scope(ctx, s, HANDLE_TYPE_BC_READER_STATE);
  s->ctx = ctx;
  s->buf_start = buf;
  s->buf_end = buf + buf_len;
  s->ptr = buf;
  s->allow_bytecode = ((flags & LEPUS_READ_OBJ_BYTECODE) != 0);
  s->is_rom_data = ((flags & LEPUS_READ_OBJ_ROM_DATA) != 0);
  if (s->allow_bytecode)
    s->first_atom = JS_ATOM_END;
  else
    s->first_atom = 1;
  if (JS_ReadObjectAtoms(s)) {
    obj = LEPUS_EXCEPTION;
  } else {
    obj = JS_ReadObjectRec(s);
  }
  if (!ctx->gc_enable) bc_reader_free(s);
  return obj;
}

/*******************************************************************/
/* runtime functions & objects */

QJS_STATIC LEPUSValue js_string_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv);
QJS_STATIC LEPUSValue js_boolean_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv);
QJS_STATIC LEPUSValue js_number_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv);

QJS_STATIC int check_function(LEPUSContext *ctx, LEPUSValueConst obj) {
  if (likely(LEPUS_IsFunction(ctx, obj))) return 0;
  LEPUS_ThrowTypeError(ctx, "not a function");
  return -1;
}

QJS_STATIC int check_exception_free(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_IsException(obj);
}

QJS_STATIC JSAtom find_atom(LEPUSContext *ctx, const char *name) {
  JSAtom atom;
  int len;

  if (*name == '[') {
    name++;
    len = strlen(name) - 1;
    /* We assume 8 bit non null strings, which is the case for these
       symbols */
    for (atom = JS_ATOM_Symbol_toPrimitive; atom < JS_ATOM_END; atom++) {
      JSAtomStruct *p = ctx->rt->atom_array[atom];
      JSString *str = p;
      if (str->len == len && !memcmp(str->u.str8, name, len))
        return LEPUS_DupAtom(ctx, atom);
    }
    abort();
  } else {
    atom = LEPUS_NewAtom(ctx, name);
  }
  return atom;
}

QJS_STATIC LEPUSValue JS_InstantiateFunctionListItem2(LEPUSContext *ctx,
                                                      LEPUSObject *p,
                                                      JSAtom atom,
                                                      void *opaque) {
  const LEPUSCFunctionListEntry *e =
      static_cast<LEPUSCFunctionListEntry *>(opaque);
  LEPUSValue val;

  switch (e->def_type) {
    case LEPUS_DEF_CFUNC:
      val = LEPUS_NewCFunction2(
          ctx, e->u.func.cfunc.generic, e->name, e->u.func.length,
          static_cast<LEPUSCFunctionEnum>(e->u.func.cproto), e->magic);
      break;
    case LEPUS_DEF_PROP_STRING:
      val = LEPUS_NewAtomString(ctx, e->u.str);
      break;
    case LEPUS_DEF_OBJECT:
      val = LEPUS_NewObject(ctx);
      LEPUS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab,
                                    e->u.prop_list.len);
      break;
    default:
      abort();
  }
  return val;
}

QJS_STATIC int JS_InstantiateFunctionListItem(
    LEPUSContext *ctx, LEPUSValueConst obj, JSAtom atom,
    const LEPUSCFunctionListEntry *e) {
  LEPUSValue val;
  int prop_flags = e->prop_flags;

  switch (e->def_type) {
    case LEPUS_DEF_ALIAS: {
      JSAtom atom1 = find_atom(ctx, e->u.alias.name);
      switch (e->u.alias.base) {
        case -1:
          val = JS_GetPropertyInternal_RC(ctx, obj, atom1, obj, 0);
          break;
        case 0:
          val = JS_GetPropertyInternal_RC(ctx, ctx->global_obj, atom1,
                                          ctx->global_obj, 0);
          break;
        case 1:
          val = JS_GetPropertyInternal_RC(ctx, ctx->class_proto[JS_CLASS_ARRAY],
                                          atom1,
                                          ctx->class_proto[JS_CLASS_ARRAY], 0);
          break;
        default:
          abort();
      }
      LEPUS_FreeAtom(ctx, atom1);
      if (atom == JS_ATOM_Symbol_toPrimitive) {
        /* Symbol.toPrimitive functions are not writable */
        prop_flags = LEPUS_PROP_CONFIGURABLE;
      } else if (atom == JS_ATOM_Symbol_hasInstance) {
        /* Function.prototype[Symbol.hasInstance] is not writable nor
         * configurable */
        prop_flags = 0;
      }
    } break;
    case LEPUS_DEF_CFUNC:
      if (atom == JS_ATOM_Symbol_toPrimitive) {
        /* Symbol.toPrimitive functions are not writable */
        prop_flags = LEPUS_PROP_CONFIGURABLE;
      } else if (atom == JS_ATOM_Symbol_hasInstance) {
        /* Function.prototype[Symbol.hasInstance] is not writable nor
         * configurable */
        prop_flags = 0;
      }
      JS_DefineAutoInitProperty(ctx, obj, atom, JS_InstantiateFunctionListItem2,
                                (void *)e, prop_flags);
      return 0;
    case LEPUS_DEF_CGETSET:
    case LEPUS_DEF_CGETSET_MAGIC: {
      LEPUSValue getter, setter;
      char buf[64];

      getter = LEPUS_UNDEFINED;
      if (e->u.getset.get.generic) {
        snprintf(buf, sizeof(buf), "get %s", e->name);
        getter = LEPUS_NewCFunction2(ctx, e->u.getset.get.generic, buf, 0,
                                     e->def_type == LEPUS_DEF_CGETSET_MAGIC
                                         ? LEPUS_CFUNC_getter_magic
                                         : LEPUS_CFUNC_getter,
                                     e->magic);
      }
      setter = LEPUS_UNDEFINED;
      if (e->u.getset.set.generic) {
        snprintf(buf, sizeof(buf), "set %s", e->name);
        setter = LEPUS_NewCFunction2(ctx, e->u.getset.set.generic, buf, 1,
                                     e->def_type == LEPUS_DEF_CGETSET_MAGIC
                                         ? LEPUS_CFUNC_setter_magic
                                         : LEPUS_CFUNC_setter,
                                     e->magic);
      }
      LEPUS_DefinePropertyGetSet(ctx, obj, atom, getter, setter, prop_flags);
      return 0;
    } break;
    case LEPUS_DEF_PROP_INT32:
      val = LEPUS_NewInt32(ctx, e->u.i32);
      break;
    case LEPUS_DEF_PROP_INT64:
      val = LEPUS_NewInt64(ctx, e->u.i64);
      break;
    case LEPUS_DEF_PROP_DOUBLE:
      val = __JS_NewFloat64(ctx, e->u.f64);
      break;
    case LEPUS_DEF_PROP_UNDEFINED:
      val = LEPUS_UNDEFINED;
      break;
    case LEPUS_DEF_PROP_STRING:
      JS_DefineAutoInitProperty(ctx, obj, atom, JS_InstantiateFunctionListItem2,
                                (void *)e, prop_flags);
      return 0;
    case LEPUS_DEF_OBJECT:
      JS_DefineAutoInitProperty(ctx, obj, atom, JS_InstantiateFunctionListItem2,
                                (void *)e, prop_flags);
      return 0;
    default:
      abort();
  }
  JS_DefinePropertyValue_RC(ctx, obj, atom, val, prop_flags);
  return 0;
}

void LEPUS_SetPropertyFunctionList(LEPUSContext *ctx, LEPUSValueConst obj,
                                   const LEPUSCFunctionListEntry *tab,
                                   int len) {
  CallGCFunc(JS_SetPropertyFunctionList_GC, ctx, obj, tab, len);
  int i, prop_flags;

  for (i = 0; i < len; i++) {
    const LEPUSCFunctionListEntry *e = &tab[i];
    JSAtom atom = find_atom(ctx, e->name);
    JS_InstantiateFunctionListItem(ctx, obj, atom, e);
    LEPUS_FreeAtom(ctx, atom);
  }
}

int LEPUS_AddModuleExportList(LEPUSContext *ctx, LEPUSModuleDef *m,
                              const LEPUSCFunctionListEntry *tab, int len) {
#ifndef NO_QUICKJS_COMPILER
  int i;
  for (i = 0; i < len; i++) {
    if (LEPUS_AddModuleExport(ctx, m, tab[i].name)) return -1;
  }
#endif
  return 0;
}

int LEPUS_SetModuleExportList(LEPUSContext *ctx, LEPUSModuleDef *m,
                              const LEPUSCFunctionListEntry *tab, int len) {
#ifndef NO_QUICKJS_COMPILER
  int i;
  LEPUSValue val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);

  for (i = 0; i < len; i++) {
    const LEPUSCFunctionListEntry *e = &tab[i];
    switch (e->def_type) {
      case LEPUS_DEF_CFUNC:
        val = LEPUS_NewCFunction2(
            ctx, e->u.func.cfunc.generic, e->name, e->u.func.length,
            static_cast<LEPUSCFunctionEnum>(e->u.func.cproto), e->magic);
        break;
      case LEPUS_DEF_PROP_STRING:
        val = LEPUS_NewString(ctx, e->u.str);
        break;
      case LEPUS_DEF_PROP_INT32:
        val = LEPUS_NewInt32(ctx, e->u.i32);
        break;
      case LEPUS_DEF_PROP_INT64:
        val = LEPUS_NewInt64(ctx, e->u.i64);
        break;
      case LEPUS_DEF_PROP_DOUBLE:
        val = __JS_NewFloat64(ctx, e->u.f64);
        break;
      default:
        abort();
    }
    if (LEPUS_SetModuleExport(ctx, m, e->name, val)) return -1;
  }
  return 0;
#else
  return 0;
#endif
}

/* Note: 'func_obj' is not necessarily a constructor */
QJS_STATIC void JS_SetConstructor2(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                   LEPUSValueConst proto, int proto_flags,
                                   int ctor_flags) {
  JS_DefinePropertyValue_RC(ctx, func_obj, JS_ATOM_prototype,
                            LEPUS_DupValue(ctx, proto), proto_flags);
  JS_DefinePropertyValue_RC(ctx, proto, JS_ATOM_constructor,
                            LEPUS_DupValue(ctx, func_obj), ctor_flags);
  set_cycle_flag(ctx, func_obj);
  set_cycle_flag(ctx, proto);
}

QJS_STATIC void JS_SetConstructor(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  LEPUSValueConst proto) {
  JS_SetConstructor2(ctx, func_obj, proto, 0,
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
}

QJS_STATIC void JS_NewGlobalCConstructor2(LEPUSContext *ctx,
                                          LEPUSValue func_obj, const char *name,
                                          LEPUSValueConst proto) {
  JS_DefinePropertyValueStr_RC(ctx, ctx->global_obj, name,
                               LEPUS_DupValue(ctx, func_obj),
                               LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  JS_SetConstructor(ctx, func_obj, proto);
  LEPUS_FreeValue(ctx, func_obj);
}

QJS_STATIC LEPUSValueConst JS_NewGlobalCConstructor(LEPUSContext *ctx,
                                                    const char *name,
                                                    LEPUSCFunction *func,
                                                    int length,
                                                    LEPUSValueConst proto) {
  LEPUSValue func_obj;
  func_obj = LEPUS_NewCFunction2(ctx, func, name, length,
                                 LEPUS_CFUNC_constructor_or_func, 0);
  JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
  return func_obj;
}

QJS_STATIC LEPUSValueConst JS_NewGlobalCConstructorOnly(LEPUSContext *ctx,
                                                        const char *name,
                                                        LEPUSCFunction *func,
                                                        int length,
                                                        LEPUSValueConst proto) {
  LEPUSValue func_obj;
  func_obj =
      LEPUS_NewCFunction2(ctx, func, name, length, LEPUS_CFUNC_constructor, 0);
  JS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
  return func_obj;
}

QJS_STATIC LEPUSValue js_global_eval(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  return JS_EvalObject(ctx, ctx->global_obj, argv[0], LEPUS_EVAL_TYPE_INDIRECT,
                       -1);
}

QJS_STATIC LEPUSValue js_global_isNaN(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  double d;

  /* XXX: does this work for bigfloat? */
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  return LEPUS_NewBool(ctx, isnan(d));
}

#ifdef CONFIG_BIGNUM
static BOOL js_number_is_finite(LEPUSContext *ctx, LEPUSValueConst val) {
  BOOL res;
  int32_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_FLOAT64:
      res = isfinite(LEPUS_VALUE_GET_FLOAT64(val));
      break;
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      res = bf_is_finite(&p->num);
    } break;
    default:
      res = TRUE;
      break;
  }
  return res;
}
#endif

QJS_STATIC LEPUSValue js_global_isFinite(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  BOOL res;
#ifdef CONFIG_BIGNUM
  LEPUSValue val;

  val = JS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(val)) return val;
  res = js_number_is_finite(ctx, val);
  LEPUS_FreeValue(ctx, val);
#else
  double d;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  res = isfinite(d);
#endif
  return LEPUS_NewBool(ctx, res);
}

/* Object class */

LEPUSValue LEPUS_ToObject(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_ToObject_GC, ctx, val);
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  LEPUSValue obj;

  switch (tag) {
    default:
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      return LEPUS_ThrowTypeError(ctx, "cannot convert to object");
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_EXCEPTION:
      return LEPUS_DupValue(ctx, val);
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx))
        obj = LEPUS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
      else
        obj = LEPUS_NewObjectClass(ctx, JS_CLASS_NUMBER);
      goto set_value;
    case LEPUS_TAG_BIG_INT:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
      goto set_value;
    case LEPUS_TAG_FLOAT64:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_NUMBER);
      goto set_value;
    case LEPUS_TAG_BIG_FLOAT:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_BIG_FLOAT);
      goto set_value;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_NUMBER);
      goto set_value;
#endif
    case LEPUS_TAG_STRING:
      /* XXX: should call the string constructor */
      {
        JSString *p1 = LEPUS_VALUE_GET_STRING(val);
        obj = LEPUS_NewObjectClass(ctx, JS_CLASS_STRING);
        JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_length,
                                  LEPUS_NewInt32(ctx, p1->len), 0);
      }
      goto set_value;
    case LEPUS_TAG_SEPARABLE_STRING: {
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_STRING);
      auto *separable_string = JS_GetSeparableString(val);
      JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_length,
                                LEPUS_NewInt32(ctx, separable_string->len), 0);
    }
      goto set_value;
    case LEPUS_TAG_BOOL:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_BOOLEAN);
      goto set_value;
    case LEPUS_TAG_SYMBOL:
      obj = LEPUS_NewObjectClass(ctx, JS_CLASS_SYMBOL);
    set_value:
      if (!LEPUS_IsException(obj))
        JS_SetObjectData(ctx, obj, LEPUS_DupValue(ctx, val));
      return obj;

// Primjs begin
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSLepusRef *pref =
          static_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(val));
      auto &obj = pref->lepus_val;
      if (LEPUS_VALUE_IS_OBJECT(obj)) {
        return LEPUS_DupValue(ctx, obj);
      }
      return obj = LEPUS_DupValue(
                 ctx, ctx->rt->js_callbacks_.convert_to_object(ctx, val));
    }
#endif
      // Primjs end
  }
}

QJS_STATIC LEPUSValue JS_ToObjectFree(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSValue obj = LEPUS_ToObject(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return obj;
}

static LEPUSValue JS_ToObject_expect_lepusref(LEPUSContext *ctx,
                                              LEPUSValue val) {
#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(val)) {
    return LEPUS_DupValue(ctx, val);
  }
#endif
  return LEPUS_ToObject(ctx, val);
}

QJS_STATIC int js_obj_to_desc(LEPUSContext *ctx, LEPUSPropertyDescriptor *d,
                              LEPUSValueConst desc) {
  LEPUSValue val, getter, setter;
  int flags;

  if (!LEPUS_IsObject(desc)) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  flags = 0;
  val = LEPUS_UNDEFINED;
  getter = LEPUS_UNDEFINED;
  setter = LEPUS_UNDEFINED;
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_configurable)) {
    LEPUSValue prop =
        JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_configurable, desc, 0);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_CONFIGURABLE;
    if (JS_ToBoolFree_RC(ctx, prop)) flags |= LEPUS_PROP_CONFIGURABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_writable)) {
    LEPUSValue prop =
        JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_writable, desc, 0);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_WRITABLE;
    if (JS_ToBoolFree_RC(ctx, prop)) flags |= LEPUS_PROP_WRITABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_enumerable)) {
    LEPUSValue prop =
        JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_enumerable, desc, 0);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_ENUMERABLE;
    if (JS_ToBoolFree_RC(ctx, prop)) flags |= LEPUS_PROP_ENUMERABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_value)) {
    flags |= LEPUS_PROP_HAS_VALUE;
    val = JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_value, desc, 0);
    if (LEPUS_IsException(val)) goto fail;
  }
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_get)) {
    flags |= LEPUS_PROP_HAS_GET;
    getter = JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_get, desc, 0);
    if (LEPUS_IsException(getter) ||
        !(LEPUS_IsUndefined(getter) || LEPUS_IsFunction(ctx, getter))) {
      LEPUS_ThrowTypeError(ctx, "invalid getter");
      goto fail;
    }
  }
  if (LEPUS_HasProperty(ctx, desc, JS_ATOM_set)) {
    flags |= LEPUS_PROP_HAS_SET;
    setter = JS_GetPropertyInternal_RC(ctx, desc, JS_ATOM_set, desc, 0);
    if (LEPUS_IsException(setter) ||
        !(LEPUS_IsUndefined(setter) || LEPUS_IsFunction(ctx, setter))) {
      LEPUS_ThrowTypeError(ctx, "invalid setter");
      goto fail;
    }
  }
  if ((flags & (LEPUS_PROP_HAS_SET | LEPUS_PROP_HAS_GET)) &&
      (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE))) {
    LEPUS_ThrowTypeError(ctx,
                         "cannot have setter/getter and value or writable");
    goto fail;
  }
  d->flags = flags;
  d->value = val;
  d->getter = getter;
  d->setter = setter;
  return 0;
fail:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, getter);
  LEPUS_FreeValue(ctx, setter);
  return -1;
}

QJS_STATIC __exception int JS_DefinePropertyDesc(LEPUSContext *ctx,
                                                 LEPUSValueConst obj,
                                                 JSAtom prop,
                                                 LEPUSValueConst desc,
                                                 int flags) {
  LEPUSPropertyDescriptor d;
  int ret;

  if (js_obj_to_desc(ctx, &d, desc) < 0) return -1;

  ret = JS_DefineProperty_RC(ctx, obj, prop, d.value, d.getter, d.setter,
                             d.flags | flags);
  js_free_desc(ctx, &d);
  return ret;
}

QJS_STATIC __exception int JS_ObjectDefineProperties(
    LEPUSContext *ctx, LEPUSValueConst obj, LEPUSValueConst properties) {
  LEPUSValue props, desc;
  LEPUSObject *p;
  LEPUSPropertyEnum *atoms;
  uint32_t len, i;
  int ret = -1;

  if (!LEPUS_IsObject(obj)) {
    JS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  desc = LEPUS_UNDEFINED;
  props = LEPUS_ToObject(ctx, properties);
  if (LEPUS_IsException(props)) return -1;
  p = LEPUS_VALUE_GET_OBJ(props);
  if (JS_GetOwnPropertyNamesInternal(
          ctx, &atoms, &len, p,
          LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK) <
      0)
    goto exception;
  for (i = 0; i < len; i++) {
    LEPUS_FreeValue(ctx, desc);
    desc = JS_GetPropertyInternal_RC(ctx, props, atoms[i].atom, props, 0);
    if (LEPUS_IsException(desc)) goto exception;
    if (JS_DefinePropertyDesc(ctx, obj, atoms[i].atom, desc, LEPUS_PROP_THROW) <
        0)
      goto exception;
  }
  ret = 0;

exception:
  js_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, props);
  LEPUS_FreeValue(ctx, desc);
  return ret;
}

QJS_STATIC LEPUSValue js_object_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv) {
  LEPUSValue ret;
  if (!LEPUS_IsUndefined(new_target) &&
      LEPUS_VALUE_GET_OBJ(new_target) !=
          LEPUS_VALUE_GET_OBJ(JS_GetActiveFunction(ctx))) {
    ret = js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);
  } else {
    int64_t tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
    switch (tag) {
      case LEPUS_TAG_NULL:
      case LEPUS_TAG_UNDEFINED:
        ret = LEPUS_NewObject(ctx);
        break;
      default:
        ret = LEPUS_ToObject(ctx, argv[0]);
        break;
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue js_object_create(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValueConst proto, props;
  LEPUSValue obj;

  proto = argv[0];
  if (!LEPUS_IsObject(proto) && !LEPUS_IsNull(proto))
    return LEPUS_ThrowTypeError(ctx, "not a prototype");
  obj = LEPUS_NewObjectProto(ctx, proto);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  props = argv[1];
  if (!LEPUS_IsUndefined(props)) {
    if (JS_ObjectDefineProperties(ctx, obj, props)) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue js_object_getPrototypeOf(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int magic) {
  LEPUSValueConst val;

  val = argv[0];
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) {
    /* ES6 feature non compatible with ES5.1: primitive types are
       accepted */
    if (magic || LEPUS_VALUE_IS_NULL(val) || LEPUS_VALUE_IS_UNDEFINED(val))
      return JS_ThrowTypeErrorNotAnObject(ctx);
  }
  return LEPUS_DupValue(ctx, JS_GetPrototype_RC(ctx, val));
}

QJS_STATIC LEPUSValue js_object_setPrototypeOf(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  obj = argv[0];
  if (JS_SetPrototypeInternal(ctx, obj, argv[1], TRUE) < 0)
    return LEPUS_EXCEPTION;
  return LEPUS_DupValue(ctx, obj);
}

/* magic = 1 if called as Reflect.defineProperty */
QJS_STATIC LEPUSValue js_object_defineProperty(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int magic) {
  LEPUSValueConst obj, prop, desc;
  int ret, flags;
  JSAtom atom;

  obj = JSRef2Value(ctx, argv[0]);
  prop = argv[1];
  desc = argv[2];

  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  flags = 0;
  if (!magic) flags |= LEPUS_PROP_THROW;
  ret = JS_DefinePropertyDesc(ctx, obj, atom, desc, flags);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    return LEPUS_EXCEPTION;
  } else if (magic) {
    return LEPUS_NewBool(ctx, ret);
  } else {
    return LEPUS_DupValue(ctx, obj);
  }
}

QJS_STATIC LEPUSValue js_object_defineProperties(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  // defineProperties(obj, properties)
  LEPUSValueConst obj = JSRef2Value(ctx, argv[0]);

  if (JS_ObjectDefineProperties(ctx, obj, argv[1]))
    return LEPUS_EXCEPTION;
  else
    return LEPUS_DupValue(ctx, obj);
}

/* magic = 1 if called as __defineSetter__ */
QJS_STATIC LEPUSValue js_object___defineGetter__(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int magic) {
  LEPUSValue obj;
  LEPUSValueConst prop, value, get, set;
  int ret, flags;
  JSAtom atom;

  prop = argv[0];
  value = argv[1];

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;

  if (check_function(ctx, value)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  flags = LEPUS_PROP_THROW | LEPUS_PROP_HAS_ENUMERABLE | LEPUS_PROP_ENUMERABLE |
          LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE;
  if (magic) {
    get = LEPUS_UNDEFINED;
    set = value;
    flags |= LEPUS_PROP_HAS_SET;
  } else {
    get = value;
    set = LEPUS_UNDEFINED;
    flags |= LEPUS_PROP_HAS_GET;
  }
  ret = JS_DefineProperty_RC(ctx, obj, atom, LEPUS_UNDEFINED, get, set, flags);
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    return LEPUS_EXCEPTION;
  } else {
    return LEPUS_UNDEFINED;
  }
}

LEPUSValue lepus_object_getOwnPropertyDescriptor(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int magic) {
  CallGCFunc(js_object_getOwnPropertyDescriptor_GC, ctx, this_val, argc, argv,
             magic);
  LEPUSValueConst obj, prop;
  JSAtom atom;
  LEPUSValue ret;
  LEPUSPropertyDescriptor desc;
  int res, flags;
  // <Primjs begin>
  obj = JSRef2Value(ctx, argv[0]);
  // <Primjs end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    /* ES6 feature non compatible with ES5.1: obj can be a primitive type */
    if (magic || LEPUS_VALUE_IS_NULL(obj) || LEPUS_VALUE_IS_UNDEFINED(obj))
      return JS_ThrowTypeErrorNotAnObject(ctx);
  }
  prop = argv[1];
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_UNDEFINED;
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    res = JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(obj), atom);
    if (res < 0) goto exception;
    if (res) {
      ret = LEPUS_NewObject(ctx);
      if (LEPUS_IsException(ret)) goto exception1;
      flags = LEPUS_PROP_C_W_E | LEPUS_PROP_THROW;
      if (desc.flags & LEPUS_PROP_GETSET) {
        if (JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_get,
                                      LEPUS_DupValue(ctx, desc.getter),
                                      flags) < 0 ||
            JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_set,
                                      LEPUS_DupValue(ctx, desc.setter),
                                      flags) < 0)
          goto exception1;
      } else {
        if (JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_value,
                                      LEPUS_DupValue(ctx, desc.value),
                                      flags) < 0 ||
            JS_DefinePropertyValue_RC(
                ctx, ret, JS_ATOM_writable,
                LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_WRITABLE) != 0),
                flags) < 0)
          goto exception1;
      }
      if (JS_DefinePropertyValue_RC(
              ctx, ret, JS_ATOM_enumerable,
              LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_ENUMERABLE) != 0),
              flags) < 0 ||
          JS_DefinePropertyValue_RC(
              ctx, ret, JS_ATOM_configurable,
              LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_CONFIGURABLE) != 0),
              flags) < 0)
        goto exception1;
      js_free_desc(ctx, &desc);
    }
  }
  LEPUS_FreeAtom(ctx, atom);
  return ret;

exception1:
  js_free_desc(ctx, &desc);
  LEPUS_FreeValue(ctx, ret);
exception:
  LEPUS_FreeAtom(ctx, atom);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue
js_object_getOwnPropertyDescriptors(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  // getOwnPropertyDescriptors(obj)
  LEPUSValue obj, r;
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;

  r = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, argv[0]);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;

  p = LEPUS_VALUE_GET_OBJ(obj);
  if (JS_GetOwnPropertyNamesInternal(
          ctx, &props, &len, p, LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK))
    goto exception;
  r = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(r)) goto exception;
  for (i = 0; i < len; i++) {
    LEPUSValue atomValue, desc;
    LEPUSValueConst args[2];

    atomValue = JS_AtomToValue_RC(ctx, props[i].atom);
    if (LEPUS_IsException(atomValue)) goto exception;
    args[0] = obj;
    args[1] = atomValue;
    desc =
        lepus_object_getOwnPropertyDescriptor(ctx, LEPUS_UNDEFINED, 2, args, 0);
    LEPUS_FreeValue(ctx, atomValue);
    if (LEPUS_IsException(desc)) goto exception;
    if (!LEPUS_IsUndefined(desc)) {
      if (JS_DefinePropertyValue_RC(ctx, r, props[i].atom, desc,
                                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  js_free_prop_enum(ctx, props, len);
  LEPUS_FreeValue(ctx, obj);
  return r;

exception:
  js_free_prop_enum(ctx, props, len);
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, r);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_GetOwnPropertyNames2(LEPUSContext *ctx,
                                              LEPUSValueConst obj1, int flags,
                                              int kind) {
  LEPUSValue obj, r, val, key, value;
  LEPUSObject *p;
  LEPUSPropertyEnum *atoms;
  uint32_t len, i, j;

  r = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, obj1);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p,
                                     flags & ~LEPUS_GPN_ENUM_ONLY))
    goto exception;
  r = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(r)) goto exception;
  for (j = i = 0; i < len; i++) {
    JSAtom atom = atoms[i].atom;
    if (flags & LEPUS_GPN_ENUM_ONLY) {
      LEPUSPropertyDescriptor desc;
      int res;

      /* Check if property is still enumerable */
      res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
      if (res < 0) goto exception;
      if (!res) continue;
      js_free_desc(ctx, &desc);
      if (!(desc.flags & LEPUS_PROP_ENUMERABLE)) continue;
    }
    switch (kind) {
      default:
      case JS_ITERATOR_KIND_KEY:
        val = JS_AtomToValue_RC(ctx, atom);
        if (LEPUS_IsException(val)) goto exception;
        break;
      case JS_ITERATOR_KIND_VALUE:
        val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
        if (LEPUS_IsException(val)) goto exception;
        break;
      case JS_ITERATOR_KIND_KEY_AND_VALUE:
        val = LEPUS_NewArray(ctx);
        if (LEPUS_IsException(val)) goto exception;
        key = JS_AtomToValue_RC(ctx, atom);
        if (LEPUS_IsException(key)) goto exception1;
        if (JS_CreateDataPropertyUint32(ctx, val, 0, key, LEPUS_PROP_THROW) < 0)
          goto exception1;
        value = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
        if (LEPUS_IsException(value)) goto exception1;
        if (JS_CreateDataPropertyUint32(ctx, val, 1, value, LEPUS_PROP_THROW) <
            0)
          goto exception1;
        break;
    }
    if (JS_CreateDataPropertyUint32(ctx, r, j++, val, 0) < 0) goto exception;
  }
  goto done;

exception1:
  LEPUS_FreeValue(ctx, val);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  js_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, obj);
  return r;
}

QJS_STATIC LEPUSValue js_object_getOwnPropertyNames(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv) {
  return JS_GetOwnPropertyNames2(ctx, argv[0], LEPUS_GPN_STRING_MASK,
                                 JS_ITERATOR_KIND_KEY);
}

QJS_STATIC LEPUSValue js_object_getOwnPropertySymbols(LEPUSContext *ctx,
                                                      LEPUSValueConst this_val,
                                                      int argc,
                                                      LEPUSValueConst *argv) {
  return JS_GetOwnPropertyNames2(ctx, argv[0], LEPUS_GPN_SYMBOL_MASK,
                                 JS_ITERATOR_KIND_KEY);
}

QJS_STATIC LEPUSValue js_object_keys(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int kind) {
  return JS_GetOwnPropertyNames2(
      ctx, argv[0], LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK, kind);
}

QJS_STATIC LEPUSValue js_object_isExtensible(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int reflect) {
  LEPUSValueConst obj;
  int ret;
  // <Primjs begin>
  obj = JSRef2Value(ctx, argv[0]);
  // <Primjs end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    if (reflect)
      return JS_ThrowTypeErrorNotAnObject(ctx);
    else
      return LEPUS_FALSE;
  }
  ret = LEPUS_IsExtensible(ctx, obj);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue js_object_preventExtensions(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv,
                                                  int reflect) {
  LEPUSValueConst obj;
  int ret;
  // <Primjs begin>
  obj = JSRef2Value(ctx, argv[0]);
  // <Primjs end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    if (reflect)
      return JS_ThrowTypeErrorNotAnObject(ctx);
    else
      return LEPUS_DupValue(ctx, obj);
  }
  ret = LEPUS_PreventExtensions(ctx, obj);
  if (ret < 0) return LEPUS_EXCEPTION;
  if (reflect)
    return LEPUS_NewBool(ctx, ret);
  else {
    if (!ret)
      return LEPUS_ThrowTypeError(
          ctx, "proxy preventExtensions handler returned false");
    return LEPUS_DupValue(ctx, obj);
  }
}

QJS_STATIC LEPUSValue js_object_hasOwnProperty(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue obj;
  JSAtom atom;
  LEPUSObject *p;
  BOOL ret;

  atom = js_value_to_atom(ctx, argv[0]); /* must be done first */

#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(this_val)) {
    ret = JSRefHasOwnProperty(ctx, this_val, atom);
    LEPUS_FreeAtom(ctx, atom);
    if (ret < 0)
      return LEPUS_EXCEPTION;
    else
      return LEPUS_NewBool(ctx, ret);
  }
#endif

  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeAtom(ctx, atom);
    return obj;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  ret = JS_GetOwnPropertyInternal(ctx, NULL, p, atom);
  LEPUS_FreeAtom(ctx, atom);
  LEPUS_FreeValue(ctx, obj);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue js_object_valueOf(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return LEPUS_ToObject(ctx, this_val);
}

QJS_STATIC LEPUSValue js_object_toString(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue obj, tag;
  int is_array;
  JSAtom atom;
  LEPUSObject *p;

  if (LEPUS_IsNull(this_val)) {
    tag = LEPUS_NewString(ctx, "Null");
  } else if (LEPUS_IsUndefined(this_val)) {
    tag = LEPUS_NewString(ctx, "Undefined");
  } else {
    obj = LEPUS_ToObject(ctx, this_val);
    if (LEPUS_IsException(obj)) return obj;
    is_array = LEPUS_IsArray(ctx, obj);
    if (is_array < 0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
    if (is_array) {
      atom = JS_ATOM_Array;
    } else if (LEPUS_IsFunction(ctx, obj)) {
      atom = JS_ATOM_Function;
    } else {
      p = LEPUS_VALUE_GET_OBJ(obj);
      switch (p->class_id) {
        case JS_CLASS_STRING:
        case JS_CLASS_ARGUMENTS:
        case JS_CLASS_MAPPED_ARGUMENTS:
        case JS_CLASS_ERROR:
        case JS_CLASS_BOOLEAN:
        case JS_CLASS_NUMBER:
        case JS_CLASS_DATE:
        case JS_CLASS_REGEXP:
          atom = ctx->rt->class_array[p->class_id].class_name;
          break;
        default:
          atom = JS_ATOM_Object;
          break;
      }
    }
    tag =
        JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_Symbol_toStringTag, obj, 0);
    LEPUS_FreeValue(ctx, obj);
    if (LEPUS_IsException(tag)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsString(tag)) {
      LEPUS_FreeValue(ctx, tag);
      tag = LEPUS_AtomToString(ctx, atom);
    }
  }
  return JS_ConcatString3(ctx, "[object ", tag, "]");
}

QJS_STATIC LEPUSValue js_object_toLocaleString(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  return LEPUS_Invoke(ctx, this_val, JS_ATOM_toString, 0, NULL);
}

QJS_STATIC LEPUSValue js_object_assign(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  // Object.assign(obj, source1)
  LEPUSValue obj, s;
  int i;

  s = LEPUS_UNDEFINED;
  obj = JS_ToObject_expect_lepusref(ctx, argv[0]);
  if (LEPUS_IsException(obj)) goto exception;
  for (i = 1; i < argc; i++) {
    if (!LEPUS_IsNull(argv[i]) && !LEPUS_IsUndefined(argv[i])) {
      s = JS_ToObject_expect_lepusref(ctx, argv[i]);
      if (LEPUS_IsException(s)) goto exception;
      if (JS_CopyDataProperties(ctx, obj, s, LEPUS_UNDEFINED, TRUE))
        goto exception;
      LEPUS_FreeValue(ctx, s);
    }
  }
  return obj;
exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, s);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_object_seal(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int freeze_flag) {
  LEPUSValueConst obj = argv[0];
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;
  int flags, desc_flags, res;
  // <Primjs begin>
  obj = JSRef2Value(ctx, obj);
  // <Primjs end>

  if (!LEPUS_IsObject(obj)) return LEPUS_DupValue(ctx, obj);

  res = LEPUS_PreventExtensions(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) {
    return LEPUS_ThrowTypeError(
        ctx, "proxy preventExtensions handler returned false");
  }

  p = LEPUS_VALUE_GET_OBJ(obj);
  flags = LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK;
  if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
    return LEPUS_EXCEPTION;

  for (i = 0; i < len; i++) {
    LEPUSPropertyDescriptor desc;
    JSAtom prop = props[i].atom;

    desc_flags = LEPUS_PROP_THROW | LEPUS_PROP_HAS_CONFIGURABLE;
    if (freeze_flag) {
      res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
      if (res < 0) goto exception;
      if (res) {
        if (desc.flags & LEPUS_PROP_WRITABLE)
          desc_flags |= LEPUS_PROP_HAS_WRITABLE;
        js_free_desc(ctx, &desc);
      }
    }
    if (JS_DefineProperty_RC(ctx, obj, prop, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
                             LEPUS_UNDEFINED, desc_flags) < 0)
      goto exception;
  }
  js_free_prop_enum(ctx, props, len);
  return js_object_preventExtensions(ctx, LEPUS_UNDEFINED, 1, argv, 0);

exception:
  js_free_prop_enum(ctx, props, len);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_object_isSealed(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int is_frozen) {
  LEPUSValueConst obj = argv[0];
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;
  int flags, res;
  // <Primjs begin>
  obj = JSRef2Value(ctx, obj);
  // <Primjs end>

  if (!LEPUS_IsObject(obj)) return LEPUS_TRUE;

  p = LEPUS_VALUE_GET_OBJ(obj);
  flags = LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK;
  if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
    return LEPUS_EXCEPTION;

  for (i = 0; i < len; i++) {
    LEPUSPropertyDescriptor desc;
    JSAtom prop = props[i].atom;

    res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
    if (res < 0) goto exception;
    if (res) {
      js_free_desc(ctx, &desc);
      if ((desc.flags & LEPUS_PROP_CONFIGURABLE) ||
          (is_frozen && (desc.flags & LEPUS_PROP_WRITABLE))) {
        res = FALSE;
        goto done;
      }
    }
  }
  res = LEPUS_IsExtensible(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  res ^= 1;
done:
  js_free_prop_enum(ctx, props, len);
  return LEPUS_NewBool(ctx, res);

exception:
  js_free_prop_enum(ctx, props, len);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_object_fromEntries(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue obj, iter, next_method = LEPUS_UNDEFINED;
  LEPUSValueConst iterable;
  BOOL done;

  /*  RequireObjectCoercible() not necessary because it is tested in
      JS_GetIterator() by LEPUS_GetProperty() */
  // <Primjs begin>
  iterable = JSRef2Value(ctx, argv[0]);
  // <Primjs end>

  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) return obj;

  iter = JS_GetIterator(ctx, iterable, FALSE);
  if (LEPUS_IsException(iter)) goto fail;
  next_method = JS_GetPropertyInternal_RC(ctx, iter, JS_ATOM_next, iter, 0);
  if (LEPUS_IsException(next_method)) goto fail;

  for (;;) {
    LEPUSValue key, value, item;
    item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(item)) goto fail;
    if (done) {
      LEPUS_FreeValue(ctx, item);
      break;
    }

    key = LEPUS_UNDEFINED;
    value = LEPUS_UNDEFINED;
    if (!LEPUS_IsObject(item)) {
      JS_ThrowTypeErrorNotAnObject(ctx);
      goto fail1;
    }
    key = LEPUS_GetPropertyUint32(ctx, item, 0);
    if (LEPUS_IsException(key)) goto fail1;
    value = LEPUS_GetPropertyUint32(ctx, item, 1);
    if (LEPUS_IsException(value)) {
      LEPUS_FreeValue(ctx, key);
      goto fail1;
    }
    if (JS_DefinePropertyValueValue(ctx, obj, key, value,
                                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0) {
    fail1:
      LEPUS_FreeValue(ctx, item);
      goto fail;
    }
    LEPUS_FreeValue(ctx, item);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  return obj;
fail:
  if (LEPUS_IsObject(iter)) {
    /* close the iterator object, preserving pending exception */
    JS_IteratorClose(ctx, iter, TRUE);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#if 0
/* Note: corresponds to ECMA spec: CreateDataPropertyOrThrow() */
static LEPUSValue js_object___setOwnProperty(LEPUSContext *ctx, LEPUSValueConst this_val,
                                          int argc, LEPUSValueConst *argv)
{
    int ret;
    ret = JS_DefinePropertyValueValue(ctx, argv[0], LEPUS_DupValue(ctx, argv[1]),
                                      LEPUS_DupValue(ctx, argv[2]),
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
    if (ret < 0)
        return LEPUS_EXCEPTION;
    else
        return LEPUS_NewBool(ctx, ret);
}

static LEPUSValue js_object___toObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToObject(ctx, argv[0]);
}

static LEPUSValue js_object___toPrimitive(LEPUSContext *ctx, LEPUSValueConst this_val,
                                       int argc, LEPUSValueConst *argv)
{
    int hint = HINT_NONE;

    if (LEPUS_VALUE_IS_INT(argv[1]))
        hint = LEPUS_VALUE_GET_INT(argv[1]);

    return JS_ToPrimitive(ctx, argv[0], hint);
}
#endif

/* return an empty string if not an object */
QJS_STATIC LEPUSValue js_object___getClass(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  JSAtom atom;
  LEPUSObject *p;
  int64_t tag;
  int class_id;
  // <Primjs begin>
#ifdef ENABLE_LEPUSNG
  LEPUSValue obj = argv[0];
  if (LEPUS_IsLepusRef(obj)) {
    if (JS_LepusRefIsArray(ctx->rt, obj)) {
      atom = ctx->rt->class_array[JS_CLASS_ARRAY].class_name;
    } else if (JS_LepusRefIsTable(ctx->rt, obj)) {
      atom = ctx->rt->class_array[JS_CLASS_OBJECT].class_name;
    } else {
      atom = JS_ATOM_empty_string;
    }
    return LEPUS_AtomToString(ctx, atom);
  }
#endif
  // <Primjs end>

  tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
  if (tag == LEPUS_TAG_OBJECT) {
    p = LEPUS_VALUE_GET_OBJ(argv[0]);
    class_id = p->class_id;
    if (class_id == JS_CLASS_PROXY && LEPUS_IsFunction(ctx, argv[0]))
      class_id = JS_CLASS_BYTECODE_FUNCTION;
    atom = ctx->rt->class_array[class_id].class_name;
  } else {
    atom = JS_ATOM_empty_string;
  }
  return LEPUS_AtomToString(ctx, atom);
}

QJS_STATIC LEPUSValue js_object_is(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv) {
  return LEPUS_NewBool(ctx, js_same_value(ctx, argv[0], argv[1]));
}

// <Primjs begin>
LEPUSValue LEPUS_DeepEqual(LEPUSContext *ctx, LEPUSValueConst obj1,
                           LEPUSValueConst obj2) {
  CallGCFunc(JS_DeepEqual_GC, ctx, obj1, obj2);
#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(obj1) && LEPUS_IsLepusRef(obj2)) {
    BOOL ret = ctx->rt->js_callbacks_.lepus_ref_equal(obj1, obj2);
    return LEPUS_NewBool(ctx, ret);
  }
#endif

  BOOL ret = js_same_value(ctx, obj1, obj2);
  if (ret || (!LEPUS_IsObject(obj1) && !LEPUS_IsLepusRef(obj1)) ||
      (!LEPUS_IsObject(obj2) && !LEPUS_IsLepusRef(obj2))) {
    return LEPUS_NewBool(ctx, ret);
  }
  obj1 = JSRef2Value(ctx, obj1);
  obj2 = JSRef2Value(ctx, obj2);
  // if both obj1 and obj2 are not object, return FALSE
  if (!LEPUS_IsObject(obj1) || !LEPUS_IsObject(obj2)) {
    return LEPUS_NewBool(ctx, FALSE);
  }
  // for object compare
  LEPUSObject *p1 = LEPUS_VALUE_GET_OBJ(obj1);
  LEPUSObject *p2 = LEPUS_VALUE_GET_OBJ(obj2);
  uint32_t i;
  JSShape *sh1, *sh2;
  JSShapeProperty *pr1, *pr2;
  LEPUSValue val1, val2, result;
  JSAtom atom;
  if (p1->class_id != p2->class_id) {
    goto fail;
  }

  if (p1->class_id != JS_CLASS_ARRAY && p1->class_id != JS_CLASS_OBJECT) {
    goto fail;
  }

  if (p1->class_id == JS_CLASS_ARRAY) {
    uint32_t len1, len2;
    if (lepus_get_length32(ctx, &len1, obj1) ||
        lepus_get_length32(ctx, &len2, obj2)) {
      goto fail;
    }
    if (len1 != len2) goto fail;

    for (i = 0; i < len1; i++) {
      val1 = LEPUS_GetPropertyUint32(ctx, obj1, i);
      val2 = LEPUS_GetPropertyUint32(ctx, obj2, i);
      if (LEPUS_IsException(val1) || LEPUS_IsException(val2)) goto fail;
      result = LEPUS_DeepEqual(ctx, val1, val2);
      LEPUS_FreeValue(ctx, val1);
      LEPUS_FreeValue(ctx, val2);
      if (!LEPUS_VALUE_GET_BOOL(result)) goto fail;
    }

    goto ok;

  } else {
    sh1 = p1->shape;
    sh2 = p2->shape;
    if (sh1->prop_count != sh2->prop_count) goto fail;
    for (i = 0, pr1 = get_shape_prop(sh1); i < sh1->prop_count; i++, pr1++) {
      atom = pr1->atom;
      if (atom != JS_ATOM_NULL && JS_AtomIsString(ctx, atom) &&
          (pr1->flags & LEPUS_PROP_ENUMERABLE)) {
        val2 = JS_GetPropertyInternal_RC(ctx, obj2, atom, obj2, 0);
        if (LEPUS_IsException(val2)) goto fail;
        val1 = p1->prop[i].u.value;
        result = LEPUS_DeepEqual(ctx, val1, val2);
        LEPUS_FreeValue(ctx, val2);
        if (!LEPUS_VALUE_GET_BOOL(result)) goto fail;
      }
    }
    goto ok;
  }

fail:
  return LEPUS_NewBool(ctx, 0);

ok:
  return LEPUS_NewBool(ctx, 1);
}

void LEPUS_IterateObject(LEPUSContext *ctx, LEPUSValue obj,
                         IterateObject callback, void *pfunc, void *raw_data) {
  CallGCFunc(JS_IterateObject_GC, ctx, obj, callback, pfunc, raw_data);
  if (!LEPUS_IsObject(obj)) return;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, len;
  LEPUSValue val = LEPUS_UNDEFINED;
  JSShape *sh;
  JSShapeProperty *pr;
  JSAtom atom;
  LEPUSValue atomValue;
  if (p->class_id == JS_CLASS_ARRAY) {
    if (lepus_get_length32(ctx, &len, obj)) goto fail;
    for (i = 0; i < len; i++) {
      val = LEPUS_GetPropertyUint32(ctx, obj, i);
      if (LEPUS_IsException(val)) goto fail;
      callback(ctx, LEPUS_NewInt32(ctx, i), val, pfunc, raw_data);
      LEPUS_FreeValue(ctx, val);
    }
  } else {
    sh = p->shape;
    for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
      atom = pr->atom;
      if (atom != JS_ATOM_NULL && JS_AtomIsString(ctx, atom) &&
          (pr->flags & LEPUS_PROP_ENUMERABLE)) {
        if (pr->flags & LEPUS_PROP_TMASK) {
          LEPUS_ThrowTypeError(ctx, "only value properties are supported");
          goto fail;
        }
        atomValue = JS_AtomToValue_RC(ctx, atom);
        callback(ctx, atomValue, p->prop[i].u.value, pfunc, raw_data);
        LEPUS_FreeValue(ctx, atomValue);
      }
    }
  }
  return;

fail:
  LEPUS_FreeValue(ctx, val);
}
int LEPUS_GetLength(LEPUSContext *ctx, LEPUSValue val) {
  CallGCFunc(JS_GetLength_GC, ctx, val);
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  if (tag == LEPUS_TAG_STRING) {
    JSString *p = LEPUS_VALUE_GET_STRING(val);
    return p->len;
  } else if (tag == LEPUS_TAG_SEPARABLE_STRING) {
    return JS_GetSeparableString(val)->len;
  } else if (tag == LEPUS_TAG_OBJECT) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
    uint32_t len;
    if (p->class_id == JS_CLASS_ARRAY) {
      if (lepus_get_length32(ctx, &len, val)) return -1;
      return len;
    } else {
      return p->shape->prop_count;
    }
  }
#ifdef ENABLE_LEPUSNG
  // <Primjs begin>
  else if (tag == LEPUS_TAG_LEPUS_REF) {
    if (ctx->rt->js_callbacks_.get_length) {
      return ctx->rt->js_callbacks_.get_length(ctx, val);
    }
  }
#endif
  // <Primjs end>
  return 0;
}

#if 0
static LEPUSValue js_object___getObjectData(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return JS_GetObjectData(ctx, argv[0]);
}

static LEPUSValue js_object___setObjectData(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    if (JS_SetObjectData(ctx, argv[0], LEPUS_DupValue(ctx, argv[1])))
        return LEPUS_EXCEPTION;
    return LEPUS_DupValue(ctx, argv[1]);
}

static LEPUSValue js_object___toPropertyKey(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToPropertyKey(ctx, argv[0]);
}

static LEPUSValue js_object___isObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, LEPUS_IsObject(argv[0]));
}

static LEPUSValue js_object___isSameValueZero(LEPUSContext *ctx, LEPUSValueConst this_val,
                                           int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, js_same_value_zero(ctx, argv[0], argv[1]));
}

static LEPUSValue js_object___isConstructor(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, LEPUS_IsConstructor(ctx, argv[0]));
}
#endif

QJS_STATIC LEPUSValue
JS_SpeciesConstructor(LEPUSContext *ctx, LEPUSValueConst obj,
                      LEPUSValueConst defaultConstructor) {
  LEPUSValue ctor, species;

  if (!LEPUS_IsObject(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  ctor = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_constructor, obj, 0);
  if (LEPUS_IsException(ctor)) return ctor;
  if (LEPUS_IsUndefined(ctor)) return LEPUS_DupValue(ctx, defaultConstructor);
  if (!LEPUS_IsObject(ctor)) {
    LEPUS_FreeValue(ctx, ctor);
    return JS_ThrowTypeErrorNotAnObject(ctx);
  }
  species =
      JS_GetPropertyInternal_RC(ctx, ctor, JS_ATOM_Symbol_species, ctor, 0);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(species)) return species;
  if (LEPUS_IsUndefined(species) || LEPUS_IsNull(species))
    return LEPUS_DupValue(ctx, defaultConstructor);
  if (!LEPUS_IsConstructor(ctx, species)) {
    LEPUS_FreeValue(ctx, species);
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  }
  return species;
}

#if 0
static LEPUSValue js_object___speciesConstructor(LEPUSContext *ctx, LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv)
{
    return JS_SpeciesConstructor(ctx, argv[0], argv[1]);
}
#endif

QJS_STATIC LEPUSValue js_object_get___proto__(LEPUSContext *ctx,
                                              LEPUSValueConst this_val) {
  LEPUSValue val, ret;

  val = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  ret = LEPUS_DupValue(ctx, JS_GetPrototype_RC(ctx, val));
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue js_object_set___proto__(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              LEPUSValueConst proto) {
  if (LEPUS_IsUndefined(this_val) || LEPUS_IsNull(this_val))
    return JS_ThrowTypeErrorNotAnObject(ctx);
  if (!LEPUS_IsObject(proto) && !LEPUS_IsNull(proto)) return LEPUS_UNDEFINED;
  if (JS_SetPrototypeInternal(ctx, this_val, proto, TRUE) < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_object_isPrototypeOf(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSValueConst v;
  int max_depth = 1000, res = -1;

  v = argv[0];
  if (!LEPUS_IsObject(v)) return LEPUS_FALSE;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  while (--max_depth > 0) {
    v = JS_GetPrototype_RC(ctx, v);
    if (LEPUS_IsException(v)) goto exception;
    if (LEPUS_IsNull(v)) {
      res = FALSE;
      break;
    }
    if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, obj), LEPUS_DupValue(ctx, v),
                      JS_EQ_STRICT)) {
      res = TRUE;
      break;
    }
  }
  LEPUS_FreeValue(ctx, obj);
  if (res < 0)
    return LEPUS_ThrowInternalError(ctx, "prototype chain cycle");
  else
    return LEPUS_NewBool(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_object_propertyIsEnumerable(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv) {
  LEPUSValue obj, res = LEPUS_EXCEPTION;
  JSAtom prop = JS_ATOM_NULL;
  LEPUSPropertyDescriptor desc;
  int has_prop;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;
  prop = js_value_to_atom(ctx, argv[0]);
  if (unlikely(prop == JS_ATOM_NULL)) goto exception;

  has_prop =
      JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(obj), prop);
  if (has_prop < 0) goto exception;
  if (has_prop) {
    res = LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_ENUMERABLE) != 0);
    js_free_desc(ctx, &desc);
  } else {
    res = LEPUS_FALSE;
  }

exception:
  LEPUS_FreeAtom(ctx, prop);
  LEPUS_FreeValue(ctx, obj);
  return res;
}

QJS_STATIC LEPUSValue js_object___lookupGetter__(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int setter) {
  LEPUSValue obj, res = LEPUS_EXCEPTION;
  LEPUSValueConst v;
  JSAtom prop = JS_ATOM_NULL;
  LEPUSPropertyDescriptor desc;
  int has_prop;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;
  prop = js_value_to_atom(ctx, argv[0]);
  if (unlikely(prop == JS_ATOM_NULL)) goto exception;

  for (v = obj;;) {
    has_prop =
        JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(v), prop);
    if (has_prop < 0) goto exception;
    if (has_prop) {
      if (desc.flags & LEPUS_PROP_GETSET)
        res = LEPUS_DupValue(ctx, setter ? desc.setter : desc.getter);
      else
        res = LEPUS_UNDEFINED;
      js_free_desc(ctx, &desc);
      break;
    }
    v = JS_GetPrototype_RC(ctx, v);
    if (LEPUS_IsException(v)) goto exception;
    if (LEPUS_IsNull(v)) {
      res = LEPUS_UNDEFINED;
      break;
    }
  }

exception:
  LEPUS_FreeAtom(ctx, prop);
  LEPUS_FreeValue(ctx, obj);
  return res;
}

static const LEPUSCFunctionListEntry js_object_funcs[] = {
    LEPUS_CFUNC_DEF("create", 2, js_object_create),
    LEPUS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, js_object_getPrototypeOf, 0),
    LEPUS_CFUNC_DEF("setPrototypeOf", 2, js_object_setPrototypeOf),
    LEPUS_CFUNC_MAGIC_DEF("defineProperty", 3, js_object_defineProperty, 0),
    LEPUS_CFUNC_DEF("defineProperties", 2, js_object_defineProperties),
    LEPUS_CFUNC_DEF("getOwnPropertyNames", 1, js_object_getOwnPropertyNames),
    LEPUS_CFUNC_DEF("getOwnPropertySymbols", 1,
                    js_object_getOwnPropertySymbols),
    LEPUS_CFUNC_MAGIC_DEF("keys", 1, js_object_keys, JS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("values", 1, js_object_keys, JS_ITERATOR_KIND_VALUE),
    LEPUS_CFUNC_MAGIC_DEF("entries", 1, js_object_keys,
                          JS_ITERATOR_KIND_KEY_AND_VALUE),
    LEPUS_CFUNC_MAGIC_DEF("isExtensible", 1, js_object_isExtensible, 0),
    LEPUS_CFUNC_MAGIC_DEF("preventExtensions", 1, js_object_preventExtensions,
                          0),
    LEPUS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2,
                          lepus_object_getOwnPropertyDescriptor, 0),
    LEPUS_CFUNC_DEF("getOwnPropertyDescriptors", 1,
                    js_object_getOwnPropertyDescriptors),
    LEPUS_CFUNC_DEF("is", 2, js_object_is),
    LEPUS_CFUNC_DEF("assign", 2, js_object_assign),
    LEPUS_CFUNC_MAGIC_DEF("seal", 1, js_object_seal, 0),
    LEPUS_CFUNC_MAGIC_DEF("freeze", 1, js_object_seal, 1),
    LEPUS_CFUNC_MAGIC_DEF("isSealed", 1, js_object_isSealed, 0),
    LEPUS_CFUNC_MAGIC_DEF("isFrozen", 1, js_object_isSealed, 1),
    LEPUS_CFUNC_DEF("__getClass", 1, js_object___getClass),
    // LEPUS_CFUNC_DEF("__isObject", 1, js_object___isObject ),
    // LEPUS_CFUNC_DEF("__isConstructor", 1, js_object___isConstructor ),
    // LEPUS_CFUNC_DEF("__toObject", 1, js_object___toObject ),
    // LEPUS_CFUNC_DEF("__setOwnProperty", 3, js_object___setOwnProperty ),
    // LEPUS_CFUNC_DEF("__toPrimitive", 2, js_object___toPrimitive ),
    // LEPUS_CFUNC_DEF("__toPropertyKey", 1, js_object___toPropertyKey ),
    // LEPUS_CFUNC_DEF("__speciesConstructor", 2,
    // js_object___speciesConstructor ), LEPUS_CFUNC_DEF("__isSameValueZero",
    // 2, js_object___isSameValueZero ), LEPUS_CFUNC_DEF("__getObjectData",
    // 1, js_object___getObjectData ), LEPUS_CFUNC_DEF("__setObjectData", 2,
    // js_object___setObjectData ),
    LEPUS_CFUNC_DEF("fromEntries", 1, js_object_fromEntries),
};

static const LEPUSCFunctionListEntry js_object_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_object_toString),
    LEPUS_CFUNC_DEF("toLocaleString", 0, js_object_toLocaleString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_object_valueOf),
    LEPUS_CFUNC_DEF("hasOwnProperty", 1, js_object_hasOwnProperty),
    LEPUS_CFUNC_DEF("isPrototypeOf", 1, js_object_isPrototypeOf),
    LEPUS_CFUNC_DEF("propertyIsEnumerable", 1, js_object_propertyIsEnumerable),
    LEPUS_CGETSET_DEF("__proto__", js_object_get___proto__,
                      js_object_set___proto__),
    LEPUS_CFUNC_MAGIC_DEF("__defineGetter__", 2, js_object___defineGetter__, 0),
    LEPUS_CFUNC_MAGIC_DEF("__defineSetter__", 2, js_object___defineGetter__, 1),
    LEPUS_CFUNC_MAGIC_DEF("__lookupGetter__", 1, js_object___lookupGetter__, 0),
    LEPUS_CFUNC_MAGIC_DEF("__lookupSetter__", 1, js_object___lookupGetter__, 1),
};

/* Function class */

QJS_STATIC LEPUSValue js_function_proto(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_function_constructor(LEPUSContext *ctx,
                                              LEPUSValueConst new_target,
                                              int argc, LEPUSValueConst *argv,
                                              int magic) {
  JSFunctionKindEnum func_kind = static_cast<JSFunctionKindEnum>(magic);
  int i, n, ret;
  LEPUSValue s, proto, obj = LEPUS_UNDEFINED;
  StringBuffer b_s, *b = &b_s;

  string_buffer_init(ctx, b, 0);
  string_buffer_putc8(b, '(');

  if (func_kind == JS_FUNC_ASYNC || func_kind == JS_FUNC_ASYNC_GENERATOR) {
    string_buffer_puts8(b, "async ");
  }
  string_buffer_puts8(b, "function");

  if (func_kind == JS_FUNC_GENERATOR || func_kind == JS_FUNC_ASYNC_GENERATOR) {
    string_buffer_putc8(b, '*');
  }
  string_buffer_puts8(b, " anonymous(");

  n = argc - 1;
  for (i = 0; i < n; i++) {
    if (i != 0) {
      string_buffer_putc8(b, ',');
    }
    if (string_buffer_concat_value(b, argv[i])) goto fail;
  }
  string_buffer_puts8(b, "\n) {\n");
  if (n >= 0) {
    if (string_buffer_concat_value(b, argv[n])) goto fail;
  }
  string_buffer_puts8(b, "\n})");
  s = string_buffer_end(b);
  if (LEPUS_IsException(s)) goto fail1;

  obj = JS_EvalObject(ctx, ctx->global_obj, s, LEPUS_EVAL_TYPE_INDIRECT, -1);
  LEPUS_FreeValue(ctx, s);
  if (LEPUS_IsException(obj)) goto fail1;
  if (!LEPUS_IsUndefined(new_target)) {
    /* set the prototype */
    proto = js_get_prototype_from_ctor(ctx, new_target, LEPUS_UNDEFINED);
    if (LEPUS_IsException(proto)) goto fail1;
    if (!LEPUS_IsUndefined(proto)) {
      ret = JS_SetPrototypeInternal(ctx, obj, proto, TRUE);
      LEPUS_FreeValue(ctx, proto);
      if (ret < 0) goto fail1;
    }
  }
  return obj;

fail:
  string_buffer_free(b);
fail1:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

__exception int lepus_get_length32(LEPUSContext *ctx, uint32_t *pres,
                                   LEPUSValueConst obj) {
  CallGCFunc(js_get_length32_gc, ctx, pres, obj);
  LEPUSValue len_val;
  len_val = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_length, obj, 0);
  if (LEPUS_IsException(len_val)) {
    *pres = 0;
    return -1;
  }
  return JS_ToUint32Free(ctx, pres, len_val);
}

QJS_STATIC __exception int js_get_length64(LEPUSContext *ctx, int64_t *pres,
                                           LEPUSValueConst obj) {
  LEPUSValue len_val;
  len_val = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_length, obj, 0);
  if (LEPUS_IsException(len_val)) {
    *pres = 0;
    return -1;
  }
  return JS_ToLengthFree(ctx, pres, len_val);
}

QJS_STATIC void free_arg_list(LEPUSContext *ctx, LEPUSValue *tab,
                              uint32_t len) {
  uint32_t i;
  for (i = 0; i < len; i++) {
    LEPUS_FreeValue(ctx, tab[i]);
  }
  lepus_free(ctx, tab);
}

/* XXX: should use ValueArray */
QJS_STATIC LEPUSValue *build_arg_list(LEPUSContext *ctx, uint32_t *plen,
                                      LEPUSValueConst array_arg) {
  uint32_t len, i;
  LEPUSValue *tab, ret;
  LEPUSObject *p;

  if (LEPUS_VALUE_IS_NOT_OBJECT(array_arg)) {
    LEPUS_ThrowTypeError(ctx, "not a object");
    return NULL;
  }
  if (lepus_get_length32(ctx, &len, array_arg)) return NULL;
  /* avoid allocating 0 bytes */
  tab = static_cast<LEPUSValue *>(lepus_mallocz(
      ctx, sizeof(tab[0]) * max_uint32(1, len), ALLOC_TAG_JSValueArray));
  if (!tab) return NULL;
  p = LEPUS_VALUE_GET_OBJ(array_arg);

  if ((p->class_id == JS_CLASS_ARRAY || p->class_id == JS_CLASS_ARGUMENTS) &&
      p->fast_array && len == p->u.array.count) {
    for (i = 0; i < len; i++) {
      tab[i] = LEPUS_DupValue(ctx, p->u.array.u.values[i]);
    }
  } else {
    for (i = 0; i < len; i++) {
      ret = LEPUS_GetPropertyUint32(ctx, array_arg, i);
      if (LEPUS_IsException(ret)) {
        free_arg_list(ctx, tab, i);
        return NULL;
      }
      tab[i] = ret;
    }
  }
  *plen = len;
  return tab;
}

LEPUSValue js_function_apply(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int argc, LEPUSValueConst *argv, int magic) {
  LEPUSValueConst this_arg, array_arg;
  uint32_t len;
  LEPUSValue *tab, ret;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;
  this_arg = argv[0];
  array_arg = argv[1];
  if (LEPUS_VALUE_IS_UNDEFINED(array_arg) || LEPUS_VALUE_IS_NULL(array_arg)) {
    return JS_Call_RC(ctx, this_val, this_arg, 0, NULL);
  }
  tab = build_arg_list(ctx, &len, array_arg);
  if (!tab) return LEPUS_EXCEPTION;
  if (magic) {
    ret = LEPUS_CallConstructor2(ctx, this_val, this_arg, len,
                                 (LEPUSValueConst *)tab);
  } else {
    ret = JS_Call_RC(ctx, this_val, this_arg, len, (LEPUSValueConst *)tab);
  }
  free_arg_list(ctx, tab, len);
  return ret;
}

QJS_STATIC LEPUSValue js_function_call(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  if (argc <= 0) {
    return JS_Call_RC(ctx, this_val, LEPUS_UNDEFINED, 0, NULL);
  } else {
    return JS_Call_RC(ctx, this_val, argv[0], argc - 1, argv + 1);
  }
}

QJS_STATIC LEPUSValue js_function_bind(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  JSBoundFunction *bf;
  LEPUSValue func_obj, name1, len_val;
  LEPUSObject *p;
  int arg_count, i, ret;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;

  // https://262.ecma-international.org/6.0/#sec-boundfunctioncreate
  func_obj = JS_NewObjectProtoClass_RC(ctx, JS_GetPrototype_RC(ctx, this_val),
                                       JS_CLASS_BOUND_FUNCTION);
  if (LEPUS_IsException(func_obj)) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->is_constructor = LEPUS_IsConstructor(ctx, this_val);
  arg_count = max_int(0, argc - 1);
  bf = static_cast<JSBoundFunction *>(
      lepus_malloc(ctx, sizeof(*bf) + arg_count * sizeof(LEPUSValue)));
  if (!bf) goto exception;
  bf->func_obj = LEPUS_DupValue(ctx, this_val);
  bf->this_val = LEPUS_DupValue(ctx, argv[0]);
  bf->argc = arg_count;
  for (i = 0; i < arg_count; i++) {
    bf->argv[i] = LEPUS_DupValue(ctx, argv[i + 1]);
  }
  p->u.bound_function = bf;

  ret = LEPUS_GetOwnProperty(ctx, NULL, this_val, JS_ATOM_length);
  if (ret < 0) goto exception;
  if (!ret) {
    len_val = LEPUS_NewInt32(ctx, 0);
  } else {
    len_val =
        JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_length, this_val, 0);
    if (LEPUS_IsException(len_val)) goto exception;
    if (LEPUS_VALUE_IS_INT(len_val)) {
      int len1 = LEPUS_VALUE_GET_INT(len_val);
      if (len1 <= arg_count)
        len1 = 0;
      else
        len1 -= arg_count;
      len_val = LEPUS_NewInt32(ctx, len1);
    } else if (LEPUS_VALUE_IS_FLOAT64(len_val)) {
      double d = LEPUS_VALUE_GET_FLOAT64(len_val);
      if (isnan(d)) {
        d = 0.0;
      } else {
        d = trunc(d);
        if (d <= (double)arg_count)
          d = 0.0;
        else
          d -= (double)arg_count; /* also converts -0 to +0 */
      }
      len_val = LEPUS_NewFloat64(ctx, d);
    } else {
      LEPUS_FreeValue(ctx, len_val);
      len_val = LEPUS_NewInt32(ctx, 0);
    }
  }

  JS_DefinePropertyValue_RC(ctx, func_obj, JS_ATOM_length, len_val,
                            LEPUS_PROP_CONFIGURABLE);

  name1 = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_name, this_val, 0);
  if (LEPUS_IsException(name1)) goto exception;
  if (!LEPUS_IsString(name1)) {
    LEPUS_FreeValue(ctx, name1);
    name1 = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  }
  name1 = JS_ConcatString3(ctx, "bound ", name1, "");
  if (LEPUS_IsException(name1)) goto exception;
  JS_DefinePropertyValue_RC(ctx, func_obj, JS_ATOM_name, name1,
                            LEPUS_PROP_CONFIGURABLE);
  return func_obj;
exception:
  LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

QJS_HIDE LEPUSValue js_function_toString(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSObject *p;
  JSFunctionKindEnum func_kind = JS_FUNC_NORMAL;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;

  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    if (b->has_debug && b->debug.source) {
      return LEPUS_NewStringLen(ctx, b->debug.source, b->debug.source_len);
    }
    func_kind = static_cast<JSFunctionKindEnum>(b->func_kind);
  }
  {
    LEPUSValue name;
    const char *pref, *suff;

    if (p->is_class) {
      pref = "class ";
      suff = " {\n    [native code]\n}";
    } else {
      switch (func_kind) {
        default:
        case JS_FUNC_NORMAL:
          pref = "function ";
          break;
        case JS_FUNC_GENERATOR:
          pref = "function *";
          break;
        case JS_FUNC_ASYNC:
          pref = "async function ";
          break;
        case JS_FUNC_ASYNC_GENERATOR:
          pref = "async function *";
          break;
      }
      suff = "() {\n    [native code]\n}";
    }
    name = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_name, this_val, 0);
    if (LEPUS_IsUndefined(name))
      name = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
    return JS_ConcatString3(ctx, pref, name, suff);
  }
}

QJS_STATIC LEPUSValue js_function_hasInstance(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  int ret;
  ret = JS_OrdinaryIsInstanceOf(ctx, argv[0], this_val);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

static const LEPUSCFunctionListEntry js_function_proto_funcs[] = {
    LEPUS_CFUNC_DEF("call", 1, js_function_call),
    LEPUS_CFUNC_MAGIC_DEF("apply", 2, js_function_apply, 0),
    LEPUS_CFUNC_DEF("bind", 1, js_function_bind),
    LEPUS_CFUNC_DEF("toString", 0, js_function_toString),
    LEPUS_CFUNC_DEF("[Symbol.hasInstance]", 1, js_function_hasInstance),
    LEPUS_CGETSET_DEF("fileName", js_function_proto_fileName, NULL),
    LEPUS_CGETSET_DEF("lineNumber", js_function_proto_lineNumber, NULL),
};

/* Error class */
QJS_STATIC LEPUSValue iterator_to_array(LEPUSContext *ctx,
                                        LEPUSValueConst items) {
  LEPUSValue iter, next_method = LEPUS_UNDEFINED;
  LEPUSValue v = LEPUS_UNDEFINED, r = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &v, HANDLE_TYPE_LEPUS_VALUE);
  int64_t k;
  BOOL done;

  iter = JS_GetIterator(ctx, items, FALSE);
  if (LEPUS_IsException(iter)) goto exception;
  func_scope.PushHandle(&iter, HANDLE_TYPE_LEPUS_VALUE);
  next_method = LEPUS_GetPropertyInternal(ctx, iter, JS_ATOM_next, iter, 0);
  if (LEPUS_IsException(next_method)) goto exception;
  func_scope.PushHandle(&next_method, HANDLE_TYPE_LEPUS_VALUE);
  r = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(r)) goto exception;
  func_scope.PushHandle(&r, HANDLE_TYPE_LEPUS_VALUE);
  for (k = 0;; k++) {
    v = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(v)) goto exception_close;
    if (done) break;
    if (JS_DefinePropertyValueInt64(ctx, r, k, v,
                                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
      goto exception_close;
  }
done:
  if (!ctx->gc_enable) {
    LEPUS_FreeValue(ctx, next_method);
    LEPUS_FreeValue(ctx, iter);
  }
  return r;
exception_close:
  JS_IteratorClose(ctx, iter, TRUE);
exception:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
  goto done;
}

LEPUSValue js_error_constructor(LEPUSContext *ctx, LEPUSValueConst new_target,
                                int argc, LEPUSValueConst *argv, int magic) {
  LEPUSValue obj, msg, proto;
  LEPUSValueConst message;

  if (LEPUS_IsUndefined(new_target)) new_target = JS_GetActiveFunction(ctx);
  proto = LEPUS_GetPropertyInternal(ctx, new_target, JS_ATOM_prototype,
                                    new_target, 0);
  if (LEPUS_IsException(proto)) return proto;
  if (!LEPUS_IsObject(proto)) {
    LEPUSValueConst proto1;
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, proto);
    if (magic < 0) {
      proto1 = ctx->class_proto[JS_CLASS_ERROR];
    } else {
      proto1 = ctx->native_error_proto[magic];
    }
    proto = LEPUS_DupValue(ctx, proto1);
  }
  HandleScope func_scope(ctx, &proto, HANDLE_TYPE_LEPUS_VALUE);
  obj = LEPUS_NewObjectProtoClass(ctx, proto, JS_CLASS_ERROR);
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, proto);
  if (LEPUS_IsException(obj)) return obj;
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  if (magic == JS_AGGREGATE_ERROR) {
    message = argv[1];
  } else {
    message = argv[0];
  }
  func_scope.PushHandle(&message, HANDLE_TYPE_LEPUS_VALUE);
  if (!LEPUS_IsUndefined(message)) {
    msg = LEPUS_ToString(ctx, message);
    if (unlikely(LEPUS_IsException(msg))) goto exception;
    func_scope.PushHandle(&msg, HANDLE_TYPE_LEPUS_VALUE);
    LEPUS_DefinePropertyValue(ctx, obj, JS_ATOM_message, msg,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }

  if (magic == JS_AGGREGATE_ERROR) {
    LEPUSValue error_list = iterator_to_array(ctx, argv[0]);
    if (LEPUS_IsException(error_list)) goto exception;
    HandleScope block_scope(ctx, &error_list, HANDLE_TYPE_LEPUS_VALUE);
    // TODO
    JSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
    block_scope.PushLEPUSAtom(atom_errors);
    LEPUS_DefinePropertyValue(ctx, obj, atom_errors, error_list,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom_errors);
  }
  /* skip the Error() function in the backtrace */
  build_backtrace(ctx, obj, NULL, 0, NULL, JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL);
  return obj;
exception:
  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_error_toString(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue name, msg;

  if (!LEPUS_IsObject(this_val)) return JS_ThrowTypeErrorNotAnObject(ctx);
  name = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_name, this_val, 0);
  if (LEPUS_IsUndefined(name))
    name = LEPUS_AtomToString(ctx, JS_ATOM_Error);
  else
    name = JS_ToStringFree(ctx, name);
  if (LEPUS_IsException(name)) return LEPUS_EXCEPTION;

  msg = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_message, this_val, 0);
  if (LEPUS_IsUndefined(msg))
    msg = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  else
    msg = JS_ToStringFree(ctx, msg);
  if (LEPUS_IsException(msg)) {
    LEPUS_FreeValue(ctx, name);
    return LEPUS_EXCEPTION;
  }
  if (!JS_IsEmptyString(name) && !JS_IsEmptyString(msg))
    name = JS_ConcatString3(ctx, "", name, ": ");
  return JS_ConcatString(ctx, name, msg);
}

static const LEPUSCFunctionListEntry js_error_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_error_toString),
    LEPUS_PROP_STRING_DEF("name", "Error",
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
    LEPUS_PROP_STRING_DEF("message", "",
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Array */

QJS_STATIC int JS_CopySubArray(LEPUSContext *ctx, LEPUSValueConst obj,
                               int64_t to_pos, int64_t from_pos, int64_t count,
                               int dir) {
  int64_t i, from, to, len = 0;
  LEPUSValue val;
  int fromPresent;
  LEPUSObject *p = nullptr;

  if (js_is_fast_array(ctx, obj)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
  }

  /* XXX: should special case fast arrays */
  for (i = 0; i < count; i++) {
    if (dir < 0) {
      from = from_pos + count - i - 1;
      to = to_pos + count - i - 1;
    } else {
      from = from_pos + i;
      to = to_pos + i;
    }

    if (p && p->fast_array && from >= 0 && from < (len = p->u.array.count) &&
        to >= 0 && to < len) {
      int64_t l, j;
      l = count - i;
      /* Fast path for fast arrays. Since we don't look at the
         prototype chain, we can optimize only the cases where
         all the elements are present in the array. */
      if (dir < 0) {
        // Make sure index 'from - j' and 'to - j' is valid;
        l = min_int64(l, from + 1);
        l = min_int64(l, to + 1);

        for (j = 0; j < l; ++j) {
          set_value(ctx, p->u.array.u.values + to - j,
                    LEPUS_DupValue(ctx, p->u.array.u.values[from - j]));
        }
      } else {
        //  Make sure index 'from + j' and 'to + j' is valid;
        l = min_int64(l, len - from);
        l = min_int64(l, len - to);
        for (j = 0; j < l; ++j) {
          set_value(ctx, p->u.array.u.values + to + j,
                    LEPUS_DupValue(ctx, p->u.array.u.values[from + j]));
        }
      }
      i += l;
    } else {
      fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &val);
      if (fromPresent < 0) goto exception;

      if (fromPresent) {
        if (LEPUS_SetPropertyInt64(ctx, obj, to, val) < 0) goto exception;
      } else {
        if (JS_DeletePropertyInt64(ctx, obj, to, LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
  }
  return 0;

exception:
  return -1;
}

QJS_STATIC LEPUSValue js_array_constructor(LEPUSContext *ctx,
                                           LEPUSValueConst new_target, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj;
  int i;

  obj = js_create_from_ctor(ctx, new_target, JS_CLASS_ARRAY);
  if (LEPUS_IsException(obj)) return obj;
  if (argc == 1 && LEPUS_IsNumber(argv[0])) {
    uint32_t len;
    if (JS_ToArrayLengthFree(ctx, &len, LEPUS_DupValue(ctx, argv[0]), TRUE))
      goto fail;
    if (JS_SetPropertyInternal_RC(ctx, obj, JS_ATOM_length,
                                  JS_NewUint32(ctx, len), LEPUS_PROP_THROW) < 0)
      goto fail;
  } else {
    for (i = 0; i < argc; i++) {
      if (LEPUS_SetPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, argv[i])) <
          0)
        goto fail;
    }
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_from(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  // from(items, mapfn = void 0, this_arg = void 0)
  LEPUSValueConst items = argv[0], mapfn, this_arg;
  LEPUSValueConst args[2];
  LEPUSValue stack[2];
  LEPUSValue iter, r, v, v2, arrayLike;
  int64_t k, len;
  int done, mapping;

  mapping = FALSE;
  mapfn = LEPUS_UNDEFINED;
  this_arg = LEPUS_UNDEFINED;
  r = LEPUS_UNDEFINED;
  arrayLike = LEPUS_UNDEFINED;
  stack[0] = LEPUS_UNDEFINED;
  stack[1] = LEPUS_UNDEFINED;

  if (argc > 1) {
    mapfn = argv[1];
    if (!LEPUS_IsUndefined(mapfn)) {
      if (check_function(ctx, mapfn)) goto exception;
      mapping = 1;
      if (argc > 2) this_arg = argv[2];
    }
  }
  // <Primjs begin>
  items = JSRef2Value(ctx, items);
  // <Primjs end>
  iter =
      JS_GetPropertyInternal_RC(ctx, items, JS_ATOM_Symbol_iterator, items, 0);
  if (LEPUS_IsException(iter)) goto exception;
  if (!LEPUS_IsUndefined(iter)) {
    LEPUS_FreeValue(ctx, iter);
    if (LEPUS_IsConstructor(ctx, this_val))
      r = LEPUS_CallConstructor(ctx, this_val, 0, NULL);
    else
      r = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(r)) goto exception;
    stack[0] = LEPUS_DupValue(ctx, items);
    if (js_for_of_start(ctx, &stack[1], FALSE)) goto exception;
    for (k = 0;; k++) {
      v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
      if (LEPUS_IsException(v)) goto exception_close;
      if (done) break;
      if (mapping) {
        args[0] = v;
        args[1] = LEPUS_NewInt32(ctx, k);
        v2 = JS_Call_RC(ctx, mapfn, this_arg, 2, args);
        LEPUS_FreeValue(ctx, v);
        v = v2;
        if (LEPUS_IsException(v)) goto exception_close;
      }
      if (JS_DefinePropertyValueInt64(ctx, r, k, v,
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception_close;
    }
  } else {
    arrayLike = LEPUS_ToObject(ctx, items);
    if (LEPUS_IsException(arrayLike)) goto exception;
    if (js_get_length64(ctx, &len, arrayLike) < 0) goto exception;
    v = LEPUS_NewInt64(ctx, len);
    args[0] = v;
    if (LEPUS_IsConstructor(ctx, this_val)) {
      r = LEPUS_CallConstructor(ctx, this_val, 1, args);
    } else {
      r = js_array_constructor(ctx, LEPUS_UNDEFINED, 1, args);
    }
    LEPUS_FreeValue(ctx, v);
    if (LEPUS_IsException(r)) goto exception;
    for (k = 0; k < len; k++) {
      v = JS_GetPropertyInt64(ctx, arrayLike, k);
      if (LEPUS_IsException(v)) goto exception;
      if (mapping) {
        args[0] = v;
        args[1] = LEPUS_NewInt32(ctx, k);
        v2 = JS_Call_RC(ctx, mapfn, this_arg, 2, args);
        LEPUS_FreeValue(ctx, v);
        v = v2;
        if (LEPUS_IsException(v)) goto exception;
      }
      if (JS_DefinePropertyValueInt64(ctx, r, k, v,
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  if (JS_SetPropertyInternal_RC(ctx, r, JS_ATOM_length, JS_NewUint32(ctx, k),
                                LEPUS_PROP_THROW) < 0)
    goto exception;
  goto done;

exception_close:
  if (!LEPUS_IsUndefined(stack[0])) JS_IteratorClose(ctx, stack[0], TRUE);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, arrayLike);
  LEPUS_FreeValue(ctx, stack[0]);
  LEPUS_FreeValue(ctx, stack[1]);
  return r;
}

QJS_STATIC LEPUSValue js_array_of(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  LEPUSValue obj, args[1];
  int i;

  if (LEPUS_IsConstructor(ctx, this_val)) {
    args[0] = LEPUS_NewInt32(ctx, argc);
    obj = LEPUS_CallConstructor(ctx, this_val, 1, (LEPUSValueConst *)args);
  } else {
    obj = LEPUS_NewArray(ctx);
  }
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  for (i = 0; i < argc; i++) {
    if (JS_CreateDataPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, argv[i]),
                                    LEPUS_PROP_THROW) < 0) {
      goto fail;
    }
  }
  if (JS_SetPropertyInternal_RC(ctx, obj, JS_ATOM_length,
                                JS_NewUint32(ctx, argc),
                                LEPUS_PROP_THROW) < 0) {
  fail:
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC LEPUSValue js_array_isArray(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  int ret;
  ret = LEPUS_IsArray(ctx, argv[0]);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else {
    if (ret == 0 && ctx && LEPUS_IsLepusRef(argv[0])) {
      ret = JS_LepusRefIsArray(ctx->rt, argv[0]);
    }
    return LEPUS_NewBool(ctx, ret);
  }
}

QJS_STATIC LEPUSValue js_get_this(LEPUSContext *ctx, LEPUSValueConst this_val) {
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue JS_ArraySpeciesCreate(LEPUSContext *ctx,
                                            LEPUSValueConst obj,
                                            LEPUSValueConst len_val) {
  LEPUSValue ctor, ret;
  int res;

  res = LEPUS_IsArray(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) return js_array_constructor(ctx, LEPUS_UNDEFINED, 1, &len_val);
  ctor = JS_SpeciesConstructor(ctx, obj, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(ctor))
    return js_array_constructor(ctx, LEPUS_UNDEFINED, 1, &len_val);
  ret = LEPUS_CallConstructor(ctx, ctor, 1, &len_val);
  LEPUS_FreeValue(ctx, ctor);
  return ret;
}

static const LEPUSCFunctionListEntry js_array_funcs[] = {
    LEPUS_CFUNC_DEF("isArray", 1, js_array_isArray),
    LEPUS_CFUNC_DEF("from", 1, js_array_from),
    LEPUS_CFUNC_DEF("of", 0, js_array_of),
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
};

int JS_isConcatSpreadable(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSValue val;

  if (!LEPUS_IsObject(obj)) {
#ifdef ENABLE_LEPUSNG
    return JS_LepusRefIsArray(ctx->rt, obj);
#else
    return false;
#endif
  }
  val = LEPUS_GetPropertyInternal(ctx, obj, JS_ATOM_Symbol_isConcatSpreadable,
                                  obj, 0);
  if (LEPUS_IsException(val)) return -1;
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  if (!LEPUS_IsUndefined(val)) return JS_ToBoolFree(ctx, val);
  return LEPUS_IsArray(ctx, obj);
}

QJS_STATIC LEPUSValue js_array_concat(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  CallGCFunc(js_array_concat_gc, ctx, this_val, argc, argv);
  LEPUSValue obj, arr, val;
  LEPUSValueConst e;
  int64_t len, k, n;
  int i, res;

  arr = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;

  arr = JS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
  if (LEPUS_IsException(arr)) goto exception;
  n = 0;
  for (i = -1; i < argc; i++) {
    if (i < 0) {
      e = obj;
    } else {
      e = argv[i];
    }

    res = JS_isConcatSpreadable(ctx, e);
    if (res < 0) goto exception;
    if (res) {
      if (js_get_length64(ctx, &len, e)) goto exception;
      if (n + len > MAX_SAFE_INTEGER) {
        LEPUS_ThrowTypeError(ctx, "Array loo long");
        goto exception;
      }
      for (k = 0; k < len; k++, n++) {
        res = JS_TryGetPropertyInt64(ctx, e, k, &val);
        if (res < 0) goto exception;
        if (res) {
          if (JS_DefinePropertyValueInt64(
                  ctx, arr, n, val, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
            goto exception;
        }
      }
    } else {
      if (n >= MAX_SAFE_INTEGER) {
        LEPUS_ThrowTypeError(ctx, "Array loo long");
        goto exception;
      }
      if (JS_DefinePropertyValueInt64(ctx, arr, n, LEPUS_DupValue(ctx, e),
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception;
      n++;
    }
  }
  if (JS_SetPropertyInternal_RC(ctx, arr, JS_ATOM_length,
                                LEPUS_NewInt64(ctx, n), LEPUS_PROP_THROW) < 0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#define special_every 0
#define special_some 1
#define special_forEach 2
#define special_map 3
#define special_filter 4
#define special_TA 8

QJS_STATIC int js_typed_array_get_length_internal(LEPUSContext *ctx,
                                                  LEPUSValueConst obj);

QJS_STATIC LEPUSValue js_typed_array___speciesCreate(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv);

QJS_STATIC LEPUSValue js_array_every(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int special) {
  LEPUSValue obj, val, index_val, res, ret;
  LEPUSValueConst args[3];
  LEPUSValueConst func, this_arg;
  int64_t len, k, n;
  int present;

  ret = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  if (special & special_TA) {
    obj = LEPUS_DupValue(ctx, this_val);
    len = js_typed_array_get_length_internal(ctx, obj);
    if (len < 0) goto exception;
  } else {
    obj = JS_ToObject_expect_lepusref(ctx, this_val);
    if (js_get_length64(ctx, &len, obj)) goto exception;
  }
  func = argv[0];
  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  if (check_function(ctx, func)) goto exception;

  switch (special) {
    case special_every:
    case special_every | special_TA:
      ret = LEPUS_TRUE;
      break;
    case special_some:
    case special_some | special_TA:
      ret = LEPUS_FALSE;
      break;
    case special_map:
      /* XXX: JS_ArraySpeciesCreate should take int64_t */
      ret = JS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt64(ctx, len));
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_filter:
      ret = JS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_map | special_TA:
      args[0] = obj;
      args[1] = LEPUS_NewInt32(ctx, len);
      ret = js_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_filter | special_TA:
      ret = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(ret)) goto exception;
      break;
  }
  n = 0;

  for (k = 0; k < len; k++) {
    present = JS_TryGetPropertyInt64(ctx, obj, k, &val);
    if (present < 0) goto exception;
    if (present) {
      index_val = LEPUS_NewInt64(ctx, k);
      if (LEPUS_IsException(index_val)) goto exception;
      // <Primjs begin>
      args[0] = val;
      // <Primjs end>
      args[1] = index_val;
      args[2] = obj;
      res = JS_Call_RC(ctx, func, this_arg, 3, args);
      LEPUS_FreeValue(ctx, index_val);
      if (LEPUS_IsException(res)) goto exception;
      switch (special) {
        case special_every:
        case special_every | special_TA:
          if (!JS_ToBoolFree_RC(ctx, res)) {
            ret = LEPUS_FALSE;
            goto done;
          }
          break;
        case special_some:
        case special_some | special_TA:
          if (JS_ToBoolFree_RC(ctx, res)) {
            ret = LEPUS_TRUE;
            goto done;
          }
          break;
        case special_map:
          if (JS_DefinePropertyValueInt64(
                  ctx, ret, k, res, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
            goto exception;
          break;
        case special_map | special_TA:
          if (JS_SetPropertyValue(ctx, ret, LEPUS_NewInt32(ctx, k), res,
                                  LEPUS_PROP_THROW) < 0)
            goto exception;
          break;
        case special_filter:
        case special_filter | special_TA:
          if (JS_ToBoolFree_RC(ctx, res)) {
            if (JS_DefinePropertyValueInt64(
                    ctx, ret, n++, LEPUS_DupValue(ctx, val),
                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
              goto exception;
          }
          break;
        default:
          LEPUS_FreeValue(ctx, res);
          break;
      }
      LEPUS_FreeValue(ctx, val);
      val = LEPUS_UNDEFINED;
    }
  }
done:
  if (special == (special_filter | special_TA)) {
    LEPUSValue arr;
    args[0] = obj;
    args[1] = LEPUS_NewInt32(ctx, n);
    arr = js_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
    if (LEPUS_IsException(arr)) goto exception;
    args[0] = ret;
    res = LEPUS_Invoke(ctx, arr, JS_ATOM_set, 1, args);
    if (check_exception_free(ctx, res)) goto exception;
    LEPUS_FreeValue(ctx, ret);
    ret = arr;
  }
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return ret;

exception:
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#define special_reduce 0
#define special_reduceRight 1

LEPUSValue js_array_reduce(LEPUSContext *ctx, LEPUSValueConst this_val,
                           int argc, LEPUSValueConst *argv, int special) {
  CallGCFunc(js_array_reduce_gc, ctx, this_val, argc, argv, special);
  LEPUSValue obj, val, index_val, acc, acc1;
  LEPUSValueConst args[4];
  LEPUSValueConst func;
  int64_t len, k, k1;
  int present;

  acc = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  if (special & special_TA) {
    obj = LEPUS_DupValue(ctx, this_val);
    len = js_typed_array_get_length_internal(ctx, obj);
    if (len < 0) goto exception;
  } else {
    obj = LEPUS_ToObject(ctx, this_val);
    if (js_get_length64(ctx, &len, obj)) goto exception;
  }
  func = argv[0];

  if (check_function(ctx, func)) goto exception;

  k = 0;
  if (argc > 1) {
    acc = LEPUS_DupValue(ctx, argv[1]);
  } else {
    for (;;) {
      if (k >= len) {
        LEPUS_ThrowTypeError(ctx, "empty array");
        goto exception;
      }
      k1 = (special & special_reduceRight) ? len - k - 1 : k;
      k++;
      present = JS_TryGetPropertyInt64(ctx, obj, k1, &acc);
      if (present < 0) goto exception;
      if (present) break;
    }
  }
  for (; k < len; k++) {
    k1 = (special & special_reduceRight) ? len - k - 1 : k;
    present = JS_TryGetPropertyInt64(ctx, obj, k1, &val);
    if (present < 0) goto exception;
    if (present) {
      index_val = LEPUS_NewInt64(ctx, k1);
      if (LEPUS_IsException(index_val)) goto exception;
      args[0] = acc;
      args[1] = val;
      args[2] = index_val;
      args[3] = obj;
      acc1 = JS_Call_RC(ctx, func, LEPUS_UNDEFINED, 4, args);
      LEPUS_FreeValue(ctx, index_val);
      LEPUS_FreeValue(ctx, val);
      val = LEPUS_UNDEFINED;
      if (LEPUS_IsException(acc1)) goto exception;
      LEPUS_FreeValue(ctx, acc);
      acc = acc1;
    }
  }
  LEPUS_FreeValue(ctx, obj);
  return acc;

exception:
  LEPUS_FreeValue(ctx, acc);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_fill(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  LEPUSValue obj;
  int64_t len, start, end;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  start = 0;
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt64Clamp(ctx, &start, argv[1], 0, len, len)) goto exception;
  }

  end = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (JS_ToInt64Clamp(ctx, &end, argv[2], 0, len, len)) goto exception;
  }

  /* XXX: should special case fast arrays */
  while (start < end) {
    if (LEPUS_SetPropertyInt64(ctx, obj, start, LEPUS_DupValue(ctx, argv[0])) <
        0)
      goto exception;
    start++;
  }
  return obj;

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_includes(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  LEPUSValue *arrp;
  uint32_t count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  res = FALSE;
  if (len > 0) {
    n = 0;
    if (argc > 1) {
      if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len)) goto exception;
    }
    if (js_get_fast_array(ctx, obj, &arrp, &count)) {
      for (; n < count; n++) {
        if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]),
                          LEPUS_DupValue(ctx, arrp[n]),
                          JS_EQ_SAME_VALUE_ZERO)) {
          res = TRUE;
          goto done;
        }
      }
    }
    for (; n < len; n++) {
      val = JS_GetPropertyInt64(ctx, obj, n);
      if (LEPUS_IsException(val)) goto exception;
      if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                        JS_EQ_SAME_VALUE_ZERO)) {
        res = TRUE;
        break;
      }
    }
  }
done:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewBool(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_indexOf(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  LEPUSValue *arrp;
  uint32_t count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  res = -1;
  if (len > 0) {
    n = 0;
    if (argc > 1) {
      if (JS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len)) goto exception;
    }
    if (js_get_fast_array(ctx, obj, &arrp, &count)) {
      for (; n < count; n++) {
        if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]),
                          LEPUS_DupValue(ctx, arrp[n]), JS_EQ_STRICT)) {
          res = n;
          goto done;
        }
      }
    }
    for (; n < len; n++) {
      int present = JS_TryGetPropertyInt64(ctx, obj, n, &val);
      if (present < 0) goto exception;
      if (present) {
        if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                          JS_EQ_STRICT)) {
          res = n;
          break;
        }
      }
    }
  }
done:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_lastIndexOf(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  int present;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  res = -1;
  if (len > 0) {
    n = len - 1;
    if (argc > 1) {
      if (JS_ToInt64Clamp(ctx, &n, argv[1], -1, len - 1, len)) goto exception;
    }
    /* XXX: should special case fast arrays */
    for (; n >= 0; n--) {
      present = JS_TryGetPropertyInt64(ctx, obj, n, &val);
      if (present < 0) goto exception;
      if (present) {
        if (js_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                          JS_EQ_STRICT)) {
          res = n;
          break;
        }
      }
    }
  }
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_find(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int findIndex) {
  LEPUSValueConst func, this_arg;
  LEPUSValueConst args[3];
  LEPUSValue obj, val, index_val, res;
  int64_t len, k;

  index_val = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  func = argv[0];
  if (check_function(ctx, func)) goto exception;

  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  for (k = 0; k < len; k++) {
    index_val = LEPUS_NewInt64(ctx, k);
    if (LEPUS_IsException(index_val)) goto exception;
    val = JS_GetPropertyValue(ctx, obj, index_val);
    if (LEPUS_IsException(val)) goto exception;
    args[0] = val;
    args[1] = index_val;
    args[2] = this_val;
    res = JS_Call_RC(ctx, func, this_arg, 3, args);
    if (LEPUS_IsException(res)) goto exception;
    if (JS_ToBoolFree_RC(ctx, res)) {
      if (findIndex) {
        LEPUS_FreeValue(ctx, val);
        LEPUS_FreeValue(ctx, obj);
        return index_val;
      } else {
        LEPUS_FreeValue(ctx, index_val);
        LEPUS_FreeValue(ctx, obj);
        return val;
      }
    }
    LEPUS_FreeValue(ctx, val);
    LEPUS_FreeValue(ctx, index_val);
  }
  LEPUS_FreeValue(ctx, obj);
  if (findIndex)
    return LEPUS_NewInt32(ctx, -1);
  else
    return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, index_val);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_toString(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue obj, method, ret;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  method = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_join, obj, 0);
  if (LEPUS_IsException(method)) {
    ret = LEPUS_EXCEPTION;
  } else if (!LEPUS_IsFunction(ctx, method)) {
    /* Use intrinsic Object.prototype.toString */
    LEPUS_FreeValue(ctx, method);
    ret = js_object_toString(ctx, obj, 0, NULL);
  } else {
    ret = JS_CallFree(ctx, method, obj, 0, NULL);
  }
  LEPUS_FreeValue(ctx, obj);
  return ret;
}

QJS_STATIC LEPUSValue js_array_join(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int toLocaleString) {
  LEPUSValue obj, sep = LEPUS_UNDEFINED, el;
  StringBuffer b_s, *b = &b_s;
  JSString *p = NULL;
  int64_t i, n;
  int c;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &n, obj)) goto exception;

  c = ','; /* default separator */
  if (!toLocaleString && argc > 0 && !LEPUS_IsUndefined(argv[0])) {
    sep = JS_ToString_RC(ctx, argv[0]);
    if (LEPUS_IsException(sep)) goto exception;
    p = LEPUS_VALUE_GET_STRING(sep);
    if (p->len == 1 && !p->is_wide_char)
      c = p->u.str8[0];
    else
      c = -1;
  }
  string_buffer_init(ctx, b, 0);

  for (i = 0; i < n; i++) {
    if (i > 0) {
      if (c >= 0) {
        string_buffer_putc8(b, c);
      } else {
        string_buffer_concat(b, p, 0, p->len);
      }
    }
    el = LEPUS_GetPropertyUint32(ctx, obj, i);
    if (LEPUS_IsException(el)) goto fail;
    if (!LEPUS_IsNull(el) && !LEPUS_IsUndefined(el)) {
      if (toLocaleString) {
        el = JS_ToLocaleStringFree(ctx, el);
      }
      if (string_buffer_concat_value_free(b, el)) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, sep);
  LEPUS_FreeValue(ctx, obj);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, sep);
exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_pop(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv, int shift) {
  LEPUSValue obj, res = LEPUS_UNDEFINED;
  int64_t len, newLen;
  LEPUSValue *arrp;
  uint32_t count32;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;
  newLen = 0;
  if (len > 0) {
    newLen = len - 1;
    /* Special case fast arrays */
    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
      if (shift) {
        res = arrp[0];
        memmove(arrp, arrp + 1, (count32 - 1) * sizeof(*arrp));
        p->u.array.count--;
      } else {
        res = arrp[count32 - 1];
        p->u.array.count--;
      }
    } else {
      if (shift) {
        res = JS_GetPropertyInt64(ctx, obj, 0);
        if (LEPUS_IsException(res)) goto exception;
        if (JS_CopySubArray(ctx, obj, 0, 1, len - 1, +1)) goto exception;
      } else {
        res = JS_GetPropertyInt64(ctx, obj, newLen);
        if (LEPUS_IsException(res)) goto exception;
      }
      if (JS_DeletePropertyInt64(ctx, obj, newLen, LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  if (JS_SetPropertyInternal_RC(ctx, obj, JS_ATOM_length,
                                LEPUS_NewInt64(ctx, newLen),
                                LEPUS_PROP_THROW) < 0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return res;

exception:
  LEPUS_FreeValue(ctx, res);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_push(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int unshift) {
  LEPUSValue obj;
  int i;
  int64_t len, from, newLen;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;
  newLen = len + argc;
  if (newLen > MAX_SAFE_INTEGER) {
    LEPUS_ThrowTypeError(ctx, "Array loo long");
    goto exception;
  }
  from = len;
  if (unshift && argc > 0) {
    if (JS_CopySubArray(ctx, obj, argc, 0, len, -1)) goto exception;
    from = 0;
  }
  for (i = 0; i < argc; i++) {
    if (LEPUS_SetPropertyInt64(ctx, obj, from + i,
                               LEPUS_DupValue(ctx, argv[i])) < 0)
      goto exception;
  }
  if (JS_SetPropertyInternal_RC(ctx, obj, JS_ATOM_length,
                                LEPUS_NewInt64(ctx, newLen),
                                LEPUS_PROP_THROW) < 0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, newLen);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_reverse(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue obj, lval, hval;
  LEPUSValue *arrp;
  int64_t len, l, h;
  int l_present, h_present;
  uint32_t count32;

  lval = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  /* Special case fast arrays */
  if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
    uint32_t ll, hh;

    if (count32 > 1) {
      for (ll = 0, hh = count32 - 1; ll < hh; ll++, hh--) {
        lval = arrp[ll];
        arrp[ll] = arrp[hh];
        arrp[hh] = lval;
      }
    }
    return obj;
  }

  for (l = 0, h = len - 1; l < h; l++, h--) {
    l_present = JS_TryGetPropertyInt64(ctx, obj, l, &lval);
    if (l_present < 0) goto exception;
    h_present = JS_TryGetPropertyInt64(ctx, obj, h, &hval);
    if (h_present < 0) goto exception;
    if (h_present) {
      if (LEPUS_SetPropertyInt64(ctx, obj, l, hval) < 0) goto exception;

      if (l_present) {
        if (LEPUS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
          lval = LEPUS_UNDEFINED;
          goto exception;
        }
        lval = LEPUS_UNDEFINED;
      } else {
        if (JS_DeletePropertyInt64(ctx, obj, h, LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    } else {
      if (l_present) {
        if (JS_DeletePropertyInt64(ctx, obj, l, LEPUS_PROP_THROW) < 0)
          goto exception;
        if (LEPUS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
          lval = LEPUS_UNDEFINED;
          goto exception;
        }
        lval = LEPUS_UNDEFINED;
      }
    }
  }
  return obj;

exception:
  LEPUS_FreeValue(ctx, lval);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_slice(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int splice) {
  LEPUSValue obj, arr, val, len_val;
  int64_t len, start, k, final, n, count, del_count, new_len;
  int kPresent;
  LEPUSValue *arrp;
  uint32_t count32, i, item_count;

  arr = LEPUS_UNDEFINED;
  obj = JS_ToObject_expect_lepusref(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;

  if (splice) {
    if (argc == 0) {
      item_count = 0;
      del_count = 0;
    } else if (argc == 1) {
      item_count = 0;
      del_count = len - start;
    } else {
      item_count = argc - 2;
      if (JS_ToInt64Clamp(ctx, &del_count, argv[1], 0, len - start, 0))
        goto exception;
    }
    if (len + item_count - del_count > MAX_SAFE_INTEGER) {
      LEPUS_ThrowTypeError(ctx, "Array loo long");
      goto exception;
    }
    count = del_count;
  } else {
    item_count = 0; /* avoid warning */
    final = len;
    if (!LEPUS_IsUndefined(argv[1])) {
      if (JS_ToInt64Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
    }
    count = max_int64(final - start, 0);
  }

#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(obj)) {
    arr = ctx->rt->primjs_callbacks_.jsarray_slice(
        ctx, obj, start, count, item_count, argv + 2, splice);
    LEPUS_FreeValue(ctx, obj);
    return arr;
  }
#endif

  len_val = LEPUS_NewInt64(ctx, count);
  arr = JS_ArraySpeciesCreate(ctx, obj, len_val);
  LEPUS_FreeValue(ctx, len_val);
  if (LEPUS_IsException(arr)) goto exception;

  k = start;
  final = start + count;
  n = 0;
  /* The fast array test on arr ensures that
     JS_CreateDataPropertyUint32() won't modify obj in case arr is
     an exotic object */
  /* Special case fast arrays */
  if (js_get_fast_array(ctx, obj, &arrp, &count32) &&
      js_is_fast_array(ctx, arr)) {
    /* XXX: should share code with fast array constructor */
    for (; k < final && k < count32; k++, n++) {
      if (JS_CreateDataPropertyUint32(ctx, arr, n, LEPUS_DupValue(ctx, arrp[k]),
                                      LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  /* Copy the remaining elements if any (handle case of inherited properties) */
  for (; k < final; k++, n++) {
    kPresent = JS_TryGetPropertyInt64(ctx, obj, k, &val);
    if (kPresent < 0) goto exception;
    if (kPresent) {
      if (JS_CreateDataPropertyUint32(ctx, arr, n, val, LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  if (JS_SetPropertyInternal_RC(ctx, arr, JS_ATOM_length,
                                LEPUS_NewInt64(ctx, n), LEPUS_PROP_THROW) < 0)
    goto exception;

  if (splice) {
    new_len = len + item_count - del_count;
    if (item_count != del_count) {
      if (JS_CopySubArray(ctx, obj, start + item_count, start + del_count,
                          len - (start + del_count),
                          item_count <= del_count ? +1 : -1) < 0)
        goto exception;

      for (k = len; k-- > new_len;) {
        if (JS_DeletePropertyInt64(ctx, obj, k, LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
    for (i = 0; i < item_count; i++) {
      int j = i;
      if (LEPUS_SetPropertyInt64(ctx, obj, start + i,
                                 LEPUS_DupValue(ctx, argv[j + 2])) < 0)
        goto exception;
    }
    if (JS_SetPropertyInternal_RC(ctx, obj, JS_ATOM_length,
                                  LEPUS_NewInt64(ctx, new_len),
                                  LEPUS_PROP_THROW) < 0)
      goto exception;
  }
  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_copyWithin(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue obj;
  int64_t len, from, to, final, count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  if (JS_ToInt64Clamp(ctx, &to, argv[0], 0, len, len)) goto exception;

  if (JS_ToInt64Clamp(ctx, &from, argv[1], 0, len, len)) goto exception;

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (JS_ToInt64Clamp(ctx, &final, argv[2], 0, len, len)) goto exception;
  }

  count = min_int64(final - from, len - to);

  if (JS_CopySubArray(ctx, obj, to, from, count,
                      (from < to && to < from + count) ? -1 : +1))
    goto exception;

  return obj;

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int64_t JS_FlattenIntoArray(
    LEPUSContext *ctx, LEPUSValueConst target, LEPUSValueConst source,
    int64_t sourceLen, int64_t targetIndex, int depth,
    LEPUSValueConst mapperFunction, LEPUSValueConst thisArg) {
  LEPUSValue element;
  int64_t sourceIndex, elementLen;
  int present, is_array;

  for (sourceIndex = 0; sourceIndex < sourceLen; sourceIndex++) {
    present = JS_TryGetPropertyInt64(ctx, source, sourceIndex, &element);
    if (present < 0) return -1;
    if (!present) continue;
    if (!LEPUS_IsUndefined(mapperFunction)) {
      LEPUSValueConst args[3] = {element, LEPUS_NewInt64(ctx, sourceIndex),
                                 source};
      element = JS_Call_RC(ctx, mapperFunction, thisArg, 3, args);
      LEPUS_FreeValue(ctx, (LEPUSValue)args[0]);
      LEPUS_FreeValue(ctx, (LEPUSValue)args[1]);
      if (LEPUS_IsException(element)) return -1;
    }
    if (depth > 0) {
      is_array = LEPUS_IsArray(ctx, element);
      if (is_array < 0) goto fail;
      if (is_array) {
        if (js_get_length64(ctx, &elementLen, element) < 0) goto fail;
        targetIndex =
            JS_FlattenIntoArray(ctx, target, element, elementLen, targetIndex,
                                depth - 1, LEPUS_UNDEFINED, LEPUS_UNDEFINED);
        if (targetIndex < 0) goto fail;
        LEPUS_FreeValue(ctx, element);
        continue;
      }
    }
    if (targetIndex >= MAX_SAFE_INTEGER) {
      LEPUS_ThrowTypeError(ctx, "Array too long");
      goto fail;
    }
    if (JS_DefinePropertyValueInt64(ctx, target, targetIndex, element,
                                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
      return -1;
    targetIndex++;
  }
  return targetIndex;

fail:
  LEPUS_FreeValue(ctx, element);
  return -1;
}

QJS_STATIC LEPUSValue js_array_flatten(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int map) {
  LEPUSValue obj, arr;
  LEPUSValueConst mapperFunction, thisArg;
  int64_t sourceLen;
  int depthNum;

  arr = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &sourceLen, obj)) goto exception;

  depthNum = 1;
  mapperFunction = LEPUS_UNDEFINED;
  thisArg = LEPUS_UNDEFINED;
  if (map) {
    mapperFunction = argv[0];
    if (argc > 1) {
      thisArg = argv[1];
    }
    if (check_function(ctx, mapperFunction)) goto exception;
  } else {
    if (argc > 0 && !LEPUS_IsUndefined(argv[0])) {
      if (JS_ToInt32Sat(ctx, &depthNum, argv[0]) < 0) goto exception;
    }
  }
  arr = JS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
  if (LEPUS_IsException(arr)) goto exception;
  if (JS_FlattenIntoArray(ctx, arr, obj, sourceLen, 0, depthNum, mapperFunction,
                          thisArg) < 0)
    goto exception;
  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

/* Array sort */
QJS_STATIC int js_array_cmp_generic(const void *a, const void *b,
                                    void *opaque) {
  struct array_sort_context *psc =
      static_cast<struct array_sort_context *>(opaque);
  LEPUSContext *ctx = psc->ctx;
  LEPUSValueConst argv[2];
  LEPUSValue res;
  ValueSlot *ap = (ValueSlot *)(void *)a;
  ValueSlot *bp = (ValueSlot *)(void *)b;
  int cmp;

  if (psc->exception) return 0;

  if (psc->has_method) {
    /* custom sort function is specified as returning 0 for identical
     * objects: avoid method call overhead.
     */
    if (!memcmp(&ap->val, &bp->val, sizeof(ap->val))) goto cmp_same;
    argv[0] = ap->val;
    argv[1] = bp->val;
    res = JS_Call_RC(ctx, psc->method, LEPUS_UNDEFINED, 2, argv);
    if (LEPUS_IsException(res)) goto exception;
    if (LEPUS_VALUE_IS_INT(res)) {
      int val = LEPUS_VALUE_GET_INT(res);
      cmp = (val > 0) - (val < 0);
    } else {
      double val;
      if (JS_ToFloat64Free(ctx, &val, res) < 0) goto exception;
      cmp = (val > 0) - (val < 0);
    }
  } else {
    /* Not supposed to bypass ToString even for identical objects as
     * tested in test262/test/built-ins/Array/prototype/sort/bug_596_1.lepus
     */
    if (!ap->str) {
      LEPUSValue str = JS_ToString_RC(ctx, ap->val);
      if (LEPUS_IsException(str)) goto exception;
      ap->str = LEPUS_VALUE_GET_STRING(str);
    }
    if (!bp->str) {
      LEPUSValue str = JS_ToString_RC(ctx, bp->val);
      if (LEPUS_IsException(str)) goto exception;
      bp->str = LEPUS_VALUE_GET_STRING(str);
    }
    cmp = js_string_compare(ctx, ap->str, bp->str);
  }
  if (cmp != 0) return cmp;
cmp_same:
  /* make sort stable: compare array offsets */
  return (ap->pos > bp->pos) - (ap->pos < bp->pos);

exception:
  psc->exception = 1;
  return 0;
}

QJS_STATIC LEPUSValue js_array_sort(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  struct array_sort_context asc = {ctx, 0, 0, argv[0]};
  LEPUSValue obj = LEPUS_UNDEFINED;
  ValueSlot *array = NULL;
  size_t array_size = 0, pos = 0, n = 0;
  int64_t i, len, undefined_count = 0;
  int present;

  if (!LEPUS_IsUndefined(asc.method)) {
    if (check_function(ctx, asc.method)) goto exception;
    asc.has_method = 1;
  }
  obj = LEPUS_ToObject(ctx, this_val);
  if (js_get_length64(ctx, &len, obj)) goto exception;

  /* XXX: should special case fast arrays */
  for (i = 0; i < len; i++) {
    if (pos >= array_size) {
      size_t new_size, slack;
      ValueSlot *new_array;
      new_size = (array_size + (array_size >> 1) + 31) & ~15;
      new_array = static_cast<ValueSlot *>(
          lepus_realloc2(ctx, array, new_size * sizeof(*array), &slack));
      if (new_array == NULL) goto exception;
      new_size += slack / sizeof(*new_array);
      array = new_array;
      array_size = new_size;
    }
    present = JS_TryGetPropertyInt64(ctx, obj, i, &array[pos].val);
    if (present < 0) goto exception;
    if (present == 0) continue;
    if (LEPUS_IsUndefined(array[pos].val)) {
      undefined_count++;
      continue;
    }
    array[pos].str = NULL;
    array[pos].pos = i;
    pos++;
  }
  rqsort(array, pos, sizeof(*array), js_array_cmp_generic, &asc);
  if (asc.exception) goto exception;

  /* XXX: should special case fast arrays */
  while (n < pos) {
    if (array[n].str)
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, array[n].str));
    if (array[n].pos == n) {
      LEPUS_FreeValue(ctx, array[n].val);
    } else {
      if (LEPUS_SetPropertyInt64(ctx, obj, n, array[n].val) < 0) {
        n++;
        goto exception;
      }
    }
    n++;
  }
  lepus_free(ctx, array);
  for (i = n; undefined_count-- > 0; i++) {
    if (LEPUS_SetPropertyInt64(ctx, obj, i, LEPUS_UNDEFINED) < 0) goto fail;
  }
  for (; i < len; i++) {
    if (JS_DeletePropertyInt64(ctx, obj, i, LEPUS_PROP_THROW) < 0) goto fail;
  }
  return obj;

exception:
  for (; n < pos; n++) {
    LEPUS_FreeValue(ctx, array[n].val);
    if (array[n].str)
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, array[n].str));
  }
  lepus_free(ctx, array);
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

typedef struct JSArrayIteratorData {
  LEPUSValue obj;
  JSIteratorKindEnum kind;
  uint32_t idx;
} JSArrayIteratorData;

QJS_STATIC void js_array_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSArrayIteratorData *it = p->u.array_iterator_data;
  if (it) {
    LEPUS_FreeValueRT(rt, it->obj);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void js_array_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func,
                                       int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSArrayIteratorData *it = p->u.array_iterator_data;
  if (it) {
    JS_MarkValue_RC(rt, it->obj, mark_func);
  }
}

QJS_STATIC LEPUSValue js_create_array(LEPUSContext *ctx, int len,
                                      LEPUSValueConst *tab) {
  LEPUSValue obj;
  int i;

  obj = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  for (i = 0; i < len; i++) {
    if (JS_CreateDataPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, tab[i]),
                                    0) < 0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue js_create_array_iterator(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int magic) {
  LEPUSValue enum_obj, arr;
  JSArrayIteratorData *it;
  JSIteratorKindEnum kind;
  int class_id;

  kind = static_cast<JSIteratorKindEnum>(magic & 3);
  if (magic & 4) {
    /* string iterator case */
    arr = JS_ToStringCheckObject(ctx, this_val);
    class_id = JS_CLASS_STRING_ITERATOR;
  } else {
    arr = JS_ToObject_expect_lepusref(ctx, this_val);
    class_id = JS_CLASS_ARRAY_ITERATOR;
  }
  if (LEPUS_IsException(arr)) goto fail;
  enum_obj = LEPUS_NewObjectClass(ctx, class_id);
  if (LEPUS_IsException(enum_obj)) goto fail;
  it = static_cast<JSArrayIteratorData *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) goto fail1;
  it->obj = arr;
  it->kind = kind;
  it->idx = 0;
  LEPUS_SetOpaque(enum_obj, it);
  return enum_obj;
fail1:
  LEPUS_FreeValue(ctx, enum_obj);
fail:
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_array_iterator_next(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv, BOOL *pdone,
                                             int magic) {
  JSArrayIteratorData *it;
  uint32_t len, idx;
  LEPUSValue val, obj;
  LEPUSObject *p;

  it = static_cast<JSArrayIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_ARRAY_ITERATOR));
  if (!it) goto fail1;
  if (LEPUS_IsUndefined(it->obj)) goto done;

#ifdef ENABLE_LEPUSNG
  if (LEPUS_VALUE_IS_LEPUS_REF(it->obj)) {
    len = ctx->rt->js_callbacks_.get_length(ctx, it->obj);
  } else {
#endif

    p = LEPUS_VALUE_GET_OBJ(it->obj);
    if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
        p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
      if (typed_array_is_detached(ctx, p)) {
        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        goto fail1;
      }
      len = p->u.array.count;
    } else {
      if (lepus_get_length32(ctx, &len, it->obj)) {
      fail1:
        *pdone = FALSE;
        return LEPUS_EXCEPTION;
      }
    }

#ifdef ENABLE_LEPUSNG
  }
#endif

  idx = it->idx;
  if (idx >= len) {
    LEPUS_FreeValue(ctx, it->obj);
    it->obj = LEPUS_UNDEFINED;
  done:
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }
  it->idx = idx + 1;
  *pdone = FALSE;
  if (it->kind == JS_ITERATOR_KIND_KEY) {
    return JS_NewUint32(ctx, idx);
  } else {
    val = LEPUS_GetPropertyUint32(ctx, it->obj, idx);
    if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
    if (it->kind == JS_ITERATOR_KIND_VALUE) {
      return val;
    } else {
      LEPUSValueConst args[2];
      LEPUSValue num;
      num = JS_NewUint32(ctx, idx);
      args[0] = num;
      args[1] = val;
      obj = js_create_array(ctx, 2, args);
      LEPUS_FreeValue(ctx, val);
      LEPUS_FreeValue(ctx, num);
      return obj;
    }
  }
}

QJS_STATIC LEPUSValue js_iterator_proto_iterator(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  return LEPUS_DupValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry js_iterator_proto_funcs[] = {
    LEPUS_CFUNC_DEF("[Symbol.iterator]", 0, js_iterator_proto_iterator),
};

static const LEPUSCFunctionListEntry js_array_proto_funcs[] = {
    LEPUS_CFUNC_DEF("concat", 1, js_array_concat),
    LEPUS_CFUNC_MAGIC_DEF("every", 1, js_array_every, special_every),
    LEPUS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, js_array_every, special_forEach),
    LEPUS_CFUNC_MAGIC_DEF("map", 1, js_array_every, special_map),
    LEPUS_CFUNC_MAGIC_DEF("filter", 1, js_array_every, special_filter),
    LEPUS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce, special_reduce),
    LEPUS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce,
                          special_reduceRight),
    LEPUS_CFUNC_DEF("fill", 1, js_array_fill),
    LEPUS_CFUNC_MAGIC_DEF("find", 1, js_array_find, 0),
    LEPUS_CFUNC_MAGIC_DEF("findIndex", 1, js_array_find, 1),
    LEPUS_CFUNC_DEF("indexOf", 1, js_array_indexOf),
    LEPUS_CFUNC_DEF("lastIndexOf", 1, js_array_lastIndexOf),
    LEPUS_CFUNC_DEF("includes", 1, js_array_includes),
    LEPUS_CFUNC_MAGIC_DEF("join", 1, js_array_join, 0),
    LEPUS_CFUNC_DEF("toString", 0, js_array_toString),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_array_join, 1),
    LEPUS_CFUNC_MAGIC_DEF("pop", 0, js_array_pop, 0),
    LEPUS_CFUNC_MAGIC_DEF("push", 1, js_array_push, 0),
    LEPUS_CFUNC_MAGIC_DEF("shift", 0, js_array_pop, 1),
    LEPUS_CFUNC_MAGIC_DEF("unshift", 1, js_array_push, 1),
    LEPUS_CFUNC_DEF("reverse", 0, js_array_reverse),
    LEPUS_CFUNC_DEF("sort", 1, js_array_sort),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, js_array_slice, 0),
    LEPUS_CFUNC_MAGIC_DEF("splice", 2, js_array_slice, 1),
    LEPUS_CFUNC_DEF("copyWithin", 2, js_array_copyWithin),
    LEPUS_CFUNC_MAGIC_DEF("flatMap", 1, js_array_flatten, 1),
    LEPUS_CFUNC_MAGIC_DEF("flat", 0, js_array_flatten, 0),
    LEPUS_CFUNC_MAGIC_DEF("flatten", 0, js_array_flatten, 0),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, js_create_array_iterator,
                          JS_ITERATOR_KIND_VALUE),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, js_create_array_iterator,
                          JS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, js_create_array_iterator,
                          JS_ITERATOR_KIND_KEY_AND_VALUE),
};

static const LEPUSCFunctionListEntry js_array_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, js_array_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Array Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

/* Number */

QJS_STATIC LEPUSValue js_number_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv) {
  LEPUSValue val, obj;
#ifdef CONFIG_BIGNUM
  if (argc == 0) {
    if (is_bignum_mode(ctx))
      val = __JS_NewFloat64(ctx, 0);
    else
      val = LEPUS_NewInt32(ctx, 0);
  } else {
    val = JS_ToNumeric(ctx, argv[0]);
    if (LEPUS_IsException(val)) return val;
    switch (LEPUS_VALUE_GET_TAG(val)) {
      case LEPUS_TAG_BIG_INT:
      case LEPUS_TAG_BIG_FLOAT: {
        JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
        double d;
        bf_get_float64(&p->num, &d, BF_RNDN);
        LEPUS_FreeValue(ctx, val);
        val = __JS_NewFloat64(ctx, d);
      } break;
      case LEPUS_TAG_INT:
        if (is_bignum_mode(ctx)) {
          /* always return a number in bignum mode */
          val = __JS_NewFloat64(ctx, LEPUS_VALUE_GET_INT(val));
        }
        break;
      default:
        break;
    }
  }
#else
  if (argc == 0) {
    val = LEPUS_NewInt32(ctx, 0);
  } else {
    val = JS_ToNumber(ctx, argv[0]);
    if (LEPUS_IsException(val)) return val;
  }
#endif
  if (!LEPUS_IsUndefined(new_target)) {
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_NUMBER);
    if (!LEPUS_IsException(obj)) JS_SetObjectData(ctx, obj, val);
    return obj;
  } else {
    return val;
  }
}

#if 0
static LEPUSValue js_number___toInteger(LEPUSContext *ctx, LEPUSValueConst this_val,
                                     int argc, LEPUSValueConst *argv)
{
    return JS_ToIntegerFree(ctx, LEPUS_DupValue(ctx, argv[0]));
}

static LEPUSValue js_number___toLength(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    int64_t v;
    if (JS_ToLengthFree(ctx, &v, LEPUS_DupValue(ctx, argv[0])))
        return LEPUS_EXCEPTION;
    return LEPUS_NewInt64(ctx, v);
}
#endif

QJS_STATIC LEPUSValue js_number_isNaN(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  /* XXX: should just check for float and big_float */
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  return js_global_isNaN(ctx, this_val, argc, argv);
}

QJS_STATIC LEPUSValue js_number_isFinite(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  return js_global_isFinite(ctx, this_val, argc, argv);
}

QJS_STATIC LEPUSValue js_number_isInteger(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  int ret;
  ret = JS_NumberIsInteger(ctx, argv[0]);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue js_number_isSafeInteger(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  double d;
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  return LEPUS_NewBool(
      ctx, isfinite(d) && floor(d) == d && fabs(d) <= (double)MAX_SAFE_INTEGER);
}

static LEPUSCFunctionListEntry js_number_funcs[] = {
    /* global ParseInt and parseFloat should be defined already or delayed */
    LEPUS_ALIAS_BASE_DEF("parseInt", "parseInt", 0),
    LEPUS_ALIAS_BASE_DEF("parseFloat", "parseFloat", 0),
    LEPUS_CFUNC_DEF("isNaN", 1, js_number_isNaN),
    LEPUS_CFUNC_DEF("isFinite", 1, js_number_isFinite),
    LEPUS_CFUNC_DEF("isInteger", 1, js_number_isInteger),
    LEPUS_CFUNC_DEF("isSafeInteger", 1, js_number_isSafeInteger),
    LEPUS_PROP_DOUBLE_DEF("MAX_VALUE", 1.7976931348623157e+308, 0),
    LEPUS_PROP_DOUBLE_DEF("MIN_VALUE", 5e-324, 0),
    LEPUS_PROP_DOUBLE_DEF("NaN", LEPUS_FLOAT64_NAN, 0),
    LEPUS_PROP_DOUBLE_DEF("NEGATIVE_INFINITY", -INFINITY, 0),
    LEPUS_PROP_DOUBLE_DEF("POSITIVE_INFINITY", INFINITY, 0),
    LEPUS_PROP_DOUBLE_DEF("EPSILON", 2.220446049250313e-16, 0),        /* ES6 */
    LEPUS_PROP_DOUBLE_DEF("MAX_SAFE_INTEGER", 9007199254740991.0, 0),  /* ES6 */
    LEPUS_PROP_DOUBLE_DEF("MIN_SAFE_INTEGER", -9007199254740991.0, 0), /* ES6 */
    // LEPUS_CFUNC_DEF("__toInteger", 1, js_number___toInteger ),
    // LEPUS_CFUNC_DEF("__toLength", 1, js_number___toLength ),
};

QJS_STATIC LEPUSValue js_thisNumberValue(LEPUSContext *ctx,
                                         LEPUSValueConst this_val) {
  if (LEPUS_IsNumber(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_NUMBER) {
      if (LEPUS_IsNumber(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a number");
}

QJS_STATIC LEPUSValue js_number_valueOf(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return js_thisNumberValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_number_toString(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic) {
  LEPUSValue val;
  int base;

  val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (magic || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (JS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
#ifdef CONFIG_BIGNUM
  {
    LEPUSValue ret =
        js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
    LEPUS_FreeValue(ctx, val);
    return ret;
  }
#else
  {
    double d;
    if (JS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
    return js_dtoa(ctx, d, base, 0, JS_DTOA_VAR_FORMAT);
  }
#endif
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

#ifdef CONFIG_BIGNUM

static LEPUSValue js_thisBigFloatValue(LEPUSContext *ctx,
                                       LEPUSValueConst this_val);

static int64_t js_number_get_prec_max(LEPUSContext *ctx, int magic) {
  if (magic)
    return BF_PREC_MAX;
  else
    return 100;
}

static int get_rnd_mode(LEPUSContext *ctx, LEPUSValueConst val) {
  int rnd_mode;
  if (JS_ToInt32Sat(ctx, &rnd_mode, val)) return -1;
  if (rnd_mode < BF_RNDN || rnd_mode > BF_RNDF) {
    LEPUS_ThrowRangeError(ctx, "invalid rounding mode");
    return -1;
  }
  return rnd_mode;
}

static LEPUSValue js_number_toFixed(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  LEPUSValue val, ret;
  int64_t f;
  int res, rnd_mode;
  bf_t a_s, *a, b;
  BOOL is_float;

  if (magic)
    val = js_thisBigFloatValue(ctx, this_val);
  else
    val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (JS_ToInt64Sat(ctx, &f, argv[0])) goto fail;
  if (f < 0 || f > js_number_get_prec_max(ctx, magic)) {
    LEPUS_ThrowRangeError(ctx, "invalid number of digits");
    goto fail;
  }
  rnd_mode = BF_RNDNA;
  if (magic && argc > 1) {
    rnd_mode = get_rnd_mode(ctx, argv[1]);
    if (rnd_mode < 0) goto fail;
  }

  a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
  if (!a) goto fail;
  bf_init(ctx->bf_ctx, &b);
  bf_set_float64(&b, 1e21);
  res = bf_cmpu(a, &b);
  bf_delete(&b);
  if (a == &a_s) bf_delete(a);
  if (res >= 0) {
    ret = JS_ToString_RC(ctx, val);
  } else {
    ret = js_ftoa(ctx, val, 10, f, rnd_mode | BF_FTOA_FORMAT_FRAC);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue js_number_toExponential(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv, int magic) {
  LEPUSValue val, ret;
  int64_t f;
  int rnd_mode;

  if (magic)
    val = js_thisBigFloatValue(ctx, this_val);
  else
    val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (JS_ToInt64Sat(ctx, &f, argv[0])) goto fail;
  if (!js_number_is_finite(ctx, val)) {
    ret = JS_ToString_RC(ctx, val);
  } else if (LEPUS_IsUndefined(argv[0])) {
    ret = js_ftoa(ctx, val, 10, 0,
                  BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);
  } else {
    if (f < 0 || f > js_number_get_prec_max(ctx, magic)) {
      LEPUS_ThrowRangeError(ctx, "invalid number of digits");
      goto fail;
    }
    rnd_mode = BF_RNDNA;
    if (magic && argc > 1) {
      rnd_mode = get_rnd_mode(ctx, argv[1]);
      if (rnd_mode < 0) goto fail;
    }
    ret = js_ftoa(ctx, val, 10, f + 1,
                  rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue js_number_toPrecision(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int magic) {
  LEPUSValue val, ret;
  int64_t p;
  int rnd_mode;

  if (magic)
    val = js_thisBigFloatValue(ctx, this_val);
  else
    val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_IsUndefined(argv[0])) goto to_string;
  if (JS_ToInt64Sat(ctx, &p, argv[0])) goto fail;
  if (!js_number_is_finite(ctx, val)) {
  to_string:
    ret = JS_ToString_RC(ctx, this_val);
  } else {
    if (p < 1 || p > js_number_get_prec_max(ctx, magic)) {
      LEPUS_ThrowRangeError(ctx, "invalid number of digits");
      goto fail;
    }
    rnd_mode = BF_RNDNA;
    if (magic && argc > 1) {
      rnd_mode = get_rnd_mode(ctx, argv[1]);
      if (rnd_mode < 0) goto fail;
    }
    ret = js_ftoa(ctx, val, 10, p, rnd_mode | BF_FTOA_FORMAT_FIXED);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry js_number_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("toExponential", 1, js_number_toExponential, 0),
    LEPUS_CFUNC_MAGIC_DEF("toFixed", 1, js_number_toFixed, 0),
    LEPUS_CFUNC_MAGIC_DEF("toPrecision", 1, js_number_toPrecision, 0),
    LEPUS_CFUNC_MAGIC_DEF("toString", 1, js_number_toString, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_number_toString, 1),
    LEPUS_CFUNC_DEF("valueOf", 0, js_number_valueOf),
};

#else /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue js_number_toFixed(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue val;
  int f;
  double d;

  val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (JS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (JS_ToInt32Sat(ctx, &f, argv[0])) return LEPUS_EXCEPTION;
  if (f < 0 || f > 100)
    return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
  if (fabs(d) >= 1e21) {
    return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  } else {
    return js_dtoa(ctx, d, 10, f, JS_DTOA_FRAC_FORMAT);
  }
}

QJS_STATIC LEPUSValue js_number_toExponential(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue val;
  int f, flags;
  double d;

  val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (JS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (JS_ToInt32Sat(ctx, &f, argv[0])) return LEPUS_EXCEPTION;
  if (!isfinite(d)) {
    return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  }
  if (LEPUS_IsUndefined(argv[0])) {
    flags = 0;
    f = 0;
  } else {
    if (f < 0 || f > 100)
      return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
    f++;
    flags = JS_DTOA_FIXED_FORMAT;
  }
  return js_dtoa(ctx, d, 10, f, flags | JS_DTOA_FORCE_EXP);
}

QJS_STATIC LEPUSValue js_number_toPrecision(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue val;
  int p;
  double d;

  val = js_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (JS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(argv[0])) goto to_string;
  if (JS_ToInt32Sat(ctx, &p, argv[0])) return LEPUS_EXCEPTION;
  if (!isfinite(d)) {
  to_string:
    return JS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  }
  if (p < 1 || p > 100)
    return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
  return js_dtoa(ctx, d, 10, p, JS_DTOA_FIXED_FORMAT);
}

static const LEPUSCFunctionListEntry js_number_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toExponential", 1, js_number_toExponential),
    LEPUS_CFUNC_DEF("toFixed", 1, js_number_toFixed),
    LEPUS_CFUNC_DEF("toPrecision", 1, js_number_toPrecision),
    LEPUS_CFUNC_MAGIC_DEF("toString", 1, js_number_toString, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_number_toString, 1),
    LEPUS_CFUNC_DEF("valueOf", 0, js_number_valueOf),
};

#endif /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue js_parseInt(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  const char *str;
  int radix;
  LEPUSValue ret;

  str = JS_ToCStringLen2_RC(ctx, NULL, argv[0], 0);
  if (!str) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &radix, argv[1])) {
    LEPUS_FreeCString(ctx, str);
    return LEPUS_EXCEPTION;
  }
  if (radix != 0 && (radix < 2 || radix > 36)) {
    ret = LEPUS_NAN;
  } else {
#ifdef CONFIG_BIGNUM
    int flags;
    flags = BF_ATOF_INT_ONLY | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64;
    if (is_bignum_mode(ctx)) flags |= BF_ATOF_INT_PREC_INF;
    ret = js_atof(ctx, str, NULL, radix, flags);
#else
    ret = js_atod(ctx, str, NULL, radix, ATOD_INT_ONLY | ATOD_NAN_IF_EMPTY);
#endif
  }
  LEPUS_FreeCString(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue js_parseFloat(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  const char *str;
  LEPUSValue ret;

  str = JS_ToCStringLen2_RC(ctx, NULL, argv[0], 0);
  if (!str) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  ret = js_atof(ctx, str, NULL, 10,
                BF_ATOF_JS_QUIRKS | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64);
#else
  ret = js_atod(ctx, str, NULL, 10, ATOD_NAN_IF_EMPTY);
#endif
  LEPUS_FreeCString(ctx, str);
  return ret;
}

/* Boolean */
QJS_STATIC LEPUSValue js_boolean_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst new_target,
                                             int argc, LEPUSValueConst *argv) {
  LEPUSValue val, obj;
  val = LEPUS_NewBool(ctx, LEPUS_ToBool(ctx, argv[0]));
  if (!LEPUS_IsUndefined(new_target)) {
    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_BOOLEAN);
    if (!LEPUS_IsException(obj)) JS_SetObjectData(ctx, obj, val);
    return obj;
  } else {
    return val;
  }
}

QJS_STATIC LEPUSValue js_thisBooleanValue(LEPUSContext *ctx,
                                          LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_BOOL(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_BOOLEAN) {
      if (LEPUS_VALUE_IS_BOOL(p->u.object_data)) return p->u.object_data;
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a boolean");
}

QJS_STATIC LEPUSValue js_boolean_toString(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue val = js_thisBooleanValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  return LEPUS_AtomToString(
      ctx, LEPUS_VALUE_GET_BOOL(val) ? JS_ATOM_true : JS_ATOM_false);
}

QJS_STATIC LEPUSValue js_boolean_valueOf(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  return js_thisBooleanValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry js_boolean_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_boolean_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_boolean_valueOf),
};

/* String */

QJS_STATIC int js_string_get_own_property(LEPUSContext *ctx,
                                          LEPUSPropertyDescriptor *desc,
                                          LEPUSValueConst obj, JSAtom prop) {
  LEPUSObject *p;
  JSString *p1;
  uint32_t idx, ch;

  /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
  if (__JS_AtomIsTaggedInt(prop)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    auto &data = p->u.object_data;
    if (JS_IsSeparableString(data)) {
      auto content = JS_GetSeparableStringContent(ctx, data);
      LEPUS_FreeValue(ctx, data);
      data = content;  // set on p->u.object_data
    }

    if (LEPUS_VALUE_IS_STRING(p->u.object_data)) {
      p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
      idx = __JS_AtomToUInt32(prop);
      if (idx < p1->len) {
        if (desc) {
          if (p1->is_wide_char)
            ch = p1->u.str16[idx];
          else
            ch = p1->u.str8[idx];
          desc->flags = LEPUS_PROP_ENUMERABLE;
          desc->value = js_new_string_char(ctx, ch);
          desc->getter = LEPUS_UNDEFINED;
          desc->setter = LEPUS_UNDEFINED;
        }
        return TRUE;
      }
    }
  }
  return FALSE;
}

QJS_STATIC uint32_t js_string_obj_get_length(LEPUSContext *ctx,
                                             LEPUSValueConst obj) {
  LEPUSObject *p;
  JSString *p1;
  uint32_t len = 0;

  /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_VALUE_IS_STRING(p->u.object_data)) {
    p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
    len = p1->len;
  } else if (JS_IsSeparableString(p->u.object_data)) {
    len = JS_GetSeparableString(p->u.object_data)->len;
  }
  return len;
}

QJS_STATIC int js_string_get_own_property_names(LEPUSContext *ctx,
                                                LEPUSPropertyEnum **ptab,
                                                uint32_t *plen,
                                                LEPUSValueConst obj) {
  LEPUSPropertyEnum *tab;
  uint32_t len, i;

  len = js_string_obj_get_length(ctx, obj);
  tab = NULL;
  if (len > 0) {
    /* do not allocate 0 bytes */
    tab = static_cast<LEPUSPropertyEnum *>(
        lepus_malloc(ctx, sizeof(LEPUSPropertyEnum) * len));
    if (!tab) return -1;
    for (i = 0; i < len; i++) {
      tab[i].atom = __JS_AtomFromUInt32(i);
    }
  }
  *ptab = tab;
  *plen = len;
  return 0;
}

QJS_STATIC int js_string_define_own_property(LEPUSContext *ctx,
                                             LEPUSValueConst this_obj,
                                             JSAtom prop, LEPUSValueConst val,
                                             LEPUSValueConst getter,
                                             LEPUSValueConst setter,
                                             int flags) {
  uint32_t idx;
  LEPUSObject *p;
  JSString *p1, *p2;

  if (__JS_AtomIsTaggedInt(prop)) {
    idx = __JS_AtomToUInt32(prop);
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    auto &data = p->u.object_data;

    if (JS_IsSeparableString(data)) {
      auto content = JS_GetSeparableStringContent(ctx, data);
      LEPUS_FreeValue(ctx, data);
      data = content;
    }

    if (!LEPUS_VALUE_IS_STRING(p->u.object_data)) goto def;
    p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
    if (idx >= p1->len) goto def;
    if (!check_define_prop_flags(LEPUS_PROP_ENUMERABLE, flags)) goto fail;
    /* check that the same value is configured */
    if (flags & LEPUS_PROP_HAS_VALUE) {
      if (JS_IsSeparableString(val)) {
        val = JS_GetSeparableStringContentNotDup(ctx, val);
      }
      if (!LEPUS_VALUE_IS_STRING(val)) goto fail;
      p2 = LEPUS_VALUE_GET_STRING(val);
      if (p2->len != 1) goto fail;
      if (string_get(p1, idx) != string_get(p2, 0)) {
      fail:
        return JS_ThrowTypeErrorOrFalse(ctx, flags,
                                        "property is not configurable");
      }
    }
    return TRUE;
  } else {
  def:
    return JS_DefineProperty_RC(ctx, this_obj, prop, val, getter, setter,
                                flags | LEPUS_PROP_NO_EXOTIC);
  }
}

QJS_STATIC int js_string_delete_property(LEPUSContext *ctx, LEPUSValueConst obj,
                                         JSAtom prop) {
  uint32_t idx;

  if (__JS_AtomIsTaggedInt(prop)) {
    idx = __JS_AtomToUInt32(prop);
    if (idx < js_string_obj_get_length(ctx, obj)) {
      return FALSE;
    }
  }
  return TRUE;
}

QJS_STATIC LEPUSValue js_string_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv) {
  LEPUSValue val, obj;
  if (argc == 0) {
    val = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  } else {
    if (LEPUS_IsUndefined(new_target) && LEPUS_IsSymbol(argv[0])) {
      JSAtomStruct *p =
          static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(argv[0]));
      val = JS_ConcatString3(
          ctx, "Symbol(",
          LEPUS_AtomToString(ctx, js_get_atom_index(ctx->rt, p)), ")");
    } else {
      val = JS_ToString_RC(ctx, argv[0]);
    }
    if (LEPUS_IsException(val)) return val;
  }
  if (!LEPUS_IsUndefined(new_target)) {
    JSString *p1 = LEPUS_VALUE_GET_STRING(val);

    obj = js_create_from_ctor(ctx, new_target, JS_CLASS_STRING);
    if (!LEPUS_IsException(obj)) {
      JS_SetObjectData(ctx, obj, val);
      JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_length,
                                LEPUS_NewInt32(ctx, p1->len), 0);
    }
    return obj;
  } else {
    return val;
  }
}

QJS_STATIC LEPUSValue js_thisStringValue(LEPUSContext *ctx,
                                         LEPUSValueConst this_val) {
  if (LEPUS_IsString(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_STRING) {
      if (LEPUS_IsString(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a string");
}

QJS_STATIC LEPUSValue js_string_fromCharCode(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  int i;
  StringBuffer b_s, *b = &b_s;

  string_buffer_init(ctx, b, argc);

  for (i = 0; i < argc; i++) {
    int32_t c;
    if (LEPUS_ToInt32(ctx, &c, argv[i]) ||
        string_buffer_putc16(b, c & 0xffff)) {
      string_buffer_free(b);
      return LEPUS_EXCEPTION;
    }
  }
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue js_string_fromCodePoint(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  double d;
  int i, c;
  StringBuffer b_s, *b = &b_s;

  /* XXX: could pre-compute string length if all arguments are LEPUS_TAG_INT */

  if (string_buffer_init(ctx, b, argc)) goto fail;
  for (i = 0; i < argc; i++) {
    if (LEPUS_VALUE_IS_INT(argv[i])) {
      c = LEPUS_VALUE_GET_INT(argv[i]);
      if (c < 0 || c > 0x10ffff) goto range_error;
    } else {
      if (LEPUS_ToFloat64(ctx, &d, argv[i])) goto fail;
      if (d < 0 || d > 0x10ffff || (c = (int)d) != d) goto range_error;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  return string_buffer_end(b);

range_error:
  LEPUS_ThrowRangeError(ctx, "invalid code point");
fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_raw(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  // raw(temp,...a)
  LEPUSValue cooked, val, raw;
  StringBuffer b_s, *b = &b_s;
  int64_t i, n;

  string_buffer_init(ctx, b, 0);
  raw = LEPUS_UNDEFINED;
  cooked = LEPUS_ToObject(ctx, argv[0]);
  if (LEPUS_IsException(cooked)) goto exception;
  raw = JS_ToObjectFree(
      ctx, JS_GetPropertyInternal_RC(ctx, cooked, JS_ATOM_raw, cooked, 0));
  if (LEPUS_IsException(raw)) goto exception;
  if (js_get_length64(ctx, &n, raw) < 0) goto exception;

  for (i = 0; i < n; i++) {
    val = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, raw, i));
    if (LEPUS_IsException(val)) goto exception;
    string_buffer_concat_value_free(b, val);
    if (i < n - 1 && i + 1 < argc) {
      if (string_buffer_concat_value(b, argv[i + 1])) goto exception;
    }
  }
  LEPUS_FreeValue(ctx, cooked);
  LEPUS_FreeValue(ctx, raw);
  return string_buffer_end(b);

exception:
  LEPUS_FreeValue(ctx, cooked);
  LEPUS_FreeValue(ctx, raw);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

#ifdef QJS_UNITTEST
/* only used in test262 */
LEPUSValue lepus_string_codePointRange(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  CallGCFunc(js_string_codePointRange_GC, ctx, this_val, argc, argv);
  uint32_t start, end, i, n;
  StringBuffer b_s, *b = &b_s;

  if (LEPUS_ToUint32(ctx, &start, argv[0]) ||
      LEPUS_ToUint32(ctx, &end, argv[1]))
    return LEPUS_EXCEPTION;
  end = min_uint32(end, 0x10ffff + 1);

  if (start > end) {
    start = end;
  }
  n = end - start;
  if (end > 0x10000) {
    n += end - max_uint32(start, 0x10000);
  }
  if (string_buffer_init2(ctx, b, n, end >= 0x100)) return LEPUS_EXCEPTION;
  for (i = start; i < end; i++) {
    string_buffer_putc(b, i);
  }
  return string_buffer_end(b);
}

/* only used in test262 */
LEPUSValue lepus_gc(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                    LEPUSValueConst *argv) {
  if (!ctx->gc_enable) LEPUS_RunGC(ctx->rt);
  return LEPUS_UNDEFINED;
}
#endif
#if 0
static LEPUSValue js_string___isSpace(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv)
{
    int c;
    if (LEPUS_ToInt32(ctx, &c, argv[0]))
        return LEPUS_EXCEPTION;
    return LEPUS_NewBool(ctx, lre_is_space(c));
}
#endif

QJS_STATIC LEPUSValue js_string_charCodeAt(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  JSString *p;
  int idx, c;

  val = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = LEPUS_NAN;
  } else {
    if (p->is_wide_char)
      c = p->u.str16[idx];
    else
      c = p->u.str8[idx];
    ret = LEPUS_NewInt32(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue js_string_charAt(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  JSString *p;
  int idx, c;

  val = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = js_new_string8(ctx, NULL, 0);
  } else {
    if (p->is_wide_char)
      c = p->u.str16[idx];
    else
      c = p->u.str8[idx];
    ret = js_new_string_char(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue js_string_codePointAt(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  JSString *p;
  int idx, c;

  val = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (JS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = LEPUS_UNDEFINED;
  } else {
    c = string_getc(p, &idx);
    ret = LEPUS_NewInt32(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue js_string_concat(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue r;
  int i;

  /* XXX: Use more efficient method */
  /* XXX: This method is OK if r has a single refcount */
  /* XXX: should use string_buffer? */
  r = JS_ToStringCheckObject(ctx, this_val);
  for (i = 0; i < argc; i++) {
    if (LEPUS_IsException(r)) break;
    r = JS_ConcatString(ctx, r, LEPUS_DupValue(ctx, argv[i]));
  }
  return r;
}

QJS_STATIC int string_cmp(JSString *p1, JSString *p2, int x1, int x2, int len) {
  int i, c1, c2;
  for (i = 0; i < len; i++) {
    if ((c1 = string_get(p1, x1 + i)) != (c2 = string_get(p2, x2 + i)))
      return c1 - c2;
  }
  return 0;
}

QJS_STATIC int string_indexof_char(JSString *p, int c, int from) {
  /* assuming 0 <= from <= p->len */
  int i, len = p->len;
  if (p->is_wide_char) {
    for (i = from; i < len; i++) {
      if (p->u.str16[i] == c) return i;
    }
  } else {
    if ((c & ~0xff) == 0) {
      for (i = from; i < len; i++) {
        if (p->u.str8[i] == (uint8_t)c) return i;
      }
    }
  }
  return -1;
}

QJS_STATIC int string_indexof(JSString *p1, JSString *p2, int from) {
  /* assuming 0 <= from <= p1->len */
  int c, i, j, len1 = p1->len, len2 = p2->len;
  if (len2 == 0) return from;
  for (i = from, c = string_get(p2, 0); i + len2 <= len1; i = j + 1) {
    j = string_indexof_char(p1, c, i);
    if (j < 0 || j + len2 > len1) break;
    if (!string_cmp(p1, p2, j + 1, 1, len2 - 1)) return j;
  }
  return -1;
}

QJS_STATIC int string_advance_index(JSString *p, int index, BOOL unicode) {
  if (!unicode || (unsigned)index >= p->len || !p->is_wide_char) {
    index++;
  } else {
    string_getc(p, &index);
  }
  return index;
}

QJS_STATIC LEPUSValue js_string_indexOf(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv,
                                        int lastIndexOf) {
  LEPUSValue str, v;
  int i, len, v_len, pos, start, stop, ret, inc;
  JSString *p;
  JSString *p1;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  v = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(v)) goto fail;
  p = LEPUS_VALUE_GET_STRING(str);
  p1 = LEPUS_VALUE_GET_STRING(v);
  len = p->len;
  v_len = p1->len;
  if (lastIndexOf) {
    pos = len - v_len;
    if (argc > 1) {
      double d;
      if (LEPUS_ToFloat64(ctx, &d, argv[1])) goto fail;
      if (!isnan(d)) {
        if (d <= 0)
          pos = 0;
        else if (d < pos)
          pos = d;
      }
    }
    start = pos;
    stop = 0;
    inc = -1;
  } else {
    pos = 0;
    if (argc > 1) {
      if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0)) goto fail;
    }
    start = pos;
    stop = len - v_len;
    inc = 1;
  }
  ret = -1;
  if (len >= v_len && inc * (stop - start) >= 0) {
    for (i = start;; i += inc) {
      if (!string_cmp(p, p1, i, 0, v_len)) {
        ret = i;
        break;
      }
      if (i == stop) break;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_NewInt32(ctx, ret);

fail:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_EXCEPTION;
}

/* return < 0 if exception or TRUE/FALSE */
QJS_HIDE int js_is_regexp(LEPUSContext *ctx, LEPUSValueConst obj);

QJS_STATIC LEPUSValue js_string_includes(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic) {
  LEPUSValue str, v = LEPUS_UNDEFINED;
  int i, len, v_len, pos, start, stop, ret;
  JSString *p;
  JSString *p1;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  ret = js_is_regexp(ctx, argv[0]);
  if (ret) {
    if (ret > 0) LEPUS_ThrowTypeError(ctx, "regex not supported");
    goto fail;
  }
  v = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(v)) goto fail;
  p = LEPUS_VALUE_GET_STRING(str);
  p1 = LEPUS_VALUE_GET_STRING(v);
  len = p->len;
  v_len = p1->len;
  pos = (magic & 2) ? len : 0;
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0)) goto fail;
  }
  len -= v_len;
  start = pos;
  stop = len;
  if (magic & 1) {
    stop = pos;
  }
  if (magic & 2) {
    pos -= v_len;
    start = stop = pos;
  }
  ret = 0;
  if (start >= 0 && start <= stop) {
    for (i = start;; i++) {
      if (!string_cmp(p, p1, i, 0, v_len)) {
        ret = 1;
        break;
      }
      if (i == stop) break;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_NewBool(ctx, ret);

fail:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_match(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int atom) {
  // match(rx), search(rx), matchAll(rx)
  // atom is JS_ATOM_Symbol_match, JS_ATOM_Symbol_search, or
  // JS_ATOM_Symbol_matchAll
  LEPUSValueConst O = this_val, regexp = argv[0], args[2];
  LEPUSValue matcher, S, rx, result, str;
  int args_len;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  if (!LEPUS_IsUndefined(regexp) && !LEPUS_IsNull(regexp)) {
    matcher = JS_GetPropertyInternal_RC(ctx, regexp, atom, regexp, 0);
    if (LEPUS_IsException(matcher)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(matcher) && !LEPUS_IsNull(matcher)) {
      return JS_CallFree(ctx, matcher, regexp, 1, &O);
    }
  }
  S = JS_ToString_RC(ctx, O);
  if (LEPUS_IsException(S)) return LEPUS_EXCEPTION;
  args_len = 1;
  args[0] = regexp;
  str = LEPUS_UNDEFINED;
  if (atom == JS_ATOM_Symbol_matchAll) {
    str = LEPUS_NewString(ctx, "g");
    if (LEPUS_IsException(str)) goto fail;
    args[args_len++] = (LEPUSValueConst)str;
  }
  rx = LEPUS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
  LEPUS_FreeValue(ctx, str);
  if (LEPUS_IsException(rx)) {
  fail:
    LEPUS_FreeValue(ctx, S);
    return LEPUS_EXCEPTION;
  }
  result = JS_InvokeFree(ctx, rx, atom, 1, (LEPUSValueConst *)&S);
  LEPUS_FreeValue(ctx, S);
  return result;
}

QJS_STATIC LEPUSValue js_string___GetSubstitution(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  // GetSubstitution(matched, str, position, captures, namedCaptures, rep)
  LEPUSValueConst matched, str, captures, namedCaptures, rep;
  LEPUSValue capture, name, s;
  uint32_t position, len, matched_len, captures_len;
  int i, j, j0, k, k1;
  int c, c1;
  StringBuffer b_s, *b = &b_s;
  JSString *sp, *rp;

  matched = argv[0];
  str = argv[1];
  captures = argv[3];
  namedCaptures = argv[4];
  rep = argv[5];

  if (!LEPUS_IsString(rep) || !LEPUS_IsString(str))
    return LEPUS_ThrowTypeError(ctx, "not a string");

  sp = LEPUS_VALUE_GET_STRING(str);
  rp = LEPUS_VALUE_GET_STRING(rep);

  string_buffer_init(ctx, b, 0);

  captures_len = 0;
  if (!LEPUS_IsUndefined(captures)) {
    if (lepus_get_length32(ctx, &captures_len, captures)) goto exception;
  }
  if (lepus_get_length32(ctx, &matched_len, matched)) goto exception;
  if (LEPUS_ToUint32(ctx, &position, argv[2]) < 0) goto exception;

  len = rp->len;
  i = 0;
  for (;;) {
    j = string_indexof_char(rp, '$', i);
    if (j < 0 || j + 1 >= len) break;
    string_buffer_concat(b, rp, i, j);
    j0 = j++;
    c = string_get(rp, j++);
    if (c == '$') {
      string_buffer_putc8(b, '$');
    } else if (c == '&') {
      if (string_buffer_concat_value(b, matched)) goto exception;
    } else if (c == '`') {
      string_buffer_concat(b, sp, 0, position);
    } else if (c == '\'') {
      string_buffer_concat(b, sp, position + matched_len, sp->len);
    } else if (c >= '0' && c <= '9') {
      k = c - '0';
      c1 = string_get(rp, j);
      if (c1 >= '0' && c1 <= '9') {
        /* This behavior is specified in ES6 and refined in ECMA 2019 */
        /* ECMA 2019 does not have the extra test, but
           Test262 S15.5.4.11_A3_T1..3 require this behavior */
        k1 = k * 10 + c1 - '0';
        if (k1 >= 1 && k1 < captures_len) {
          k = k1;
          j++;
        }
      }
      if (k >= 1 && k < captures_len) {
        s = JS_GetPropertyInt64(ctx, captures, k);
        if (LEPUS_IsException(s)) goto exception;
        if (!LEPUS_IsUndefined(s)) {
          if (string_buffer_concat_value_free(b, s)) goto exception;
        }
      } else {
        goto norep;
      }
    } else if (c == '<' && !LEPUS_IsUndefined(namedCaptures)) {
      k = string_indexof_char(rp, '>', j);
      if (k < 0) goto norep;
      name = js_sub_string(ctx, rp, j, k);
      if (LEPUS_IsException(name)) goto exception;
      capture = JS_GetPropertyValue(ctx, namedCaptures, name);
      if (LEPUS_IsException(capture)) goto exception;
      if (!LEPUS_IsUndefined(capture)) {
        if (string_buffer_concat_value_free(b, capture)) goto exception;
      }
      j = k + 1;
    } else {
    norep:
      string_buffer_concat(b, rp, j0, j);
    }
    i = j;
  }
  string_buffer_concat(b, rp, i, rp->len);
  return string_buffer_end(b);
exception:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_replace(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  // replace(rx, rep)
  LEPUSValueConst O = this_val, searchValue = argv[0], replaceValue = argv[1];
  LEPUSValueConst args[6];
  LEPUSValue str, search_str, replaceValue_str, repl_str;
  JSString *sp, *searchp;
  StringBuffer b_s, *b = &b_s;
  int pos, functionalReplace;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  search_str = LEPUS_UNDEFINED;
  replaceValue_str = LEPUS_UNDEFINED;
  repl_str = LEPUS_UNDEFINED;

  if (!LEPUS_IsUndefined(searchValue) && !LEPUS_IsNull(searchValue)) {
    LEPUSValue replacer;
    replacer = JS_GetPropertyInternal_RC(
        ctx, searchValue, JS_ATOM_Symbol_replace, searchValue, 0);
    if (LEPUS_IsException(replacer)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(replacer) && !LEPUS_IsNull(replacer)) {
      args[0] = O;
      args[1] = replaceValue;
      return JS_CallFree(ctx, replacer, searchValue, 2, args);
    }
  }
  string_buffer_init(ctx, b, 0);

  str = JS_ToString_RC(ctx, O);
  if (LEPUS_IsException(str)) goto exception;
  search_str = JS_ToString_RC(ctx, searchValue);
  if (LEPUS_IsException(search_str)) goto exception;
  functionalReplace = LEPUS_IsFunction(ctx, replaceValue);
  if (!functionalReplace) {
    replaceValue_str = JS_ToString_RC(ctx, replaceValue);
    if (LEPUS_IsException(replaceValue_str)) goto exception;
  }

  sp = LEPUS_VALUE_GET_STRING(str);
  searchp = LEPUS_VALUE_GET_STRING(search_str);

  pos = string_indexof(sp, searchp, 0);
  if (pos < 0) {
    string_buffer_free(b);
    LEPUS_FreeValue(ctx, search_str);
    LEPUS_FreeValue(ctx, replaceValue_str);
    return str;
  }
  if (functionalReplace) {
    args[0] = search_str;
    args[1] = LEPUS_NewInt32(ctx, pos);
    args[2] = str;
    repl_str = JS_ToStringFree(
        ctx, JS_Call_RC(ctx, replaceValue, LEPUS_UNDEFINED, 3, args));
  } else {
    args[0] = search_str;
    args[1] = str;
    args[2] = LEPUS_NewInt32(ctx, pos);
    args[3] = LEPUS_UNDEFINED;
    args[4] = LEPUS_UNDEFINED;
    args[5] = replaceValue_str;
    repl_str = js_string___GetSubstitution(ctx, LEPUS_UNDEFINED, 6, args);
  }
  if (LEPUS_IsException(repl_str)) goto exception;

  string_buffer_concat(b, sp, 0, pos);
  string_buffer_concat_value_free(b, repl_str);
  string_buffer_concat(b, sp, pos + searchp->len, sp->len);
  LEPUS_FreeValue(ctx, search_str);
  LEPUS_FreeValue(ctx, replaceValue_str);
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

exception:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, search_str);
  LEPUS_FreeValue(ctx, replaceValue_str);
  LEPUS_FreeValue(ctx, str);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_split(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  // split(sep, limit)
  LEPUSValueConst O = this_val, separator = argv[0], limit = argv[1];
  LEPUSValueConst args[2];
  LEPUSValue S, A, R, T;
  uint32_t lim, lengthA;
  int64_t p, q, s, r, e;
  JSString *sp, *rp;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  S = LEPUS_UNDEFINED;
  A = LEPUS_UNDEFINED;
  R = LEPUS_UNDEFINED;

  if (!LEPUS_IsUndefined(separator) && !LEPUS_IsNull(separator)) {
    LEPUSValue splitter;
    splitter = JS_GetPropertyInternal_RC(ctx, separator, JS_ATOM_Symbol_split,
                                         separator, 0);
    if (LEPUS_IsException(splitter)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(splitter) && !LEPUS_IsNull(splitter)) {
      args[0] = O;
      args[1] = limit;
      return JS_CallFree(ctx, splitter, separator, 2, args);
    }
  }
  S = JS_ToString_RC(ctx, O);
  if (LEPUS_IsException(S)) goto exception;
  A = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(A)) goto exception;
  lengthA = 0;
  if (LEPUS_IsUndefined(limit)) {
    lim = 0xffffffff;
  } else {
    if (LEPUS_ToUint32(ctx, &lim, limit) < 0) goto exception;
  }
  sp = LEPUS_VALUE_GET_STRING(S);
  s = sp->len;
  R = JS_ToString_RC(ctx, separator);
  if (LEPUS_IsException(R)) goto exception;
  rp = LEPUS_VALUE_GET_STRING(R);
  r = rp->len;
  p = 0;
  if (lim == 0) goto done;
  if (LEPUS_IsUndefined(separator)) goto add_tail;
  if (s == 0) {
    if (r != 0) goto add_tail;
    goto done;
  }
  q = p;
  for (q = p; (q += !r) <= s - r - !r; q = p = e + r) {
    e = string_indexof(sp, rp, q);
    if (e < 0) break;
    T = js_sub_string(ctx, sp, p, e);
    if (LEPUS_IsException(T)) goto exception;
    if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0)
      goto exception;
    if (lengthA == lim) goto done;
  }
add_tail:
  T = js_sub_string(ctx, sp, p, s);
  if (LEPUS_IsException(T)) goto exception;
  if (JS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0) goto exception;
done:
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, R);
  return A;

exception:
  LEPUS_FreeValue(ctx, A);
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, R);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_substring(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int a, b, start, end;
  JSString *p;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, p->len, 0)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  b = p->len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &b, argv[1], 0, p->len, 0)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  if (a < b) {
    start = a;
    end = b;
  } else {
    start = b;
    end = a;
  }
  ret = js_sub_string(ctx, p, start, end);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue js_string_substr(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int a, len, n;
  JSString *p;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (JS_ToInt32Clamp(ctx, &a, argv[0], 0, len, len)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  n = len - a;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &n, argv[1], 0, len - a, 0)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  ret = js_sub_string(ctx, p, a, a + n);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue js_string_slice(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int len, start, end;
  JSString *p;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  end = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &end, argv[1], 0, len, len)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  ret = js_sub_string(ctx, p, start, max_int(end, start));
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue js_string_pad(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int padEnd) {
  LEPUSValue str, v = LEPUS_UNDEFINED;
  StringBuffer b_s, *b = &b_s;
  JSString *p, *p1 = NULL;
  int n, len, c = ' ';

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) goto fail1;
  if (JS_ToInt32Sat(ctx, &n, argv[0])) goto fail2;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (len >= n) return str;
  if (n > JS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(ctx, "string too long");
    goto fail2;
  }
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    v = JS_ToString_RC(ctx, argv[1]);
    if (LEPUS_IsException(v)) goto fail2;
    p1 = LEPUS_VALUE_GET_STRING(v);
    if (p1->len == 0) {
      LEPUS_FreeValue(ctx, v);
      return str;
    }
    if (p1->len == 1) {
      c = string_get(p1, 0);
      p1 = NULL;
    }
  }
  if (string_buffer_init(ctx, b, n)) goto fail3;
  n -= len;
  if (padEnd) {
    if (string_buffer_concat(b, p, 0, len)) goto fail;
  }
  if (p1) {
    while (n > 0) {
      int chunk = min_int(n, p1->len);
      if (string_buffer_concat(b, p1, 0, chunk)) goto fail;
      n -= chunk;
    }
  } else {
    if (string_buffer_fill(b, c, n)) goto fail;
  }
  if (!padEnd) {
    if (string_buffer_concat(b, p, 0, len)) goto fail;
  }
  LEPUS_FreeValue(ctx, v);
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
fail3:
  LEPUS_FreeValue(ctx, v);
fail2:
  LEPUS_FreeValue(ctx, str);
fail1:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_repeat(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int64_t val;
  int n, len;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) goto fail;
  if (JS_ToInt64Sat(ctx, &val, argv[0])) goto fail;
  if (val < 0 || val > 2147483647) {
    LEPUS_ThrowRangeError(ctx, "invalid repeat count");
    goto fail;
  }
  n = val;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (len == 0 || n == 1) return str;
  if (val * len > JS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(ctx, "string too long");
    goto fail;
  }
  if (string_buffer_init2(ctx, b, n * len, p->is_wide_char)) goto fail;
  if (len == 1) {
    string_buffer_fill(b, string_get(p, 0), n);
  } else {
    while (n-- > 0) {
      string_buffer_concat(b, p, 0, len);
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_trim(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  LEPUSValue str, ret;
  int a, b, len;
  JSString *p;

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  a = 0;
  b = len = p->len;
  if (magic & 1) {
    while (a < len && lre_is_space(string_get(p, a))) a++;
  }
  if (magic & 2) {
    while (b > a && lre_is_space(string_get(p, b - 1))) b--;
  }
  ret = js_sub_string(ctx, p, a, b);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue js_string___quote(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return JS_ToQuotedString(ctx, this_val);
}

/* return 0 if before the first char */
QJS_STATIC int string_prevc(JSString *p, int *pidx) {
  int idx, c, c1;

  idx = *pidx;
  if (idx <= 0) return 0;
  idx--;
  if (p->is_wide_char) {
    c = p->u.str16[idx];
    if (c >= 0xdc00 && c < 0xe000 && idx > 0) {
      c1 = p->u.str16[idx - 1];
      if (c1 >= 0xd800 && c1 <= 0xdc00) {
        c = (((c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000;
        idx--;
      }
    }
  } else {
    c = p->u.str8[idx];
  }
  *pidx = idx;
  return c;
}

BOOL test_final_sigma(JSString *p, int sigma_pos) {
  int k, c1;

  /* before C: skip case ignorable chars and check there is
     a cased letter */
  k = sigma_pos;
  for (;;) {
    c1 = string_prevc(p, &k);
    if (!lre_is_case_ignorable(c1)) break;
  }
  if (!lre_is_cased(c1)) return FALSE;

  /* after C: skip case ignorable chars and check there is
     no cased letter */
  k = sigma_pos + 1;
  for (;;) {
    if (k >= p->len) return TRUE;
    c1 = string_getc(p, &k);
    if (!lre_is_case_ignorable(c1)) break;
  }
  return !lre_is_cased(c1);
}

QJS_STATIC LEPUSValue js_string_localeCompare(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue a, b;
  int cmp;

  a = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(a)) return LEPUS_EXCEPTION;
  b = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(b)) {
    LEPUS_FreeValue(ctx, a);
    return LEPUS_EXCEPTION;
  }
  cmp = js_string_compare(ctx, LEPUS_VALUE_GET_STRING(a),
                          LEPUS_VALUE_GET_STRING(b));
  LEPUS_FreeValue(ctx, a);
  LEPUS_FreeValue(ctx, b);
  return LEPUS_NewInt32(ctx, cmp);
}

QJS_STATIC LEPUSValue js_string_toLowerCase(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv,
                                            int to_lower) {
  LEPUSValue val;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int i, c, j, l;
  uint32_t res[LRE_CC_RES_LEN_MAX];

  val = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (p->len == 0) return val;
  if (string_buffer_init(ctx, b, p->len)) goto fail;
  for (i = 0; i < p->len;) {
    c = string_getc(p, &i);
    if (c == 0x3a3 && to_lower && test_final_sigma(p, i - 1)) {
      res[0] = 0x3c2; /* final sigma */
      l = 1;
    } else {
      l = lre_case_conv(res, c, to_lower);
    }
    for (j = 0; j < l; j++) {
      if (string_buffer_putc(b, res[j])) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, val);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, val);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

#ifdef CONFIG_ALL_UNICODE

/* return (-1, NULL) if exception, otherwise (len, buf) */
QJS_STATIC int JS_ToUTF32String(LEPUSContext *ctx, uint32_t **pbuf,
                                LEPUSValueConst val1) {
  LEPUSValue val;
  JSString *p;
  uint32_t *buf;
  int i, j, len;

  val = JS_ToString_RC(ctx, val1);
  if (LEPUS_IsException(val)) return -1;
  p = LEPUS_VALUE_GET_STRING(val);
  len = p->len;
  /* UTF32 buffer length is len minus the number of correct surrogates pairs */
  buf = static_cast<uint32_t *>(
      lepus_malloc(ctx, sizeof(buf[0]) * max_int(len, 1)));
  if (!buf) {
    LEPUS_FreeValue(ctx, val);
    goto fail;
  }
  for (i = j = 0; i < len;) buf[j++] = string_getc(p, &i);
  LEPUS_FreeValue(ctx, val);
  *pbuf = buf;
  return j;
fail:
  *pbuf = NULL;
  return -1;
}

QJS_STATIC LEPUSValue JS_NewUTF32String(LEPUSContext *ctx, const uint32_t *buf,
                                        int len) {
  int i;
  StringBuffer b_s, *b = &b_s;
  if (string_buffer_init(ctx, b, len)) return LEPUS_EXCEPTION;
  for (i = 0; i < len; i++) {
    if (string_buffer_putc(b, buf[i])) goto fail;
  }
  return string_buffer_end(b);
fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_string_normalize(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  const char *form, *p;
  size_t form_len;
  int is_compat, buf_len, out_len;
  UnicodeNormalizationEnum n_type;
  LEPUSValue val;
  uint32_t *buf, *out_buf;

  val = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  buf_len = JS_ToUTF32String(ctx, &buf, val);
  LEPUS_FreeValue(ctx, val);
  if (buf_len < 0) return LEPUS_EXCEPTION;

  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    n_type = UNICODE_NFC;
  } else {
    form = JS_ToCStringLen2_RC(ctx, &form_len, argv[0], 0);
    if (!form) goto fail1;
    p = form;
    if (p[0] != 'N' || p[1] != 'F') goto bad_form;
    p += 2;
    is_compat = FALSE;
    if (*p == 'K') {
      is_compat = TRUE;
      p++;
    }
    if (*p == 'C' || *p == 'D') {
      n_type = static_cast<UnicodeNormalizationEnum>(
          UNICODE_NFC + is_compat * 2 + (*p - 'C'));
      if ((p + 1 - form) != form_len) goto bad_form;
    } else {
    bad_form:
      LEPUS_FreeCString(ctx, form);
      LEPUS_ThrowRangeError(ctx, "bad normalization form");
    fail1:
      lepus_free(ctx, buf);
      return LEPUS_EXCEPTION;
    }
    LEPUS_FreeCString(ctx, form);
  }

  out_len =
      unicode_normalize(&out_buf, buf, buf_len, n_type, ctx->rt, ctx, nullptr);
  lepus_free(ctx, buf);
  if (out_len < 0) return LEPUS_EXCEPTION;
  val = JS_NewUTF32String(ctx, out_buf, out_len);
  system_free(out_buf);
  return val;
}
#endif /* CONFIG_ALL_UNICODE */

/* also used for String.prototype.valueOf */
QJS_STATIC LEPUSValue js_string_toString(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  return js_thisStringValue(ctx, this_val);
}

#if 0
static LEPUSValue js_string___toStringCheckObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv)
{
    return JS_ToStringCheckObject(ctx, argv[0]);
}

static LEPUSValue js_string___toString(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return JS_ToString_RC(ctx, argv[0]);
}

static LEPUSValue js_string___advanceStringIndex(LEPUSContext *ctx, LEPUSValueConst
                                              this_val,
                                              int argc, LEPUSValueConst *argv)
{
    LEPUSValue str;
    int idx;
    BOOL is_unicode;
    JSString *p;

    str = JS_ToString_RC(ctx, argv[0]);
    if (LEPUS_IsException(str))
        return str;
    if (JS_ToInt32Sat(ctx, &idx, argv[1])) {
        LEPUS_FreeValue(ctx, str);
        return LEPUS_EXCEPTION;
    }
    is_unicode = LEPUS_ToBool(ctx, argv[2]);
    p = LEPUS_VALUE_GET_STRING(str);
    if (!is_unicode || (unsigned)idx >= p->len || !p->is_wide_char) {
        idx++;
    } else {
        string_getc(p, &idx);
    }
    LEPUS_FreeValue(ctx, str);
    return LEPUS_NewInt32(ctx, idx);
}
#endif

/* String Iterator */

QJS_STATIC LEPUSValue js_string_iterator_next(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              BOOL *pdone, int magic) {
  JSArrayIteratorData *it;
  uint32_t idx, c, start;
  JSString *p;

  it = static_cast<JSArrayIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_STRING_ITERATOR));
  if (!it) {
    *pdone = FALSE;
    return LEPUS_EXCEPTION;
  }
  if (LEPUS_IsUndefined(it->obj)) goto done;
  p = LEPUS_VALUE_GET_STRING(it->obj);
  idx = it->idx;
  if (idx >= p->len) {
    LEPUS_FreeValue(ctx, it->obj);
    it->obj = LEPUS_UNDEFINED;
  done:
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }

  start = idx;
  c = string_getc(p, (int *)&idx);
  it->idx = idx;
  *pdone = FALSE;
  if (c <= 0xffff) {
    return js_new_string_char(ctx, c);
  } else {
    return js_new_string16(ctx, p->u.str16 + start, 2);
  }
}

/* ES6 Annex B 2.3.2 etc. */
enum {
  magic_string_anchor,
  magic_string_big,
  magic_string_blink,
  magic_string_bold,
  magic_string_fixed,
  magic_string_fontcolor,
  magic_string_fontsize,
  magic_string_italics,
  magic_string_link,
  magic_string_small,
  magic_string_strike,
  magic_string_sub,
  magic_string_sup,
};

QJS_STATIC LEPUSValue js_string_CreateHTML(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv, int magic) {
  LEPUSValue str;
  const JSString *p;
  StringBuffer b_s, *b = &b_s;
  static struct {
    const char *tag, *attr;
  } const defs[] = {
      {"a", "name"}, {"big", NULL},     {"blink", NULL},  {"b", NULL},
      {"tt", NULL},  {"font", "color"}, {"font", "size"}, {"i", NULL},
      {"a", "href"}, {"small", NULL},   {"strike", NULL}, {"sub", NULL},
      {"sup", NULL},
  };

  str = JS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
  string_buffer_init(ctx, b, 7);
  string_buffer_putc8(b, '<');
  string_buffer_puts8(b, defs[magic].tag);
  if (defs[magic].attr) {
    // r += " " + attr + "=\"" + value + "\"";
    LEPUSValue value;
    int i;

    string_buffer_putc8(b, ' ');
    string_buffer_puts8(b, defs[magic].attr);
    string_buffer_puts8(b, "=\"");
    value = JS_ToStringCheckObject(ctx, argv[0]);
    if (LEPUS_IsException(value)) {
      LEPUS_FreeValue(ctx, str);
      string_buffer_free(b);
      return LEPUS_EXCEPTION;
    }
    p = LEPUS_VALUE_GET_STRING(value);
    for (i = 0; i < p->len; i++) {
      int c = string_get(p, i);
      if (c == '"') {
        string_buffer_puts8(b, "&quot;");
      } else {
        string_buffer_putc16(b, c);
      }
    }
    LEPUS_FreeValue(ctx, value);
    string_buffer_putc8(b, '\"');
  }
  // return r + ">" + str + "</" + tag + ">";
  string_buffer_putc8(b, '>');
  string_buffer_concat_value_free(b, str);
  string_buffer_puts8(b, "</");
  string_buffer_puts8(b, defs[magic].tag);
  string_buffer_putc8(b, '>');
  return string_buffer_end(b);
}

static const LEPUSCFunctionListEntry js_string_funcs[] = {
    LEPUS_CFUNC_DEF("fromCharCode", 1, js_string_fromCharCode),
    LEPUS_CFUNC_DEF("fromCodePoint", 1, js_string_fromCodePoint),
    LEPUS_CFUNC_DEF("raw", 1, js_string_raw),
    // LEPUS_CFUNC_DEF("__toString", 1, js_string___toString ),
    // LEPUS_CFUNC_DEF("__isSpace", 1, js_string___isSpace ),
    // LEPUS_CFUNC_DEF("__toStringCheckObject", 1,
    // js_string___toStringCheckObject
    // ), LEPUS_CFUNC_DEF("__advanceStringIndex", 3,
    // js_string___advanceStringIndex
    // ), LEPUS_CFUNC_DEF("__GetSubstitution", 6, js_string___GetSubstitution
    // ),
};

static const LEPUSCFunctionListEntry js_string_proto_funcs[] = {
    LEPUS_PROP_INT32_DEF("length", 0, LEPUS_PROP_CONFIGURABLE),
    LEPUS_CFUNC_DEF("charCodeAt", 1, js_string_charCodeAt),
    LEPUS_CFUNC_DEF("charAt", 1, js_string_charAt),
    LEPUS_CFUNC_DEF("concat", 1, js_string_concat),
    LEPUS_CFUNC_DEF("codePointAt", 1, js_string_codePointAt),
    LEPUS_CFUNC_MAGIC_DEF("indexOf", 1, js_string_indexOf, 0),
    LEPUS_CFUNC_MAGIC_DEF("lastIndexOf", 1, js_string_indexOf, 1),
    LEPUS_CFUNC_MAGIC_DEF("includes", 1, js_string_includes, 0),
    LEPUS_CFUNC_MAGIC_DEF("endsWith", 1, js_string_includes, 2),
    LEPUS_CFUNC_MAGIC_DEF("startsWith", 1, js_string_includes, 1),
    LEPUS_CFUNC_MAGIC_DEF("match", 1, js_string_match, JS_ATOM_Symbol_match),
    LEPUS_CFUNC_MAGIC_DEF("matchAll", 1, js_string_match,
                          JS_ATOM_Symbol_matchAll),
    LEPUS_CFUNC_MAGIC_DEF("search", 1, js_string_match, JS_ATOM_Symbol_search),
    LEPUS_CFUNC_DEF("split", 2, js_string_split),
    LEPUS_CFUNC_DEF("substring", 2, js_string_substring),
    LEPUS_CFUNC_DEF("substr", 2, js_string_substr),
    LEPUS_CFUNC_DEF("slice", 2, js_string_slice),
    LEPUS_CFUNC_DEF("repeat", 1, js_string_repeat),
    LEPUS_CFUNC_DEF("replace", 2, js_string_replace),
    LEPUS_CFUNC_MAGIC_DEF("padEnd", 1, js_string_pad, 1),
    LEPUS_CFUNC_MAGIC_DEF("padStart", 1, js_string_pad, 0),
    LEPUS_CFUNC_MAGIC_DEF("trim", 0, js_string_trim, 3),
    LEPUS_CFUNC_MAGIC_DEF("trimEnd", 0, js_string_trim, 2),
    LEPUS_ALIAS_DEF("trimRight", "trimEnd"),
    LEPUS_CFUNC_MAGIC_DEF("trimStart", 0, js_string_trim, 1),
    LEPUS_ALIAS_DEF("trimLeft", "trimStart"),
    LEPUS_CFUNC_DEF("toString", 0, js_string_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_string_toString),
    LEPUS_CFUNC_DEF("__quote", 1, js_string___quote),
    LEPUS_CFUNC_DEF("localeCompare", 1, js_string_localeCompare),
    LEPUS_CFUNC_MAGIC_DEF("toLowerCase", 0, js_string_toLowerCase, 1),
    LEPUS_CFUNC_MAGIC_DEF("toUpperCase", 0, js_string_toLowerCase, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleLowerCase", 0, js_string_toLowerCase, 1),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleUpperCase", 0, js_string_toLowerCase, 0),
    LEPUS_CFUNC_MAGIC_DEF("[Symbol.iterator]", 0, js_create_array_iterator,
                          JS_ITERATOR_KIND_VALUE | 4),
    /* ES6 Annex B 2.3.2 etc. */
    LEPUS_CFUNC_MAGIC_DEF("anchor", 1, js_string_CreateHTML,
                          magic_string_anchor),
    LEPUS_CFUNC_MAGIC_DEF("big", 0, js_string_CreateHTML, magic_string_big),
    LEPUS_CFUNC_MAGIC_DEF("blink", 0, js_string_CreateHTML, magic_string_blink),
    LEPUS_CFUNC_MAGIC_DEF("bold", 0, js_string_CreateHTML, magic_string_bold),
    LEPUS_CFUNC_MAGIC_DEF("fixed", 0, js_string_CreateHTML, magic_string_fixed),
    LEPUS_CFUNC_MAGIC_DEF("fontcolor", 1, js_string_CreateHTML,
                          magic_string_fontcolor),
    LEPUS_CFUNC_MAGIC_DEF("fontsize", 1, js_string_CreateHTML,
                          magic_string_fontsize),
    LEPUS_CFUNC_MAGIC_DEF("italics", 0, js_string_CreateHTML,
                          magic_string_italics),
    LEPUS_CFUNC_MAGIC_DEF("link", 1, js_string_CreateHTML, magic_string_link),
    LEPUS_CFUNC_MAGIC_DEF("small", 0, js_string_CreateHTML, magic_string_small),
    LEPUS_CFUNC_MAGIC_DEF("strike", 0, js_string_CreateHTML,
                          magic_string_strike),
    LEPUS_CFUNC_MAGIC_DEF("sub", 0, js_string_CreateHTML, magic_string_sub),
    LEPUS_CFUNC_MAGIC_DEF("sup", 0, js_string_CreateHTML, magic_string_sup),
};

static const LEPUSCFunctionListEntry js_string_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, js_string_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "String Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

#ifdef CONFIG_ALL_UNICODE
static const LEPUSCFunctionListEntry js_string_proto_normalize[] = {
    LEPUS_CFUNC_DEF("normalize", 0, js_string_normalize),
};
#endif

void LEPUS_AddIntrinsicStringNormalize(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicStringNormalize_GC, ctx);
#ifdef CONFIG_ALL_UNICODE
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING],
                                js_string_proto_normalize,
                                countof(js_string_proto_normalize));
#endif
}

/* Math */

/* precondition: a and b are not NaN */
QJS_STATIC double js_fmin(double a, double b) {
  if (a == 0 && b == 0) {
    JSFloat64Union a1, b1;
    a1.d = a;
    b1.d = b;
    a1.u64 |= b1.u64;
    return a1.d;
  } else {
    return fmin(a, b);
  }
}

/* precondition: a and b are not NaN */
QJS_STATIC double js_fmax(double a, double b) {
  if (a == 0 && b == 0) {
    JSFloat64Union a1, b1;
    a1.d = a;
    b1.d = b;
    a1.u64 &= b1.u64;
    return a1.d;
  } else {
    return fmax(a, b);
  }
}

#ifdef CONFIG_BIGNUM

enum {
  MATH_OP_ABS,
  MATH_OP_FLOOR,
  MATH_OP_CEIL,
  MATH_OP_ROUND,
  MATH_OP_TRUNC,
  MATH_OP_SQRT,
  MATH_OP_FPROUND,
  MATH_OP_ACOS,
  MATH_OP_ASIN,
  MATH_OP_ATAN,
  MATH_OP_ATAN2,
  MATH_OP_COS,
  MATH_OP_EXP,
  MATH_OP_LOG,
  MATH_OP_POW,
  MATH_OP_SIN,
  MATH_OP_TAN,
  MATH_OP_FMOD,
  MATH_OP_REM,
  MATH_OP_SIGN,

  MATH_OP_ADD,
  MATH_OP_SUB,
  MATH_OP_MUL,
  MATH_OP_DIV,
};

static LEPUSValue js_math_fop(LEPUSContext *ctx, LEPUSValueConst this_val,
                              int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, r_s, *r = &r_s;
  BOOL is_float;
  JSFloatEnv *fe;
  int rnd_mode;
  LEPUSValue op1;

  op1 = JS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(op1)) return op1;
  a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
  fe = &ctx->fp_env;
  if (argc > 1) {
    fe = static_cast<JSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV));
    if (!fe) {
      if (a == &a_s) bf_delete(a);
      LEPUS_FreeValue(ctx, op1);
      return LEPUS_EXCEPTION;
    }
  }

  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case MATH_OP_ABS:
      bf_set(r, a);
      r->sign = 0;
      break;
    case MATH_OP_FLOOR:
      rnd_mode = BF_RNDD;
      goto rint;
    case MATH_OP_CEIL:
      rnd_mode = BF_RNDU;
      goto rint;
    case MATH_OP_ROUND:
      rnd_mode = BF_RNDNU;
      goto rint;
    case MATH_OP_TRUNC:
      rnd_mode = BF_RNDZ;
    rint:
      bf_set(r, a);
      fe->status |= bf_rint(r, fe->prec, (fe->flags & ~BF_RND_MASK) | rnd_mode);
      break;
    case MATH_OP_SQRT:
      fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_FPROUND:
      bf_set(r, a);
      fe->status |= bf_round(r, fe->prec, fe->flags);
      break;
    case MATH_OP_ACOS:
      fe->status |= bf_acos(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_ASIN:
      fe->status |= bf_asin(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_ATAN:
      fe->status |= bf_atan(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_COS:
      fe->status |= bf_cos(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_EXP:
      fe->status |= bf_exp(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_LOG:
      fe->status |= bf_log(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_SIN:
      fe->status |= bf_sin(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_TAN:
      fe->status |= bf_tan(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_SIGN:
      if (bf_is_nan(a) || bf_is_zero(a)) {
        bf_set(r, a);
      } else {
        bf_set_si(r, 1 - 2 * a->sign);
      }
      break;
    default:
      abort();
  }
  if (a == &a_s) bf_delete(a);
  LEPUS_FreeValue(ctx, op1);
  return JS_NewBigFloat(ctx, r);
}

static LEPUSValue js_math_fop2(LEPUSContext *ctx, LEPUSValueConst this_val,
                               int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, b_s, *b, r_s, *r = &r_s;
  BOOL is_float;
  JSFloatEnv *fe;
  LEPUSValue op1, op2;

  op1 = JS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(op1)) return op1;
  op2 = JS_ToNumber(ctx, argv[1]);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    return op2;
  }
  a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
  b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
  fe = &ctx->fp_env;
  if (argc > 2) {
    fe = static_cast<JSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, (argv[2]), JS_CLASS_FLOAT_ENV));
    if (!fe) {
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(b);
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      return LEPUS_EXCEPTION;
    }
  }

  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case MATH_OP_ATAN2:
      fe->status |= bf_atan2(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_POW:
      fe->status |= bf_pow(r, a, b, fe->prec, fe->flags | BF_POW_JS_QUICKS);
      break;
    case MATH_OP_FMOD:
      fe->status |= bf_fmod(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_REM:
      fe->status |= bf_remainder(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_ADD:
      fe->status |= bf_add(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_SUB:
      fe->status |= bf_sub(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_MUL:
      fe->status |= bf_mul(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_DIV:
      fe->status |= bf_div(r, a, b, fe->prec, fe->flags);
      break;
    default:
      abort();
  }
  if (a == &a_s) bf_delete(a);
  if (b == &b_s) bf_delete(b);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return JS_NewBigFloat(ctx, r);
}

static LEPUSValue js_math_min_max(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv, int magic) {
  BOOL is_max = magic;
  LEPUSValue val, ret;
  int i;
  uint32_t tag;

  if (unlikely(argc == 0)) {
    return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
  }

  tag = LEPUS_VALUE_GET_TAG(argv[0]);
  if (tag == LEPUS_TAG_INT) {
    int a1, r1 = LEPUS_VALUE_GET_INT(argv[0]);
    for (i = 1; i < argc; i++) {
      tag = LEPUS_VALUE_GET_TAG(argv[i]);
      if (tag != LEPUS_TAG_INT) {
        ret = LEPUS_NewInt32(ctx, r1);
        goto generic_case;
      }
      a1 = LEPUS_VALUE_GET_INT(argv[i]);
      if (is_max)
        r1 = max_int(r1, a1);
      else
        r1 = min_int(r1, a1);
    }
    ret = LEPUS_NewInt32(ctx, r1);
  } else {
    ret = JS_ToNumber(ctx, argv[0]);
    if (LEPUS_IsException(ret)) return ret;
    i = 1;
  generic_case:
    for (; i < argc; i++) {
      val = JS_ToNumber(ctx, argv[i]);
      if (LEPUS_IsException(val)) {
        LEPUS_FreeValue(ctx, ret);
        return val;
      }
      if (LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(ret)) &&
          LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(val))) {
        double r, a;
        r = LEPUS_VALUE_GET_FLOAT64(ret);
        a = LEPUS_VALUE_GET_FLOAT64(val);
        if (!isnan(r)) {
          if (isnan(a)) {
            r = a;
          } else {
            if (is_max)
              r = js_fmax(r, a);
            else
              r = js_fmin(r, a);
          }
          ret = __JS_NewFloat64(ctx, r);
        }
      } else {
        bf_t a_s, *a, r_s, *r;
        BOOL is_float;
        int res;

        r = JS_ToBigFloat(ctx, &is_float, &r_s, ret);
        if (!bf_is_nan(r)) {
          a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
          res = bf_cmp_full(a, r);
          if (is_max) res = -res;
          if (bf_is_nan(a) || res < 0) {
            LEPUS_FreeValue(ctx, ret);
            ret = LEPUS_DupValue(ctx, val);
          }
          if (a == &a_s) bf_delete(a);
        }
        if (r == &r_s) bf_delete(r);
      }
    }
  }
  return ret;
}

static LEPUSValue js_math_abs(LEPUSContext *ctx, LEPUSValueConst this_val,
                              int argc, LEPUSValueConst *argv) {
  LEPUSValue val;
  int32_t tag;

  val = JS_ToNumeric(ctx, argv[0]);
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      if (LEPUS_VALUE_GET_INT(val) < 0)
        val = LEPUS_NewInt64(ctx, -(int64_t)LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_FLOAT64:
      val = __JS_NewFloat64(ctx, fabs(LEPUS_VALUE_GET_FLOAT64(val)));
      break;
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t r_s, *r = &r_s;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      r->sign = 0;
      LEPUS_FreeValue(ctx, val);
      if (tag == LEPUS_TAG_BIG_FLOAT)
        val = JS_NewBigFloat(ctx, r);
      else
        val = JS_NewBigInt2(ctx, r, TRUE);
    } break;
    default:
      break;
  }
  return val;
}

#if 0
/* XXX: should give exact rounding */
/* XXX: correct NaN/Infinity handling */
static LEPUSValue js_math_hypot(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int argc, LEPUSValueConst *argv)
{
    bf_t a_s, *a, r_s, *r = &r_s, r2_s, *r2 = &r2_s;
    LEPUSValue val;
    int i;
    BOOL is_float;

    bf_init(ctx->bf_ctx, r);
    bf_set_si(r, 0);
    for(i = 0; i < argc; i++) {
        val = JS_ToNumber(ctx, argv[i]);
        if (LEPUS_IsException(val)) {
            bf_delete(r);
            return val;
        }
        a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
        bf_add(r, r, a, ctx->fp_env.prec, ctx->fp_env.flags);
        if (a == &a_s)
            bf_delete(a);
    }
    bf_init(ctx->bf_ctx, r2);
    bf_sqrt(r2, r, ctx->fp_env.prec, ctx->fp_env.flags);
    bf_delete(r);
    return JS_NewBigFloat(ctx, r2);
}
#endif

#else

QJS_STATIC LEPUSValue js_math_min_max(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int magic) {
  BOOL is_max = magic;
  double r, a;
  int i;

  if (unlikely(argc == 0)) {
    return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
  }

  if (LEPUS_VALUE_IS_INT(argv[0])) {
    int a1, r1 = LEPUS_VALUE_GET_INT(argv[0]);
    for (i = 1; i < argc; i++) {
      if (!LEPUS_VALUE_IS_INT(argv[i])) {
        r = r1;
        goto generic_case;
      }
      a1 = LEPUS_VALUE_GET_INT(argv[i]);
      if (is_max)
        r1 = max_int(r1, a1);
      else
        r1 = min_int(r1, a1);
    }
    return LEPUS_NewInt32(ctx, r1);
  } else {
    if (LEPUS_ToFloat64(ctx, &r, argv[0])) return LEPUS_EXCEPTION;
    i = 1;
  generic_case:
    while (i < argc) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isnan(r)) {
        if (isnan(a)) {
          r = a;
        } else {
          if (is_max)
            r = js_fmax(r, a);
          else
            r = js_fmin(r, a);
        }
      }
      i++;
    }
    return LEPUS_NewFloat64(ctx, r);
  }
}

#endif /* !CONFIG_BIGNUM */

QJS_STATIC double js_math_sign(double a) {
  if (isnan(a) || a == 0.0) return a;
  if (a < 0)
    return -1;
  else
    return 1;
}

QJS_STATIC double js_math_round(double a) {
  JSFloat64Union u;
  uint64_t frac_mask, one;
  unsigned int e, s;

  u.d = a;
  e = (u.u64 >> 52) & 0x7ff;
  if (e < 1023) {
    /* abs(a) < 1 */
    if (e == (1023 - 1) && u.u64 != 0xbfe0000000000000) {
      /* abs(a) > 0.5 or a = 0.5: return +/-1.0 */
      u.u64 = (u.u64 & ((uint64_t)1 << 63)) | ((uint64_t)1023 << 52);
    } else {
      /* return +/-0.0 */
      u.u64 &= (uint64_t)1 << 63;
    }
  } else if (e < (1023 + 52)) {
    s = u.u64 >> 63;
    one = (uint64_t)1 << (52 - (e - 1023));
    frac_mask = one - 1;
    u.u64 += (one >> 1) - s;
    u.u64 &= ~frac_mask; /* truncate to an integer */
  }
  /* otherwise: abs(a) >= 2^52, or NaN, +/-Infinity: no change */
  return u.d;
}
QJS_STATIC LEPUSValue js_math_hypot(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  double r, a;
  int i;

  r = 0;
  if (argc > 0) {
    if (LEPUS_ToFloat64(ctx, &r, argv[0])) return LEPUS_EXCEPTION;
    if (argc == 1) {
      r = fabs(r);
    } else {
      /* use the built-in function to minimize precision loss */
      for (i = 1; i < argc; i++) {
        if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
        r = hypot(r, a);
      }
    }
  }
  return LEPUS_NewFloat64(ctx, r);
}

QJS_STATIC double js_math_fround(double a) { return (float)a; }

QJS_STATIC LEPUSValue js_math_imul(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv) {
  int a, b;

  if (LEPUS_ToInt32(ctx, &a, argv[0])) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &b, argv[1])) return LEPUS_EXCEPTION;
  /* purposely ignoring overflow */
  return LEPUS_NewInt32(ctx, a * b);
}

QJS_STATIC LEPUSValue js_math_clz32(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  uint32_t a, r;

  if (LEPUS_ToUint32(ctx, &a, argv[0])) return LEPUS_EXCEPTION;
  if (a == 0)
    r = 32;
  else
    r = clz32(a);
  return LEPUS_NewInt32(ctx, r);
}

/* xorshift* random number generator by Marsaglia */
QJS_STATIC uint64_t xorshift64star(uint64_t *pstate) {
  uint64_t x;
  x = *pstate;
  x ^= x >> 12;
  x ^= x << 25;
  x ^= x >> 27;
  *pstate = x;
  return x * 0x2545F4914F6CDD1D;
}

void js_random_init(LEPUSContext *ctx) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  ctx->random_state = ((int64_t)tv.tv_sec * 1000000) + tv.tv_usec;
  /* the state must be non zero */
  if (ctx->random_state == 0) ctx->random_state = 1;
}

LEPUSValue js_math_random(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                          LEPUSValueConst *argv) {
  JSFloat64Union u;
  uint64_t v;

  v = xorshift64star(&ctx->random_state);
  /* 1.0 <= u.d < 2 */
  u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
  return __JS_NewFloat64(ctx, u.d - 1.0);
}

static const LEPUSCFunctionListEntry js_math_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0),
    LEPUS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1),
#ifdef CONFIG_BIGNUM
    LEPUS_CFUNC_DEF("abs", 1, js_math_abs),
#else
    LEPUS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs),
#endif
    LEPUS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor),
    LEPUS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil),
    LEPUS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round),
    LEPUS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt),

    LEPUS_CFUNC_SPECIAL_DEF("acos", 1, f_f, acos),
    LEPUS_CFUNC_SPECIAL_DEF("asin", 1, f_f, asin),
    LEPUS_CFUNC_SPECIAL_DEF("atan", 1, f_f, atan),
    LEPUS_CFUNC_SPECIAL_DEF("atan2", 2, f_f_f, atan2),
    LEPUS_CFUNC_SPECIAL_DEF("cos", 1, f_f, cos),
    LEPUS_CFUNC_SPECIAL_DEF("exp", 1, f_f, exp),
    LEPUS_CFUNC_SPECIAL_DEF("log", 1, f_f, log),
    LEPUS_CFUNC_SPECIAL_DEF("pow", 2, f_f_f, js_pow),
    LEPUS_CFUNC_SPECIAL_DEF("sin", 1, f_f, sin),
    LEPUS_CFUNC_SPECIAL_DEF("tan", 1, f_f, tan),
    /* ES6 */
    LEPUS_CFUNC_SPECIAL_DEF("trunc", 1, f_f, trunc),
    LEPUS_CFUNC_SPECIAL_DEF("sign", 1, f_f, js_math_sign),
    LEPUS_CFUNC_SPECIAL_DEF("cosh", 1, f_f, cosh),
    LEPUS_CFUNC_SPECIAL_DEF("sinh", 1, f_f, sinh),
    LEPUS_CFUNC_SPECIAL_DEF("tanh", 1, f_f, tanh),
    LEPUS_CFUNC_SPECIAL_DEF("acosh", 1, f_f, acosh),
    LEPUS_CFUNC_SPECIAL_DEF("asinh", 1, f_f, asinh),
    LEPUS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh),
    LEPUS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1),
    LEPUS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p),
    LEPUS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2),
    LEPUS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10),
    LEPUS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt),
    LEPUS_CFUNC_DEF("hypot", 2, js_math_hypot),
    LEPUS_CFUNC_DEF("random", 0, js_math_random),
    LEPUS_CFUNC_SPECIAL_DEF("fround", 1, f_f, js_math_fround),
    LEPUS_CFUNC_DEF("imul", 2, js_math_imul),
    LEPUS_CFUNC_DEF("clz32", 1, js_math_clz32),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Math",
                          LEPUS_PROP_CONFIGURABLE),
    LEPUS_PROP_DOUBLE_DEF("E", 2.718281828459045, 0),
    LEPUS_PROP_DOUBLE_DEF("LN10", 2.302585092994046, 0),
    LEPUS_PROP_DOUBLE_DEF("LN2", 0.6931471805599453, 0),
    LEPUS_PROP_DOUBLE_DEF("LOG2E", 1.4426950408889634, 0),
    LEPUS_PROP_DOUBLE_DEF("LOG10E", 0.4342944819032518, 0),
    LEPUS_PROP_DOUBLE_DEF("PI", 3.141592653589793, 0),
    LEPUS_PROP_DOUBLE_DEF("SQRT1_2", 0.7071067811865476, 0),
    LEPUS_PROP_DOUBLE_DEF("SQRT2", 1.4142135623730951, 0),
};

static const LEPUSCFunctionListEntry js_math_obj[] = {
    LEPUS_OBJECT_DEF("Math", js_math_funcs, countof(js_math_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Date */

#if 0
/* OS dependent: return the UTC time in ms since 1970. */
static LEPUSValue js___date_now(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int argc, LEPUSValueConst *argv)
{
    int64_t d;
    struct timeval tv;
    gettimeofday(&tv, NULL);
    d = (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
    return LEPUS_NewInt64(ctx, d);
}
#endif

/* OS dependent: return the UTC time in microseconds since 1970. */
QJS_STATIC LEPUSValue js___date_clock(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  int64_t d;
  struct timeval tv;
  gettimeofday(&tv, NULL);
  d = (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
  return LEPUS_NewInt64(ctx, d);
}

/* OS dependent. d = argv[0] is in ms from 1970. Return the difference
   between local time and UTC time 'd' in minutes */
int getTimezoneOffset(int64_t time) {
#if defined(_WIN32)
  TIME_ZONE_INFORMATION tzi;
  memset(&tzi, 0, sizeof(tzi));
  DWORD ctz = GetTimeZoneInformation(&tzi);
  int r = tzi.Bias;  // in minutes
  switch (ctz) {
    case TIME_ZONE_ID_STANDARD:
      r += tzi.StandardBias;
      break;
    case TIME_ZONE_ID_DAYLIGHT:
      r += tzi.DaylightBias;
      break;
  }
  return r;
#else
  time_t ti;
  struct tm tm;

  time /= 1000; /* convert to seconds */
  if (sizeof(time_t) == 4) {
    /* on 32-bit systems, we need to clamp the time value to the
       range of `time_t`. This is better than truncating values to
       32 bits and hopefully provides the same result as 64-bit
       implementation of localtime_r.
     */
    if ((time_t)-1 < 0) {
      if (time < INT32_MIN) {
        time = INT32_MIN;
      } else if (time > INT32_MAX) {
        time = INT32_MAX;
      }
    } else {
      if (time < 0) {
        time = 0;
      } else if (time > UINT32_MAX) {
        time = UINT32_MAX;
      }
    }
  }
  ti = time;
  localtime_r(&ti, &tm);
  return -tm.tm_gmtoff / 60;
#endif
}

#if 0
static LEPUSValue js___date_getTimezoneOffset(LEPUSContext *ctx, LEPUSValueConst this_val,
                                           int argc, LEPUSValueConst *argv)
{
    double dd;

    if (LEPUS_ToFloat64(ctx, &dd, argv[0]))
        return LEPUS_EXCEPTION;
    if (isnan(dd))
        return __JS_NewFloat64(ctx, dd);
    else
        return LEPUS_NewInt32(ctx, getTimezoneOffset((int64_t)dd));
}

static LEPUSValue js_get_prototype_from_ctor(LEPUSContext *ctx, LEPUSValueConst ctor,
                                          LEPUSValueConst def_proto)
{
    LEPUSValue proto;
    proto = JS_GetPropertyInternal_RC(ctx, ctor, JS_ATOM_prototype, ctor, 0);
    if (LEPUS_IsException(proto))
        return proto;
    if (!LEPUS_IsObject(proto)) {
        LEPUS_FreeValue(ctx, proto);
        proto = LEPUS_DupValue(ctx, def_proto);
    }
    return proto;
}

/* create a new date object */
static LEPUSValue js___date_create(LEPUSContext *ctx, LEPUSValueConst this_val,
                                int argc, LEPUSValueConst *argv)
{
    LEPUSValue obj, proto;
    proto = js_get_prototype_from_ctor(ctx, argv[0], argv[1]);
    if (LEPUS_IsException(proto))
        return proto;
    obj = JS_NewObjectProtoClass_RC(ctx, proto, JS_CLASS_DATE);
    LEPUS_FreeValue(ctx, proto);
    if (!LEPUS_IsException(obj))
        JS_SetObjectData(ctx, obj, LEPUS_DupValue(ctx, argv[2]));
    return obj;
}
#endif

/* RegExp */

QJS_STATIC void js_regexp_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSRegExp *re = &p->u.regexp;
  LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
  LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
}

/* create a string containing the RegExp bytecode */
QJS_STATIC LEPUSValue js_compile_regexp(LEPUSContext *ctx,
                                        LEPUSValueConst pattern,
                                        LEPUSValueConst flags) {
  const char *str;
  int re_flags, mask;
  uint8_t *re_bytecode_buf;
  size_t i, len;
  int re_bytecode_len;
  LEPUSValue ret;
  char error_msg[64];

  re_flags = 0;
  if (!LEPUS_IsUndefined(flags)) {
    str = JS_ToCStringLen2_RC(ctx, &len, flags, 0);
    if (!str) return LEPUS_EXCEPTION;
    /* XXX: re_flags = LRE_FLAG_OCTAL unless strict mode? */
    for (i = 0; i < len; i++) {
      switch (str[i]) {
        case 'g':
          mask = LRE_FLAG_GLOBAL;
          break;
        case 'i':
          mask = LRE_FLAG_IGNORECASE;
          break;
        case 'm':
          mask = LRE_FLAG_MULTILINE;
          break;
        case 's':
          mask = LRE_FLAG_DOTALL;
          break;
        case 'u':
          mask = LRE_FLAG_UTF16;
          break;
        case 'y':
          mask = LRE_FLAG_STICKY;
          break;
        default:
          goto bad_flags;
      }
      if ((re_flags & mask) != 0) {
      bad_flags:
        LEPUS_FreeCString(ctx, str);
        return LEPUS_ThrowSyntaxError(ctx, "invalid regular expression flags");
      }
      re_flags |= mask;
    }
    LEPUS_FreeCString(ctx, str);
  }

  str = JS_ToCStringLen2_RC(ctx, &len, pattern, !(re_flags & LRE_FLAG_UTF16));
  if (!str) return LEPUS_EXCEPTION;
  re_bytecode_buf = lre_compile(&re_bytecode_len, error_msg, sizeof(error_msg),
                                str, len, re_flags, ctx);
  LEPUS_FreeCString(ctx, str);
  if (!re_bytecode_buf) {
    LEPUS_ThrowSyntaxError(ctx, "%s", error_msg);
    return LEPUS_EXCEPTION;
  }

  ret = js_new_string8(ctx, re_bytecode_buf, re_bytecode_len);
  lre_free(re_bytecode_buf);
  return ret;
}

/* create a RegExp object from a string containing the RegExp bytecode
   and the source pattern */
LEPUSValue js_regexp_constructor_internal(LEPUSContext *ctx,
                                          LEPUSValueConst ctor,
                                          LEPUSValue pattern, LEPUSValue bc) {
  LEPUSValue obj;
  LEPUSObject *p;
  JSRegExp *re;

  if (JS_IsSeparableString(pattern)) {
    auto content = JS_GetSeparableStringContent(ctx, pattern);
    LEPUS_FreeValue(ctx, pattern);
    pattern = content;
  }

  if (JS_IsSeparableString(bc)) {
    auto content = JS_GetSeparableStringContent(ctx, bc);
    LEPUS_FreeValue(ctx, bc);
    bc = content;
  }

  /* sanity check */
  if (!LEPUS_VALUE_IS_STRING(bc) || !LEPUS_VALUE_IS_STRING(pattern)) {
    LEPUS_ThrowTypeError(ctx, "string expected");
  fail:
    LEPUS_FreeValue(ctx, bc);
    LEPUS_FreeValue(ctx, pattern);
    return LEPUS_EXCEPTION;
  }

  obj = js_create_from_ctor(ctx, ctor, JS_CLASS_REGEXP);
  if (LEPUS_IsException(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
  re = &p->u.regexp;
  re->pattern = LEPUS_VALUE_GET_STRING(pattern);
  re->bytecode = LEPUS_VALUE_GET_STRING(bc);
  JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_lastIndex, LEPUS_NewInt32(ctx, 0),
                            LEPUS_PROP_WRITABLE);
  return obj;
}

JSRegExp *js_get_regexp(LEPUSContext *ctx, LEPUSValueConst obj,
                        BOOL throw_error) {
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == JS_CLASS_REGEXP) return &p->u.regexp;
  }
  if (throw_error) {
    JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);
  }
  return NULL;
}

/* return < 0 if exception or TRUE/FALSE */
QJS_HIDE int js_is_regexp(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSValue m;

  if (!LEPUS_IsObject(obj)) return FALSE;
  m = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_Symbol_match, obj, 0);
  if (LEPUS_IsException(m)) return -1;
  if (!LEPUS_IsUndefined(m)) return JS_ToBoolFree_RC(ctx, m);
  return js_get_regexp(ctx, obj, FALSE) != NULL;
}

QJS_STATIC LEPUSValue js_regexp_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv) {
  LEPUSValue pattern, flags, bc, val;
  LEPUSValueConst pat, flags1;
  JSRegExp *re;
  int pat_is_regexp;

  pat = argv[0];
  flags1 = argv[1];
  pat_is_regexp = js_is_regexp(ctx, pat);
  if (pat_is_regexp < 0) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(new_target)) {
    /* called as a function */
    new_target = JS_GetActiveFunction(ctx);
    if (pat_is_regexp && LEPUS_IsUndefined(flags1)) {
      LEPUSValue ctor;
      BOOL res;
      ctor = JS_GetPropertyInternal_RC(ctx, pat, JS_ATOM_constructor, pat, 0);
      if (LEPUS_IsException(ctor)) return ctor;
      res = js_same_value(ctx, ctor, new_target);
      LEPUS_FreeValue(ctx, ctor);
      if (res) return LEPUS_DupValue(ctx, pat);
    }
  }
  re = js_get_regexp(ctx, pat, FALSE);
  if (re) {
    pattern = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
    if (LEPUS_IsUndefined(flags1)) {
      bc = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
      goto no_compilation;
    } else {
      flags = JS_ToString_RC(ctx, flags1);
      if (LEPUS_IsException(flags)) goto fail;
    }
  } else {
    flags = LEPUS_UNDEFINED;
    if (pat_is_regexp) {
      pattern = JS_GetPropertyInternal_RC(ctx, pat, JS_ATOM_source, pat, 0);
      if (LEPUS_IsException(pattern)) goto fail;
      if (LEPUS_IsUndefined(flags1)) {
        flags = JS_GetPropertyInternal_RC(ctx, pat, JS_ATOM_flags, pat, 0);
        if (LEPUS_IsException(flags)) goto fail;
      } else {
        flags = LEPUS_DupValue(ctx, flags1);
      }
    } else {
      pattern = LEPUS_DupValue(ctx, pat);
      flags = LEPUS_DupValue(ctx, flags1);
    }
    if (LEPUS_IsUndefined(pattern)) {
      pattern = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
    } else {
      val = pattern;
      pattern = JS_ToString_RC(ctx, val);
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_IsException(pattern)) goto fail;
    }
  }
  bc = js_compile_regexp(ctx, pattern, flags);
  if (LEPUS_IsException(bc)) goto fail;
  LEPUS_FreeValue(ctx, flags);
no_compilation:
  return js_regexp_constructor_internal(ctx, new_target, pattern, bc);
fail:
  LEPUS_FreeValue(ctx, pattern);
  LEPUS_FreeValue(ctx, flags);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_regexp_compile(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  JSRegExp *re1, *re;
  LEPUSValueConst pattern1, flags1;
  LEPUSValue bc, pattern;

  re = js_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;
  pattern1 = argv[0];
  flags1 = argv[1];
  re1 = js_get_regexp(ctx, pattern1, FALSE);
  if (re1) {
    if (!LEPUS_IsUndefined(flags1))
      return LEPUS_ThrowTypeError(ctx, "flags must be undefined");
    pattern = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re1->pattern));
    bc = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re1->bytecode));
  } else {
    bc = LEPUS_UNDEFINED;
    if (LEPUS_IsUndefined(pattern1))
      pattern = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
    else
      pattern = JS_ToString_RC(ctx, pattern1);
    if (LEPUS_IsException(pattern)) goto fail;
    bc = js_compile_regexp(ctx, pattern, flags1);
    if (LEPUS_IsException(bc)) goto fail;
  }
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
  re->pattern = LEPUS_VALUE_GET_STRING(pattern);
  re->bytecode = LEPUS_VALUE_GET_STRING(bc);
  if (JS_SetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex,
                                LEPUS_NewInt32(ctx, 0), LEPUS_PROP_THROW) < 0)
    return LEPUS_EXCEPTION;
  return LEPUS_DupValue(ctx, this_val);
fail:
  LEPUS_FreeValue(ctx, pattern);
  LEPUS_FreeValue(ctx, bc);
  return LEPUS_EXCEPTION;
}

#if 0
static LEPUSValue js_regexp_get___source(LEPUSContext *ctx, LEPUSValueConst this_val)
{
    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
    if (!re)
        return LEPUS_EXCEPTION;
    return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
}

static LEPUSValue js_regexp_get___flags(LEPUSContext *ctx, LEPUSValueConst this_val)
{
    JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
    int flags;

    if (!re)
        return LEPUS_EXCEPTION;
    flags = lre_get_flags(re->bytecode->u.str8);
    return LEPUS_NewInt32(ctx, flags);
}
#endif

QJS_STATIC LEPUSValue js_regexp_get_source(LEPUSContext *ctx,
                                           LEPUSValueConst this_val) {
  JSRegExp *re;
  JSString *p;
  StringBuffer b_s, *b = &b_s;
  int i, n, c, c2, bra;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return JS_ThrowTypeErrorNotAnObject(ctx);

  if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
    goto empty_regex;

  re = js_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;

  p = re->pattern;

  if (p->len == 0) {
  empty_regex:
    return LEPUS_NewString(ctx, "(?:)");
  }
  string_buffer_init2(ctx, b, p->len, p->is_wide_char);

  /* Escape '/' and newline sequences as needed */
  bra = 0;
  for (i = 0, n = p->len; i < n;) {
    c2 = -1;
    switch (c = string_get(p, i++)) {
      case '\\':
        if (i < n) c2 = string_get(p, i++);
        break;
      case ']':
        bra = 0;
        break;
      case '[':
        if (!bra) {
          if (i < n && string_get(p, i) == ']') c2 = string_get(p, i++);
          bra = 1;
        }
        break;
      case '\n':
        c = '\\';
        c2 = 'n';
        break;
      case '\r':
        c = '\\';
        c2 = 'r';
        break;
      case '/':
        if (!bra) {
          c = '\\';
          c2 = '/';
        }
        break;
    }
    string_buffer_putc16(b, c);
    if (c2 >= 0) string_buffer_putc16(b, c2);
  }
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue js_regexp_get_flag(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int mask) {
  JSRegExp *re;
  int flags;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return JS_ThrowTypeErrorNotAnObject(ctx);

  if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
    return LEPUS_UNDEFINED;

  re = js_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;

  flags = lre_get_flags(re->bytecode->u.str8);
  return LEPUS_NewBool(ctx, (flags & mask) != 0);
}

QJS_STATIC LEPUSValue js_regexp_get_flags(LEPUSContext *ctx,
                                          LEPUSValueConst this_val) {
  char str[8], *p = str;
  int res;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return JS_ThrowTypeErrorNotAnObject(ctx);

  res = JS_ToBoolFree_RC(ctx, JS_GetPropertyInternal_RC(
                                  ctx, this_val, JS_ATOM_global, this_val, 0));
  if (res < 0) goto exception;
  if (res) *p++ = 'g';
  res =
      JS_ToBoolFree_RC(ctx, LEPUS_GetPropertyStr(ctx, this_val, "ignoreCase"));
  if (res < 0) goto exception;
  if (res) *p++ = 'i';
  res = JS_ToBoolFree_RC(ctx, LEPUS_GetPropertyStr(ctx, this_val, "multiline"));
  if (res < 0) goto exception;
  if (res) *p++ = 'm';
  res = JS_ToBoolFree_RC(ctx, LEPUS_GetPropertyStr(ctx, this_val, "dotAll"));
  if (res < 0) goto exception;
  if (res) *p++ = 's';
  res = JS_ToBoolFree_RC(ctx, JS_GetPropertyInternal_RC(
                                  ctx, this_val, JS_ATOM_unicode, this_val, 0));
  if (res < 0) goto exception;
  if (res) *p++ = 'u';
  res = JS_ToBoolFree_RC(ctx, LEPUS_GetPropertyStr(ctx, this_val, "sticky"));
  if (res < 0) goto exception;
  if (res) *p++ = 'y';
  return LEPUS_NewStringLen(ctx, str, p - str);

exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_regexp_toString(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue pattern, flags;
  StringBuffer b_s, *b = &b_s;

  if (!LEPUS_IsObject(this_val)) return JS_ThrowTypeErrorNotAnObject(ctx);

  string_buffer_init(ctx, b, 0);
  string_buffer_putc8(b, '/');
  pattern =
      JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_source, this_val, 0);
  if (string_buffer_concat_value_free(b, pattern)) goto fail;
  string_buffer_putc8(b, '/');
  flags = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_flags, this_val, 0);
  if (string_buffer_concat_value_free(b, flags)) goto fail;
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  return js_check_stack_overflow(ctx, alloca_size);
}

void *lre_realloc(void *opaque, void *ptr, size_t size) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  /* No LEPUS exception is raised here */
  return lepus_realloc_rt(ctx->rt, ptr, size);
}

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
QJS_STATIC void js_clear_regexp_caputre_property(LEPUSContext *ctx,
                                                 LEPUSValue constructor,
                                                 uint32_t caputre_count) {
  if (LEPUS_IsUndefined(constructor) || LEPUS_IsException(constructor)) return;
  char regexp_capture_name[] = {'$', '0', 0};
  LEPUSValue null_string = LEPUS_NewString(ctx, "");
  uint32_t i;

  int32_t prop_flags = LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE;
  if (caputre_count == 0) {
    JS_DefinePropertyValueStr_RC(ctx, constructor, "$&",
                                 LEPUS_DupValue(ctx, null_string), prop_flags);
    caputre_count = 1;
  }

  for (i = caputre_count, regexp_capture_name[1] += i; i < 10;
       ++i, ++regexp_capture_name[1]) {
    JS_DefinePropertyValueStr_RC(ctx, constructor, regexp_capture_name,
                                 LEPUS_DupValue(ctx, null_string), prop_flags);
  }
  LEPUS_FreeValue(ctx, null_string);
}
#endif

QJS_STATIC LEPUSValue js_regexp_exec(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
  JSString *str;
  LEPUSValue str_val, obj, val, groups = LEPUS_UNDEFINED;
  uint8_t *re_bytecode;
  int ret;
  uint8_t **capture, *str_buf;
  int capture_count, shift, i, re_flags;
  int64_t last_index;
  const char *group_name_ptr;
  LEPUSValue regexp_obj = LEPUS_UNDEFINED;

  if (!re) return LEPUS_EXCEPTION;
  str_val = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str_val)) return str_val;
  val =
      JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex, this_val, 0);
  if (LEPUS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val)) {
    LEPUS_FreeValue(ctx, str_val);
    return LEPUS_EXCEPTION;
  }
  re_bytecode = re->bytecode->u.str8;
  re_flags = lre_get_flags(re_bytecode);
  if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
    last_index = 0;
  }
  str = LEPUS_VALUE_GET_STRING(str_val);
  capture_count = lre_get_capture_count(re_bytecode);
  capture = NULL;
  if (capture_count > 0) {
    capture = static_cast<uint8_t **>(
        lepus_malloc(ctx, sizeof(capture[0]) * capture_count * 2));
    if (!capture) {
      LEPUS_FreeValue(ctx, str_val);
      return LEPUS_EXCEPTION;
    }
  }
  shift = str->is_wide_char;
  str_buf = str->u.str8;
  if (last_index > str->len) {
    ret = 2;
  } else {
    ret = lre_exec(capture, re_bytecode, str_buf, last_index, str->len, shift,
                   ctx);
  }
  obj = LEPUS_NULL;
  if (ret != 1) {
    if (ret >= 0) {
      if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
        if (JS_SetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex,
                                      LEPUS_NewInt32(ctx, 0),
                                      LEPUS_PROP_THROW) < 0)
          goto fail;
      }
    } else {
      LEPUS_ThrowInternalError(ctx, "out of memory in regexp execution");
      goto fail;
    }
    LEPUS_FreeValue(ctx, str_val);
  } else {
    int prop_flags;
    if (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) {
      if (JS_SetPropertyInternal_RC(
              ctx, this_val, JS_ATOM_lastIndex,
              LEPUS_NewInt32(ctx, (capture[1] - str_buf) >> shift),
              LEPUS_PROP_THROW) < 0)
        goto fail;
    }
    obj = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(obj)) goto fail;
    prop_flags = LEPUS_PROP_C_W_E | LEPUS_PROP_THROW;
    group_name_ptr = NULL;
    if (re_flags & LRE_FLAG_NAMED_GROUPS) {
      uint32_t re_bytecode_len;
      groups = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
      if (LEPUS_IsException(groups)) goto fail;
      re_bytecode_len = get_u32(re_bytecode + 3);
      group_name_ptr = (char *)(re_bytecode + 7 + re_bytecode_len);
    }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
    static constexpr const char *regexp_capture_name[] = {
        "$&", "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9"};
    regexp_obj = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_constructor,
                                           this_val, 0);
    bool regexp_invalid =
        LEPUS_IsUndefined(regexp_obj) || LEPUS_IsException(regexp_obj);
#endif

    for (i = 0; i < capture_count; i++) {
      int start, end;
      LEPUSValue val;
      if (capture[2 * i] == NULL || capture[2 * i + 1] == NULL) {
        val = LEPUS_UNDEFINED;
      } else {
        start = (capture[2 * i] - str_buf) >> shift;
        end = (capture[2 * i + 1] - str_buf) >> shift;
        val = js_sub_string(ctx, str, start, end);
        if (LEPUS_IsException(val)) goto fail;
      }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
      if (!regexp_invalid &&
          i < (sizeof(regexp_capture_name) / sizeof(regexp_capture_name[0]))) {
        JS_DefinePropertyValueStr_RC(ctx, regexp_obj, regexp_capture_name[i],
                                     LEPUS_DupValue(ctx, val), prop_flags);
      }
#endif

      if (group_name_ptr && i > 0) {
        if (*group_name_ptr) {
          if (JS_DefinePropertyValueStr_RC(ctx, groups, group_name_ptr,
                                           LEPUS_DupValue(ctx, val),
                                           prop_flags) < 0) {
            LEPUS_FreeValue(ctx, val);
            goto fail;
          }
        }
        group_name_ptr += strlen(group_name_ptr) + 1;
      }
      if (JS_DefinePropertyValueUint32_RC(ctx, obj, i, val, prop_flags) < 0)
        goto fail;
    }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
    js_clear_regexp_caputre_property(ctx, regexp_obj, capture_count);
#endif

    if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_groups, groups,
                                  prop_flags) < 0)
      goto fail;
    if (JS_DefinePropertyValue_RC(
            ctx, obj, JS_ATOM_index,
            LEPUS_NewInt32(ctx, (capture[0] - str_buf) >> shift),
            prop_flags) < 0)
      goto fail;
    if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_input, str_val,
                                  prop_flags) < 0)
      goto fail1;
  }
  LEPUS_FreeValue(ctx, regexp_obj);
  lepus_free(ctx, capture);
  return obj;
fail:
  LEPUS_FreeValue(ctx, regexp_obj);
  LEPUS_FreeValue(ctx, groups);
  LEPUS_FreeValue(ctx, str_val);
fail1:
  LEPUS_FreeValue(ctx, obj);
  lepus_free(ctx, capture);
  return LEPUS_EXCEPTION;
}

/* delete partions of a string that match a given regex */
QJS_STATIC LEPUSValue JS_RegExpDelete(LEPUSContext *ctx,
                                      LEPUSValueConst this_val,
                                      LEPUSValueConst arg) {
  JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
  JSString *str;
  LEPUSValue str_val, val;
  uint8_t *re_bytecode;
  int ret;
  uint8_t **capture, *str_buf;
  int capture_count, shift, re_flags;
  int next_src_pos, start, end;
  int64_t last_index;
  StringBuffer b_s, *b = &b_s;

  if (!re) return LEPUS_EXCEPTION;

  string_buffer_init(ctx, b, 0);

  capture = NULL;
  str_val = JS_ToString_RC(ctx, arg);
  if (LEPUS_IsException(str_val)) goto fail;
  str = LEPUS_VALUE_GET_STRING(str_val);
  re_bytecode = re->bytecode->u.str8;
  re_flags = lre_get_flags(re_bytecode);
  if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
    last_index = 0;
  } else {
    val = JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex, this_val,
                                    0);
    if (LEPUS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val))
      goto fail;
  }
  capture_count = lre_get_capture_count(re_bytecode);
  if (capture_count > 0) {
    capture = static_cast<uint8_t **>(
        lepus_malloc(ctx, sizeof(capture[0]) * capture_count * 2));
    if (!capture) goto fail;
  }
  shift = str->is_wide_char;
  str_buf = str->u.str8;
  next_src_pos = 0;
  for (;;) {
    if (last_index > str->len) break;

    ret = lre_exec(capture, re_bytecode, str_buf, last_index, str->len, shift,
                   ctx);
    if (ret != 1) {
      if (ret >= 0) {
        if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
          if (JS_SetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex,
                                        LEPUS_NewInt32(ctx, 0),
                                        LEPUS_PROP_THROW) < 0)
            goto fail;
        }
      } else {
        LEPUS_ThrowInternalError(ctx, "out of memory in regexp execution");
        goto fail;
      }
      break;
    }
    start = (capture[0] - str_buf) >> shift;
    end = (capture[1] - str_buf) >> shift;
    last_index = end;
    if (next_src_pos < start) {
      if (string_buffer_concat(b, str, next_src_pos, start)) goto fail;
    }
    next_src_pos = end;
    if (!(re_flags & LRE_FLAG_GLOBAL)) {
      if (JS_SetPropertyInternal_RC(ctx, this_val, JS_ATOM_lastIndex,
                                    LEPUS_NewInt32(ctx, end),
                                    LEPUS_PROP_THROW) < 0)
        goto fail;
      break;
    }
    if (end == start) {
      if (!(re_flags & LRE_FLAG_UTF16) || (unsigned)end >= str->len ||
          !str->is_wide_char) {
        end++;
      } else {
        string_getc(str, &end);
      }
    }
    last_index = end;
  }
  if (string_buffer_concat(b, str, next_src_pos, str->len)) goto fail;
  LEPUS_FreeValue(ctx, str_val);
  lepus_free(ctx, capture);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, str_val);
  lepus_free(ctx, capture);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue JS_RegExpExec(LEPUSContext *ctx, LEPUSValueConst r,
                                    LEPUSValueConst s) {
  LEPUSValue method, ret;

  method = JS_GetPropertyInternal_RC(ctx, r, JS_ATOM_exec, r, 0);
  if (LEPUS_IsException(method)) return method;
  if (LEPUS_IsFunction(ctx, method)) {
    ret = JS_CallFree(ctx, method, r, 1, &s);
    if (LEPUS_IsException(ret)) return ret;
    if (!LEPUS_IsObject(ret) && !LEPUS_IsNull(ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(
          ctx, "RegExp exec method must return an object or null");
    }
    return ret;
  }
  LEPUS_FreeValue(ctx, method);
  return js_regexp_exec(ctx, r, 1, &s);
}

#if 0
static LEPUSValue js_regexp___RegExpExec(LEPUSContext *ctx, LEPUSValueConst this_val,
                                      int argc, LEPUSValueConst *argv)
{
    return JS_RegExpExec(ctx, argv[0], argv[1]);
}
static LEPUSValue js_regexp___RegExpDelete(LEPUSContext *ctx, LEPUSValueConst this_val,
                                        int argc, LEPUSValueConst *argv)
{
    return JS_RegExpDelete(ctx, argv[0], argv[1]);
}
#endif

QJS_STATIC LEPUSValue js_regexp_test(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  LEPUSValue val;
  BOOL ret;

  val = JS_RegExpExec(ctx, this_val, argv[0]);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
  ret = !LEPUS_IsNull(val);
  LEPUS_FreeValue(ctx, val);
  return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue js_regexp_Symbol_match(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  // [Symbol.match](str)
  LEPUSValueConst rx = this_val;
  LEPUSValue A, S, result, matchStr;
  int global, n, fullUnicode, isEmpty;
  JSString *p;

  if (!LEPUS_IsObject(rx)) return JS_ThrowTypeErrorNotAnObject(ctx);

  A = LEPUS_UNDEFINED;
  result = LEPUS_UNDEFINED;
  matchStr = LEPUS_UNDEFINED;
  S = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(S)) goto exception;

  global = JS_ToBoolFree_RC(
      ctx, JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_global, rx, 0));
  if (global < 0) goto exception;

  if (!global) {
    A = JS_RegExpExec(ctx, rx, S);
  } else {
    fullUnicode = JS_ToBoolFree_RC(
        ctx, JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_unicode, rx, 0));
    if (fullUnicode < 0) goto exception;

    if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex,
                                  LEPUS_NewInt32(ctx, 0), LEPUS_PROP_THROW) < 0)
      goto exception;
    A = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(A)) goto exception;
    n = 0;
    for (;;) {
      LEPUS_FreeValue(ctx, result);
      result = JS_RegExpExec(ctx, rx, S);
      if (LEPUS_IsException(result)) goto exception;
      if (LEPUS_IsNull(result)) break;
      matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
      if (LEPUS_IsException(matchStr)) goto exception;
      isEmpty = JS_IsEmptyString(matchStr);
      if (LEPUS_SetPropertyInt64(ctx, A, n++, matchStr) < 0) goto exception;
      if (isEmpty) {
        int64_t thisIndex, nextIndex;
        if (JS_ToLengthFree(ctx, &thisIndex,
                            JS_GetPropertyInternal_RC(
                                ctx, rx, JS_ATOM_lastIndex, rx, 0)) < 0)
          goto exception;
        p = LEPUS_VALUE_GET_STRING(S);
        nextIndex = thisIndex + 1;
        if (thisIndex < p->len)
          nextIndex = string_advance_index(p, thisIndex, fullUnicode);
        if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex,
                                      LEPUS_NewInt64(ctx, nextIndex),
                                      LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
    if (n == 0) {
      LEPUS_FreeValue(ctx, A);
      A = LEPUS_NULL;
    }
  }
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, S);
  return A;

exception:
  LEPUS_FreeValue(ctx, A);
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, S);
  return LEPUS_EXCEPTION;
}

typedef struct JSRegExpStringIteratorData {
  LEPUSValue iterating_regexp;
  LEPUSValue iterated_string;
  BOOL global;
  BOOL unicode;
  BOOL done;
} JSRegExpStringIteratorData;

QJS_STATIC void js_regexp_string_iterator_finalizer(LEPUSRuntime *rt,
                                                    LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
  if (it) {
    LEPUS_FreeValueRT(rt, it->iterating_regexp);
    LEPUS_FreeValueRT(rt, it->iterated_string);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void js_regexp_string_iterator_mark(LEPUSRuntime *rt,
                                               LEPUSValueConst val,
                                               LEPUS_MarkFunc *mark_func,
                                               int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
  if (it) {
    JS_MarkValue_RC(rt, it->iterating_regexp, mark_func);
    JS_MarkValue_RC(rt, it->iterated_string, mark_func);
  }
}

QJS_STATIC LEPUSValue js_regexp_string_iterator_next(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv,
                                                     BOOL *pdone, int magic) {
  JSRegExpStringIteratorData *it;
  LEPUSValueConst R, S;
  LEPUSValue matchStr = LEPUS_UNDEFINED, match = LEPUS_UNDEFINED;
  JSString *sp;

  it = static_cast<JSRegExpStringIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_REGEXP_STRING_ITERATOR));
  if (!it) goto exception;
  if (it->done) {
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }
  R = it->iterating_regexp;
  S = it->iterated_string;
  match = JS_RegExpExec(ctx, R, S);
  if (LEPUS_IsException(match)) goto exception;
  if (LEPUS_IsNull(match)) {
    it->done = TRUE;
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  } else if (it->global) {
    matchStr = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, match, 0));
    if (LEPUS_IsException(matchStr)) goto exception;
    if (JS_IsEmptyString(matchStr)) {
      int64_t thisIndex, nextIndex;
      if (JS_ToLengthFree(
              ctx, &thisIndex,
              JS_GetPropertyInternal_RC(ctx, R, JS_ATOM_lastIndex, R, 0)) < 0)
        goto exception;
      sp = LEPUS_VALUE_GET_STRING(S);
      nextIndex = string_advance_index(sp, thisIndex, it->unicode);
      if (JS_SetPropertyInternal_RC(ctx, R, JS_ATOM_lastIndex,
                                    LEPUS_NewInt32(ctx, nextIndex),
                                    LEPUS_PROP_THROW) < 0)
        goto exception;
    }
    LEPUS_FreeValue(ctx, matchStr);
  } else {
    it->done = TRUE;
  }
  *pdone = FALSE;
  return match;
exception:
  LEPUS_FreeValue(ctx, match);
  LEPUS_FreeValue(ctx, matchStr);
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_regexp_Symbol_matchAll(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  // [Symbol.matchAll](str)
  LEPUSValueConst R = this_val;
  LEPUSValue S, C, flags, matcher, iter;
  LEPUSValueConst args[2];
  JSString *strp;
  int64_t lastIndex;
  JSRegExpStringIteratorData *it;

  if (!LEPUS_IsObject(R)) return JS_ThrowTypeErrorNotAnObject(ctx);

  C = LEPUS_UNDEFINED;
  flags = LEPUS_UNDEFINED;
  matcher = LEPUS_UNDEFINED;
  iter = LEPUS_UNDEFINED;

  S = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(S)) goto exception;
  C = JS_SpeciesConstructor(ctx, R, ctx->regexp_ctor);
  if (LEPUS_IsException(C)) goto exception;
  flags = JS_ToStringFree(
      ctx, JS_GetPropertyInternal_RC(ctx, R, JS_ATOM_flags, R, 0));
  if (LEPUS_IsException(flags)) goto exception;
  args[0] = R;
  args[1] = flags;
  matcher = LEPUS_CallConstructor(ctx, C, 2, args);
  if (LEPUS_IsException(matcher)) goto exception;
  if (JS_ToLengthFree(
          ctx, &lastIndex,
          JS_GetPropertyInternal_RC(ctx, R, JS_ATOM_lastIndex, R, 0)))
    goto exception;
  if (JS_SetPropertyInternal_RC(ctx, matcher, JS_ATOM_lastIndex,
                                LEPUS_NewInt32(ctx, lastIndex),
                                LEPUS_PROP_THROW) < 0)
    goto exception;

  iter = LEPUS_NewObjectClass(ctx, JS_CLASS_REGEXP_STRING_ITERATOR);
  if (LEPUS_IsException(iter)) goto exception;
  it =
      static_cast<JSRegExpStringIteratorData *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) goto exception;
  it->iterating_regexp = matcher;
  it->iterated_string = S;
  strp = LEPUS_VALUE_GET_STRING(flags);
  it->global = string_indexof_char(strp, 'g', 0) >= 0;
  it->unicode = string_indexof_char(strp, 'u', 0) >= 0;
  it->done = FALSE;
  LEPUS_SetOpaque(iter, it);

  LEPUS_FreeValue(ctx, C);
  LEPUS_FreeValue(ctx, flags);
  return iter;
exception:
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, C);
  LEPUS_FreeValue(ctx, flags);
  LEPUS_FreeValue(ctx, matcher);
  LEPUS_FreeValue(ctx, iter);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int value_buffer_init(LEPUSContext *ctx, ValueBuffer *b) {
  b->ctx = ctx;
  b->len = 0;
  b->size = 4;
  b->error_status = 0;
  b->arr = b->def;
  return 0;
}

QJS_STATIC void value_buffer_free(ValueBuffer *b) {
  while (b->len > 0) LEPUS_FreeValue(b->ctx, b->arr[--b->len]);
  if (b->arr != b->def) lepus_free(b->ctx, b->arr);
  b->arr = b->def;
  b->size = 4;
}

QJS_STATIC int value_buffer_append(ValueBuffer *b, LEPUSValue val) {
  if (b->error_status) return -1;

  if (b->len >= b->size) {
    int new_size = (b->len + (b->len >> 1) + 31) & ~16;
    size_t slack;
    LEPUSValue *new_arr;

    if (b->arr == b->def) {
      new_arr = static_cast<LEPUSValue *>(
          lepus_realloc2(b->ctx, NULL, sizeof(*b->arr) * new_size, &slack));
      if (new_arr) memcpy(new_arr, b->def, sizeof b->def);
    } else {
      new_arr = static_cast<LEPUSValue *>(
          lepus_realloc2(b->ctx, b->arr, sizeof(*b->arr) * new_size, &slack));
    }
    if (!new_arr) {
      value_buffer_free(b);
      LEPUS_FreeValue(b->ctx, val);
      b->error_status = -1;
      return -1;
    }
    new_size += slack / sizeof(*new_arr);
    b->arr = new_arr;
    b->size = new_size;
  }
  b->arr[b->len++] = val;
  return 0;
}

QJS_STATIC int js_is_standard_regexp(LEPUSContext *ctx, LEPUSValueConst rx) {
  LEPUSValue val;
  int res;

  val = JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_constructor, rx, 0);
  if (LEPUS_IsException(val)) return -1;
  // rx.constructor === RegExp
  res = js_same_value(ctx, val, ctx->regexp_ctor);
  LEPUS_FreeValue(ctx, val);
  if (res) {
    val = JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_exec, rx, 0);
    if (LEPUS_IsException(val)) return -1;
    // rx.exec === RE_exec
    res = JS_IsCFunction(ctx, val, js_regexp_exec, 0);
    LEPUS_FreeValue(ctx, val);
  }
  return res;
}

QJS_STATIC LEPUSValue js_regexp_Symbol_replace(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  // [Symbol.replace](str, rep)
  LEPUSValueConst rx = this_val, rep = argv[1];
  LEPUSValueConst args[6];
  LEPUSValue str, rep_val, matched, tab, rep_str, namedCaptures, res;
  JSString *sp, *rp;
  StringBuffer b_s, *b = &b_s;
  ValueBuffer v_b, *results = &v_b;
  int nextSourcePosition, n, j, functionalReplace, is_global, fullUnicode;
  uint32_t nCaptures;
  int64_t position;

  if (!LEPUS_IsObject(rx)) return JS_ThrowTypeErrorNotAnObject(ctx);

  string_buffer_init(ctx, b, 0);
  value_buffer_init(ctx, results);

  rep_val = LEPUS_UNDEFINED;
  matched = LEPUS_UNDEFINED;
  tab = LEPUS_UNDEFINED;
  rep_str = LEPUS_UNDEFINED;
  namedCaptures = LEPUS_UNDEFINED;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;

  sp = LEPUS_VALUE_GET_STRING(str);
  rp = NULL;
  functionalReplace = LEPUS_IsFunction(ctx, rep);
  if (!functionalReplace) {
    rep_val = JS_ToString_RC(ctx, rep);
    if (LEPUS_IsException(rep_val)) goto exception;
    rp = LEPUS_VALUE_GET_STRING(rep_val);
  }
  fullUnicode = 0;
  is_global = JS_ToBoolFree_RC(
      ctx, JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_global, rx, 0));
  if (is_global < 0) goto exception;
  if (is_global) {
    fullUnicode = JS_ToBoolFree_RC(
        ctx, JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_unicode, rx, 0));
    if (fullUnicode < 0) goto exception;
    if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex,
                                  LEPUS_NewInt32(ctx, 0), LEPUS_PROP_THROW) < 0)
      goto exception;
  }

  if (rp && rp->len == 0 && is_global && js_is_standard_regexp(ctx, rx)) {
    /* use faster version for simple cases */
    res = JS_RegExpDelete(ctx, rx, str);
    goto done;
  }
  for (;;) {
    LEPUSValue result;
    result = JS_RegExpExec(ctx, rx, str);
    if (LEPUS_IsException(result)) goto exception;
    if (LEPUS_IsNull(result)) break;
    if (value_buffer_append(results, result) < 0) goto exception;
    if (!is_global) break;
    LEPUS_FreeValue(ctx, matched);
    matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
    if (LEPUS_IsException(matched)) goto exception;
    if (JS_IsEmptyString(matched)) {
      /* always advance of at least one char */
      int64_t thisIndex, nextIndex;
      if (JS_ToLengthFree(
              ctx, &thisIndex,
              JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex, rx, 0)) < 0)
        goto exception;
      nextIndex = string_advance_index(sp, thisIndex, fullUnicode);
      if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex,
                                    LEPUS_NewInt32(ctx, nextIndex),
                                    LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  nextSourcePosition = 0;
  for (j = 0; j < results->len; j++) {
    LEPUSValueConst result;
    result = results->arr[j];
    if (lepus_get_length32(ctx, &nCaptures, result) < 0) goto exception;
    LEPUS_FreeValue(ctx, matched);
    matched = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, result, 0));
    if (LEPUS_IsException(matched)) goto exception;
    if (JS_ToLengthFree(
            ctx, &position,
            JS_GetPropertyInternal_RC(ctx, result, JS_ATOM_index, result, 0)))
      goto exception;
    if (position > sp->len)
      position = sp->len;
    else if (position < 0)
      position = 0;
    /* ignore substition if going backward (can happen
       with custom regexp object) */
    LEPUS_FreeValue(ctx, tab);
    tab = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(tab)) goto exception;
    if (LEPUS_SetPropertyInt64(ctx, tab, 0, LEPUS_DupValue(ctx, matched)) < 0)
      goto exception;
    for (n = 1; n < nCaptures; n++) {
      LEPUSValue capN;
      capN = JS_GetPropertyInt64(ctx, result, n);
      if (LEPUS_IsException(capN)) goto exception;
      if (!LEPUS_IsUndefined(capN)) {
        capN = JS_ToStringFree(ctx, capN);
        if (LEPUS_IsException(capN)) goto exception;
      }
      if (LEPUS_SetPropertyInt64(ctx, tab, n, capN) < 0) goto exception;
    }
    LEPUS_FreeValue(ctx, namedCaptures);
    namedCaptures =
        JS_GetPropertyInternal_RC(ctx, result, JS_ATOM_groups, result, 0);
    if (LEPUS_IsException(namedCaptures)) goto exception;
    if (functionalReplace) {
      if (LEPUS_SetPropertyInt64(ctx, tab, n++, LEPUS_NewInt32(ctx, position)) <
          0)
        goto exception;
      if (LEPUS_SetPropertyInt64(ctx, tab, n++, LEPUS_DupValue(ctx, str)) < 0)
        goto exception;
      if (!LEPUS_IsUndefined(namedCaptures)) {
        if (LEPUS_SetPropertyInt64(ctx, tab, n++,
                                   LEPUS_DupValue(ctx, namedCaptures)) < 0)
          goto exception;
      }
      args[0] = LEPUS_UNDEFINED;
      args[1] = tab;
      LEPUS_FreeValue(ctx, rep_str);
      rep_str = JS_ToStringFree(ctx, js_function_apply(ctx, rep, 2, args, 0));
    } else {
      args[0] = matched;
      args[1] = str;
      args[2] = LEPUS_NewInt32(ctx, position);
      args[3] = tab;
      args[4] = namedCaptures;
      args[5] = rep_val;
      LEPUS_FreeValue(ctx, rep_str);
      rep_str = js_string___GetSubstitution(ctx, LEPUS_UNDEFINED, 6, args);
    }
    if (LEPUS_IsException(rep_str)) goto exception;
    if (position >= nextSourcePosition) {
      string_buffer_concat(b, sp, nextSourcePosition, position);
      string_buffer_concat_value(b, rep_str);
      nextSourcePosition = position + LEPUS_VALUE_GET_STRING(matched)->len;
    }
  }
  string_buffer_concat(b, sp, nextSourcePosition, sp->len);
  res = string_buffer_end(b);
  goto done1;

exception:
  res = LEPUS_EXCEPTION;
done:
  string_buffer_free(b);
done1:
  value_buffer_free(results);
  LEPUS_FreeValue(ctx, rep_val);
  LEPUS_FreeValue(ctx, matched);
  LEPUS_FreeValue(ctx, tab);
  LEPUS_FreeValue(ctx, rep_str);
  LEPUS_FreeValue(ctx, namedCaptures);
  LEPUS_FreeValue(ctx, str);
  return res;
}

QJS_STATIC LEPUSValue js_regexp_Symbol_search(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValueConst rx = this_val;
  LEPUSValue str, previousLastIndex, currentLastIndex, result, index;

  if (!LEPUS_IsObject(rx)) return JS_ThrowTypeErrorNotAnObject(ctx);

  result = LEPUS_UNDEFINED;
  currentLastIndex = LEPUS_UNDEFINED;
  previousLastIndex = LEPUS_UNDEFINED;
  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;

  previousLastIndex =
      JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex, rx, 0);
  if (LEPUS_IsException(previousLastIndex)) goto exception;

  if (!js_same_value(ctx, previousLastIndex, LEPUS_NewInt32(ctx, 0))) {
    if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex,
                                  LEPUS_NewInt32(ctx, 0),
                                  LEPUS_PROP_THROW) < 0) {
      goto exception;
    }
  }
  result = JS_RegExpExec(ctx, rx, str);
  if (LEPUS_IsException(result)) goto exception;
  currentLastIndex =
      JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex, rx, 0);
  if (LEPUS_IsException(currentLastIndex)) goto exception;
  if (js_same_value(ctx, currentLastIndex, previousLastIndex)) {
    LEPUS_FreeValue(ctx, previousLastIndex);
  } else {
    if (JS_SetPropertyInternal_RC(ctx, rx, JS_ATOM_lastIndex, previousLastIndex,
                                  LEPUS_PROP_THROW) < 0) {
      previousLastIndex = LEPUS_UNDEFINED;
      goto exception;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, currentLastIndex);

  if (LEPUS_IsNull(result)) {
    return LEPUS_NewInt32(ctx, -1);
  } else {
    index = JS_GetPropertyInternal_RC(ctx, result, JS_ATOM_index, result, 0);
    LEPUS_FreeValue(ctx, result);
    return index;
  }

exception:
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, currentLastIndex);
  LEPUS_FreeValue(ctx, previousLastIndex);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_regexp_Symbol_split(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  // [Symbol.split](str, limit)
  LEPUSValueConst rx = this_val;
  LEPUSValueConst args[2];
  LEPUSValue str, ctor, splitter, A, flags, z, sub;
  JSString *strp;
  uint32_t lim, size, p, q;
  int unicodeMatching;
  int64_t lengthA, e, numberOfCaptures, i;

  if (!LEPUS_IsObject(rx)) return JS_ThrowTypeErrorNotAnObject(ctx);

  ctor = LEPUS_UNDEFINED;
  splitter = LEPUS_UNDEFINED;
  A = LEPUS_UNDEFINED;
  flags = LEPUS_UNDEFINED;
  z = LEPUS_UNDEFINED;
  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;
  ctor = JS_SpeciesConstructor(ctx, rx, ctx->regexp_ctor);
  if (LEPUS_IsException(ctor)) goto exception;
  flags = JS_ToStringFree(
      ctx, JS_GetPropertyInternal_RC(ctx, rx, JS_ATOM_flags, rx, 0));
  if (LEPUS_IsException(flags)) goto exception;
  strp = LEPUS_VALUE_GET_STRING(flags);
  unicodeMatching = string_indexof_char(strp, 'u', 0) >= 0;
  if (string_indexof_char(strp, 'y', 0) < 0) {
    flags = JS_ConcatString3(ctx, "", flags, "y");
    if (LEPUS_IsException(flags)) goto exception;
  }
  args[0] = rx;
  args[1] = flags;
  splitter = LEPUS_CallConstructor(ctx, ctor, 2, args);
  if (LEPUS_IsException(splitter)) goto exception;
  A = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(A)) goto exception;
  lengthA = 0;
  if (LEPUS_IsUndefined(argv[1])) {
    lim = 0xffffffff;
  } else {
    if (LEPUS_ToUint32(ctx, &lim, argv[1]) < 0) goto exception;
    if (lim == 0) goto done;
  }
  strp = LEPUS_VALUE_GET_STRING(str);
  p = q = 0;
  size = strp->len;
  if (size == 0) {
    z = JS_RegExpExec(ctx, splitter, str);
    if (LEPUS_IsException(z)) goto exception;
    if (LEPUS_IsNull(z)) goto add_tail;
    goto done;
  }
  while (q < size) {
    if (JS_SetPropertyInternal_RC(ctx, splitter, JS_ATOM_lastIndex,
                                  LEPUS_NewInt32(ctx, q), LEPUS_PROP_THROW) < 0)
      goto exception;
    LEPUS_FreeValue(ctx, z);
    z = JS_RegExpExec(ctx, splitter, str);
    if (LEPUS_IsException(z)) goto exception;
    if (LEPUS_IsNull(z)) {
      q = string_advance_index(strp, q, unicodeMatching);
    } else {
      if (JS_ToLengthFree(ctx, &e,
                          JS_GetPropertyInternal_RC(
                              ctx, splitter, JS_ATOM_lastIndex, splitter, 0)))
        goto exception;
      if (e > size) e = size;
      if (e == p) {
        q = string_advance_index(strp, q, unicodeMatching);
      } else {
        sub = js_sub_string(ctx, strp, p, q);
        if (LEPUS_IsException(sub)) goto exception;
        if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0) goto exception;
        if (lengthA == lim) goto done;
        p = e;
        if (js_get_length64(ctx, &numberOfCaptures, z)) goto exception;
        for (i = 1; i < numberOfCaptures; i++) {
          sub = JS_GetPropertyInt64(ctx, z, i);
          if (LEPUS_IsException(sub)) goto exception;
          if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0)
            goto exception;
          if (lengthA == lim) goto done;
        }
        q = p;
      }
    }
  }
add_tail:
  if (p > size) p = size;
  sub = js_sub_string(ctx, strp, p, size);
  if (LEPUS_IsException(sub)) goto exception;
  if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0) goto exception;
  goto done;
exception:
  LEPUS_FreeValue(ctx, A);
  A = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, ctor);
  LEPUS_FreeValue(ctx, splitter);
  LEPUS_FreeValue(ctx, flags);
  LEPUS_FreeValue(ctx, z);
  return A;
}

static const LEPUSCFunctionListEntry js_regexp_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
    // LEPUS_CFUNC_DEF("__RegExpExec", 2, js_regexp___RegExpExec ),
    // LEPUS_CFUNC_DEF("__RegExpDelete", 2, js_regexp___RegExpDelete ),
};

static const LEPUSCFunctionListEntry js_regexp_proto_funcs[] = {
    LEPUS_CGETSET_DEF("flags", js_regexp_get_flags, NULL),
    LEPUS_CGETSET_DEF("source", js_regexp_get_source, NULL),
    LEPUS_CGETSET_MAGIC_DEF("global", js_regexp_get_flag, NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("ignoreCase", js_regexp_get_flag, NULL, 2),
    LEPUS_CGETSET_MAGIC_DEF("multiline", js_regexp_get_flag, NULL, 4),
    LEPUS_CGETSET_MAGIC_DEF("dotAll", js_regexp_get_flag, NULL, 8),
    LEPUS_CGETSET_MAGIC_DEF("unicode", js_regexp_get_flag, NULL, 16),
    LEPUS_CGETSET_MAGIC_DEF("sticky", js_regexp_get_flag, NULL, 32),
    LEPUS_CFUNC_DEF("exec", 1, js_regexp_exec),
    LEPUS_CFUNC_DEF("compile", 2, js_regexp_compile),
    LEPUS_CFUNC_DEF("test", 1, js_regexp_test),
    LEPUS_CFUNC_DEF("toString", 0, js_regexp_toString),
    LEPUS_CFUNC_DEF("[Symbol.replace]", 2, js_regexp_Symbol_replace),
    LEPUS_CFUNC_DEF("[Symbol.match]", 1, js_regexp_Symbol_match),
    LEPUS_CFUNC_DEF("[Symbol.matchAll]", 1, js_regexp_Symbol_matchAll),
    LEPUS_CFUNC_DEF("[Symbol.search]", 1, js_regexp_Symbol_search),
    LEPUS_CFUNC_DEF("[Symbol.split]", 2, js_regexp_Symbol_split),
    // LEPUS_CGETSET_DEF("__source", js_regexp_get___source, NULL ),
    // LEPUS_CGETSET_DEF("__flags", js_regexp_get___flags, NULL ),
};

static const LEPUSCFunctionListEntry js_regexp_string_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, js_regexp_string_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "RegExp String Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

void LEPUS_AddIntrinsicRegExpCompiler(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicRegExpCompiler_GC, ctx);
  ctx->compile_regexp = js_compile_regexp;
}

void LEPUS_AddIntrinsicRegExp(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicRegExp_GC, ctx);
  LEPUSValueConst obj;

  LEPUS_AddIntrinsicRegExpCompiler(ctx);

  ctx->class_proto[JS_CLASS_REGEXP] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_REGEXP],
                                js_regexp_proto_funcs,
                                countof(js_regexp_proto_funcs));
  obj = JS_NewGlobalCConstructor(ctx, "RegExp", js_regexp_constructor, 2,
                                 ctx->class_proto[JS_CLASS_REGEXP]);
  ctx->regexp_ctor = LEPUS_DupValue(ctx, obj);

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
  js_clear_regexp_caputre_property(ctx, obj, 0);
#endif

  LEPUS_SetPropertyFunctionList(ctx, obj, js_regexp_funcs,
                                countof(js_regexp_funcs));

  ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[JS_CLASS_REGEXP_STRING_ITERATOR],
      js_regexp_string_iterator_proto_funcs,
      countof(js_regexp_string_iterator_proto_funcs));
}

#define JSON_TYPE_MASK ((uint8_t)0x07)
#define JSON_SUBTYPE_MASK ((uint8_t)0x18)
#define JSON_TAG_MASK ((uint8_t)0xFF)
#define JSON_TAG_BIT ((uint8_t)8)
#define JSON_TYPE_BIT ((uint8_t)3)

#define JSON_TYPE_NULL ((uint8_t)2)
#define JSON_TYPE_BOOL ((uint8_t)3)
#define JSON_TYPE_NUM ((uint8_t)4)
#define JSON_TYPE_STR ((uint8_t)5)
#define JSON_TYPE_ARR ((uint8_t)6)
#define JSON_TYPE_OBJ ((uint8_t)7)

#define JSON_SUBTYPE_FALSE ((uint8_t)(0 << 3)) /* ___00___ */
#define JSON_SUBTYPE_TRUE ((uint8_t)(1 << 3))  /* ___01___ */
#define JSON_SUBTYPE_SINT ((uint8_t)(1 << 3))  /* ___01___ */
#define JSON_SUBTYPE_REAL ((uint8_t)(2 << 3))  /* ___10___ */

#define USIZE_MAX ((size_t)(~(size_t)0))
#define U64_MAX U64(0xFFFFFFFF, 0xFFFFFFFF)

#define repeat16_incr(x)                                                      \
  {                                                                           \
    x(0) x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(9) x(10) x(11) x(12) x(13) \
        x(14) x(15)                                                           \
  }

typedef struct v16 {
  char c1, c2;
} v16;

typedef union v16_uni {
  v16 v;
  uint16_t u;
} v16_uni;

typedef struct v32 {
  char c1, c2, c3, c4;
} v32;

typedef union v32_uni {
  v32 v;
  uint32_t u;
} v32_uni;

typedef struct v64 {
  char c1, c2, c3, c4, c5, c6, c7, c8;
} v64;

static force_inline uint32_t byte_load_4(const void *src) {
  v32_uni uni;
  uni.v = *(v32 *)src;
  return uni.u;
}

static force_inline void byte_move(void *dst, const void *src, size_t len) {
  memmove(dst, src, len);
}

static force_inline uint8_t unsafe_json_get_type(void *val) {
  uint8_t tag = (uint8_t)((json_val *)val)->tag;
  return (uint8_t)(tag & JSON_TYPE_MASK);
}

static force_inline uint8_t unsafe_json_get_tag(void *val) {
  uint8_t tag = (uint8_t)((json_val *)val)->tag;
  return (uint8_t)(tag & JSON_TAG_MASK);
}

static force_inline bool unsafe_json_get_bool(void *val) {
  uint8_t tag = unsafe_json_get_tag(val);
  return (bool)((tag & JSON_SUBTYPE_MASK) >> JSON_TYPE_BIT);
}

static force_inline bool unsafe_json_is_ctn(void *val) {
  uint8_t mask = JSON_TYPE_ARR & JSON_TYPE_OBJ;
  return (unsafe_json_get_tag(val) & mask) == mask;
}

static force_inline const char *unsafe_json_get_str(json_val *val) {
  return (const char *)(val->uni.str);
}

/* JSON */
#ifndef NO_QUICKJS_COMPILER
/* XXX: this parser is less strict than the JSON standard because we
   reuse the Javascript tokenizer. It could be improved by adding a
   specific JSON parse flag. */
#define JSON_READER_ESTIMATED_MINIFY_RATIO 6

struct json_obj_iter {
  size_t idx;    /**< current key index, from 0 */
  size_t max;    /**< maximum key index, idx < max */
  json_val *cur; /**< current key */
  json_val *obj; /**< the object being iterated */
};

struct json_arr_iter {
  size_t idx;    /**< current index, from 0 */
  size_t max;    /**< maximum index, idx < max */
  json_val *cur; /**< current value */
};

static const uint8_t hex_conv_table[256] = {
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0};

static force_inline bool read_hex_u16(const uint8_t *cur, uint16_t *val) {
  uint16_t c0, c1, c2, c3, t0, t1;
  c0 = hex_conv_table[cur[0]];
  c1 = hex_conv_table[cur[1]];
  c2 = hex_conv_table[cur[2]];
  c3 = hex_conv_table[cur[3]];
  t0 = (uint16_t)((c0 << 8) | c2);
  t1 = (uint16_t)((c1 << 8) | c3);
  *val = (uint16_t)((t0 << 4) | t1);
  return ((t0 | t1) & (uint16_t)0xF0F0) == 0;
}

static force_inline bool byte_match_2(void *buf, const char *pat) {
  v16_uni u1, u2;
  u1.v = *(const v16 *)pat;
  u2.v = *(const v16 *)buf;
  return u1.u == u2.u;
}

static force_inline bool char_is_ascii_stop(const uint8_t c) {
  if (c == '"' || c == '\\' || (c >= 0x00 && c <= 0x1F) ||
      (c >= 0x80 && c <= 0xFF)) {
    return true;
  } else {
    return false;
  }
}

#define CopyAsciiStopN(V) \
  V(1)                    \
  V(2)                    \
  V(3)                    \
  V(4)                    \
  V(5)                    \
  V(6)                    \
  V(7)                    \
  V(8)                    \
  V(9)                    \
  V(10)                   \
  V(11)                   \
  V(12)                   \
  V(13)                   \
  V(14)                   \
  V(15)

bool read_string(JSParseState *s, uint8_t **ptr, json_val *val) {
  /*
   Each unicode code point is encoded as 1 to 4 bytes in UTF-8 encoding,
   we use 4-byte mask and pattern value to validate UTF-8 byte sequence,
   this requires the input data to have 4-byte zero padding.
   ---------------------------------------------------
   1 byte
   unicode range [U+0000, U+007F]
   unicode min   [.......0]
   unicode max   [.1111111]
   bit pattern   [0.......]
   ---------------------------------------------------
   2 byte
   unicode range [U+0080, U+07FF]
   unicode min   [......10 ..000000]
   unicode max   [...11111 ..111111]
   bit require   [...xxxx. ........] (1E 00)
   bit mask      [xxx..... xx......] (E0 C0)
   bit pattern   [110..... 10......] (C0 80)
   ---------------------------------------------------
   3 byte
   unicode range [U+0800, U+FFFF]
   unicode min   [........ ..100000 ..000000]
   unicode max   [....1111 ..111111 ..111111]
   bit require   [....xxxx ..x..... ........] (0F 20 00)
   bit mask      [xxxx.... xx...... xx......] (F0 C0 C0)
   bit pattern   [1110.... 10...... 10......] (E0 80 80)
   ---------------------------------------------------
   3 byte invalid (reserved for surrogate halves)
   unicode range [U+D800, U+DFFF]
   unicode min   [....1101 ..100000 ..000000]
   unicode max   [....1101 ..111111 ..111111]
   bit mask      [....xxxx ..x..... ........] (0F 20 00)
   bit pattern   [....1101 ..1..... ........] (0D 20 00)
   ---------------------------------------------------
   4 byte
   unicode range [U+10000, U+10FFFF]
   unicode min   [........ ...10000 ..000000 ..000000]
   unicode max   [.....100 ..001111 ..111111 ..111111]
   bit require   [.....xxx ..xx.... ........ ........] (07 30 00 00)
   bit mask      [xxxxx... xx...... xx...... xx......] (F8 C0 C0 C0)
   bit pattern   [11110... 10...... 10...... 10......] (F0 80 80 80)
   ---------------------------------------------------
   */
  v32_uni b1_mask_uni = {{(char)0x80, 0x00, 0x00, 0x00}};
  v32_uni b1_patt_uni = {{0x00, 0x00, 0x00, 0x00}};
  v32_uni b2_mask_uni = {{(char)0xE0, (char)0xC0, 0x00, 0x00}};
  v32_uni b2_patt_uni = {{(char)0xC0, (char)0x80, 0x00, 0x00}};
  v32_uni b2_requ_uni = {{(char)0x1E, 0x00, 0x00, 0x00}};
  v32_uni b3_mask_uni = {{(char)0xF0, (char)0xC0, (char)0xC0, 0x00}};
  v32_uni b3_patt_uni = {{(char)0xE0, (char)0x80, (char)0x80, 0x00}};
  v32_uni b3_requ_uni = {{(char)0x0F, (char)0x20, 0x00, 0x00}};
  v32_uni b3_erro_uni = {{(char)0x0D, (char)0x20, 0x00, 0x00}};
  v32_uni b4_mask_uni = {{(char)0xF8, (char)0xC0, (char)0xC0, (char)0xC0}};
  v32_uni b4_patt_uni = {{(char)0xF0, (char)0x80, (char)0x80, (char)0x80}};
  v32_uni b4_requ_uni = {{(char)0x07, (char)0x30, 0x00, 0x00}};
  v32_uni b4_err0_uni = {{(char)0x04, 0x00, 0x00, 0x00}};
  v32_uni b4_err1_uni = {{(char)0x03, (char)0x30, 0x00, 0x00}};
  uint32_t b1_mask = b1_mask_uni.u;
  uint32_t b1_patt = b1_patt_uni.u;
  uint32_t b2_mask = b2_mask_uni.u;
  uint32_t b2_patt = b2_patt_uni.u;
  uint32_t b2_requ = b2_requ_uni.u;
  uint32_t b3_mask = b3_mask_uni.u;
  uint32_t b3_patt = b3_patt_uni.u;
  uint32_t b3_requ = b3_requ_uni.u;
  uint32_t b3_erro = b3_erro_uni.u;
  uint32_t b4_mask = b4_mask_uni.u;
  uint32_t b4_patt = b4_patt_uni.u;
  uint32_t b4_requ = b4_requ_uni.u;
  uint32_t b4_err0 = b4_err0_uni.u;
  uint32_t b4_err1 = b4_err1_uni.u;

#define is_valid_seq_1(uni) (((uni & b1_mask) == b1_patt))

#define is_valid_seq_2(uni) (((uni & b2_mask) == b2_patt) && ((uni & b2_requ)))

#define is_valid_seq_3(uni)                                     \
  (((uni & b3_mask) == b3_patt) && ((tmp = (uni & b3_requ))) && \
   ((tmp != b3_erro)))

#define is_valid_seq_4(uni)                                     \
  (((uni & b4_mask) == b4_patt) && ((tmp = (uni & b4_requ))) && \
   ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0))

#define return_err(_end, _msg) \
  do {                         \
    js_parse_error(s, _msg);   \
    *end = _end;               \
    return false;              \
  } while (false)

  uint8_t *cur = *ptr;
  uint8_t **end = ptr;
  uint8_t *src = ++cur, *dst, *pos;
  uint16_t hi, lo;
  uint32_t uni, tmp;

skip_ascii:
  /* Most strings have no escaped characters, so we can jump them quickly. */
skip_ascii_begin:
#define expr_jump(i)                         \
  if (likely(!char_is_ascii_stop(src[i]))) { \
  } else                                     \
    goto skip_ascii_stop##i;

#define expr_stop(i)             \
  skip_ascii_stop##i : src += i; \
  goto skip_ascii_end;

  repeat16_incr(expr_jump);
  src += 16;
  goto skip_ascii_begin;
  repeat16_incr(expr_stop);

#undef expr_jump
#undef expr_stop

skip_ascii_end:
  if (likely(*src == '"')) {
    val->tag = ((uint64_t)(src - cur) << JSON_TAG_BIT) | JSON_TYPE_STR;
    val->uni.str = (const char *)cur;
    *src = '\0';
    *end = src + 1;
    return true;
  }

  if (*src & 0x80) { /* non-ASCII character */
    /*
     Non-ASCII character appears here, which means that the text is likely
     to be written in non-English or emoticons. According to some common
     data set statistics, byte sequences of the same length may appear
     consecutively. We process the byte sequences of the same length in each
     loop, which is more friendly to branch prediction.
     */
    pos = src;
    int adapt_size = 0;
    uni = byte_load_4(src);
    while (is_valid_seq_3(uni)) {
      src += 3;
      adapt_size += 2;
      uni = byte_load_4(src);
    }
    if (src > s->utf8_parse_front) {
      s->utf8_adapte_size += adapt_size;
      s->utf8_parse_front = src;
    }
    if (is_valid_seq_1(uni)) goto skip_ascii;

    adapt_size = 0;
    while (is_valid_seq_2(uni)) {
      src += 2;
      adapt_size += 1;
      uni = byte_load_4(src);
    }
    while (is_valid_seq_4(uni)) {
      src += 4;
      adapt_size += 3;
      uni = byte_load_4(src);
    }
    if (src > s->utf8_parse_front) {
      s->utf8_adapte_size += adapt_size;
      s->utf8_parse_front = src;
    }
    if (unlikely(pos == src)) {
      return_err(src, "invalid UTF-8 encoding in string");
    }
    goto skip_ascii;
  }

  /* The escape character appears, we need to copy it. */
  dst = src;
copy_escape:
  if (likely(*src == '\\')) {
    switch (*++src) {
      case '"':
        *dst++ = '"';
        src++;
        break;
      case '\\':
        *dst++ = '\\';
        src++;
        break;
      case '/':
        *dst++ = '/';
        src++;
        break;
      case 'b':
        *dst++ = '\b';
        src++;
        break;
      case 'f':
        *dst++ = '\f';
        src++;
        break;
      case 'n':
        *dst++ = '\n';
        src++;
        s->last_line_begin_ptr = s->line_begin_ptr;
        s->line_begin_ptr = src;
        s->func_call_adapte_size = -1;
        s->utf8_adapte_size = 0;
        s->line_num++;
        break;
      case 'r':
        *dst++ = '\r';
        src++;
        break;
      case 't':
        *dst++ = '\t';
        src++;
        break;
      case 'u':
        if (unlikely(!read_hex_u16(++src, &hi))) {
          return_err(src - 2, "invalid escaped unicode in string");
        }
        src += 4;
        if (likely((hi & 0xF800) != 0xD800)) {
          /* a BMP character */
          if (hi >= 0x800) {
            *dst++ = (uint8_t)(0xE0 | (hi >> 12));
            *dst++ = (uint8_t)(0x80 | ((hi >> 6) & 0x3F));
            *dst++ = (uint8_t)(0x80 | (hi & 0x3F));
          } else if (hi >= 0x80) {
            *dst++ = (uint8_t)(0xC0 | (hi >> 6));
            *dst++ = (uint8_t)(0x80 | (hi & 0x3F));
          } else {
            *dst++ = (uint8_t)hi;
          }
        } else {
          /* a non-BMP character, represented as a surrogate pair */
          if (unlikely((hi & 0xFC00) != 0xD800)) {
            return_err(src - 6, "invalid high surrogate in string");
          }
          if (unlikely(!byte_match_2(src, "\\u")) ||
              unlikely(!read_hex_u16(src + 2, &lo))) {
            return_err(src, "no matched low surrogate in string");
          }
          if (unlikely((lo & 0xFC00) != 0xDC00)) {
            return_err(src, "invalid low surrogate in string");
          }
          uni = ((((uint32_t)hi - 0xD800) << 10) | ((uint32_t)lo - 0xDC00)) +
                0x10000;
          *dst++ = (uint8_t)(0xF0 | (uni >> 18));
          *dst++ = (uint8_t)(0x80 | ((uni >> 12) & 0x3F));
          *dst++ = (uint8_t)(0x80 | ((uni >> 6) & 0x3F));
          *dst++ = (uint8_t)(0x80 | (uni & 0x3F));
          src += 6;
        }
        break;
      default:
        return_err(src, "invalid escaped character in string");
    }
  } else if (likely(*src == '"')) {
    val->tag = ((uint64_t)(dst - cur) << JSON_TAG_BIT) | JSON_TYPE_STR;
    val->uni.str = (const char *)cur;
    *dst = '\0';
    *end = src + 1;
    return true;
  } else {
    return_err(src, "unexpected control character in string");
  }

copy_ascii:
#define expr_jump(i)                           \
  if (likely(!(char_is_ascii_stop(src[i])))) { \
  } else {                                     \
    goto copy_ascii_stop_##i;                  \
  }
  repeat16_incr(expr_jump);
#undef expr_jump

  byte_move(dst, src, 16);
  src += 16;
  dst += 16;
  goto copy_ascii;

copy_ascii_stop_0:
  goto copy_utf8;
#define StopN(num)                                  \
  copy_ascii_stop_##num : byte_move(dst, src, num); \
  src += num;                                       \
  dst += num;                                       \
  goto copy_utf8;
  CopyAsciiStopN(StopN)
#undef StopN
      copy_utf8 : if (*src & 0x80) { /* non-ASCII character */
    pos = src;
    int adapt_size = 0;
    uni = byte_load_4(src);
    while (is_valid_seq_3(uni)) {
      byte_move(dst, src, 3);
      dst += 3;
      src += 3;
      adapt_size += 2;
      uni = byte_load_4(src);
    }
    if (src > s->utf8_parse_front) {
      s->last_utf8_adapte_size = s->utf8_adapte_size;
      s->utf8_adapte_size += adapt_size;
      s->utf8_parse_front = src;
    }
    if (is_valid_seq_1(uni)) goto copy_ascii;
    adapt_size = 0;
    while (is_valid_seq_2(uni)) {
      byte_move(dst, src, 2);
      dst += 2;
      src += 2;
      adapt_size += 1;
      uni = byte_load_4(src);
    }
    while (is_valid_seq_4(uni)) {
      byte_move(dst, src, 4);
      dst += 4;
      src += 4;
      adapt_size += 3;
      uni = byte_load_4(src);
    }
    if (src > s->utf8_parse_front) {
      s->last_utf8_adapte_size = s->utf8_adapte_size;
      s->utf8_adapte_size += adapt_size;
      s->utf8_parse_front = src;
    }
    if (unlikely(pos == src)) {
      return_err(src, "invalid UTF-8 encoding in string");
    }
    goto copy_ascii;
  }
  goto copy_escape;

#undef return_err
#undef is_valid_seq_1
#undef is_valid_seq_2
#undef is_valid_seq_3
#undef is_valid_seq_4
}

void parse_json_space(JSParseState *s, const uint8_t **cur) {
  s->buf_ptr = *cur;
  const uint8_t *p;
  int c;
  p = s->last_ptr = s->buf_ptr;
  s->got_lf = FALSE;
  s->last_line_num = s->token.line_num;
  s->debugger_last_line_num = s->last_line_num;
redo:
  s->token.line_num = s->line_num;
  s->token.ptr = p;
  c = *p;
  switch (c) {
    case '\r': /* accept DOS and MAC newline sequences */
      if (p[1] == '\n') {
        p++;
      }
      /* fall thru */
    case '\n':
      p++;
      s->last_ptr = p;
      s->got_lf = TRUE;
      s->last_line_begin_ptr = s->line_begin_ptr;
      s->line_begin_ptr = p;
      s->utf8_adapte_size = 0;
      s->func_call_adapte_size = -1;
      s->line_num++;
      s->debugger_last_line_num = s->line_num;
      goto redo;
    case ' ':
    case '\t':
      p++;
      s->last_ptr = p;
      goto redo;
    default:
      break;
  }
  s->buf_ptr = p;
  *cur = s->buf_ptr;
}

/** Match a whitespace: ' ', '\\t', '\\n', '\\r'. */
static force_inline bool char_is_space(uint8_t c) {
  if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
    return true;
  }
  return false;
}

static force_inline bool char_is_number(uint8_t c) {
  if ((c >= '0' && c <= '9') || c == '-') {
    return true;
  }
  return false;
}

static force_inline bool read_true(const uint8_t **ptr, json_val *val) {
  const uint8_t *cur = *ptr;
  const uint8_t **end = ptr;
  if (cur[1] == 'r' && cur[2] == 'u' && cur[3] == 'e') {
    *end = cur + 4;
    val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_TRUE;
    return true;
  }
  return false;
}

static force_inline bool read_false(const uint8_t **ptr, json_val *val) {
  const uint8_t *cur = *ptr;
  const uint8_t **end = ptr;
  if (cur[1] == 'a' && cur[2] == 'l' && cur[3] == 's' && cur[4] == 'e') {
    *end = cur + 5;
    val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_FALSE;
    return true;
  }
  return false;
}

/** Read 'null' literal, '*cur' should be 'n'. */
static force_inline bool read_null(const uint8_t **ptr, json_val *val) {
  const uint8_t *cur = *ptr;
  const uint8_t **end = ptr;
  if (cur[1] == 'u' && cur[2] == 'l' && cur[3] == 'l') {
    *end = cur + 4;
    val->tag = JSON_TYPE_NULL;
    return true;
  }
  return false;
}

QJS_STATIC inline void js_json_get_number(JSParseState *s, bool is_neg,
                                          json_val *json_val) {
  LEPUSContext *ctx = s->ctx;
#ifdef CONFIG_BIGNUM
  LEPUSValue val = ctx->gc_enable ? s->token.u.num.val
                                  : LEPUS_DupValue(ctx, s->token.u.num.val);
  if (is_neg) {
    switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
      case LEPUS_TAG_BIG_INT:
      case LEPUS_TAG_BIG_FLOAT: {
        JSBigFloat *p;
        p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
        bf_neg(&p->num);
      } break;
      case LEPUS_TAG_FLOAT64: {
        double d;
        d = LEPUS_VALUE_GET_FLOAT64(val);
        val = __JS_NewFloat64(ctx, -d);
      } break;
      default:
      case LEPUS_TAG_INT: {
        int v;
        v = LEPUS_VALUE_GET_INT(val);
        if (v == 0 && !is_bignum_mode(s->ctx))
          val = __JS_NewFloat64(ctx, -0.0);
        else
          val = LEPUS_NewInt64(ctx, -(int64_t)v);
      } break;
    }
  }
#else
  LEPUSValue val = s->token.u.num.val;
  if (is_neg) {
    double d;
    LEPUS_ToFloat64(ctx, &d, val); /* no exception possible */
    val = LEPUS_NewFloat64(ctx, -d);
  }
#endif
  json_val->uni.num = val;
  json_val->tag = JSON_TYPE_NUM;
}

static force_inline bool json_is_bool(json_val *val) {
  return val ? (unsafe_json_get_type(val) == JSON_TYPE_BOOL) : false;
}

static force_inline bool json_get_bool(json_val *val) {
  return json_is_bool(val) ? unsafe_json_get_bool(val) : false;
}

static force_inline bool json_obj_iter_init(json_val *obj,
                                            json_obj_iter *iter) {
  iter->idx = 0;
  iter->max = (size_t)(((json_val *)obj)->tag >> JSON_TAG_BIT);
  iter->cur = obj + 1;
  iter->obj = obj;
  return true;
}

static force_inline bool json_arr_iter_init(json_val *arr,
                                            json_arr_iter *iter) {
  iter->idx = 0;
  iter->max = (size_t)(((json_val *)arr)->tag >> JSON_TAG_BIT);
  iter->cur = arr + 1;
  return true;
}

static force_inline json_val *unsafe_json_get_next(json_val *val) {
  bool is_ctn = unsafe_json_is_ctn(val);
  size_t ctn_ofs = val->uni.ofs;
  size_t ofs = (is_ctn ? ctn_ofs : sizeof(json_val));
  return (json_val *)(void *)((uint8_t *)val + ofs);
}

static force_inline json_val *json_arr_iter_next(json_arr_iter *iter) {
  json_val *val;
  if (iter && iter->idx < iter->max) {
    val = iter->cur;
    iter->cur = unsafe_json_get_next(val);
    iter->idx++;
    return val;
  }
  return NULL;
}

static force_inline json_val *json_obj_iter_next(json_obj_iter *iter) {
  if (iter && iter->idx < iter->max) {
    json_val *key = iter->cur;
    iter->idx++;
    iter->cur = unsafe_json_get_next(key + 1);
    return key;
  }
  return NULL;
}

static force_inline bool json_is_str(json_val *val) {
  return val ? (unsafe_json_get_type(val) == JSON_TYPE_STR) : false;
}

static force_inline const char *json_get_str(json_val *val) {
  return json_is_str(val) ? unsafe_json_get_str(val) : NULL;
}

LEPUSValue make_json_object(LEPUSContext *ctx, json_val *cur_val) {
  LEPUSValue lepus_val = LEPUS_UNDEFINED;
  HandleScope func_scope(ctx, &lepus_val, HANDLE_TYPE_LEPUS_VALUE);
  json_val *val;
  int64_t type = unsafe_json_get_type(cur_val);
  switch (type) {
    case JSON_TYPE_OBJ: {
      LEPUSValue js_obj = LEPUS_NewObject(ctx);
      func_scope.PushHandle(&js_obj, HANDLE_TYPE_LEPUS_VALUE);
      json_val *key;
      json_obj_iter iter;
      json_obj_iter_init(cur_val, &iter);
      while ((key = json_obj_iter_next(&iter))) {
        val = key ? key + 1 : NULL;
        const char *key_str = json_get_str(key);
        lepus_val = make_json_object(ctx, val);
        LEPUS_DefinePropertyValueStr(ctx, js_obj, key_str, lepus_val,
                                     LEPUS_PROP_C_W_E);
      }
      return js_obj;
    }

    case JSON_TYPE_ARR: {
      LEPUSValue js_arr = LEPUS_NewArray(ctx);
      func_scope.PushHandle(&js_arr, HANDLE_TYPE_LEPUS_VALUE);
      json_arr_iter iter;
      json_arr_iter_init(cur_val, &iter);
      size_t index = 0;
      while ((val = json_arr_iter_next(&iter))) {
        lepus_val = make_json_object(ctx, val);
        LEPUS_DefinePropertyValueUint32(ctx, js_arr, index, lepus_val,
                                        LEPUS_PROP_C_W_E);
        ++index;
      }
      return js_arr;
    }
    case JSON_TYPE_STR: {
      return LEPUS_NewString(ctx, json_get_str(cur_val));
    }
    case JSON_TYPE_NUM: {
      return cur_val->uni.num;
    }
    case JSON_TYPE_BOOL: {
      return LEPUS_NewBool(ctx, json_get_bool(cur_val));
    }
    case JSON_TYPE_NULL: {
      return LEPUS_NULL;
    }
    default: {
      break;
    }
  }
  return LEPUS_NULL;
}

json_val *json_parse_value(JSParseState *s, size_t dat_len) {
  LEPUSContext *ctx = s->ctx;
  BOOL is_neg;
  const uint8_t *cur = (uint8_t *)s->buf_ptr;
  const uint8_t *end = cur + dat_len;
  HandleScope func_scope(ctx);

#define json_parse_err(msg)                        \
  do {                                             \
    s->last_ptr = cur;                             \
    if (!ctx->gc_enable) lepus_free(ctx, val_hdr); \
    js_parse_error(s, msg);                        \
    return nullptr;                                \
  } while (false)

#define val_incr()                                                        \
  do {                                                                    \
    val++;                                                                \
    if (unlikely(val >= val_end)) {                                       \
      alc_len += alc_len / 2;                                             \
      val_tmp = static_cast<json_val *>(                                  \
          lepus_realloc(ctx, (void *)val_hdr, alc_len * sizeof(json_val), \
                        ALLOC_TAG_WITHOUT_PTR));                          \
      if (!val_tmp) {                                                     \
        goto fail_alloc;                                                  \
      }                                                                   \
      val = val_tmp + (size_t)(val - val_hdr);                            \
      ctn = val_tmp + (size_t)(ctn - val_hdr);                            \
      val_hdr = val_tmp;                                                  \
      val_end = val_tmp + (alc_len - 2);                                  \
    }                                                                     \
  } while (false)

  size_t alc_len;       /* value count allocated */
  size_t alc_max;       /* maximum value count for allocator */
  size_t ctn_len;       /* the number of elements in current container */
  json_val *val_hdr;    /* the head of allocated values */
  json_val *val_end;    /* the end of allocated values */
  json_val *val_tmp;    /* temporary pointer for realloc */
  json_val *val;        /* current JSON value */
  json_val *ctn;        /* current container */
  json_val *ctn_parent; /* parent of current container */

  alc_max = USIZE_MAX / sizeof(json_val);
  alc_len = (dat_len / JSON_READER_ESTIMATED_MINIFY_RATIO) + 4;
  alc_len = alc_len < alc_max ? alc_len : alc_max;

  val_hdr = (json_val *)lepus_malloc(ctx, alc_len * sizeof(json_val),
                                     ALLOC_TAG_WITHOUT_PTR);
  if (unlikely(!val_hdr)) {
    goto fail_alloc;
  }
  func_scope.PushHandle(&val_hdr, HANDLE_TYPE_HEAP_OBJ);
  val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */
  val = val_hdr;
  ctn = val;
  ctn_len = 0;
  /*
  container:
    val->tag represents value count and type
    val->u.int64 represents the distance between current container and parent
  container. use val->u.int64 to find the parent container
  */
  switch (*cur) {
    case '{':
      cur++;
      ctn->tag = JSON_TYPE_OBJ;
      ctn->uni.ofs = 0;
      goto obj_key_begin;
    case '[':
      cur++;
      ctn->tag = JSON_TYPE_ARR;
      ctn->uni.ofs = 0;
      goto arr_val_begin;
    default:
      goto single;
  }

arr_begin:
  ctn->tag =
      (((uint64_t)ctn_len + 1) << JSON_TAG_BIT) | (ctn->tag & JSON_TAG_MASK);
  val_incr();
  val->tag = JSON_TYPE_ARR;
  val->uni.ofs = (size_t)((uint8_t *)val - (uint8_t *)ctn);
  ctn = val;
  ctn_len = 0;

arr_val_begin:
  if (*cur == '{') {
    cur++;
    goto obj_begin;
  }

  if (*cur == '[') {
    cur++;
    goto arr_begin;
  }

  if (char_is_number(*cur)) {
    val_incr();
    ctn_len++;
    is_neg = 0;
    if (*cur == '-') {
      cur++;
      is_neg = 1;
    }
    s->buf_ptr = cur;
    if (unlikely(next_token(s))) goto fail_number;
    if (unlikely(s->token.val != TOK_NUMBER)) {
      json_parse_err("number expected");
      goto fail_number;
    }
    cur = s->buf_ptr;
    js_json_get_number(s, is_neg, val);
    goto arr_val_end;
  }
  if (*cur == '"') {
    val_incr();
    ctn_len++;
    if (likely(read_string(s, (uint8_t **)&cur, val))) goto arr_val_end;
    goto fail_string;
  }
  if (*cur == 't') {
    val_incr();
    ctn_len++;
    if (likely(read_true(&cur, val))) {
      goto arr_val_end;
    }
    goto fail_literal;
  }
  if (*cur == 'f') {
    val_incr();
    ctn_len++;
    if (likely(read_false(&cur, val))) {
      goto arr_val_end;
    }
    goto fail_literal;
  }
  if (*cur == 'n') {
    val_incr();
    ctn_len++;
    if (likely(read_null(&cur, val))) {
      goto arr_val_end;
    }
    goto fail_literal;
  }

  if (*cur == ']') {
    cur++;
    if (likely(ctn_len == 0)) {
      goto arr_end;
    }
    goto fail_trailing_comma;
  }
  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto arr_val_begin;
  }
  goto fail_character;

arr_val_end:
  if (*cur == ',') {
    cur++;
    goto arr_val_begin;
  }
  if (*cur == ']') {
    cur++;
    goto arr_end;
  }
  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto arr_val_end;
  }
  goto fail_character;

arr_end:
  /* get parent container */
  ctn_parent = (json_val *)(void *)((uint8_t *)ctn - ctn->uni.ofs);
  /* save the next sibling value offset */
  ctn->uni.ofs = (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
  ctn->tag = ((ctn_len) << JSON_TAG_BIT) | JSON_TYPE_ARR;
  if (unlikely(ctn == ctn_parent)) goto doc_end;
  /* pop parent as current container */
  ctn = ctn_parent;
  ctn_len = (size_t)(ctn->tag >> JSON_TAG_BIT);
  if ((ctn->tag & JSON_TYPE_MASK) == JSON_TYPE_OBJ) {
    goto obj_val_end;
  } else {
    goto arr_val_end;
  }

obj_begin:
  ctn->tag =
      (((uint64_t)ctn_len + 1) << JSON_TAG_BIT) | (ctn->tag & JSON_TAG_MASK);
  val_incr();
  val->tag = JSON_TYPE_OBJ;
  val->uni.ofs = (size_t)((uint8_t *)val - (uint8_t *)ctn);
  ctn = val;
  ctn_len = 0;

obj_key_begin:
  if (likely((*cur == '"'))) {
    val_incr();
    ctn_len++;
    if (likely(read_string(s, (uint8_t **)&cur, val))) goto obj_key_end;
    goto fail_string;
  }
  if (likely(*cur == '}')) {
    cur++;
    if (likely(ctn_len == 0)) goto obj_end;
    goto fail_trailing_comma;
  }

  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto obj_key_begin;
  }
  goto fail_character;

obj_key_end:
  if (*cur == ':') {
    cur++;
    goto obj_val_begin;
  }
  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto obj_key_end;
  }
  goto fail_character;

obj_val_begin:
  if (*cur == '"') {
    val++;
    ctn_len++;
    if (likely(read_string(s, (uint8_t **)&cur, val))) goto obj_val_end;
    goto fail_string;
  }
  if (char_is_number(*cur)) {
    val++;
    ctn_len++;
    is_neg = 0;
    if (*cur == '-') {
      cur++;
      is_neg = 1;
    }
    s->buf_ptr = cur;
    if (unlikely(next_token(s))) goto fail_number;
    if (unlikely(s->token.val != TOK_NUMBER)) {
      json_parse_err("number expected");
      goto fail_number;
    }
    cur = s->buf_ptr;
    js_json_get_number(s, is_neg, val);
    goto obj_val_end;
  }
  if (*cur == '{') {
    cur++;
    goto obj_begin;
  }
  if (*cur == '[') {
    cur++;
    goto arr_begin;
  }
  if (*cur == 't') {
    val++;
    ctn_len++;
    if (likely(read_true(&cur, val))) {
      goto obj_val_end;
    }
    goto fail_literal;
  }
  if (*cur == 'f') {
    val++;
    ctn_len++;
    if (likely(read_false(&cur, val))) {
      goto obj_val_end;
    }
    goto fail_literal;
  }
  if (*cur == 'n') {
    val++;
    ctn_len++;
    if (likely(read_null(&cur, val))) {
      goto obj_val_end;
    }
    goto fail_literal;
  }
  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto obj_val_begin;
  }
  goto fail_character;

obj_val_end:
  if (likely(*cur == ',')) {
    cur++;
    goto obj_key_begin;
  }
  if (likely(*cur == '}')) {
    cur++;
    goto obj_end;
  }
  if (char_is_space(*cur)) {
    parse_json_space(s, &cur);  // skip space
    goto obj_val_end;
  }
  goto fail_character;

obj_end:
  ctn_parent = (json_val *)(void *)((uint8_t *)ctn - ctn->uni.ofs);
  ctn->uni.ofs = (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
  ctn->tag = (ctn_len << (JSON_TAG_BIT - 1)) | JSON_TYPE_OBJ;
  if (unlikely(ctn == ctn_parent)) goto doc_end;
  ctn = ctn_parent;
  ctn_len = (size_t)(ctn->tag >> JSON_TAG_BIT);
  if ((ctn->tag & JSON_TYPE_MASK) == JSON_TYPE_OBJ) {
    goto obj_val_end;
  } else {
    goto arr_val_end;
  }

single:
  if (char_is_number(*cur)) {
    is_neg = 0;
    if (*cur == '-') {
      cur++;
      is_neg = 1;
    }
    s->buf_ptr = cur;
    if (unlikely(next_token(s))) goto fail_number;
    if (unlikely(s->token.val != TOK_NUMBER)) {
      json_parse_err("number expected");
      goto fail_number;
    }
    cur = s->buf_ptr;
    js_json_get_number(s, is_neg, val);
    goto doc_end;
  }
  if (*cur == '"') {
    if (likely(read_string(s, (uint8_t **)&cur, val))) goto doc_end;
    goto fail_string;
  }
  if (*cur == 't') {
    if (likely(read_true(&cur, val))) {
      goto doc_end;
    }
    goto fail_literal;
  }
  if (*cur == 'f') {
    if (likely(read_false(&cur, val))) {
      goto doc_end;
    }
    goto fail_literal;
  }
  if (*cur == 'n') {
    if (likely(read_null(&cur, val))) {
      goto doc_end;
    }
    goto fail_literal;
  }
  goto fail_character;
doc_end:
  if (unlikely(cur < end)) {
    while (char_is_space(*cur)) cur++;
    if (unlikely(cur < end)) goto fail;
  }
  if (!ctx->gc_enable) free_token(s, &s->token);
  s->token.val = TOK_EOF;
  return val_hdr;

fail_character:
  json_parse_err("unexpected character");
  return nullptr;
fail_literal:
  json_parse_err("invalid literal");
fail_trailing_comma:
  json_parse_err("trailing comma is not allowed");
fail_alloc:
  json_parse_err("json parse memory allocation failed");
fail:
  json_parse_err("unexpected content after document");
fail_number:
fail_string:
  if (!ctx->gc_enable) lepus_free(ctx, val_hdr);
  return nullptr;
#undef val_incr
}

QJS_STATIC LEPUSValue json_parse_value(JSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val = LEPUS_NULL;
  BOOL is_neg;
  int ret;

  switch (s->token.val) {
    case '{': {
      LEPUSValue prop_val, prop_str;

      if (next_token(s)) goto fail;
      val = LEPUS_NewObject(ctx);
      if (LEPUS_IsException(val)) goto fail;
      if (s->token.val != '}') {
        for (;;) {
          if (s->token.val != TOK_STRING) {
            js_parse_error(s, "expecting property name");
            goto fail;
          }
          prop_str = LEPUS_DupValue(ctx, s->token.u.str.str);
          if (next_token(s)) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          if (js_parse_expect(s, ':')) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          prop_val = json_parse_value(s);
          if (LEPUS_IsException(prop_val)) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          ret = JS_DefinePropertyValueValue(ctx, val, prop_str, prop_val,
                                            LEPUS_PROP_C_W_E);
          if (ret < 0) goto fail;

          if (s->token.val != ',') break;
          if (next_token(s)) goto fail;
        }
      }
      if (js_parse_expect(s, '}')) goto fail;
    } break;
    case '[': {
      LEPUSValue el;
      uint32_t idx;

      if (next_token(s)) goto fail;
      val = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(val)) goto fail;
      if (s->token.val != ']') {
        idx = 0;
        for (;;) {
          el = json_parse_value(s);
          if (LEPUS_IsException(el)) goto fail;
          ret = JS_DefinePropertyValueUint32_RC(ctx, val, idx, el,
                                                LEPUS_PROP_C_W_E);
          if (ret < 0) goto fail;
          if (s->token.val != ',') break;
          if (next_token(s)) goto fail;
          idx++;
        }
      }
      if (js_parse_expect(s, ']')) goto fail;
    } break;
    case TOK_STRING:
      val = LEPUS_DupValue(ctx, s->token.u.str.str);
      if (next_token(s)) goto fail;
      break;
    case TOK_NUMBER:
      is_neg = 0;
      goto number;
    case '-':
      if (next_token(s)) goto fail;
      if (s->token.val != TOK_NUMBER) {
        js_parse_error(s, "number expected");
        goto fail;
      }
      is_neg = 1;
    number:
#ifdef CONFIG_BIGNUM
      val = LEPUS_DupValue(ctx, s->token.u.num.val);
      if (is_neg) {
        switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
          case LEPUS_TAG_BIG_INT:
          case LEPUS_TAG_BIG_FLOAT: {
            JSBigFloat *p;
            p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
            bf_neg(&p->num);
          } break;
          case LEPUS_TAG_FLOAT64: {
            double d;
            d = LEPUS_VALUE_GET_FLOAT64(val);
            val = __JS_NewFloat64(ctx, -d);
          } break;
          default:
          case LEPUS_TAG_INT: {
            int v;
            v = LEPUS_VALUE_GET_INT(val);
            if (v == 0 && !is_bignum_mode(s->ctx))
              val = __JS_NewFloat64(ctx, -0.0);
            else
              val = LEPUS_NewInt64(ctx, -(int64_t)v);
          } break;
        }
      }
#else
      val = s->token.u.num.val;
      if (is_neg) {
        double d;
        LEPUS_ToFloat64(ctx, &d, val); /* no exception possible */
        val = LEPUS_NewFloat64(ctx, -d);
      }
#endif
      if (next_token(s)) goto fail;
      break;
    case TOK_FALSE:
    case TOK_TRUE:
      val = LEPUS_NewBool(ctx, s->token.val - TOK_FALSE);
      if (next_token(s)) goto fail;
      break;
    case TOK_NULL:
      if (next_token(s)) goto fail;
      break;
    default:
      if (s->token.val == TOK_EOF) {
        js_parse_error(s, "unexpected end of input");
      } else {
        js_parse_error(s, "unexpected token: '%.*s'",
                       (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
      }
      goto fail;
  }
  return val;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}
#endif

LEPUSValue LEPUS_ParseJSON(LEPUSContext *ctx, const char *buf, size_t buf_len,
                           const char *filename) {
#ifndef NO_QUICKJS_COMPILER
  CallGCFunc(JS_ParseJSONOPT, ctx, buf, buf_len, filename);
  JSParseState s1, *s = &s1;
  LEPUSValue val;
  js_parse_init(ctx, s, buf, buf_len, filename);

  if (next_token(s)) goto fail;
  val = json_parse_value(s);
  if (LEPUS_IsException(val)) goto fail;
  if (s->token.val != TOK_EOF) {
    if (js_parse_error(s, "unexpected data at the end")) goto fail;
  }
  return val;
fail:
  free_token(s, &s->token);
  return LEPUS_EXCEPTION;
#else
  return LEPUS_UNDEFINED;
#endif
}

LEPUSValue JS_ParseJSONOPT(LEPUSContext *ctx, const char *buf, size_t buf_len,
                           const char *filename) {
#ifndef NO_QUICKJS_COMPILER
  JSParseState s1, *s = &s1;
  LEPUSValue val;
  // to avoid memory corruption in function `byte_load_4`, increase 4 bytes
  // unittest: json_parse.js
  const uint8_t *cur = static_cast<const uint8_t *>(lepus_mallocz(
      ctx, sizeof(uint8_t) * (buf_len + 4), ALLOC_TAG_WITHOUT_PTR));
  if (!cur) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx, (void *)cur, HANDLE_TYPE_DIR_HEAP_OBJ);
  uint8_t *str_start = (uint8_t *)cur;
  const uint8_t *buf_end = str_start + buf_len;
  json_val *json_val_arr;

  memcpy((void *)cur, (void *)buf, buf_len + 1);
  js_parse_init(ctx, s, (const char *)cur, buf_len, filename);
  func_scope.PushHandle(&s->token, HANDLE_TYPE_LEPUS_TOKEN);
  if (unlikely(char_is_space(*cur))) {
    parse_json_space(s, &cur);  // skip space
  }
  if (cur >= buf_end) {
    js_parse_error(s, "input data is empty");
    goto fail;
  }

  json_val_arr = json_parse_value(s, buf_end - cur);
  func_scope.PushHandle(json_val_arr, HANDLE_TYPE_DIR_HEAP_OBJ);
  if (json_val_arr) {
    val = make_json_object(ctx, json_val_arr);
    if (!ctx->gc_enable) {
      lepus_free(ctx, json_val_arr);
      lepus_free(ctx, str_start);
    }
    return val;
  }
fail:
  if (!ctx->gc_enable) {
    lepus_free(ctx, str_start);
    free_token(s, &s->token);
  }
  return LEPUS_EXCEPTION;
#else
  return LEPUS_UNDEFINED;
#endif
}

QJS_STATIC LEPUSValue internalize_json_property(LEPUSContext *ctx,
                                                LEPUSValueConst holder,
                                                JSAtom name,
                                                LEPUSValueConst reviver) {
  LEPUSValue val, new_el, name_val, res;
  LEPUSValueConst args[2];
  int ret, is_array;
  uint32_t i, len = 0;
  JSAtom prop;
  LEPUSPropertyEnum *atoms = NULL;

  if (js_check_stack_overflow(ctx, 0)) {
    return JS_ThrowStackOverflow(ctx);
  }

  val = JS_GetPropertyInternal_RC(ctx, holder, name, holder, 0);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_IsObject(val)) {
    is_array = LEPUS_IsArray(ctx, val);
    if (is_array < 0) goto fail;
    if (is_array) {
      if (lepus_get_length32(ctx, &len, val)) goto fail;
    } else {
      ret = JS_GetOwnPropertyNamesInternal(
          ctx, &atoms, &len, LEPUS_VALUE_GET_OBJ(val),
          LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK);
      if (ret < 0) goto fail;
    }
    for (i = 0; i < len; i++) {
      if (is_array) {
        prop = LEPUS_NewAtomUInt32(ctx, i);
        if (prop == JS_ATOM_NULL) goto fail;
      } else {
        prop = LEPUS_DupAtom(ctx, atoms[i].atom);
      }
      new_el = internalize_json_property(ctx, val, prop, reviver);
      if (LEPUS_IsException(new_el)) {
        LEPUS_FreeAtom(ctx, prop);
        goto fail;
      }
      if (LEPUS_IsUndefined(new_el)) {
        ret = LEPUS_DeleteProperty(ctx, val, prop, 0);
      } else {
        ret =
            JS_DefinePropertyValue_RC(ctx, val, prop, new_el, LEPUS_PROP_C_W_E);
      }
      LEPUS_FreeAtom(ctx, prop);
      if (ret < 0) goto fail;
    }
  }
  js_free_prop_enum(ctx, atoms, len);
  atoms = NULL;
  name_val = JS_AtomToValue_RC(ctx, name);
  if (LEPUS_IsException(name_val)) goto fail;
  args[0] = name_val;
  args[1] = val;
  res = JS_Call_RC(ctx, reviver, holder, 2, args);
  LEPUS_FreeValue(ctx, name_val);
  LEPUS_FreeValue(ctx, val);
  return res;
fail:
  js_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_json_parse(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  LEPUSValue obj, root;
  LEPUSValueConst reviver;
  const char *str;
  size_t len;

  str = JS_ToCStringLen2_RC(ctx, &len, argv[0], 0);
  if (!str) return LEPUS_EXCEPTION;
  if (!json_opt_disabled(ctx->rt)) {
    obj = JS_ParseJSONOPT(ctx, str, len, "<input>");
  } else {
    obj = LEPUS_ParseJSON(ctx, str, len, "<input>");
  }
  LEPUS_FreeCString(ctx, str);
  if (LEPUS_IsException(obj)) return obj;
  if (argc > 1 && LEPUS_IsFunction(ctx, argv[1])) {
    reviver = argv[1];
    root = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(root)) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
    if (JS_DefinePropertyValue_RC(ctx, root, JS_ATOM_empty_string, obj,
                                  LEPUS_PROP_C_W_E) < 0) {
      LEPUS_FreeValue(ctx, root);
      return LEPUS_EXCEPTION;
    }
    obj = internalize_json_property(ctx, root, JS_ATOM_empty_string, reviver);
    LEPUS_FreeValue(ctx, root);
  }
  return obj;
}

typedef struct JSONStringifyContext {
  LEPUSValueConst replacer_func;
  LEPUSValue stack;
  LEPUSValue property_list;
  LEPUSValue gap;
  LEPUSValue empty;
  StringBuffer *b;
} JSONStringifyContext;

QJS_STATIC LEPUSValue JS_ToQuotedStringFree(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSValue r = JS_ToQuotedString(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return r;
}

#ifdef CONFIG_BIGNUM
static inline BOOL JS_IsBigInt(LEPUSContext *ctx, LEPUSValueConst v);
#endif

QJS_STATIC LEPUSValue js_json_check(LEPUSContext *ctx,
                                    JSONStringifyContext *jsc,
                                    LEPUSValueConst holder, LEPUSValue val,
                                    LEPUSValueConst key) {
  LEPUSValue v;
  LEPUSValueConst args[2];

  if (LEPUS_IsObject(val)
#ifdef CONFIG_BIGNUM
      || JS_IsBigInt(ctx, val) /* XXX: probably useless */
#endif
  ) {
    LEPUSValue f = JS_GetPropertyInternal_RC(ctx, val, JS_ATOM_toJSON, val, 0);
    if (LEPUS_IsException(f)) goto exception;
    if (LEPUS_IsFunction(ctx, f)) {
      v = JS_CallFree(ctx, f, val, 1, &key);
      LEPUS_FreeValue(ctx, val);
      val = v;
      if (LEPUS_IsException(val)) goto exception;
    } else {
      LEPUS_FreeValue(ctx, f);
    }
  }

  if (!LEPUS_IsUndefined(jsc->replacer_func)) {
    args[0] = key;
    args[1] = val;
    v = JS_Call_RC(ctx, jsc->replacer_func, holder, 2, args);
    LEPUS_FreeValue(ctx, val);
    val = v;
    if (LEPUS_IsException(val)) goto exception;
  }

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
    case LEPUS_TAG_OBJECT:
      if (LEPUS_IsFunction(ctx, val)) break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
#endif
    case LEPUS_TAG_EXCEPTION:
    case LEPUS_TAG_SEPARABLE_STRING:
    case LEPUS_TAG_LEPUS_REF:
      return val;
    default:
      break;
  }
  LEPUS_FreeValue(ctx, val);
  return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

#define U64(hi, lo) ((((uint64_t)hi##UL) << 32U) + lo##UL)
#define CHAR_ENC_CPY_1 0 /* 1-byte UTF-8, copy. */
#define CHAR_ENC_ERR_1 1 /* 1-byte UTF-8, error. */
#define CHAR_ENC_ESC_A 2 /* 1-byte ASCII, escaped as '\x'. */
#define CHAR_ENC_ESC_1 3 /* 1-byte UTF-8, escaped as '\uXXXX'. */
#define CHAR_ENC_CPY_2 4 /* 2-byte UTF-8, copy. */
#define CHAR_ENC_ESC_2 5 /* 2-byte UTF-8, escaped as '\uXXXX'. */
#define CHAR_ENC_CPY_3 6 /* 3-byte UTF-8, copy. */
#define CHAR_ENC_ESC_3 7 /* 3-byte UTF-8, escaped as '\uXXXX'. */
#define CHAR_ENC_CPY_4 8 /* 4-byte UTF-8, copy. */
#define CHAR_ENC_ESC_4 9 /* 4-byte UTF-8, escaped as '\uXXXX\uXXXX'. */
#define JSON_ALLOC_INIT_SIZE 256
#define repeat4_incr(x) \
  { x(0) x(1) x(2) x(3) }

typedef struct json_write_ctx {
  size_t tag;
} json_write_ctx;

static const uint8_t esc_single_char_table[512] = {
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', '\\', 'b',  '\\', 't', '\\', 'n', ' ', ' ', '\\', 'f', '\\', 'r',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', '\\', '"',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', '\\', '/', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', '\\', '\\', ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' ', ' ', ' ', ' ',  ' ', ' ',  ' ',
    ' ', ' ', ' ',  ' ',  ' ',  ' ', ' ',  ' '};

static const uint8_t esc_hex_char_table[512] = {
    '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0',
    '7', '0', '8', '0', '9', '0', 'a', '0', 'b', '0', 'c', '0', 'd', '0', 'e',
    '0', 'f', '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1',
    '6', '1', '7', '1', '8', '1', '9', '1', 'a', '1', 'b', '1', 'c', '1', 'd',
    '1', 'e', '1', 'f', '2', '0', '2', '1', '2', '2', '2', '3', '2', '4', '2',
    '5', '2', '6', '2', '7', '2', '8', '2', '9', '2', 'a', '2', 'b', '2', 'c',
    '2', 'd', '2', 'e', '2', 'f', '3', '0', '3', '1', '3', '2', '3', '3', '3',
    '4', '3', '5', '3', '6', '3', '7', '3', '8', '3', '9', '3', 'a', '3', 'b',
    '3', 'c', '3', 'd', '3', 'e', '3', 'f', '4', '0', '4', '1', '4', '2', '4',
    '3', '4', '4', '4', '5', '4', '6', '4', '7', '4', '8', '4', '9', '4', 'a',
    '4', 'b', '4', 'c', '4', 'd', '4', 'e', '4', 'f', '5', '0', '5', '1', '5',
    '2', '5', '3', '5', '4', '5', '5', '5', '6', '5', '7', '5', '8', '5', '9',
    '5', 'a', '5', 'b', '5', 'c', '5', 'd', '5', 'e', '5', 'f', '6', '0', '6',
    '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6', '6', '7', '6', '8',
    '6', '9', '6', 'a', '6', 'b', '6', 'c', '6', 'd', '6', 'e', '6', 'f', '7',
    '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6', '7', '7',
    '7', '8', '7', '9', '7', 'a', '7', 'b', '7', 'c', '7', 'd', '7', 'e', '7',
    'f', '8', '0', '8', '1', '8', '2', '8', '3', '8', '4', '8', '5', '8', '6',
    '8', '7', '8', '8', '8', '9', '8', 'a', '8', 'b', '8', 'c', '8', 'd', '8',
    'e', '8', 'f', '9', '0', '9', '1', '9', '2', '9', '3', '9', '4', '9', '5',
    '9', '6', '9', '7', '9', '8', '9', '9', '9', 'a', '9', 'b', '9', 'c', '9',
    'd', '9', 'e', '9', 'f', 'a', '0', 'a', '1', 'a', '2', 'a', '3', 'a', '4',
    'a', '5', 'a', '6', 'a', '7', 'a', '8', 'a', '9', 'a', 'a', 'a', 'b', 'a',
    'c', 'a', 'd', 'a', 'e', 'a', 'f', 'b', '0', 'b', '1', 'b', '2', 'b', '3',
    'b', '4', 'b', '5', 'b', '6', 'b', '7', 'b', '8', 'b', '9', 'b', 'a', 'b',
    'b', 'b', 'c', 'b', 'd', 'b', 'e', 'b', 'f', 'c', '0', 'c', '1', 'c', '2',
    'c', '3', 'c', '4', 'c', '5', 'c', '6', 'c', '7', 'c', '8', 'c', '9', 'c',
    'a', 'c', 'b', 'c', 'c', 'c', 'd', 'c', 'e', 'c', 'f', 'd', '0', 'd', '1',
    'd', '2', 'd', '3', 'd', '4', 'd', '5', 'd', '6', 'd', '7', 'd', '8', 'd',
    '9', 'd', 'a', 'd', 'b', 'd', 'c', 'd', 'd', 'd', 'e', 'd', 'f', 'e', '0',
    'e', '1', 'e', '2', 'e', '3', 'e', '4', 'e', '5', 'e', '6', 'e', '7', 'e',
    '8', 'e', '9', 'e', 'a', 'e', 'b', 'e', 'c', 'e', 'd', 'e', 'e', 'e', 'f',
    'f', '0', 'f', '1', 'f', '2', 'f', '3', 'f', '4', 'f', '5', 'f', '6', 'f',
    '7', 'f', '8', 'f', '9', 'f', 'a', 'f', 'b', 'f', 'c', 'f', 'd', 'f', 'e',
    'f', 'f'};

static const uint8_t enc_table[256] = {
    3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1};

static force_inline size_t unsafe_json_get_len(void *val) {
  return (size_t)(((json_val *)val)->tag >> JSON_TAG_BIT);
}

// use str_arr to store char* needed to free in the end of JSON.stringify
const char *generate_json_str(LEPUSContext *ctx, LEPUSValue obj,
                              size_t &str_len, const char ***str_arr,
                              size_t &ts, size_t &cs) {
  const char *str = LEPUS_ToCStringLen2(ctx, &str_len, obj, 0);
  HandleScope func_scope(ctx, &str, HANDLE_TYPE_CSTRING);
  if (cs < ts) {
    (*str_arr)[cs] = str;
    ++cs;
    if (ctx->gc_enable) {
      set_heap_obj_len(*str_arr, cs);
    }
  } else {
    size_t new_len = ts + ts / 2 + 1;
    const char **new_arr = (const char **)lepus_realloc(
        ctx, *str_arr, sizeof(const char *) * new_len, ALLOC_TAG_JsonStrArray);
    if (likely(new_arr)) {
      *str_arr = new_arr;
      ts = new_len;
      (*str_arr)[cs] = str;
      ++cs;
      if (ctx->gc_enable) {
        set_heap_obj_len(*str_arr, cs);
      }
    } else {
      if (!ctx->gc_enable) {
        LEPUS_FreeCString(ctx, str);
        lepus_free(ctx, *str_arr);
      }
      *str_arr = nullptr;
      cs = 0;
      if (ctx->gc_enable) {
        set_heap_obj_len(*str_arr, cs);
      }
      return nullptr;
    }
  }
  return str;
}

int make_json_val_incr(LEPUSContext *ctx, size_t &alc_len, json_val **val_hdr,
                       json_val **val, json_val **ctn, json_val **val_end) {
  alc_len += alc_len / 2 + 2;
  json_val *val_tmp = static_cast<json_val *>(
      lepus_realloc(ctx, (void *)*val_hdr, alc_len * sizeof(json_val),
                    ALLOC_TAG_WITHOUT_PTR));
  if (!val_tmp) {
    return -1;
  }
  *val = val_tmp + (size_t)(*val - *val_hdr);
  *ctn = val_tmp + (size_t)(*ctn - *val_hdr);
  *val_hdr = val_tmp;
  *val_end = val_tmp + (alc_len - 2);
  return 0;
}

// LEPUSValue --> json_val
static int make_json_val(LEPUSContext *ctx, LEPUSValue obj,
                         JSONStringifyContext *jsc, json_val *&val_hdr,
                         json_val *&val, size_t &alc_len, const char ***str_arr,
                         size_t &ts, size_t &cs) {
#define val_incr()                                                            \
  do {                                                                        \
    val++;                                                                    \
    if (unlikely(val >= val_end)) {                                           \
      if (make_json_val_incr(ctx, alc_len, &val_hdr, &val, &ctn, &val_end)) { \
        LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");     \
        goto fail_alloc;                                                      \
      }                                                                       \
    }                                                                         \
  } while (false)

  int64_t len;
  json_val *val_end = val_hdr + (alc_len - 2);
  json_val *ctn;
  LEPUSValue v, tab, prop;

  tab = LEPUS_UNDEFINED;
  prop = LEPUS_UNDEFINED;

  LEPUSObject *p;
  int cl, ret;
  int64_t i;
  int32_t is_lepus_array = 0;
  switch (LEPUS_VALUE_GET_NORM_TAG(obj)) {
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      if (JS_LepusRefIsTable(ctx->rt, obj)) {
        goto do_object_stringify;
      } else if (JS_LepusRefIsArray(ctx->rt, obj)) {
        is_lepus_array = 1;
        goto do_object_stringify;
      }
      LEPUS_FreeValue(ctx, obj);
      goto process_null;
    } break;
#endif
    case LEPUS_TAG_OBJECT: {
      p = LEPUS_VALUE_GET_OBJ(obj);
      cl = p->class_id;
      if (cl == JS_CLASS_STRING) {
        obj = JS_ToStringFree(ctx, obj);
        if (LEPUS_IsException(obj)) goto exception;
        return make_json_val(ctx, obj, jsc, val_hdr, val, alc_len, str_arr, ts,
                             cs);
      } else if (cl == JS_CLASS_NUMBER) {
        obj = JS_ToNumberFree(ctx, obj);
        if (LEPUS_IsException(obj)) goto exception;
        return make_json_val(ctx, obj, jsc, val_hdr, val, alc_len, str_arr, ts,
                             cs);
      } else if (cl == JS_CLASS_BOOLEAN) {
        val_incr();
        if (LEPUS_ToBool(ctx, p->u.object_data)) {
          val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_TRUE;
        } else {
          val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_FALSE;
        }
        LEPUS_FreeValue(ctx, obj);
        return 0;
      }
#ifdef CONFIG_BIGNUM
      else if (cl == JS_CLASS_BIG_FLOAT) {
        obj = JS_ToNumberFree(ctx, obj);
        return make_json_val(ctx, obj, jsc, val_hdr, val, alc_len, str_arr, ts,
                             cs);
      } else if (cl == JS_CLASS_BIG_INT) {
        LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
        goto exception;
      }
#endif
#ifdef ENABLE_LEPUSNG
    do_object_stringify:
#endif
      // check circular reference
      v = js_array_includes(ctx, jsc->stack, 1, (LEPUSValueConst *)&obj);
      if (LEPUS_IsException(v)) goto exception;
      if (unlikely(JS_ToBoolFree_RC(ctx, v))) {
        LEPUS_ThrowTypeError(ctx, "circular reference");
        goto exception;
      }
      v = js_array_push(ctx, jsc->stack, 1, (LEPUSValueConst *)&obj, 0);
      if (check_exception_free(ctx, v)) goto exception;

      ret = LEPUS_IsArray(ctx, obj) || is_lepus_array;
      if (unlikely(ret < 0)) goto exception;
      if (ret) {
        if (unlikely(js_get_length64(ctx, &len, obj))) goto exception;
        val_incr();
        size_t dis = (size_t)(val - val_hdr);
        for (i = 0; i < len; i++) {
          v = JS_GetPropertyInt64(ctx, obj, i);
          if (LEPUS_IsException(v)) goto exception;
          prop = JS_ToStringFree(ctx, LEPUS_NewInt64(ctx, i));
          if (LEPUS_IsException(prop)) goto exception;
          v = js_json_check(ctx, jsc, obj, v, prop);
          LEPUS_FreeValue(ctx, prop);
          prop = LEPUS_UNDEFINED;
          if (LEPUS_IsException(v)) goto exception;
          if (unlikely(LEPUS_IsUndefined(v))) v = LEPUS_NULL;
          if (unlikely(make_json_val(ctx, v, jsc, val_hdr, val, alc_len,
                                     str_arr, ts, cs))) {
            len = i;
            ctn = val_hdr + dis;
            ctn->tag = ((len) << JSON_TAG_BIT) | JSON_TYPE_ARR;
            ctn->uni.ofs =
                (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
            goto exception;
          }
        }
        ctn = val_hdr + dis;
        ctn->tag = ((len) << JSON_TAG_BIT) | JSON_TYPE_ARR;
        ctn->uni.ofs =
            (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
      } else {
        if (!LEPUS_IsUndefined(jsc->property_list))
          tab = LEPUS_DupValue(ctx, jsc->property_list);
        else
          tab = js_object_keys(ctx, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&obj,
                               JS_ITERATOR_KIND_KEY);
        if (LEPUS_IsException(tab)) goto exception;
        if (unlikely(js_get_length64(ctx, &len, tab))) goto exception;
        val_incr();
        size_t dis = (size_t)(val - val_hdr);
        size_t len_final = len;
        for (i = 0; i < len; i++) {
          LEPUS_FreeValue(ctx, prop);
          prop = JS_GetPropertyInt64(ctx, tab, i);
          if (LEPUS_IsException(prop)) goto exception;

          v = JS_GetPropertyValue(ctx, obj, LEPUS_DupValue(ctx, prop));
          if (LEPUS_IsException(v)) goto exception;
          v = js_json_check(ctx, jsc, obj, v, prop);
          if (LEPUS_IsException(v)) goto exception;
          if (!LEPUS_IsUndefined(v)) {
            size_t str_len = 0;
            const char *str =
                generate_json_str(ctx, prop, str_len, str_arr, ts, cs);
            if (unlikely(!str)) {
              LEPUS_FreeValue(ctx, v);
              LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
              goto fail_alloc;
            }
            val++;
            val->tag = (str_len << JSON_TAG_BIT) | JSON_TYPE_STR;
            val->uni.str = str;

            if (unlikely(make_json_val(ctx, v, jsc, val_hdr, val, alc_len,
                                       str_arr, ts, cs))) {
              goto obj_exception;
            }
            continue;
          obj_exception:
            len_final = i;
            ctn = val_hdr + dis;
            ctn->tag = (len_final << (JSON_TAG_BIT)) | JSON_TYPE_OBJ;
            ctn->uni.ofs =
                (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
            goto exception;
          } else {
            len_final--;
          }
        }
        ctn = val_hdr + dis;
        ctn->tag = (len_final << (JSON_TAG_BIT)) | JSON_TYPE_OBJ;
        ctn->uni.ofs =
            (size_t)((uint8_t *)val - (uint8_t *)ctn) + sizeof(json_val);
      }
      if (check_exception_free(ctx, js_array_pop(ctx, jsc->stack, 0, NULL, 0)))
        goto exception;
      LEPUS_FreeValue(ctx, obj);
      LEPUS_FreeValue(ctx, tab);
      LEPUS_FreeValue(ctx, prop);
      return 0;
    }
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING: {
      size_t str_len = 0;
      const char *str = generate_json_str(ctx, obj, str_len, str_arr, ts, cs);
      if (unlikely(!str)) {
        LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
        goto fail_alloc;
      }
      LEPUS_FreeValue(ctx, obj);
      val_incr();
      val->tag = (str_len << JSON_TAG_BIT) | JSON_TYPE_STR;
      val->uni.str = str;
      return 0;
    }
    case LEPUS_TAG_FLOAT64:
      if (unlikely(!isfinite(LEPUS_VALUE_GET_FLOAT64(obj)))) {
        obj = LEPUS_NULL;
        goto process_null;
      }
      double d;
      LEPUS_ToFloat64(ctx, &d, obj);
      if (unlikely(abs(d) <= 1e-15)) {
        goto process_int;
      }
      goto process_float;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
#endif
    process_float:
      val_incr();
      val->tag = JSON_TYPE_NUM | JSON_SUBTYPE_REAL;
#ifdef CONFIG_BIGNUM
      val->uni.bigf = obj;
#else
      val->uni.f64 = d;
      LEPUS_FreeValue(ctx, obj);
#endif
      return 0;
    case LEPUS_TAG_INT: {
    process_int:
      val_incr();
      int64_t num = 0;
      LEPUS_ToInt64(ctx, &num, obj);
      val->tag = JSON_TYPE_NUM | JSON_SUBTYPE_SINT;
      LEPUS_FreeValue(ctx, obj);
      val->uni.i64 = num;
      return 0;
    }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
      goto exception;
#endif
    case LEPUS_TAG_BOOL: {
      val_incr();
      if (LEPUS_ToBool(ctx, obj)) {
        val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_TRUE;
      } else {
        val->tag = JSON_TYPE_BOOL | JSON_SUBTYPE_FALSE;
      }
      return 0;
    }
    case LEPUS_TAG_NULL: {
    process_null:
      val_incr();
      val->tag = JSON_TYPE_NULL;
      return 0;
    }
    default: {
      LEPUS_FreeValue(ctx, obj);
      return 0;
    }
  }
exception:
fail_alloc:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, tab);
  LEPUS_FreeValue(ctx, prop);
  return -1;
#undef val_incr
}

static force_inline void byte_copy(void *dst, const void *src, size_t size) {
  memcpy(dst, src, size);
}

static force_inline uint8_t *write_null(uint8_t *cur) {
  v64 v = {'n', 'u', 'l', 'l', ',', '\n', 0, 0};
  memcpy(cur, &v, 8);
  return cur + 4;
}

static force_inline uint8_t *write_bool(uint8_t *cur, bool val) {
  v64 v0 = {'f', 'a', 'l', 's', 'e', ',', '\n', 0};
  v64 v1 = {'t', 'r', 'u', 'e', ',', '\n', 0, 0};
  if (val) {
    memcpy(cur, &v1, 8);
  } else {
    memcpy(cur, &v0, 8);
  }
  return cur + 5 - val;
}

static force_inline void json_write_ctx_set(json_write_ctx *json_ctx,
                                            size_t size, bool is_obj) {
  json_ctx->tag = (size << 1) | (size_t)is_obj;
}

static force_inline uint16_t byte_load_2(const void *src) {
  v16_uni uni;
  uni.v = *(v16 *)src;
  return uni.u;
}

static force_inline uint32_t byte_load_3(const void *src) {
  v32_uni uni;
  ((v16_uni *)&uni)->v = *(v16 *)src;
  uni.v.c3 = ((char *)src)[2];
  uni.v.c4 = 0;
  return uni.u;
}

static uint8_t *write_number(LEPUSContext *ctx, uint8_t *cur, json_val *val) {
  if (val->tag & JSON_SUBTYPE_REAL) {
#ifdef CONFIG_BIGNUM
    size_t len = 0;
    LEPUSValue raw = val->uni.bigf;
    char *str = js_ftoa1(ctx, raw, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
    LEPUS_FreeValue(ctx, raw);
    len = strlen(str);
    memcpy(cur, str, len);
    bf_realloc(ctx->bf_ctx, str, 0);
    cur += len;
#else
    double raw = val->uni.f64;
    js_dtoa1((char *)cur, raw, 10, 0, JS_DTOA_VAR_FORMAT);
    cur += strlen((char *)cur);
#endif
    return cur;
  } else {
    snprintf((char *)cur, 32, "%d", (int)(val->uni.i64));
    cur += strlen((char *)cur);
    return cur;
  }
}

static void process_lone_surrogates(const uint8_t **src, uint8_t **cur) {
  uint32_t uni = 0;
  uint32_t part1 = (*src)[0] & 0b1111;
  uint32_t part2 = (*src)[1] & 0b111111;
  uint32_t part3 = (*src)[2] & 0b111111;
  uni = part1 << 12 | part2 << 6 | part3;
  char buf[16];
  snprintf(buf, sizeof(buf), "\\u%04x", uni);
  size_t buf_len = strlen(buf);
  byte_copy((void *)*cur, buf, buf_len);
  *src += 3;
  *cur += buf_len;
}

uint8_t *write_string(uint8_t *cur, const uint8_t *str, size_t str_len,
                      const uint8_t *enc_table) {
  /* UTF-8 character mask and pattern, see `read_string` for details. */
  v16_uni b2_mask_uni = {{(char)0xE0, (char)0xC0}};
  v16_uni b2_patt_uni = {{(char)0xC0, (char)0x80}};
  v16_uni b2_requ_uni = {{(char)0x1E, 0x00}};
  v32_uni b3_mask_uni = {{(char)0xF0, (char)0xC0, (char)0xC0, 0x00}};
  v32_uni b3_patt_uni = {{(char)0xE0, (char)0x80, (char)0x80, 0x00}};
  v32_uni b3_requ_uni = {{(char)0x0F, (char)0x20, 0x00, 0x00}};
  v32_uni b3_erro_uni = {{(char)0x0D, (char)0x20, 0x00, 0x00}};
  v32_uni b4_mask_uni = {{(char)0xF8, (char)0xC0, (char)0xC0, (char)0xC0}};
  v32_uni b4_patt_uni = {{(char)0xF0, (char)0x80, (char)0x80, (char)0x80}};
  v32_uni b4_requ_uni = {{(char)0x07, (char)0x30, 0x00, 0x00}};
  v32_uni b4_err0_uni = {{(char)0x04, 0x00, 0x00, 0x00}};
  v32_uni b4_err1_uni = {{(char)0x03, (char)0x30, 0x00, 0x00}};
  uint16_t b2_mask = b2_mask_uni.u;
  uint16_t b2_patt = b2_patt_uni.u;
  uint16_t b2_requ = b2_requ_uni.u;
  uint32_t b3_mask = b3_mask_uni.u;
  uint32_t b3_patt = b3_patt_uni.u;
  uint32_t b3_requ = b3_requ_uni.u;
  uint32_t b3_erro = b3_erro_uni.u;
  uint32_t b4_mask = b4_mask_uni.u;
  uint32_t b4_patt = b4_patt_uni.u;
  uint32_t b4_requ = b4_requ_uni.u;
  uint32_t b4_err0 = b4_err0_uni.u;
  uint32_t b4_err1 = b4_err1_uni.u;

#define is_valid_seq_2(uni) (((uni & b2_mask) == b2_patt) && ((uni & b2_requ)))

#define is_valid_seq_3(uni)                                     \
  (((uni & b3_mask) == b3_patt) && ((tmp = (uni & b3_requ))) && \
   ((tmp != b3_erro)))

#define is_valid_seq_4(uni)                                     \
  (((uni & b4_mask) == b4_patt) && ((tmp = (uni & b4_requ))) && \
   ((tmp & b4_err0) == 0 || (tmp & b4_err1) == 0))

  const v32 pre = {'\\', 'u', '0', '0'};
  const uint8_t *src = str;
  const uint8_t *end = str + str_len;
  *cur++ = '"';

copy_ascii:
#define expr_jump(i) \
  if (unlikely(enc_table[src[i]])) goto stop_char_##i;

#define expr_stop(i)                   \
  stop_char_##i : memcpy(cur, src, i); \
  cur += i;                            \
  src += i;                            \
  goto copy_utf8;

  while (end - src >= 16) {
    repeat16_incr(expr_jump);
    byte_copy(cur, src, 16);
    cur += 16;
    src += 16;
  }

  while (end - src >= 4) {
    repeat4_incr(expr_jump);
    byte_copy(cur, src, 4);
    cur += 4;
    src += 4;
  }

  while (end > src) {
    expr_jump(0);
    *cur++ = *src++;
  }

  *cur++ = '"';
  return cur;

  repeat16_incr(expr_stop);

#undef expr_jump
#undef expr_stop

copy_utf8:
  if (unlikely(src + 4 > end)) {
    if (end == src) goto copy_end;
    if (end - src < enc_table[*src] / 2) goto err_one;
  }
  switch (enc_table[*src]) {
    case CHAR_ENC_CPY_1: {
      *cur++ = *src++;
      goto copy_ascii;
    }
    case CHAR_ENC_CPY_2: {
      uint16_t v;
      v = byte_load_2(src);
      if (unlikely(!is_valid_seq_2(v))) goto err_cpy;

      byte_copy(cur, src, 2);
      cur += 2;
      src += 2;
      goto copy_utf8;
    }
    case CHAR_ENC_CPY_3: {
      uint32_t v, tmp;
      v = byte_load_3(src);
      if (unlikely(!is_valid_seq_3(v))) {
        process_lone_surrogates(&src, &cur);
        goto copy_utf8;
      } else {
        byte_copy(cur, src, 3);
      }
      cur += 3;
      src += 3;
      goto copy_utf8;
    }
    case CHAR_ENC_CPY_4: {
      uint32_t v, tmp;
      v = byte_load_4(src);
      if (unlikely(!is_valid_seq_4(v))) goto err_cpy;

      byte_copy(cur, src, 4);
      cur += 4;
      src += 4;
      goto copy_utf8;
    }
    case CHAR_ENC_ESC_A: {
      byte_move(cur, &esc_single_char_table[*src * 2], 2);
      cur += 2;
      src += 1;
      goto copy_utf8;
    }
    case CHAR_ENC_ESC_1: {
      byte_copy(cur + 0, &pre, 4);
      byte_copy(cur + 4, &esc_hex_char_table[*src * 2], 2);
      cur += 6;
      src += 1;
      goto copy_utf8;
    }
    case CHAR_ENC_ERR_1: {
      goto err_one;
    }
    default:
      break;
  }

copy_end:
  *cur++ = '"';
  return cur;

err_one:
err_cpy:
  return NULL;

#undef is_valid_seq_2
#undef is_valid_seq_3
#undef is_valid_seq_4
}

static inline size_t size_align_up(size_t size, size_t align) {
  return (size + (align - 1)) & ~(align - 1);
}

static inline uint8_t *write_indent(uint8_t *cur, size_t level,
                                    const char *gap_str, size_t gap_len) {
  while (level-- > 0) {
    byte_copy(cur, gap_str, gap_len);
    cur += gap_len;
  }
  return cur;
}

static force_inline bool size_add_is_overflow(size_t size, size_t add) {
  size_t val = size + add;
  return (val < size) | (val < add);
}

static force_inline void json_write_ctx_get(json_write_ctx *json_ctx,
                                            size_t *size, bool *is_obj) {
  size_t tag = json_ctx->tag;
  *size = tag >> 1;
  *is_obj = (bool)(tag & 1);
}

static uint8_t *json_write_single(LEPUSContext *ctx, json_val *root) {
#define incr_len(_len)                                                  \
  do {                                                                  \
    hdr = (uint8_t *)lepus_malloc(ctx, _len, ALLOC_TAG_WITHOUT_PTR);    \
    if (!hdr) {                                                         \
      LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify"); \
      goto fail_alloc;                                                  \
    }                                                                   \
    cur = hdr;                                                          \
  } while (false)

#define check_str_len(_len)                                             \
  do {                                                                  \
    if ((USIZE_MAX < U64_MAX) && (_len >= (USIZE_MAX - 16) / 6)) {      \
      LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify"); \
      goto fail_alloc;                                                  \
    }                                                                   \
  } while (false)

  uint8_t *hdr = NULL, *cur;
  size_t str_len;
  const uint8_t *str_ptr;

  switch (unsafe_json_get_type(root)) {
    case JSON_TYPE_STR:
      str_len = unsafe_json_get_len(root);
      str_ptr = (const uint8_t *)unsafe_json_get_str(root);
      check_str_len(str_len);
      incr_len(str_len * 6 + 4);
      cur = write_string(cur, str_ptr, str_len, enc_table);
      if (unlikely(!cur)) {
        LEPUS_ThrowInternalError(ctx, "write string fail in JSON.stringify");
        goto fail_str;
      }
      break;

    case JSON_TYPE_NUM:
      incr_len(32);
      cur = write_number(ctx, cur, root);
      if (unlikely(!cur)) {
        LEPUS_ThrowInternalError(ctx, "write number fail in JSON.stringify");
        goto fail_num;
      }
      break;

    case JSON_TYPE_BOOL:
      incr_len(8);
      cur = write_bool(cur, unsafe_json_get_bool(root));
      break;

    case JSON_TYPE_NULL:
      incr_len(8);
      cur = write_null(cur);
      break;

    case JSON_TYPE_ARR:
      incr_len(4);
      byte_copy(cur, "[]", 2);
      cur += 2;
      break;

    case JSON_TYPE_OBJ:
      incr_len(4);
      byte_copy(cur, "{}", 2);
      cur += 2;
      break;

    default:
      LEPUS_ThrowInternalError(ctx, "write type fail in JSON.stringify");
      goto fail_type;
  }

  *cur = '\0';
  return hdr;
fail_alloc:
fail_str:
fail_num:
fail_type:
  if (!ctx->gc_enable) lepus_free(ctx, hdr);
  return nullptr;

#undef incr_len
}

static int json_write_val_incr(LEPUSContext *ctx, size_t len, size_t &alc_len,
                               json_write_ctx **json_ctx, uint8_t **hdr,
                               uint8_t **cur, uint8_t **end) {
  size_t half_alc = alc_len / 2;
  size_t alc_inc = half_alc > len ? half_alc : len;
  alc_inc = size_align_up(alc_inc, sizeof(json_write_ctx));
  if (size_add_is_overflow(alc_len, alc_inc)) {
    return -1;
  }
  alc_len += alc_inc;
  uint8_t *tmp =
      (uint8_t *)lepus_realloc(ctx, *hdr, alc_len, ALLOC_TAG_WITHOUT_PTR);
  if (unlikely(!tmp)) return -1;
  size_t json_ctx_len = (size_t)(*end - (uint8_t *)*json_ctx);
  json_write_ctx *json_ctx_tmp =
      (json_write_ctx *)(void *)(tmp + (alc_len - json_ctx_len));
  memmove((void *)json_ctx_tmp, (void *)(tmp + ((uint8_t *)(*json_ctx) - *hdr)),
          json_ctx_len);
  *json_ctx = json_ctx_tmp;
  *cur = tmp + (*cur - *hdr);
  *end = tmp + alc_len;
  *hdr = tmp;
  return 0;
}

uint8_t *json_val_write_format(LEPUSContext *ctx, json_val *root,
                               const char *gap_str) {
#define incr_len(_len)                                                    \
  do {                                                                    \
    if (unlikely((uint8_t *)(cur + _len) >= (uint8_t *)json_ctx)) {       \
      if (json_write_val_incr(ctx, _len, alc_len, &json_ctx, &hdr, &cur,  \
                              &end)) {                                    \
        LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify"); \
        goto fail_alloc;                                                  \
      }                                                                   \
    }                                                                     \
  } while (false)

  json_val *val;
  uint8_t val_type;
  size_t ctn_len, ctn_len_tmp, alc_len, str_len, level;
  size_t gap_len = strlen(gap_str);
  bool ctn_obj, ctn_obj_tmp, is_key, no_indent;
  uint8_t *hdr, *cur, *end;
  json_write_ctx *json_ctx;
  const uint8_t *str_ptr;
  HandleScope func_scope(ctx);

  if (!unsafe_json_is_ctn(root) || unsafe_json_get_len(root) == 0) {
    goto single;
  }

  alc_len = root->uni.ofs / sizeof(json_val);
  alc_len = alc_len * 18 + 64;
  alc_len = size_align_up(alc_len, sizeof(json_write_ctx));
  hdr = (uint8_t *)lepus_malloc(ctx, alc_len, ALLOC_TAG_WITHOUT_PTR);
  if (!hdr) {
    LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
    goto fail_alloc;
  }
  func_scope.PushHandle(&hdr, HANDLE_TYPE_HEAP_OBJ);
  cur = hdr;
  end = hdr + alc_len;
  json_ctx = (json_write_ctx *)(void *)end;

  val = (json_val *)root;
  val_type = unsafe_json_get_type(val);
  ctn_obj = (val_type == JSON_TYPE_OBJ);
  ctn_len = unsafe_json_get_len(val) << (uint8_t)ctn_obj;
  *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj << 5));
  *cur++ = '\n';
  val++;
  level = 1;

val_begin:
  val_type = unsafe_json_get_type(val);
  if (val_type == JSON_TYPE_STR) {
    is_key = ((uint8_t)ctn_obj & (uint8_t)~ctn_len);
    no_indent = (bool)((uint8_t)ctn_obj & (uint8_t)ctn_len);
    str_len = unsafe_json_get_len(val);
    str_ptr = (const uint8_t *)unsafe_json_get_str(val);
    check_str_len(str_len);
    incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * gap_len));
    cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
    cur = write_string(cur, str_ptr, str_len, enc_table);
    if (unlikely(!cur)) {
      LEPUS_ThrowInternalError(ctx, "write string fail in JSON.stringify");
      goto fail_str;
    }
    *cur++ = is_key ? ':' : ',';
    *cur++ = is_key ? ' ' : '\n';
    goto val_end;
  }
  if (val_type == JSON_TYPE_NUM) {
    no_indent = (bool)((uint8_t)ctn_obj & (uint8_t)ctn_len);
    incr_len(32 + (no_indent ? 0 : level * gap_len));
    cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
    cur = write_number(ctx, cur, val);
    if (unlikely(!cur)) {
      LEPUS_ThrowInternalError(ctx, "write number fail in JSON.stringify");
      goto fail_num;
    }
    *cur++ = ',';
    *cur++ = '\n';
    goto val_end;
  }
  if ((val_type & (JSON_TYPE_ARR & JSON_TYPE_OBJ)) ==
      (JSON_TYPE_ARR & JSON_TYPE_OBJ)) {
    no_indent = (bool)((uint8_t)ctn_obj & (uint8_t)ctn_len);
    ctn_len_tmp = unsafe_json_get_len(val);
    ctn_obj_tmp = (val_type == JSON_TYPE_OBJ);

    if (unlikely(ctn_len_tmp == 0)) {
      /* write empty container */
      incr_len(16 + (no_indent ? 0 : level * gap_len));
      cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
      *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj_tmp << 5));
      *cur++ = (uint8_t)(']' | ((uint8_t)ctn_obj_tmp << 5));
      *cur++ = ',';
      *cur++ = '\n';
      goto val_end;
    } else {
      /* push context, setup new container */
      incr_len(32 + (no_indent ? 0 : level * gap_len));
      json_write_ctx_set(--json_ctx, ctn_len, ctn_obj);
      ctn_len = ctn_len_tmp << (uint8_t)ctn_obj_tmp;
      ctn_obj = ctn_obj_tmp;
      cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
      level++;
      *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj << 5));
      *cur++ = '\n';
      val++;
      goto val_begin;
    }
  }
  if (val_type == JSON_TYPE_BOOL) {
    no_indent = (bool)((uint8_t)ctn_obj & (uint8_t)ctn_len);
    incr_len(16 + (no_indent ? 0 : level * gap_len));
    cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
    cur = write_bool(cur, unsafe_json_get_bool(val));
    cur += 2;
    goto val_end;
  }
  if (val_type == JSON_TYPE_NULL) {
    no_indent = (bool)((uint8_t)ctn_obj & (uint8_t)ctn_len);
    incr_len(16 + (no_indent ? 0 : level * gap_len));
    cur = write_indent(cur, no_indent ? 0 : level, gap_str, gap_len);
    cur = write_null(cur);
    cur += 2;
    goto val_end;
  }
  LEPUS_ThrowInternalError(ctx, "write type fail in JSON.stringify");
  goto fail_type;

val_end:
  val++;
  ctn_len--;
  if (unlikely(ctn_len == 0)) goto ctn_end;
  goto val_begin;

ctn_end:
  cur -= 2;
  *cur++ = '\n';
  incr_len(level * gap_len);
  cur = write_indent(cur, --level, gap_str, gap_len);
  *cur++ = (uint8_t)(']' | ((uint8_t)ctn_obj << 5));
  if (unlikely((uint8_t *)json_ctx >= end)) goto doc_end;
  json_write_ctx_get(json_ctx++, &ctn_len, &ctn_obj);
  ctn_len--;
  *cur++ = ',';
  *cur++ = '\n';
  if (likely(ctn_len > 0)) {
    goto val_begin;
  } else {
    goto ctn_end;
  }

single:
  return json_write_single(ctx, root);

doc_end:
  *cur = '\0';
  return hdr;

fail_alloc:
fail_type:
fail_num:
fail_str:
  if (!ctx->gc_enable) lepus_free(ctx, hdr);
  return nullptr;

#undef return_err
}

uint8_t *json_val_write(LEPUSContext *ctx, json_val *root) {
  json_val *val;
  uint8_t val_type;
  size_t ctn_len, ctn_len_tmp, alc_len, str_len;
  bool ctn_obj, ctn_obj_tmp, is_key;
  uint8_t *hdr, *cur, *end;
  json_write_ctx *json_ctx;
  const uint8_t *str_ptr;
  HandleScope func_scope(ctx);

  if (!unsafe_json_is_ctn(root) || unsafe_json_get_len(root) == 0) {
    goto single;
  }

  alc_len = root->uni.ofs / sizeof(json_val);
  alc_len = alc_len * 18 + 64;
  alc_len = size_align_up(alc_len, sizeof(json_write_ctx));
  hdr = (uint8_t *)lepus_malloc(ctx, alc_len, ALLOC_TAG_WITHOUT_PTR);
  if (!hdr) {
    LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
    goto fail_alloc;
  }
  func_scope.PushHandle(&hdr, HANDLE_TYPE_HEAP_OBJ);
  cur = hdr;
  end = hdr + alc_len;
  json_ctx = (json_write_ctx *)(void *)end;

  val = (json_val *)root;
  val_type = unsafe_json_get_type(val);
  ctn_obj = (val_type == JSON_TYPE_OBJ);
  ctn_len = unsafe_json_get_len(val) << (uint8_t)ctn_obj;
  *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj << 5));
  val++;

val_begin:
  val_type = unsafe_json_get_type(val);
  if (val_type == JSON_TYPE_STR) {
    is_key = ((uint8_t)ctn_obj & (uint8_t)~ctn_len);
    str_len = unsafe_json_get_len(val);
    str_ptr = (const uint8_t *)unsafe_json_get_str(val);
    check_str_len(str_len);
    incr_len(str_len * 6 + 16);
    cur = write_string(cur, str_ptr, str_len, enc_table);
    if (unlikely(!cur)) {
      LEPUS_ThrowInternalError(ctx, "write string fail in JSON.stringify");
      goto fail_str;
    }
    *cur++ = is_key ? ':' : ',';
    goto val_end;
  }
  if (val_type == JSON_TYPE_NUM) {
    incr_len(32);
    cur = write_number(ctx, cur, val);
    if (unlikely(!cur)) {
      LEPUS_ThrowInternalError(ctx, "write number fail in JSON.stringify");
      goto fail_num;
    }
    *cur++ = ',';
    goto val_end;
  }
  if ((val_type & (JSON_TYPE_ARR & JSON_TYPE_OBJ)) ==
      (JSON_TYPE_ARR & JSON_TYPE_OBJ)) {
    ctn_len_tmp = unsafe_json_get_len(val);
    ctn_obj_tmp = (val_type == JSON_TYPE_OBJ);
    incr_len(16);
    if (unlikely(ctn_len_tmp == 0)) {
      /* write empty container */
      *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj_tmp << 5));
      *cur++ = (uint8_t)(']' | ((uint8_t)ctn_obj_tmp << 5));
      *cur++ = ',';
      goto val_end;
    } else {
      /* push context, setup new container */
      json_write_ctx_set(--json_ctx, ctn_len, ctn_obj);
      ctn_len = ctn_len_tmp << (uint8_t)ctn_obj_tmp;
      ctn_obj = ctn_obj_tmp;
      *cur++ = (uint8_t)('[' | ((uint8_t)ctn_obj << 5));
      val++;
      goto val_begin;
    }
  }
  if (val_type == JSON_TYPE_BOOL) {
    incr_len(16);
    cur = write_bool(cur, unsafe_json_get_bool(val));
    cur++;
    goto val_end;
  }
  if (val_type == JSON_TYPE_NULL) {
    incr_len(16);
    cur = write_null(cur);
    cur++;
    goto val_end;
  }
  LEPUS_ThrowInternalError(ctx, "write type fail in JSON.stringify");
  goto fail_type;

val_end:
  val++;
  ctn_len--;
  if (unlikely(ctn_len == 0)) goto ctn_end;
  goto val_begin;

ctn_end:
  cur--;
  *cur++ = (uint8_t)(']' | ((uint8_t)ctn_obj << 5));
  *cur++ = ',';
  if (unlikely((uint8_t *)json_ctx >= end)) goto doc_end;
  json_write_ctx_get(json_ctx++, &ctn_len, &ctn_obj);
  ctn_len--;
  if (likely(ctn_len > 0)) {
    goto val_begin;
  } else {
    goto ctn_end;
  }

single:
  return json_write_single(ctx, root);

doc_end:
  *--cur = '\0';
  return hdr;

fail_alloc:
fail_type:
fail_num:
fail_str:
  if (!ctx->gc_enable) lepus_free(ctx, hdr);
  return nullptr;

#undef return_err
#undef check_str_len
#undef incr_len
}

QJS_STATIC int js_json_to_str(LEPUSContext *ctx, JSONStringifyContext *jsc,
                              LEPUSValueConst holder, LEPUSValue val,
                              LEPUSValueConst indent) {
  LEPUSValue indent1, sep, sep1, tab, v, prop;
  LEPUSObject *p;
  int64_t i, len;
  int cl, ret;

  indent1 = LEPUS_UNDEFINED;
  sep = LEPUS_UNDEFINED;
  sep1 = LEPUS_UNDEFINED;
  tab = LEPUS_UNDEFINED;
  prop = LEPUS_UNDEFINED;

  BOOL has_content = FALSE, is_lepus_array = FALSE;

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      if (JS_LepusRefIsArray(ctx->rt, val)) {
        is_lepus_array = TRUE;
        goto do_object_stringify;
      } else if (JS_LepusRefIsTable(ctx->rt, val)) {
        goto do_object_stringify;
      }
      LEPUS_FreeValue(ctx, val);
      return string_buffer_concat_value(jsc->b, LEPUS_NULL);
    } break;
#endif
    case LEPUS_TAG_OBJECT:
      p = LEPUS_VALUE_GET_OBJ(val);
      cl = p->class_id;
      if (cl == JS_CLASS_STRING) {
        val = JS_ToStringFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        val = JS_ToQuotedStringFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        return string_buffer_concat_value_free(jsc->b, val);
      } else if (cl == JS_CLASS_NUMBER) {
        val = JS_ToNumberFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        return string_buffer_concat_value_free(jsc->b, val);
      } else if (cl == JS_CLASS_BOOLEAN) {
        ret = string_buffer_concat_value(jsc->b, p->u.object_data);
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
#ifdef CONFIG_BIGNUM
      else if (cl == JS_CLASS_BIG_FLOAT) {
        return string_buffer_concat_value_free(jsc->b, val);
      } else if (cl == JS_CLASS_BIG_INT) {
        LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
        goto exception;
      }
#endif
#ifdef ENABLE_LEPUSNG
    do_object_stringify:
#endif
      v = js_array_includes(ctx, jsc->stack, 1, (LEPUSValueConst *)&val);
      if (LEPUS_IsException(v)) goto exception;
      if (JS_ToBoolFree_RC(ctx, v)) {
        LEPUS_ThrowTypeError(ctx, "circular reference");
        goto exception;
      }
      indent1 = JS_ConcatString(ctx, LEPUS_DupValue(ctx, indent),
                                LEPUS_DupValue(ctx, jsc->gap));
      if (LEPUS_IsException(indent1)) goto exception;
      if (!JS_IsEmptyString(jsc->gap)) {
        sep = JS_ConcatString3(ctx, "\n", LEPUS_DupValue(ctx, indent1), "");
        if (LEPUS_IsException(sep)) goto exception;
        sep1 = LEPUS_NewString(ctx, " ");
        if (LEPUS_IsException(sep1)) goto exception;
      } else {
        sep = LEPUS_DupValue(ctx, jsc->empty);
        sep1 = LEPUS_DupValue(ctx, jsc->empty);
      }
      v = js_array_push(ctx, jsc->stack, 1, (LEPUSValueConst *)&val, 0);
      if (check_exception_free(ctx, v)) goto exception;
      ret = LEPUS_IsArray(ctx, val) || is_lepus_array;
      if (ret < 0) goto exception;
      if (ret) {
        if (js_get_length64(ctx, &len, val)) goto exception;
        string_buffer_putc8(jsc->b, '[');
        for (i = 0; i < len; i++) {
          if (i > 0) string_buffer_putc8(jsc->b, ',');
          string_buffer_concat_value(jsc->b, sep);
          v = JS_GetPropertyInt64(ctx, val, i);
          if (LEPUS_IsException(v)) goto exception;
          /* XXX: could do this string conversion only when needed */
          prop = JS_ToStringFree(ctx, LEPUS_NewInt64(ctx, i));
          if (LEPUS_IsException(prop)) goto exception;
          v = js_json_check(ctx, jsc, val, v, prop);
          LEPUS_FreeValue(ctx, prop);
          prop = LEPUS_UNDEFINED;
          if (LEPUS_IsException(v)) goto exception;
          if (LEPUS_IsUndefined(v)) v = LEPUS_NULL;
          if (js_json_to_str(ctx, jsc, val, v, indent1)) goto exception;
        }
        if (len > 0 && !JS_IsEmptyString(jsc->gap)) {
          string_buffer_putc8(jsc->b, '\n');
          string_buffer_concat_value(jsc->b, indent);
        }
        string_buffer_putc8(jsc->b, ']');
      } else {
        if (!LEPUS_IsUndefined(jsc->property_list))
          tab = LEPUS_DupValue(ctx, jsc->property_list);
        else
          tab = js_object_keys(ctx, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&val,
                               JS_ITERATOR_KIND_KEY);
        if (LEPUS_IsException(tab)) goto exception;
        if (js_get_length64(ctx, &len, tab)) goto exception;
        string_buffer_putc8(jsc->b, '{');
        has_content = FALSE;
        for (i = 0; i < len; i++) {
          LEPUS_FreeValue(ctx, prop);
          prop = JS_GetPropertyInt64(ctx, tab, i);
          if (LEPUS_IsException(prop)) goto exception;
          v = JS_GetPropertyValue(ctx, val, LEPUS_DupValue(ctx, prop));
          if (LEPUS_IsException(v)) goto exception;
          v = js_json_check(ctx, jsc, val, v, prop);
          if (LEPUS_IsException(v)) goto exception;
          if (!LEPUS_IsUndefined(v)) {
            if (has_content) string_buffer_putc8(jsc->b, ',');
            prop = JS_ToQuotedStringFree(ctx, prop);
            if (LEPUS_IsException(prop)) {
              LEPUS_FreeValue(ctx, v);
              goto exception;
            }
            string_buffer_concat_value(jsc->b, sep);
            string_buffer_concat_value(jsc->b, prop);
            string_buffer_putc8(jsc->b, ':');
            string_buffer_concat_value(jsc->b, sep1);
            if (js_json_to_str(ctx, jsc, val, v, indent1)) goto exception;
            has_content = TRUE;
          }
        }
        if (has_content && LEPUS_VALUE_GET_STRING(jsc->gap)->len != 0) {
          string_buffer_putc8(jsc->b, '\n');
          string_buffer_concat_value(jsc->b, indent);
        }
        string_buffer_putc8(jsc->b, '}');
      }
      if (check_exception_free(ctx, js_array_pop(ctx, jsc->stack, 0, NULL, 0)))
        goto exception;
      LEPUS_FreeValue(ctx, val);
      LEPUS_FreeValue(ctx, tab);
      LEPUS_FreeValue(ctx, sep);
      LEPUS_FreeValue(ctx, sep1);
      LEPUS_FreeValue(ctx, indent1);
      LEPUS_FreeValue(ctx, prop);
      return 0;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING:
      val = JS_ToQuotedStringFree(ctx, val);
      if (LEPUS_IsException(val)) goto exception;
      return string_buffer_concat_value_free(jsc->b, val);
    case LEPUS_TAG_FLOAT64:
      if (!isfinite(LEPUS_VALUE_GET_FLOAT64(val))) {
        val = LEPUS_NULL;
      }
      return string_buffer_concat_value_free(jsc->b, val);
    case LEPUS_TAG_INT:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
      return string_buffer_concat_value_free(jsc->b, val);
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
      goto exception;
#endif
    default:
      LEPUS_FreeValue(ctx, val);
      return 0;
  }

exception:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, tab);
  LEPUS_FreeValue(ctx, sep);
  LEPUS_FreeValue(ctx, sep1);
  LEPUS_FreeValue(ctx, indent1);
  LEPUS_FreeValue(ctx, prop);
  return -1;
}

QJS_STATIC LEPUSValue js_json_stringify(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  // stringify(val, replacer, space)
  CallGCFunc(js_json_stringify_opt_GC, ctx, this_val, argc, argv);
  JSONStringifyContext jsc_s, *jsc = &jsc_s;
  LEPUSValueConst replacer = argv[1];
  LEPUSValue val, v, space, ret, wrapper;
  int res;
  int64_t i, j, n;
  StringBuffer b_s;

  jsc->replacer_func = LEPUS_UNDEFINED;
  jsc->stack = LEPUS_UNDEFINED;
  jsc->property_list = LEPUS_UNDEFINED;
  jsc->gap = LEPUS_UNDEFINED;
  jsc->empty = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  ret = LEPUS_UNDEFINED;
  wrapper = LEPUS_UNDEFINED;
  jsc->b = &b_s;
  string_buffer_init(ctx, jsc->b, 0);

  jsc->stack = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(jsc->stack)) goto exception;
  if (LEPUS_IsFunction(ctx, replacer)) {
    jsc->replacer_func = replacer;
  } else {
    res = LEPUS_IsArray(ctx, replacer);
    if (res < 0) goto exception;
    if (res == 0 && LEPUS_IsLepusRef(replacer) && ctx) {
      res = JS_LepusRefIsArray(ctx->rt, replacer);
    }
    if (res) {
      /* XXX: enumeration is not fully correct */
      jsc->property_list = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(jsc->property_list)) goto exception;
      if (js_get_length64(ctx, &n, replacer)) goto exception;
      for (i = j = 0; i < n; i++) {
        LEPUSValue present;
        v = JS_GetPropertyInt64(ctx, replacer, i);
        if (LEPUS_IsException(v)) goto exception;
        if (LEPUS_IsObject(v)) {
          LEPUSObject *p = LEPUS_VALUE_GET_OBJ(v);
          if (p->class_id == JS_CLASS_STRING ||
              p->class_id == JS_CLASS_NUMBER) {
            v = JS_ToStringFree(ctx, v);
            if (LEPUS_IsException(v)) goto exception;
          } else {
            LEPUS_FreeValue(ctx, v);
            continue;
          }
        } else if (LEPUS_IsNumber(v)) {
          v = JS_ToStringFree(ctx, v);
          if (LEPUS_IsException(v)) goto exception;
        } else if (!LEPUS_IsString(v)) {
          LEPUS_FreeValue(ctx, v);
          continue;
        }
        present = js_array_includes(ctx, jsc->property_list, 1,
                                    (LEPUSValueConst *)&v);
        if (LEPUS_IsException(present)) {
          LEPUS_FreeValue(ctx, v);
          goto exception;
        }
        if (!JS_ToBoolFree_RC(ctx, present)) {
          LEPUS_SetPropertyInt64(ctx, jsc->property_list, j++, v);
        } else {
          LEPUS_FreeValue(ctx, v);
        }
      }
    }
  }
  space = LEPUS_DupValue(ctx, argv[2]);
  if (LEPUS_IsObject(space)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(space);
    if (p->class_id == JS_CLASS_NUMBER) {
      space = JS_ToNumberFree(ctx, space);
    } else if (p->class_id == JS_CLASS_STRING) {
      space = JS_ToStringFree(ctx, space);
    }
    if (LEPUS_IsException(space)) {
      LEPUS_FreeValue(ctx, space);
      goto exception;
    }
  }
  if (LEPUS_IsNumber(space)) {
    int n;
    if (JS_ToInt32Clamp(ctx, &n, space, 0, 10, 0)) goto exception;
    jsc->gap = LEPUS_NewStringLen(ctx, "          ", n);
  } else if (LEPUS_IsString(space)) {
    JSString *p = nullptr;
    if (JS_IsSeparableString(space)) {
      auto content = JS_GetSeparableStringContentNotDup(ctx, space);
      p = LEPUS_VALUE_GET_STRING(content);
    } else {
      p = LEPUS_VALUE_GET_STRING(space);
    }
    jsc->gap = js_sub_string(ctx, p, 0, min_int(p->len, 10));
  } else {
    jsc->gap = LEPUS_DupValue(ctx, jsc->empty);
  }
  LEPUS_FreeValue(ctx, space);
  if (LEPUS_IsException(jsc->gap)) goto exception;
  wrapper = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(wrapper)) goto exception;
  if (JS_DefinePropertyValue_RC(ctx, wrapper, JS_ATOM_empty_string,
                                LEPUS_DupValue(ctx, argv[0]),
                                LEPUS_PROP_C_W_E) < 0) {
    goto exception;
  }
  val = LEPUS_DupValue(ctx, argv[0]);
  val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);
  if (LEPUS_IsException(val)) goto exception;
  if (LEPUS_IsUndefined(val)) {
    ret = LEPUS_UNDEFINED;
    goto done1;
  }

  if (js_json_to_str(ctx, jsc, wrapper, val, jsc->empty)) goto exception;

  ret = string_buffer_end(jsc->b);
  goto done;

exception:
  ret = LEPUS_EXCEPTION;
done1:
  string_buffer_free(jsc->b);
done:
  LEPUS_FreeValue(ctx, wrapper);
  LEPUS_FreeValue(ctx, jsc->empty);
  LEPUS_FreeValue(ctx, jsc->gap);
  LEPUS_FreeValue(ctx, jsc->property_list);
  LEPUS_FreeValue(ctx, jsc->stack);
  return ret;
}

QJS_STATIC LEPUSValue js_json_stringify_opt(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  // stringify(val, replacer, space)
  CallGCFunc(js_json_stringify_opt_GC, ctx, this_val, argc, argv);
  JSONStringifyContext jsc_s, *jsc = &jsc_s;
  LEPUSValueConst replacer = argv[1];
  LEPUSValue val, v, space, ret, wrapper;
  int res;
  int64_t i, j, n;

  json_val *json_cur_val = nullptr;
  json_val *json_root = nullptr;
  uint8_t *json_str = nullptr;
  const char *gap_str = nullptr;
  size_t alc_len = JSON_ALLOC_INIT_SIZE;
  // need to free in the end of JSON.stringify
  const char **str_arr =
      (const char **)lepus_mallocz(ctx, sizeof(char *) * JSON_ALLOC_INIT_SIZE);
  if (!str_arr)
    return LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
  size_t ts = JSON_ALLOC_INIT_SIZE;
  size_t cs = 0;

  jsc->replacer_func = LEPUS_UNDEFINED;
  jsc->stack = LEPUS_UNDEFINED;
  jsc->property_list = LEPUS_UNDEFINED;
  jsc->gap = LEPUS_UNDEFINED;
  jsc->empty = LEPUS_AtomToString(ctx, JS_ATOM_empty_string);
  ret = LEPUS_UNDEFINED;
  wrapper = LEPUS_UNDEFINED;

  jsc->stack = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(jsc->stack)) goto exception;
  if (LEPUS_IsFunction(ctx, replacer)) {
    jsc->replacer_func = replacer;
  } else {
    res = LEPUS_IsArray(ctx, replacer);
    if (res < 0) goto exception;
    if (res == 0 && LEPUS_IsLepusRef(replacer) && ctx) {
      res = JS_LepusRefIsArray(ctx->rt, replacer);
    }
    if (res) {
      /* XXX: enumeration is not fully correct */
      jsc->property_list = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(jsc->property_list)) goto exception;
      if (js_get_length64(ctx, &n, replacer)) goto exception;
      for (i = j = 0; i < n; i++) {
        LEPUSValue present;
        v = JS_GetPropertyInt64(ctx, replacer, i);
        if (LEPUS_IsException(v)) goto exception;
        if (LEPUS_IsObject(v)) {
          LEPUSObject *p = LEPUS_VALUE_GET_OBJ(v);
          if (p->class_id == JS_CLASS_STRING ||
              p->class_id == JS_CLASS_NUMBER) {
            v = JS_ToStringFree(ctx, v);
            if (LEPUS_IsException(v)) goto exception;
          } else {
            LEPUS_FreeValue(ctx, v);
            continue;
          }
        } else if (LEPUS_IsNumber(v)) {
          v = JS_ToStringFree(ctx, v);
          if (LEPUS_IsException(v)) goto exception;
        } else if (!LEPUS_IsString(v)) {
          LEPUS_FreeValue(ctx, v);
          continue;
        }
        present = js_array_includes(ctx, jsc->property_list, 1,
                                    (LEPUSValueConst *)&v);
        if (LEPUS_IsException(present)) {
          LEPUS_FreeValue(ctx, v);
          goto exception;
        }
        if (!JS_ToBoolFree_RC(ctx, present)) {
          LEPUS_SetPropertyInt64(ctx, jsc->property_list, j++, v);
        } else {
          LEPUS_FreeValue(ctx, v);
        }
      }
    }
  }
  space = LEPUS_DupValue(ctx, argv[2]);
  if (LEPUS_IsObject(space)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(space);
    if (p->class_id == JS_CLASS_NUMBER) {
      space = JS_ToNumberFree(ctx, space);
    } else if (p->class_id == JS_CLASS_STRING) {
      space = JS_ToStringFree(ctx, space);
    }
    if (LEPUS_IsException(space)) {
      LEPUS_FreeValue(ctx, space);
      goto exception;
    }
  }
  if (LEPUS_IsNumber(space)) {
    int n;
    if (JS_ToInt32Clamp(ctx, &n, space, 0, 10, 0)) goto exception;
    jsc->gap = LEPUS_NewStringLen(ctx, "          ", n);
  } else if (LEPUS_IsString(space)) {
    JSString *p = LEPUS_VALUE_GET_STRING(space);
    jsc->gap = js_sub_string(ctx, p, 0, min_int(p->len, 10));
  } else {
    jsc->gap = LEPUS_DupValue(ctx, jsc->empty);
  }
  LEPUS_FreeValue(ctx, space);
  if (LEPUS_IsException(jsc->gap)) goto exception;
  wrapper = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(wrapper)) goto exception;
  if (JS_DefinePropertyValue_RC(ctx, wrapper, JS_ATOM_empty_string,
                                LEPUS_DupValue(ctx, argv[0]),
                                LEPUS_PROP_C_W_E) < 0) {
    goto exception;
  }
  val = LEPUS_DupValue(ctx, argv[0]);
  val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);
  if (LEPUS_IsException(val)) goto exception;
  if (LEPUS_IsUndefined(val)) {
    ret = LEPUS_UNDEFINED;
    goto done;
  }

  json_root =
      static_cast<json_val *>(lepus_mallocz(ctx, alc_len * sizeof(json_val)));
  if (unlikely(!json_root)) {
    LEPUS_ThrowInternalError(ctx, "out of memory in JSON.stringify");
    goto exception;
  }
  json_cur_val = json_root;
  if (make_json_val(ctx, val, jsc, json_root, json_cur_val, alc_len, &str_arr,
                    ts, cs)) {
    goto exception;
  }
  gap_str = JS_ToCStringLen2_RC(ctx, NULL, jsc->gap, 0);
  if (gap_str && *gap_str != '\0') {
    json_str = json_val_write_format(ctx, json_root + 1, gap_str);
  } else {
    json_str = json_val_write(ctx, json_root + 1);
  }
  LEPUS_FreeCString(ctx, gap_str);
  ret = json_str ? LEPUS_NewString(ctx, (char *)json_str) : LEPUS_EXCEPTION;
  goto done;

exception:
  ret = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, wrapper);
  LEPUS_FreeValue(ctx, jsc->empty);
  LEPUS_FreeValue(ctx, jsc->gap);
  LEPUS_FreeValue(ctx, jsc->property_list);
  LEPUS_FreeValue(ctx, jsc->stack);

  if (likely(str_arr)) {
    for (int i = 0; i < cs; ++i) {
      LEPUS_FreeCString(ctx, str_arr[i]);
    }
    lepus_free(ctx, str_arr);
  }
  if (likely(json_root)) lepus_free(ctx, json_root);
  if (likely(json_str)) lepus_free(ctx, json_str);
  return ret;
}

static const LEPUSCFunctionListEntry js_json_funcs[] = {
    LEPUS_CFUNC_DEF("parse", 2, js_json_parse),
    LEPUS_CFUNC_DEF("stringify", 3, js_json_stringify),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "JSON",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_json_funcs_opt[] = {
    LEPUS_CFUNC_DEF("parse", 2, js_json_parse),
    LEPUS_CFUNC_DEF("stringify", 3, js_json_stringify_opt),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "JSON",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_json_obj[] = {
    LEPUS_OBJECT_DEF("JSON", js_json_funcs, countof(js_json_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_json_obj_opt[] = {
    LEPUS_OBJECT_DEF("JSON", js_json_funcs_opt, countof(js_json_funcs_opt),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

void LEPUS_AddIntrinsicJSON(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicJSON_GC, ctx);
  /* add JSON as autoinit object */
  if (!json_opt_disabled(ctx->rt)) {
    LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_json_obj_opt,
                                  countof(js_json_obj_opt));
  } else {
    LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_json_obj,
                                  countof(js_json_obj));
  }
}

/* Reflect */

QJS_STATIC LEPUSValue js_reflect_apply(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  return js_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 0);
}

QJS_STATIC LEPUSValue js_reflect_construct(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValueConst func, array_arg, new_target;
  LEPUSValue *tab, ret;
  uint32_t len;

  func = argv[0];
  array_arg = argv[1];
  if (argc > 2) {
    new_target = argv[2];
    if (!LEPUS_IsConstructor(ctx, new_target))
      return LEPUS_ThrowTypeError(ctx, "not a constructor");
  } else {
    new_target = func;
  }
  tab = build_arg_list(ctx, &len, array_arg);
  if (!tab) return LEPUS_EXCEPTION;
  ret = LEPUS_CallConstructor2(ctx, func, new_target, len,
                               (LEPUSValueConst *)tab);
  free_arg_list(ctx, tab, len);
  return ret;
}

LEPUSValue js_reflect_deleteProperty(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  JSAtom atom;
  int ret;

  obj = argv[0];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  atom = js_value_to_atom(ctx, argv[1]);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx);
  func_scope.PushLEPUSAtom(atom);
  ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

LEPUSValue js_reflect_get(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                          LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop, receiver;
  JSAtom atom;
  LEPUSValue ret;

  obj = argv[0];
  prop = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  if (argc > 2)
    receiver = argv[2];
  else
    receiver = obj;
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx);
  func_scope.PushLEPUSAtom(atom);
  ret = LEPUS_GetPropertyInternal(ctx, obj, atom, receiver, FALSE);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
  return ret;
}

LEPUSValue js_reflect_has(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                          LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop;
  JSAtom atom;
  int ret;

  obj = argv[0];
  prop = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx);
  func_scope.PushLEPUSAtom(atom);
  ret = LEPUS_HasProperty(ctx, obj, atom);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

LEPUSValue js_reflect_set(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                          LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop, val, receiver;
  int ret;
  JSAtom atom;

  obj = argv[0];
  prop = argv[1];
  val = argv[2];
  if (argc > 3)
    receiver = argv[3];
  else
    receiver = obj;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);
  atom = js_value_to_atom(ctx, prop);
  if (unlikely(atom == JS_ATOM_NULL)) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx);
  func_scope.PushLEPUSAtom(atom);
  ret = JS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(obj), atom,
                              LEPUS_DupValue(ctx, val), receiver, 0);
  if (!ctx->gc_enable) LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

LEPUSValue js_reflect_setPrototypeOf(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  int ret;
  ret = JS_SetPrototypeInternal(ctx, argv[0], argv[1], FALSE);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue js_reflect_ownKeys(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(argv[0]))
    return JS_ThrowTypeErrorNotAnObject(ctx);
  return JS_GetOwnPropertyNames2(ctx, argv[0],
                                 LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK,
                                 JS_ITERATOR_KIND_KEY);
}

static const LEPUSCFunctionListEntry js_reflect_funcs[] = {
    LEPUS_CFUNC_DEF("apply", 3, js_reflect_apply),
    LEPUS_CFUNC_DEF("construct", 2, js_reflect_construct),
    LEPUS_CFUNC_MAGIC_DEF("defineProperty", 3, js_object_defineProperty, 1),
    LEPUS_CFUNC_DEF("deleteProperty", 2, js_reflect_deleteProperty),
    LEPUS_CFUNC_DEF("get", 2, js_reflect_get),
    LEPUS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2,
                          lepus_object_getOwnPropertyDescriptor, 1),
    LEPUS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, js_object_getPrototypeOf, 1),
    LEPUS_CFUNC_DEF("has", 2, js_reflect_has),
    LEPUS_CFUNC_MAGIC_DEF("isExtensible", 1, js_object_isExtensible, 1),
    LEPUS_CFUNC_DEF("ownKeys", 1, js_reflect_ownKeys),
    LEPUS_CFUNC_MAGIC_DEF("preventExtensions", 1, js_object_preventExtensions,
                          1),
    LEPUS_CFUNC_DEF("set", 3, js_reflect_set),
    LEPUS_CFUNC_DEF("setPrototypeOf", 2, js_reflect_setPrototypeOf),
};

static const LEPUSCFunctionListEntry js_reflect_obj[] = {
    LEPUS_OBJECT_DEF("Reflect", js_reflect_funcs, countof(js_reflect_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Proxy */

QJS_STATIC void js_proxy_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  JSProxyData *s =
      static_cast<JSProxyData *>(LEPUS_GetOpaque(val, JS_CLASS_PROXY));
  if (s) {
    LEPUS_FreeValueRT(rt, s->target);
    LEPUS_FreeValueRT(rt, s->handler);
    LEPUS_FreeValueRT(rt, s->proto);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void js_proxy_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func, int local_idx) {
  JSProxyData *s =
      static_cast<JSProxyData *>(LEPUS_GetOpaque(val, JS_CLASS_PROXY));
  if (s) {
    JS_MarkValue_RC(rt, s->target, mark_func);
    JS_MarkValue_RC(rt, s->handler, mark_func);
    JS_MarkValue_RC(rt, s->proto, mark_func);
  }
}

QJS_STATIC LEPUSValue JS_ThrowTypeErrorRevokedProxy(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "revoked proxy");
}

QJS_STATIC JSProxyData *get_proxy_method(LEPUSContext *ctx, LEPUSValue *pmethod,
                                         LEPUSValueConst obj, JSAtom name) {
  JSProxyData *s =
      static_cast<JSProxyData *>(LEPUS_GetOpaque(obj, JS_CLASS_PROXY));
  LEPUSValue method;

  /* safer to test recursion in all proxy methods */
  if (js_check_stack_overflow(ctx, 0)) {
    JS_ThrowStackOverflow(ctx);
    return NULL;
  }

  /* 's' should never be NULL */
  if (s->is_revoked) {
    JS_ThrowTypeErrorRevokedProxy(ctx);
    return NULL;
  }
  method = JS_GetPropertyInternal_RC(ctx, s->handler, name, s->handler, 0);
  if (LEPUS_IsException(method)) return NULL;
  if (LEPUS_IsNull(method)) method = LEPUS_UNDEFINED;
  *pmethod = method;
  return s;
}

QJS_STATIC LEPUSValueConst js_proxy_getPrototypeOf(LEPUSContext *ctx,
                                                   LEPUSValueConst obj) {
  JSProxyData *s;
  LEPUSValue method, ret;
  LEPUSValueConst proto1;
  int res;

  /* must check for timeout to avoid infinite loop in instanceof */
  if (js_poll_interrupts(ctx)) return LEPUS_EXCEPTION;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_getPrototypeOf);
  if (!s) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(method)) return JS_GetPrototype_RC(ctx, s->target);
  ret = JS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return ret;
  if (!LEPUS_VALUE_IS_NULL(ret) && LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
    goto fail;
  }
  res = LEPUS_IsExtensible(ctx, s->target);
  if (res < 0) {
    LEPUS_FreeValue(ctx, ret);
    return LEPUS_EXCEPTION;
  }
  if (!res) {
    /* check invariant */
    proto1 = JS_GetPrototype_RC(ctx, s->target);
    if (LEPUS_IsException(proto1)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    if (LEPUS_VALUE_GET_OBJ(proto1) != LEPUS_VALUE_GET_OBJ(ret)) {
    fail:
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
    }
  }
  /* store the prototype in the proxy so that its refcount is at least 1 */
  set_value(ctx, &s->proto, ret);
  return (LEPUSValueConst)ret;
}

QJS_STATIC int js_proxy_setPrototypeOf(LEPUSContext *ctx, LEPUSValueConst obj,
                                       LEPUSValueConst proto_val,
                                       BOOL throw_flag) {
  JSProxyData *s;
  LEPUSValue method, ret, proto1;
  LEPUSValueConst args[2];
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_setPrototypeOf);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method))
    return JS_SetPrototypeInternal(ctx, s->target, proto_val, throw_flag);
  args[0] = s->target;
  args[1] = proto_val;
  ret = JS_CallFree(ctx, method, s->handler, 2, args);
  if (LEPUS_IsException(ret)) return -1;
  res = JS_ToBoolFree_RC(ctx, ret);
  if (!res) {
    if (throw_flag) {
      LEPUS_ThrowTypeError(ctx, "proxy: bad prototype");
      return -1;
    } else {
      return FALSE;
    }
  }
  res2 = LEPUS_IsExtensible(ctx, s->target);
  if (res2 < 0) return -1;
  if (!res2) {
    proto1 = JS_GetPrototype_RC(ctx, s->target);
    if (LEPUS_IsException(proto1)) return -1;
    if (LEPUS_VALUE_GET_OBJ(proto_val) != LEPUS_VALUE_GET_OBJ(proto1)) {
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
      return -1;
    }
  }
  return TRUE;
}

QJS_STATIC int js_proxy_isExtensible(LEPUSContext *ctx, LEPUSValueConst obj) {
  JSProxyData *s;
  LEPUSValue method, ret;
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_isExtensible);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_IsExtensible(ctx, s->target);
  ret = JS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return -1;
  res = JS_ToBoolFree_RC(ctx, ret);
  res2 = LEPUS_IsExtensible(ctx, s->target);
  if (res2 < 0) return res2;
  if (res != res2) {
    LEPUS_ThrowTypeError(ctx, "proxy: inconsistent isExtensible");
    return -1;
  }
  return res;
}

QJS_STATIC int js_proxy_preventExtensions(LEPUSContext *ctx,
                                          LEPUSValueConst obj) {
  JSProxyData *s;
  LEPUSValue method, ret;
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_preventExtensions);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_PreventExtensions(ctx, s->target);
  ret = JS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return -1;
  res = JS_ToBoolFree_RC(ctx, ret);
  if (res) {
    res2 = LEPUS_IsExtensible(ctx, s->target);
    if (res2 < 0) return res2;
    if (res2) {
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent preventExtensions");
      return -1;
    }
  }
  return res;
}

QJS_STATIC int js_proxy_has(LEPUSContext *ctx, LEPUSValueConst obj,
                            JSAtom atom) {
  JSProxyData *s;
  LEPUSValue method, ret1, atom_val;
  int ret, res;
  LEPUSObject *p;
  LEPUSValueConst args[2];
  BOOL res2;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_has);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_HasProperty(ctx, s->target, atom);
  atom_val = JS_AtomToValue_RC(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  ret1 = JS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = JS_ToBoolFree_RC(ctx, ret1);
  if (!ret) {
    LEPUSPropertyDescriptor desc;
    p = LEPUS_VALUE_GET_OBJ(s->target);
    res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);
    if (res < 0) return -1;
    if (res) {
      res2 = !(desc.flags & LEPUS_PROP_CONFIGURABLE);
      js_free_desc(ctx, &desc);
      if (res2 || !p->extensible) {
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent has");
        return -1;
      }
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue js_proxy_get(LEPUSContext *ctx, LEPUSValueConst obj,
                                   JSAtom atom, LEPUSValueConst receiver) {
  JSProxyData *s;
  LEPUSValue method, ret, atom_val;
  int res;
  LEPUSValueConst args[3];
  LEPUSPropertyDescriptor desc;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_get);
  if (!s) return LEPUS_EXCEPTION;
  /* Note: recursion is possible thru the prototype of s->target */
  if (LEPUS_IsUndefined(method))
    return LEPUS_GetPropertyInternal(ctx, s->target, atom, receiver, FALSE);
  atom_val = JS_AtomToValue_RC(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return LEPUS_EXCEPTION;
  }
  args[0] = s->target;
  args[1] = atom_val;
  args[2] = receiver;
  ret = JS_CallFree(ctx, method, s->handler, 3, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret)) return LEPUS_EXCEPTION;
  res = JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target),
                                  atom);
  if (res < 0) return LEPUS_EXCEPTION;
  if (res) {
    if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE |
                       LEPUS_PROP_WRITABLE)) == 0) {
      if (!js_same_value(ctx, desc.value, ret)) {
        goto fail;
      }
    } else if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
               LEPUS_PROP_GETSET) {
      if (LEPUS_IsUndefined(desc.getter) && !LEPUS_IsUndefined(ret)) {
      fail:
        js_free_desc(ctx, &desc);
        LEPUS_FreeValue(ctx, ret);
        return LEPUS_ThrowTypeError(ctx, "proxy: inconsistent get");
      }
    }
    js_free_desc(ctx, &desc);
  }
  return ret;
}

QJS_STATIC int js_proxy_set(LEPUSContext *ctx, LEPUSValueConst obj, JSAtom atom,
                            LEPUSValueConst value, LEPUSValueConst receiver,
                            int flags) {
  JSProxyData *s;
  LEPUSValue method, ret1, atom_val;
  int ret, res;
  LEPUSValueConst args[4];

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_set);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return JS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(s->target), atom,
                                 LEPUS_DupValue(ctx, value), receiver, flags);
  }
  atom_val = JS_AtomToValue_RC(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  args[2] = value;
  args[3] = receiver;
  ret1 = JS_CallFree(ctx, method, s->handler, 4, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = JS_ToBoolFree_RC(ctx, ret1);
  if (ret) {
    LEPUSPropertyDescriptor desc;
    res = JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target),
                                    atom);
    if (res < 0) return -1;
    if (res) {
      if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE |
                         LEPUS_PROP_WRITABLE)) == 0) {
        if (!js_same_value(ctx, desc.value, value)) {
          goto fail;
        }
      } else if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
                     LEPUS_PROP_GETSET &&
                 LEPUS_IsUndefined(desc.setter)) {
      fail:
        js_free_desc(ctx, &desc);
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent set");
        return -1;
      }
      js_free_desc(ctx, &desc);
    }
  } else {
    if ((flags & LEPUS_PROP_THROW) ||
        ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
      LEPUS_ThrowTypeError(ctx, "proxy: cannot set property");
      return -1;
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue js_create_desc(LEPUSContext *ctx, LEPUSValueConst val,
                                     LEPUSValueConst getter,
                                     LEPUSValueConst setter, int flags) {
  LEPUSValue ret;
  ret = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(ret)) return ret;
  if (flags & LEPUS_PROP_HAS_GET) {
    JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_get,
                              LEPUS_DupValue(ctx, getter), LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_SET) {
    JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_set,
                              LEPUS_DupValue(ctx, setter), LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_VALUE) {
    JS_DefinePropertyValue_RC(ctx, ret, JS_ATOM_value, LEPUS_DupValue(ctx, val),
                              LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_WRITABLE) {
    JS_DefinePropertyValue_RC(
        ctx, ret, JS_ATOM_writable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_WRITABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_ENUMERABLE) {
    JS_DefinePropertyValue_RC(
        ctx, ret, JS_ATOM_enumerable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_ENUMERABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_CONFIGURABLE) {
    JS_DefinePropertyValue_RC(
        ctx, ret, JS_ATOM_configurable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_CONFIGURABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  return ret;
}

QJS_STATIC int js_proxy_get_own_property(LEPUSContext *ctx,
                                         LEPUSPropertyDescriptor *pdesc,
                                         LEPUSValueConst obj, JSAtom prop) {
  JSProxyData *s;
  LEPUSValue method, ret1, prop_val;
  int res, target_res, ret;
  LEPUSObject *p;
  LEPUSValueConst args[2];
  LEPUSPropertyDescriptor desc, target_desc;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_getOwnPropertyDescriptor);
  if (!s) return -1;
  p = LEPUS_VALUE_GET_OBJ(s->target);
  if (LEPUS_IsUndefined(method)) {
    return JS_GetOwnPropertyInternal(ctx, pdesc, p, prop);
  }
  prop_val = JS_AtomToValue_RC(ctx, prop);
  if (LEPUS_IsException(prop_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = prop_val;
  ret1 = JS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, prop_val);
  if (LEPUS_IsException(ret1)) return -1;
  if (!LEPUS_IsObject(ret1) && !LEPUS_IsUndefined(ret1)) {
    LEPUS_FreeValue(ctx, ret1);
    goto fail;
  }
  target_res = JS_GetOwnPropertyInternal(ctx, &target_desc, p, prop);
  if (target_res < 0) {
    LEPUS_FreeValue(ctx, ret1);
    return -1;
  }
  if (target_res) js_free_desc(ctx, &target_desc);
  if (LEPUS_IsUndefined(ret1)) {
    if (target_res) {
      if (!(target_desc.flags & LEPUS_PROP_CONFIGURABLE) || !p->extensible)
        goto fail;
    }
    ret = FALSE;
  } else {
    int flags1;

    res = js_obj_to_desc(ctx, &desc, ret1);
    LEPUS_FreeValue(ctx, ret1);
    if (res < 0) return -1;
    if (target_res) {
      /* convert desc.flags to defineProperty flags */
      flags1 =
          desc.flags | LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_ENUMERABLE;
      if (desc.flags & LEPUS_PROP_GETSET)
        flags1 |= LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET;
      else
        flags1 |= LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE;
      /* XXX: not complete check: need to compare value &
         getter/setter as in defineproperty */
      if (!check_define_prop_flags(target_desc.flags, flags1)) goto fail1;
    } else {
      if (!p->extensible) goto fail1;
    }
    res = (!(desc.flags & LEPUS_PROP_CONFIGURABLE) &&
           (!target_res || (target_desc.flags & LEPUS_PROP_CONFIGURABLE)));
    if (res) {
    fail1:
      js_free_desc(ctx, &desc);
    fail:
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent getOwnPropertyDescriptor");
      return -1;
    }
    ret = TRUE;
    if (pdesc) {
      *pdesc = desc;
    } else {
      js_free_desc(ctx, &desc);
    }
  }
  return ret;
}

QJS_STATIC int js_proxy_define_own_property(LEPUSContext *ctx,
                                            LEPUSValueConst obj, JSAtom prop,
                                            LEPUSValueConst val,
                                            LEPUSValueConst getter,
                                            LEPUSValueConst setter, int flags) {
  JSProxyData *s;
  LEPUSValue method, ret1, prop_val, desc_val;
  int res, ret;
  LEPUSObject *p;
  LEPUSValueConst args[3];
  LEPUSPropertyDescriptor desc;
  BOOL setting_not_configurable;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_defineProperty);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return JS_DefineProperty_RC(ctx, s->target, prop, val, getter, setter,
                                flags);
  }
  prop_val = JS_AtomToValue_RC(ctx, prop);
  if (LEPUS_IsException(prop_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  desc_val = js_create_desc(ctx, val, getter, setter, flags);
  if (LEPUS_IsException(desc_val)) {
    LEPUS_FreeValue(ctx, prop_val);
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = prop_val;
  args[2] = desc_val;
  ret1 = JS_CallFree(ctx, method, s->handler, 3, args);
  LEPUS_FreeValue(ctx, prop_val);
  LEPUS_FreeValue(ctx, desc_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = JS_ToBoolFree_RC(ctx, ret1);
  if (!ret) {
    if (flags & LEPUS_PROP_THROW) {
      LEPUS_ThrowTypeError(ctx, "proxy: defineProperty exception");
      return -1;
    } else {
      return 0;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(s->target);
  res = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
  if (res < 0) return -1;
  setting_not_configurable =
      ((flags & (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) ==
       LEPUS_PROP_HAS_CONFIGURABLE);
  if (!res) {
    if (!p->extensible || setting_not_configurable) goto fail;
  } else {
    if (!check_define_prop_flags(desc.flags, flags) ||
        ((desc.flags & LEPUS_PROP_CONFIGURABLE) && setting_not_configurable)) {
      goto fail1;
    }
    if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
      if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
          LEPUS_PROP_GETSET) {
        if ((flags & LEPUS_PROP_HAS_GET) &&
            !js_same_value(ctx, getter, desc.getter)) {
          goto fail1;
        }
        if ((flags & LEPUS_PROP_HAS_SET) &&
            !js_same_value(ctx, setter, desc.setter)) {
          goto fail1;
        }
      }
    } else if (flags & LEPUS_PROP_HAS_VALUE) {
      if ((desc.flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)) == 0 &&
          !js_same_value(ctx, val, desc.value)) {
      fail1:
        js_free_desc(ctx, &desc);
      fail:
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent defineProperty");
        return -1;
      }
    }
    js_free_desc(ctx, &desc);
  }
  return 1;
}

QJS_STATIC int js_proxy_delete_property(LEPUSContext *ctx, LEPUSValueConst obj,
                                        JSAtom atom) {
  JSProxyData *s;
  LEPUSValue method, ret, atom_val;
  int res, res2;
  LEPUSValueConst args[2];

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_deleteProperty);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_DeleteProperty(ctx, s->target, atom, 0);
  }
  atom_val = JS_AtomToValue_RC(ctx, atom);
  ;
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  ret = JS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret)) return -1;
  res = JS_ToBoolFree_RC(ctx, ret);
  if (res) {
    LEPUSPropertyDescriptor desc;
    res2 = JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target),
                                     atom);
    if (res2 < 0) return -1;
    if (res2) {
      res2 = !(desc.flags & LEPUS_PROP_CONFIGURABLE);
      js_free_desc(ctx, &desc);
      if (res2) {
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent deleteProperty");
        return -1;
      }
    }
  }
  return res;
}

/* return the index of the property or -1 if not found */
QJS_STATIC int find_prop_key(const LEPUSPropertyEnum *tab, int n, JSAtom atom) {
  int i;
  for (i = 0; i < n; i++) {
    if (tab[i].atom == atom) return i;
  }
  return -1;
}

QJS_STATIC int js_proxy_get_own_property_names(LEPUSContext *ctx,
                                               LEPUSPropertyEnum **ptab,
                                               uint32_t *plen,
                                               LEPUSValueConst obj) {
  JSProxyData *s;
  LEPUSValue method, prop_array, val;
  uint32_t len, i, len2;
  LEPUSPropertyEnum *tab, *tab2;
  JSAtom atom;
  LEPUSPropertyDescriptor desc;
  int res, is_extensible, idx;

  s = get_proxy_method(ctx, &method, obj, JS_ATOM_ownKeys);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return JS_GetOwnPropertyNamesInternal(
        ctx, ptab, plen, LEPUS_VALUE_GET_OBJ(s->target),
        LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK);
  }
  prop_array =
      JS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(prop_array)) return -1;
  tab = NULL;
  len = 0;
  tab2 = NULL;
  len2 = 0;
  if (lepus_get_length32(ctx, &len, prop_array)) goto fail;
  if (len > 0) {
    tab = static_cast<LEPUSPropertyEnum *>(
        lepus_mallocz(ctx, sizeof(tab[0]) * len));
    if (!tab) goto fail;
  }
  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, prop_array, i);
    if (LEPUS_IsException(val)) goto fail;
    if (!LEPUS_IsString(val) && !LEPUS_IsSymbol(val)) {
      LEPUS_FreeValue(ctx, val);
      LEPUS_ThrowTypeError(ctx, "proxy: properties must be strings or symbols");
      goto fail;
    }
    atom = js_value_to_atom(ctx, val);
    LEPUS_FreeValue(ctx, val);
    if (atom == JS_ATOM_NULL) goto fail;
    tab[i].atom = atom;
    tab[i].is_enumerable = FALSE; /* XXX: redundant? */
  }

  /* check duplicate properties (XXX: inefficient, could store the
   * properties an a temporary object to use the hash) */
  for (i = 1; i < len; i++) {
    if (find_prop_key(tab, i, tab[i].atom) >= 0) {
      LEPUS_ThrowTypeError(ctx, "proxy: duplicate property");
      goto fail;
    }
  }

  is_extensible = LEPUS_IsExtensible(ctx, s->target);
  if (is_extensible < 0) goto fail;

  /* check if there are non configurable properties */
  if (s->is_revoked) {
    JS_ThrowTypeErrorRevokedProxy(ctx);
    goto fail;
  }
  if (JS_GetOwnPropertyNamesInternal(
          ctx, &tab2, &len2, LEPUS_VALUE_GET_OBJ(s->target),
          LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK))
    goto fail;
  for (i = 0; i < len2; i++) {
    if (s->is_revoked) {
      JS_ThrowTypeErrorRevokedProxy(ctx);
      goto fail;
    }
    res = JS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target),
                                    tab2[i].atom);
    if (res < 0) goto fail;
    if (res) { /* safety, property should be found */
      js_free_desc(ctx, &desc);
      if (!(desc.flags & LEPUS_PROP_CONFIGURABLE) || !is_extensible) {
        idx = find_prop_key(tab, len, tab2[i].atom);
        if (idx < 0) {
          LEPUS_ThrowTypeError(
              ctx, "proxy: target property must be present in proxy ownKeys");
          goto fail;
        }
        /* mark the property as found */
        if (!is_extensible) tab[idx].is_enumerable = TRUE;
      }
    }
  }
  if (!is_extensible) {
    /* check that all property in 'tab' were checked */
    for (i = 0; i < len; i++) {
      if (!tab[i].is_enumerable) {
        LEPUS_ThrowTypeError(
            ctx,
            "proxy: property not present in target were returned "
            "by non extensible proxy");
        goto fail;
      }
    }
  }

  js_free_prop_enum(ctx, tab2, len2);
  LEPUS_FreeValue(ctx, prop_array);
  *ptab = tab;
  *plen = len;
  return 0;
fail:
  js_free_prop_enum(ctx, tab2, len2);
  js_free_prop_enum(ctx, tab, len);
  LEPUS_FreeValue(ctx, prop_array);
  return -1;
}

QJS_STATIC LEPUSValue js_proxy_call_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst func_obj,
                                                LEPUSValueConst new_target,
                                                int argc,
                                                LEPUSValueConst *argv) {
  JSProxyData *s;
  LEPUSValue method, arg_array, ret;
  LEPUSValueConst args[3];

  s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_construct);
  if (!s) return LEPUS_EXCEPTION;
  if (!LEPUS_IsConstructor(ctx, s->target))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (LEPUS_IsUndefined(method))
    return LEPUS_CallConstructor2(ctx, s->target, new_target, argc, argv);
  arg_array = js_create_array(ctx, argc, argv);
  if (LEPUS_IsException(arg_array)) {
    ret = LEPUS_EXCEPTION;
    goto fail;
  }
  args[0] = s->target;
  args[1] = arg_array;
  args[2] = new_target;
  ret = JS_Call_RC(ctx, method, s->handler, 3, args);
  if (!LEPUS_IsException(ret) && LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
    LEPUS_FreeValue(ctx, ret);
    ret = JS_ThrowTypeErrorNotAnObject(ctx);
  }
fail:
  LEPUS_FreeValue(ctx, method);
  LEPUS_FreeValue(ctx, arg_array);
  return ret;
}

QJS_STATIC LEPUSValue js_proxy_call(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                    LEPUSValueConst this_obj, int argc,
                                    LEPUSValueConst *argv, int flags) {
  JSProxyData *s;
  LEPUSValue method, arg_array, ret;
  LEPUSValueConst args[3];

  if (flags & LEPUS_CALL_FLAG_CONSTRUCTOR)
    return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);

  s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);
  if (!s) return LEPUS_EXCEPTION;
  if (!s->is_func) {
    LEPUS_FreeValue(ctx, method);
    return LEPUS_ThrowTypeError(ctx, "not a function");
  }
  if (LEPUS_IsUndefined(method))
    return JS_Call_RC(ctx, s->target, this_obj, argc, argv);
  arg_array = js_create_array(ctx, argc, argv);
  if (LEPUS_IsException(arg_array)) {
    ret = LEPUS_EXCEPTION;
    goto fail;
  }
  args[0] = s->target;
  args[1] = this_obj;
  args[2] = arg_array;
  ret = JS_Call_RC(ctx, method, s->handler, 3, args);
fail:
  LEPUS_FreeValue(ctx, method);
  LEPUS_FreeValue(ctx, arg_array);
  return ret;
}

QJS_STATIC int js_proxy_isArray(LEPUSContext *ctx, LEPUSValueConst obj) {
  JSProxyData *s =
      static_cast<JSProxyData *>(LEPUS_GetOpaque(obj, JS_CLASS_PROXY));
  if (!s) return FALSE;
  if (js_check_stack_overflow(ctx, 0)) {
    JS_ThrowStackOverflow(ctx);
    return -1;
  }
  if (s->is_revoked) {
    JS_ThrowTypeErrorRevokedProxy(ctx);
    return -1;
  }
  return LEPUS_IsArray(ctx, s->target);
}

QJS_STATIC LEPUSValue js_proxy_constructor(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValueConst target, handler;
  LEPUSValue obj;
  JSProxyData *s;

  target = argv[0];
  handler = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(target) || LEPUS_VALUE_IS_NOT_OBJECT(handler))
    return JS_ThrowTypeErrorNotAnObject(ctx);
  s = static_cast<JSProxyData *>(LEPUS_GetOpaque(target, JS_CLASS_PROXY));
  if (s && s->is_revoked) goto revoked_proxy;
  s = static_cast<JSProxyData *>(LEPUS_GetOpaque(handler, JS_CLASS_PROXY));
  if (s && s->is_revoked) {
  revoked_proxy:
    return JS_ThrowTypeErrorRevokedProxy(ctx);
  }

  obj = JS_NewObjectProtoClass_RC(ctx, LEPUS_NULL, JS_CLASS_PROXY);
  if (LEPUS_IsException(obj)) return obj;
  s = static_cast<JSProxyData *>(lepus_malloc(ctx, sizeof(JSProxyData)));
  if (!s) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  s->target = LEPUS_DupValue(ctx, target);
  s->handler = LEPUS_DupValue(ctx, handler);
  s->proto = LEPUS_NULL;
  s->is_func = LEPUS_IsFunction(ctx, target);
  s->is_revoked = FALSE;
  LEPUS_SetOpaque(obj, s);
  LEPUS_SetConstructorBit(ctx, obj, LEPUS_IsConstructor(ctx, target));
  return obj;
}

QJS_STATIC LEPUSValue js_proxy_revoke(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int magic,
                                      LEPUSValue *func_data) {
  JSProxyData *s =
      static_cast<JSProxyData *>(LEPUS_GetOpaque(func_data[0], JS_CLASS_PROXY));
  if (s) {
    /* We do not free the handler and target in case they are
       referenced as constants in the C call stack */
    s->is_revoked = TRUE;
    LEPUS_FreeValue(ctx, func_data[0]);
    func_data[0] = LEPUS_NULL;
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_proxy_revoke_constructor(LEPUSContext *ctx,
                                                  LEPUSValueConst proxy_obj) {
  return LEPUS_NewCFunctionData(ctx, js_proxy_revoke, 0, 0, 1, &proxy_obj);
}

QJS_STATIC LEPUSValue js_proxy_revocable(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue proxy_obj, revoke_obj = LEPUS_UNDEFINED, obj;

  proxy_obj = js_proxy_constructor(ctx, LEPUS_UNDEFINED, argc, argv);
  if (LEPUS_IsException(proxy_obj)) goto fail;
  revoke_obj = js_proxy_revoke_constructor(ctx, proxy_obj);
  if (LEPUS_IsException(revoke_obj)) goto fail;
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) goto fail;
  // XXX: exceptions?
  JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_proxy, proxy_obj,
                            LEPUS_PROP_C_W_E);
  JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_revoke, revoke_obj,
                            LEPUS_PROP_C_W_E);
  return obj;
fail:
  LEPUS_FreeValue(ctx, proxy_obj);
  LEPUS_FreeValue(ctx, revoke_obj);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry js_proxy_funcs[] = {
    LEPUS_CFUNC_DEF("revocable", 2, js_proxy_revocable),
};

static const JSClassShortDef js_proxy_class_def[] = {
    {JS_ATOM_Object, js_proxy_finalizer, js_proxy_mark}, /* JS_CLASS_PROXY */
};

void LEPUS_AddIntrinsicProxy(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicProxy_GC, ctx);
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue obj1;

  if (!LEPUS_IsRegisteredClass(rt, JS_CLASS_PROXY)) {
    init_class_range(rt, js_proxy_class_def, JS_CLASS_PROXY,
                     countof(js_proxy_class_def));
    rt->class_array[JS_CLASS_PROXY].exotic = &js_proxy_exotic_methods;
    rt->class_array[JS_CLASS_PROXY].call = js_proxy_call;
  }

  obj1 = LEPUS_NewCFunction2(ctx, js_proxy_constructor, "Proxy", 2,
                             LEPUS_CFUNC_constructor, 0);
  LEPUS_SetConstructorBit(ctx, obj1, TRUE);
  LEPUS_SetPropertyFunctionList(ctx, obj1, js_proxy_funcs,
                                countof(js_proxy_funcs));
  JS_DefinePropertyValueStr_RC(ctx, ctx->global_obj, "Proxy", obj1,
                               LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
}

/* Symbol */

QJS_STATIC LEPUSValue js_symbol_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv) {
  LEPUSValue str;
  JSString *p;

  if (!LEPUS_IsUndefined(new_target))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    p = NULL;
  } else {
    str = JS_ToString_RC(ctx, argv[0]);
    if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
    p = LEPUS_VALUE_GET_STRING(str);
  }
  return JS_NewSymbol(ctx, p, JS_ATOM_TYPE_SYMBOL);
}

QJS_STATIC LEPUSValue js_thisSymbolValue(LEPUSContext *ctx,
                                         LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_SYMBOL(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_SYMBOL) {
      if (LEPUS_VALUE_IS_SYMBOL(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a symbol");
}

QJS_HIDE LEPUSValue js_symbol_toString(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  val = js_thisSymbolValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  /* XXX: use JS_ToStringInternal() with a flags */
  ret = js_string_constructor(ctx, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&val);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue js_symbol_valueOf(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return js_thisSymbolValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_symbol_get_description(LEPUSContext *ctx,
                                                LEPUSValueConst this_val) {
  LEPUSValue val, ret;
  JSAtomStruct *p;

  val = js_thisSymbolValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
  if (p->len == 0 && p->is_wide_char != 0) {
    ret = LEPUS_UNDEFINED;
  } else {
    ret = LEPUS_AtomToString(ctx, js_get_atom_index(ctx->rt, p));
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

static const LEPUSCFunctionListEntry js_symbol_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_symbol_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_symbol_valueOf),
    // XXX: should have writable: false
    LEPUS_CFUNC_DEF("[Symbol.toPrimitive]", 1, js_symbol_valueOf),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Symbol",
                          LEPUS_PROP_CONFIGURABLE),
    LEPUS_CGETSET_DEF("description", js_symbol_get_description, NULL),
};

QJS_STATIC LEPUSValue js_symbol_for(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  LEPUSValue str;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
  return JS_NewSymbol(ctx, LEPUS_VALUE_GET_STRING(str),
                      JS_ATOM_TYPE_GLOBAL_SYMBOL);
}

QJS_STATIC LEPUSValue js_symbol_keyFor(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  JSAtomStruct *p;

  if (!LEPUS_IsSymbol(argv[0]))
    return LEPUS_ThrowTypeError(ctx, "not a symbol");
  p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(argv[0]));
  if (p->atom_type != JS_ATOM_TYPE_GLOBAL_SYMBOL) return LEPUS_UNDEFINED;
  return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
}

static const LEPUSCFunctionListEntry js_symbol_funcs[] = {
    LEPUS_CFUNC_DEF("for", 1, js_symbol_for),
    LEPUS_CFUNC_DEF("keyFor", 1, js_symbol_keyFor),
};

QJS_STATIC void delete_weak_ref(LEPUSRuntime *, LEPUSObject *, void *);

QJS_STATIC void js_weakref_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  if (!p->u.weak_ref_data) return;
  LEPUSValue target = p->u.weak_ref_data->target;
  if (LEPUS_VALUE_IS_OBJECT(target)) {
    delete_weak_ref(rt, LEPUS_VALUE_GET_OBJ(target), p->u.weak_ref_data);
  }
  lepus_free_rt(rt, p->u.weak_ref_data);
  return;
}

QJS_STATIC void js_finalizationRegistry_finalizer(LEPUSRuntime *rt,
                                                  LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  FinalizationRegistryData *frd = static_cast<FinalizationRegistryData *>(
      LEPUS_GetOpaque(val, JS_CLASS_FinalizationRegistry));
  if (!frd) return;
  list_head *el, *el1;
  list_for_each_safe(el, el1, &frd->entries) {
    FinalizationRegistryEntry *fin_node =
        list_entry(el, FinalizationRegistryEntry, link);
    delete_weak_ref(rt, LEPUS_VALUE_GET_OBJ(fin_node->target), fin_node);
    LEPUS_FreeValueRT(rt, fin_node->held_value);
    LEPUS_FreeValueRT(rt, fin_node->token);
    lepus_free_rt(rt, fin_node);
  }
  LEPUS_FreeValueRT(rt, frd->cbs);
  free_finalization_registry_context(rt, frd->fg_ctx);
  lepus_free_rt(rt, frd);
  return;
}

QJS_STATIC void js_finalizationRegistry_mark(LEPUSRuntime *rt,
                                             LEPUSValueConst val,
                                             LEPUS_MarkFunc *mark_func,
                                             int local_idx) {
  FinalizationRegistryData *frd = static_cast<FinalizationRegistryData *>(
      LEPUS_GetOpaque(val, JS_CLASS_FinalizationRegistry));
  if (!frd) return;
  mark_func(rt, frd->cbs, local_idx);
  list_head *el;
  list_for_each(el, &frd->entries) {
    FinalizationRegistryEntry *fin_node =
        list_entry(el, FinalizationRegistryEntry, link);
    LEPUS_MarkValue(rt, fin_node->held_value, mark_func, local_idx);
    LEPUS_MarkValue(rt, fin_node->token, mark_func, local_idx);
  }
  return;
}

QJS_STATIC LEPUSValue js_map_constructor(LEPUSContext *ctx,
                                         LEPUSValueConst new_target, int argc,
                                         LEPUSValueConst *argv, int magic) {
  JSMapState *s;
  LEPUSValue obj, adder = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED,
                  next_method = LEPUS_UNDEFINED;
  LEPUSValueConst arr;
  BOOL is_set, is_weak;

  is_set = magic & MAGIC_SET;
  is_weak = ((magic & MAGIC_WEAK) != 0);
  obj = js_create_from_ctor(ctx, new_target, JS_CLASS_MAP + magic);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s = static_cast<JSMapState *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) goto fail;
  init_list_head(&s->records);
  s->is_weak = is_weak;
  LEPUS_SetOpaque(obj, s);
  s->hash_size = 1;
  s->hash_table = static_cast<struct list_head *>(
      lepus_malloc(ctx, sizeof(s->hash_table[0]) * s->hash_size));
  if (!s->hash_table) goto fail;
  init_list_head(&s->hash_table[0]);
  s->record_count_threshold = 4;

  arr = LEPUS_UNDEFINED;
  if (argc > 0) arr = argv[0];
  if (!LEPUS_IsUndefined(arr) && !LEPUS_IsNull(arr)) {
    LEPUSValue item, ret;
    BOOL done;

    adder = JS_GetPropertyInternal_RC(
        ctx, obj, is_set ? JS_ATOM_add : JS_ATOM_set, obj, 0);
    if (LEPUS_IsException(adder)) goto fail;
    if (!LEPUS_IsFunction(ctx, adder)) {
      LEPUS_ThrowTypeError(ctx, "set/add is not a function");
      goto fail;
    }

    iter = JS_GetIterator(ctx, arr, FALSE);
    if (LEPUS_IsException(iter)) goto fail;
    next_method = JS_GetPropertyInternal_RC(ctx, iter, JS_ATOM_next, iter, 0);
    if (LEPUS_IsException(next_method)) goto fail;

    for (;;) {
      item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail;
      if (done) {
        LEPUS_FreeValue(ctx, item);
        break;
      }
      if (is_set) {
        ret = JS_Call_RC(ctx, adder, obj, 1, (LEPUSValueConst *)&item);
        if (LEPUS_IsException(ret)) {
          LEPUS_FreeValue(ctx, item);
          goto fail;
        }
      } else {
        LEPUSValue key, value;
        LEPUSValueConst args[2];
        key = LEPUS_UNDEFINED;
        value = LEPUS_UNDEFINED;
        if (!LEPUS_IsObject(item)) {
          JS_ThrowTypeErrorNotAnObject(ctx);
          goto fail1;
        }
        key = LEPUS_GetPropertyUint32(ctx, item, 0);
        if (LEPUS_IsException(key)) goto fail1;
        value = LEPUS_GetPropertyUint32(ctx, item, 1);
        if (LEPUS_IsException(value)) goto fail1;
        args[0] = key;
        args[1] = value;
        ret = JS_Call_RC(ctx, adder, obj, 2, args);
        if (LEPUS_IsException(ret)) {
        fail1:
          LEPUS_FreeValue(ctx, item);
          LEPUS_FreeValue(ctx, key);
          LEPUS_FreeValue(ctx, value);
          goto fail;
        }
        LEPUS_FreeValue(ctx, key);
        LEPUS_FreeValue(ctx, value);
      }
      LEPUS_FreeValue(ctx, ret);
      LEPUS_FreeValue(ctx, item);
    }
    LEPUS_FreeValue(ctx, next_method);
    LEPUS_FreeValue(ctx, iter);
    LEPUS_FreeValue(ctx, adder);
  }
  return obj;
fail:
  if (LEPUS_IsObject(iter)) {
    /* close the iterator object, preserving pending exception */
    JS_IteratorClose(ctx, iter, TRUE);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, adder);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

/* XXX: could normalize strings to speed up comparison */
QJS_STATIC LEPUSValueConst map_normalize_key(LEPUSContext *ctx,
                                             LEPUSValueConst key) {
  /* convert -0.0 to +0.0 */
  if (LEPUS_VALUE_IS_FLOAT64(key) && LEPUS_VALUE_GET_FLOAT64(key) == 0.0) {
    key = LEPUS_NewInt32(ctx, 0);
  }
  return key;
}

#ifdef ENABLE_LEPUSNG
void LEPUS_FreeRefCountedWeakRef(LEPUSRuntime *rt,
                                 struct JSMapRecord *first_mr) {}
#endif

/* XXX: better hash ? */
QJS_STATIC uint32_t map_hash_key(LEPUSContext *ctx, LEPUSValueConst key) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(key);
  uint32_t h;
  double d;
  JSFloat64Union u;

  switch (tag) {
    case LEPUS_TAG_BOOL:
      h = LEPUS_VALUE_GET_BOOL(key);
      break;
    case LEPUS_TAG_SEPARABLE_STRING:
      key = JS_GetSeparableStringContentNotDup(ctx, key);
      tag = LEPUS_TAG_STRING;
    case LEPUS_TAG_STRING:
      h = hash_string(LEPUS_VALUE_GET_STRING(key), 0);
      break;
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_LEPUS_CPOINTER:
    case LEPUS_TAG_SYMBOL:
      h = (uintptr_t)LEPUS_VALUE_GET_PTR(key) * 3163;
      break;
    case LEPUS_TAG_INT:
      d = LEPUS_VALUE_GET_INT(key) * 3163;
      goto hash_float64;
    case LEPUS_TAG_FLOAT64:
      d = LEPUS_VALUE_GET_FLOAT64(key);
      /* normalize the NaN */
      if (isnan(d)) d = LEPUS_FLOAT64_NAN;
    hash_float64:
      u.d = d;
      h = (u.u32[0] ^ u.u32[1]) * 3163;
      break;
    default:
      h = 0; /* XXX: bignum support */
      break;
  }
  h ^= tag;
  return h;
}

QJS_STATIC JSMapRecord *map_find_record(LEPUSContext *ctx, JSMapState *s,
                                        LEPUSValueConst key) {
  struct list_head *el;
  JSMapRecord *mr;
  uint32_t h;

  h = map_hash_key(ctx, key) & (s->hash_size - 1);
  list_for_each(el, &s->hash_table[h]) {
    mr = list_entry(el, JSMapRecord, hash_link);
    if (js_same_value_zero(ctx, mr->key, key)) return mr;
  }
  return NULL;
}

QJS_STATIC void map_hash_resize(LEPUSContext *ctx, JSMapState *s) {
  uint32_t new_hash_size, i, h;
  size_t slack;
  struct list_head *new_hash_table, *el;
  JSMapRecord *mr;

  /* XXX: no reporting of memory allocation failure */
  if (s->hash_size == 1)
    new_hash_size = 4;
  else
    new_hash_size = s->hash_size * 2;
  new_hash_table = static_cast<struct list_head *>(lepus_realloc2(
      ctx, s->hash_table, sizeof(new_hash_table[0]) * new_hash_size, &slack));
  if (!new_hash_table) return;
  new_hash_size += slack / sizeof(*new_hash_table);

  for (i = 0; i < new_hash_size; i++) init_list_head(&new_hash_table[i]);

  list_for_each(el, &s->records) {
    mr = list_entry(el, JSMapRecord, link);
    if (!mr->empty) {
      h = map_hash_key(ctx, mr->key) & (new_hash_size - 1);
      list_add_tail(&mr->hash_link, &new_hash_table[h]);
    }
  }
  s->hash_table = new_hash_table;
  s->hash_size = new_hash_size;
  s->record_count_threshold = new_hash_size * 2;
}

QJS_STATIC JSMapRecord *map_add_record(LEPUSContext *ctx, JSMapState *s,
                                       LEPUSValueConst key) {
  uint32_t h;
  JSMapRecord *mr;
  WeakRefRecord *wr;

  mr = static_cast<JSMapRecord *>(lepus_malloc(ctx, sizeof(*mr)));
  if (!mr) return NULL;
  mr->ref_count = 1;
  mr->map = s;
  mr->empty = FALSE;
  if (s->is_weak) {
    wr = static_cast<WeakRefRecord *>(
        lepus_malloc(ctx, sizeof(WeakRefRecord), 0));
    if (!wr) {
      lepus_free(ctx, mr);
      return nullptr;
    }
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(key);
    wr->kind = WEAK_REF_KIND_WEAK_MAP;
    wr->u.map_record = mr;
    insert_weakref_record(LEPUS_VALUE_GET_OBJ(key), wr);
  } else {
    LEPUS_DupValue(ctx, key);
  }
  mr->key = (LEPUSValue)key;
  h = map_hash_key(ctx, key) & (s->hash_size - 1);
  list_add_tail(&mr->hash_link, &s->hash_table[h]);
  list_add_tail(&mr->link, &s->records);
  s->record_count++;
  if (s->record_count >= s->record_count_threshold) {
    map_hash_resize(ctx, s);
  }
  return mr;
}

/* Remove the weak reference from the object weak
   reference list. we don't use a doubly linked list to
   save space, assuming a given object has few weak
       references to it */
QJS_STATIC void delete_weak_ref(LEPUSRuntime *rt, LEPUSObject *p, void *ptr) {
  struct WeakRefRecord **pwr, *wr;
  pwr = &p->first_weak_ref;
  for (;;) {
    wr = *pwr;
    assert(wr != nullptr);
    if (wr->u.ptr == ptr) {
      // find record
      break;
    }
    pwr = &wr->next_weak_ref;
  }
  assert(wr != nullptr);
  *pwr = wr->next_weak_ref;
  lepus_free_rt(rt, wr);
  return;
}

QJS_STATIC void map_delete_record(LEPUSRuntime *rt, JSMapState *s,
                                  JSMapRecord *mr) {
  if (mr->empty) return;
  list_del(&mr->hash_link);
  if (s->is_weak) {
    delete_weak_ref(rt, LEPUS_VALUE_GET_OBJ(mr->key), mr);
  } else {
    LEPUS_FreeValueRT(rt, mr->key);
  }
  LEPUS_FreeValueRT(rt, mr->value);
  if (--mr->ref_count == 0) {
    list_del(&mr->link);
    lepus_free_rt(rt, mr);
  } else {
    /* keep a zombie record for iterators */
    mr->empty = TRUE;
    mr->key = LEPUS_UNDEFINED;
    mr->value = LEPUS_UNDEFINED;
  }
  s->record_count--;
}

QJS_STATIC void map_decref_record(LEPUSRuntime *rt, JSMapRecord *mr) {
  if (--mr->ref_count == 0) {
    /* the record can be safely removed */
    assert(mr->empty);
    list_del(&mr->link);
    lepus_free_rt(rt, mr);
  }
}

QJS_STATIC void reset_weak_ref(LEPUSRuntime *rt, LEPUSObject *p) {
  WeakRefRecord *wr, *wr_next;

  /* first pass to remove the records from the WeakMap/WeakSet
     lists */
  for (wr = p->first_weak_ref; wr != NULL; wr = wr->next_weak_ref) {
    switch (wr->kind) {
      case WEAK_REF_KIND_WEAK_MAP: {
        JSMapRecord *mr;
        mr = wr->u.map_record;
        assert(mr->map->is_weak);
        assert(!mr->empty);
        list_del(&mr->link);
        list_del(&mr->hash_link);
      } break;
      case WEAK_REF_KIND_WEAK_REF: {
        WeakRefData *weak_ref = wr->u.weak_ref;
        weak_ref->target = LEPUS_UNDEFINED;
      } break;
      case WEAK_REF_KIND_FINALIZATION_REGISTRY: {
        FinalizationRegistryEntry *fin_node = wr->u.fin_node;
        list_del(&fin_node->link);
      } break;
    }
  }

  /* second pass to free the values to avoid modifying the weak
     reference list while traversing it. */
  for (wr = p->first_weak_ref; wr != nullptr; wr = wr_next) {
    wr_next = wr->next_weak_ref;
    switch (wr->kind) {
      case WEAK_REF_KIND_WEAK_MAP: {
        LEPUS_FreeValueRT(rt, wr->u.map_record->value);
        lepus_free_rt(rt, wr->u.map_record);
      } break;
      case WEAK_REF_KIND_FINALIZATION_REGISTRY: {
        FinalizationRegistryEntry *fin_node = wr->u.fin_node;
        FinalizationRegistryData *frd = fin_node->data;
        LEPUSContext *ctx = frd->fg_ctx->ctx;
        if (ctx) {
          LEPUS_FreeValueRT(rt, LEPUS_Call(ctx, frd->cbs, LEPUS_UNDEFINED, 1,
                                           &fin_node->held_value));
        }
        LEPUS_FreeValueRT(rt, fin_node->held_value);
        LEPUS_FreeValueRT(rt, fin_node->token);
        lepus_free_rt(rt, fin_node);
      } break;
      default:
        break;
    }
    lepus_free_rt(rt, wr);
  }
  return;
}

QJS_STATIC LEPUSValue js_map_set(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  JSMapRecord *mr;
  LEPUSValueConst key, value;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);

  if (s->is_weak && LEPUS_VALUE_IS_NOT_OBJECT(key)) {
#ifdef ENABLE_LEPUSNG
    key = JSRef2Value(ctx, key);
    if (LEPUS_VALUE_IS_NOT_OBJECT(key))
#endif
      return JS_ThrowTypeErrorNotAnObject(ctx);
  }

  if (magic & MAGIC_SET)
    value = LEPUS_UNDEFINED;
  else
    value = argv[1];
  mr = map_find_record(ctx, s, key);
  if (mr) {
    LEPUS_FreeValue(ctx, mr->value);
  } else {
    mr = map_add_record(ctx, s, key);
    if (!mr) return LEPUS_EXCEPTION;
  }
  mr->value = LEPUS_DupValue(ctx, value);
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_map_get(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  JSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);

#ifdef ENABLE_LEPUSNG
  if (s->is_weak && LEPUS_VALUE_IS_LEPUS_REF(key)) {
    key = JSRef2Value(ctx, key);
  }
#endif

  mr = map_find_record(ctx, s, key);
  if (!mr)
    return LEPUS_UNDEFINED;
  else
    return LEPUS_DupValue(ctx, mr->value);
}

QJS_STATIC LEPUSValue js_map_has(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  JSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);

#ifdef ENABLE_LEPUSNG
  if (s->is_weak && LEPUS_VALUE_IS_LEPUS_REF(key)) {
    key = JSRef2Value(ctx, key);
  }
#endif

  mr = map_find_record(ctx, s, key);
  return LEPUS_NewBool(ctx, (mr != NULL));
}

QJS_STATIC LEPUSValue js_map_delete(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  JSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);

#ifdef ENABLE_LEPUSNG
  if (s->is_weak && LEPUS_VALUE_IS_LEPUS_REF(key)) {
    key = JSRef2Value(ctx, key);
  }
#endif

  mr = map_find_record(ctx, s, key);
  if (!mr) return LEPUS_FALSE;
  map_delete_record(ctx->rt, s, mr);
  return LEPUS_TRUE;
}

QJS_STATIC LEPUSValue js_map_clear(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv, int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  struct list_head *el, *el1;
  JSMapRecord *mr;

  if (!s) return LEPUS_EXCEPTION;
  list_for_each_safe(el, el1, &s->records) {
    mr = list_entry(el, JSMapRecord, link);
    map_delete_record(ctx->rt, s, mr);
  }
  return LEPUS_UNDEFINED;
}

QJS_HIDE LEPUSValue js_map_get_size(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  if (!s) return LEPUS_EXCEPTION;
  return JS_NewUint32(ctx, s->record_count);
}

QJS_STATIC LEPUSValue js_map_forEach(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  JSMapState *s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  LEPUSValueConst func, this_arg;
  LEPUSValue ret;
  LEPUSValue args[3];
  struct list_head *el;
  JSMapRecord *mr;

  if (!s) return LEPUS_EXCEPTION;
  func = argv[0];
  if (argc > 1)
    this_arg = argv[1];
  else
    this_arg = LEPUS_UNDEFINED;
  if (check_function(ctx, func)) return LEPUS_EXCEPTION;
  /* Note: the list can be modified while traversing it, but the
     current element is locked */
  el = s->records.next;
  while (el != &s->records) {
    mr = list_entry(el, JSMapRecord, link);
    if (!mr->empty) {
      mr->ref_count++;
      /* must duplicate in case the record is deleted */

      args[1] = LEPUS_DupValue(ctx, mr->key);
      if (magic)
        args[0] = args[1];
      else
        args[0] = LEPUS_DupValue(ctx, mr->value);
      args[2] = (LEPUSValue)this_val;
      ret = JS_Call_RC(ctx, func, this_arg, 3, (LEPUSValueConst *)args);
      LEPUS_FreeValue(ctx, args[0]);
      if (!magic) LEPUS_FreeValue(ctx, args[1]);
      el = el->next;
      map_decref_record(ctx->rt, mr);
      if (LEPUS_IsException(ret)) return ret;
      LEPUS_FreeValue(ctx, ret);
    } else {
      el = el->next;
    }
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC void js_map_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p;
  JSMapState *s;
  struct list_head *el, *el1;
  JSMapRecord *mr;

  p = LEPUS_VALUE_GET_OBJ(val);
  s = p->u.map_state;
  if (s) {
    /* if the object is deleted we are sure that no iterator is
       using it */
    list_for_each_safe(el, el1, &s->records) {
      mr = list_entry(el, JSMapRecord, link);
      if (!mr->empty) {
        if (s->is_weak)
          delete_weak_ref(rt, LEPUS_VALUE_GET_OBJ(mr->key), mr);
        else
          LEPUS_FreeValueRT(rt, mr->key);
        LEPUS_FreeValueRT(rt, mr->value);
      }
      lepus_free_rt(rt, mr);
    }
    lepus_free_rt(rt, s->hash_table);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void js_map_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                            LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSMapState *s;
  struct list_head *el;
  JSMapRecord *mr;

  s = p->u.map_state;
  if (s) {
    list_for_each(el, &s->records) {
      mr = list_entry(el, JSMapRecord, link);
      if (!s->is_weak) JS_MarkValue_RC(rt, mr->key, mark_func);
      JS_MarkValue_RC(rt, mr->value, mark_func);
    }
  }
}

/* Map Iterator */

typedef struct JSMapIteratorData {
  LEPUSValue obj;
  JSIteratorKindEnum kind;
  JSMapRecord *cur_record;
} JSMapIteratorData;

QJS_STATIC void js_map_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p;
  JSMapIteratorData *it;

  p = LEPUS_VALUE_GET_OBJ(val);
  it = p->u.map_iterator_data;
  if (it) {
    /* During the GC sweep phase the Map finalizer may be
       called before the Map iterator finalizer */
    if (JS_IsLiveObject(rt, it->obj) && it->cur_record) {
      map_decref_record(rt, it->cur_record);
    }
    LEPUS_FreeValueRT(rt, it->obj);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void js_map_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                     LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSMapIteratorData *it;
  it = p->u.map_iterator_data;
  if (it) {
    /* the record is already marked by the object */
    JS_MarkValue_RC(rt, it->obj, mark_func);
  }
}

QJS_STATIC LEPUSValue js_create_map_iterator(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv, int magic) {
  JSIteratorKindEnum kind;
  JSMapState *s;
  JSMapIteratorData *it;
  LEPUSValue enum_obj;

  kind = static_cast<JSIteratorKindEnum>(magic >> 2);
  magic &= 3;
  s = static_cast<JSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP + magic));
  if (!s) return LEPUS_EXCEPTION;
  enum_obj = LEPUS_NewObjectClass(ctx, JS_CLASS_MAP_ITERATOR + magic);
  if (LEPUS_IsException(enum_obj)) goto fail;
  it = static_cast<JSMapIteratorData *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) {
    LEPUS_FreeValue(ctx, enum_obj);
    goto fail;
  }
  it->obj = LEPUS_DupValue(ctx, this_val);
  it->kind = kind;
  it->cur_record = NULL;
  LEPUS_SetOpaque(enum_obj, it);
  return enum_obj;
fail:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_map_iterator_next(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv, BOOL *pdone,
                                           int magic) {
  JSMapIteratorData *it;
  JSMapState *s;
  JSMapRecord *mr;
  struct list_head *el;

  it = static_cast<JSMapIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_MAP_ITERATOR + magic));
  if (!it) {
    *pdone = FALSE;
    return LEPUS_EXCEPTION;
  }
  if (LEPUS_IsUndefined(it->obj)) goto done;
  s = static_cast<JSMapState *>(LEPUS_GetOpaque(it->obj, JS_CLASS_MAP + magic));
  assert(s != NULL);
  if (!it->cur_record) {
    el = s->records.next;
  } else {
    mr = it->cur_record;
    el = mr->link.next;
    map_decref_record(ctx->rt, mr); /* the record can be freed here */
  }
  for (;;) {
    if (el == &s->records) {
      /* no more record  */
      it->cur_record = NULL;
      LEPUS_FreeValue(ctx, it->obj);
      it->obj = LEPUS_UNDEFINED;
    done:
      /* end of enumeration */
      *pdone = TRUE;
      return LEPUS_UNDEFINED;
    }
    mr = list_entry(el, JSMapRecord, link);
    if (!mr->empty) break;
    /* get the next record */
    el = mr->link.next;
  }

  /* lock the record so that it won't be freed */
  mr->ref_count++;
  it->cur_record = mr;
  *pdone = FALSE;

  if (it->kind == JS_ITERATOR_KIND_KEY) {
    return LEPUS_DupValue(ctx, mr->key);
  } else {
    LEPUSValueConst args[2];
    args[0] = mr->key;
    if (magic)
      args[1] = mr->key;
    else
      args[1] = mr->value;
    if (it->kind == JS_ITERATOR_KIND_VALUE) {
      return LEPUS_DupValue(ctx, args[1]);
    } else {
      return js_create_array(ctx, 2, args);
    }
  }
}

static const LEPUSCFunctionListEntry js_map_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
};

static const LEPUSCFunctionListEntry js_map_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("set", 2, js_map_set, 0),
    LEPUS_CFUNC_MAGIC_DEF("get", 1, js_map_get, 0),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, js_map_has, 0),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, 0),
    LEPUS_CFUNC_MAGIC_DEF("clear", 0, js_map_clear, 0),
    LEPUS_CGETSET_MAGIC_DEF("size", js_map_get_size, NULL, 0),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, js_map_forEach, 0),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, js_create_map_iterator,
                          (JS_ITERATOR_KIND_VALUE << 2) | 0),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, js_create_map_iterator,
                          (JS_ITERATOR_KIND_KEY << 2) | 0),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, js_create_map_iterator,
                          (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | 0),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "entries"),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_map_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, js_map_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_set_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 1, js_map_set, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("clear", 0, js_map_clear, MAGIC_SET),
    LEPUS_CGETSET_MAGIC_DEF("size", js_map_get_size, NULL, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, js_map_forEach, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, js_create_map_iterator,
                          (JS_ITERATOR_KIND_KEY << 2) | MAGIC_SET),
    LEPUS_ALIAS_DEF("keys", "values"),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, js_create_map_iterator,
                          (JS_ITERATOR_KIND_KEY_AND_VALUE << 2) | MAGIC_SET),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_set_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, js_map_iterator_next, MAGIC_SET),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_weak_map_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("set", 2, js_map_set, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("get", 1, js_map_get, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_WEAK),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakMap",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_weak_set_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 1, js_map_set, MAGIC_SET | MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, js_map_has, MAGIC_SET | MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, js_map_delete, MAGIC_SET | MAGIC_WEAK),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakSet",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry *const js_map_proto_funcs_ptr[6] = {
    js_map_proto_funcs,          js_set_proto_funcs,
    js_weak_map_proto_funcs,     js_weak_set_proto_funcs,
    js_map_iterator_proto_funcs, js_set_iterator_proto_funcs,
};

static const uint8_t js_map_proto_funcs_count[6] = {
    countof(js_map_proto_funcs),          countof(js_set_proto_funcs),
    countof(js_weak_map_proto_funcs),     countof(js_weak_set_proto_funcs),
    countof(js_map_iterator_proto_funcs), countof(js_set_iterator_proto_funcs),
};

void LEPUS_AddIntrinsicMapSet(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicMapSet_GC, ctx);
  int i;
  LEPUSValue obj1;
  char buf[ATOM_GET_STR_BUF_SIZE];

  for (i = 0; i < 4; i++) {
    const char *name = JS_AtomGetStr(ctx, buf, sizeof(buf), JS_ATOM_Map + i);
    ctx->class_proto[JS_CLASS_MAP + i] = LEPUS_NewObject(ctx);
    LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_MAP + i],
                                  js_map_proto_funcs_ptr[i],
                                  js_map_proto_funcs_count[i]);
    obj1 = LEPUS_NewCFunctionMagic(ctx, js_map_constructor, name, 0,
                                   LEPUS_CFUNC_constructor_magic, i);
    if (i < 2) {
      LEPUS_SetPropertyFunctionList(ctx, obj1, js_map_funcs,
                                    countof(js_map_funcs));
    }
    JS_NewGlobalCConstructor2(ctx, obj1, name,
                              ctx->class_proto[JS_CLASS_MAP + i]);
  }

  for (i = 0; i < 2; i++) {
    ctx->class_proto[JS_CLASS_MAP_ITERATOR + i] =
        LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
    LEPUS_SetPropertyFunctionList(
        ctx, ctx->class_proto[JS_CLASS_MAP_ITERATOR + i],
        js_map_proto_funcs_ptr[i + 4], js_map_proto_funcs_count[i + 4]);
  }
}

/* Generator */
static const LEPUSCFunctionListEntry js_generator_function_proto_funcs[] = {
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "GeneratorFunction",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_generator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 1, js_generator_next, GEN_MAGIC_NEXT),
    LEPUS_ITERATOR_NEXT_DEF("return", 1, js_generator_next, GEN_MAGIC_RETURN),
    LEPUS_ITERATOR_NEXT_DEF("throw", 1, js_generator_next, GEN_MAGIC_THROW),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Generator",
                          LEPUS_PROP_CONFIGURABLE),
};

/* WeakRef */
QJS_STATIC LEPUSValue js_weakref_deref(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  WeakRefData *data =
      static_cast<WeakRefData *>(LEPUS_GetOpaque(this_val, JS_CLASS_WeakRef));
  if (!data) {
    return LEPUS_ThrowTypeError(
        ctx, "Method WeakRef.prototype.deref called on incompatible receiver");
  }
  return LEPUS_DupValue(ctx, data->target);
}

static const LEPUSCFunctionListEntry js_weakref_proto_funcs[] = {
    LEPUS_CFUNC_DEF("deref", 0, js_weakref_deref),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakRef",
                          LEPUS_PROP_CONFIGURABLE),
};

QJS_STATIC LEPUSValue js_weakref_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst new_target,
                                             int argc, LEPUSValueConst *argv) {
  if (argc < 1 || LEPUS_VALUE_IS_NOT_OBJECT(argv[0])) {
    return LEPUS_ThrowTypeError(ctx, "WeakRef: target must be an object");
  }
  LEPUSValue val;
  LEPUSValue target;
  WeakRefRecord *wr = nullptr;
  WeakRefData *wrd = nullptr;

  val = js_create_from_ctor(ctx, new_target, JS_CLASS_WeakRef);
  if (LEPUS_IsException(val)) return val;
  wrd = static_cast<WeakRefData *>(lepus_malloc(ctx, sizeof(WeakRefData)));
  if (!wrd) goto fail1;
  target = argv[0];
  wrd->target = target;

  wr = static_cast<WeakRefRecord *>(lepus_malloc(ctx, sizeof(WeakRefRecord)));
  if (!wr) goto fail2;

  wr->kind = WEAK_REF_KIND_WEAK_REF;
  wr->u.weak_ref = wrd;
  insert_weakref_record(LEPUS_VALUE_GET_OBJ(target), wr);
  LEPUS_SetOpaque(val, wrd);
  return val;

fail2:
  lepus_free(ctx, wrd);
fail1:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

QJS_STATIC void JS_AddIntrinsicWeakRef(LEPUSContext *ctx) {
  const char *name = "WeakRef";
  JSAtom JS_ATOM_WeakRef = LEPUS_NewAtom(ctx, "WeakRef");
  JSClassShortDef const js_weak_ref_def[] = {
      {JS_ATOM_WeakRef, js_weakref_finalizer, NULL},
  };

  LEPUSRuntime *rt = ctx->rt;
  if (!LEPUS_IsRegisteredClass(rt, JS_CLASS_WeakRef)) {
    init_class_range(rt, js_weak_ref_def, JS_CLASS_WeakRef,
                     countof(js_weak_ref_def));
  }
  // weakref
  LEPUSValue proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, proto, js_weakref_proto_funcs, 2);
  ctx->class_proto[JS_CLASS_WeakRef] = proto;
  JS_NewGlobalCConstructorOnly(ctx, name, &js_weakref_constructor, 1, proto);
  LEPUS_FreeAtom(ctx, JS_ATOM_WeakRef);
}

LEPUSValue js_finalizationRegistry_register(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue target, held_value, token;
  LEPUSObject *target_p;
  FinalizationRegistryData *frd;
  FinalizationRegistryEntry *fin_node;
  WeakRefRecord *wr;
  frd = static_cast<FinalizationRegistryData *>(
      LEPUS_GetOpaque(this_val, JS_CLASS_FinalizationRegistry));
  if (!frd) {
    return LEPUS_ThrowTypeError(
        ctx,
        "Method FinalizationRegistry.prototype.register called on incompatible "
        "receiver");
  }

  target = argv[0];
  if (LEPUS_VALUE_IS_NOT_OBJECT(target)) {
    return LEPUS_ThrowTypeError(
        ctx,
        "FinalizationRegistry.prototype.register: target must be an object");
  }
  target_p = LEPUS_VALUE_GET_OBJ(target);
  held_value = argv[1];
  if (LEPUS_VALUE_IS_OBJECT(held_value) &&
      (LEPUS_VALUE_GET_OBJ(held_value) == target_p)) {
    return LEPUS_ThrowTypeError(ctx,
                                "FinalizationRegistry.prototype.register: "
                                "target and holdings must not be same");
  }

  if (argc > 2) {
    token = argv[2];
    if (LEPUS_VALUE_IS_NOT_OBJECT(token)) {
      return LEPUS_ThrowTypeError(ctx, "unregisterToken must be an object");
    }
  } else {
    token = LEPUS_UNDEFINED;
  }
  wr = static_cast<WeakRefRecord *>(lepus_malloc(ctx, sizeof(WeakRefRecord)));
  if (!wr) return LEPUS_EXCEPTION;
  fin_node = static_cast<FinalizationRegistryEntry *>(
      lepus_malloc(ctx, sizeof(FinalizationRegistryEntry)));
  if (!fin_node) {
    lepus_free(ctx, wr);
    return LEPUS_EXCEPTION;
  }
  fin_node->data = frd;
  fin_node->target = target;
  fin_node->held_value = LEPUS_DupValue(ctx, held_value);
  fin_node->token = LEPUS_DupValue(ctx, token);
  list_add_tail(&fin_node->link, &frd->entries);
  wr->kind = WEAK_REF_KIND_FINALIZATION_REGISTRY;
  wr->u.fin_node = fin_node;
  insert_weakref_record(target_p, wr);
  return LEPUS_UNDEFINED;
}

LEPUSValue js_finalizationRegistry_unregister(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue token = argv[0];
  FinalizationRegistryData *frd;
  list_head *el, *el1;
  FinalizationRegistryEntry *fin_node;
  LEPUSObject *token_p;
  bool removed = false;

  frd = static_cast<FinalizationRegistryData *>(
      LEPUS_GetOpaque(this_val, JS_CLASS_FinalizationRegistry));
  if (!frd) {
    return LEPUS_ThrowTypeError(ctx,
                                "FinalizationRegistry.prototype.unregister: "
                                "called on incompatible receiver");
  }
  if (LEPUS_VALUE_IS_NOT_OBJECT(token)) {
    return LEPUS_ThrowTypeError(ctx, "unregisterToken must be an object");
  }
  token_p = LEPUS_VALUE_GET_OBJ(token);
  list_for_each_safe(el, el1, &frd->entries) {
    fin_node = list_entry(el, FinalizationRegistryEntry, link);
    if (LEPUS_VALUE_IS_OBJECT(fin_node->token) &&
        LEPUS_VALUE_GET_OBJ(fin_node->token) == token_p) {
      list_del(&fin_node->link);
      delete_weak_ref(ctx->rt, LEPUS_VALUE_GET_OBJ(fin_node->target), fin_node);
      LEPUS_FreeValue(ctx, fin_node->held_value);
      LEPUS_FreeValue(ctx, fin_node->token);
      lepus_free(ctx, fin_node);
      removed = true;
    }
  }
  return LEPUS_NewBool(ctx, removed);
};

QJS_STATIC LEPUSValue js_finalizationRegistry_constructor(
    LEPUSContext *ctx, LEPUSValueConst new_target, int argc,
    LEPUSValueConst *argv) {
  LEPUSValue executor;
  LEPUSValue val;

  executor = argv[0];
  if (check_function(ctx, executor))
    return LEPUS_ThrowTypeError(
        ctx, "FinalizationRegistry: cleanup must be callable");
  val = js_create_from_ctor(ctx, new_target, JS_CLASS_FinalizationRegistry);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;

  FinalizationRegistryData *frd = static_cast<FinalizationRegistryData *>(
      lepus_malloc(ctx, sizeof(FinalizationRegistryData)));
  if (!frd) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  frd->fg_ctx = ctx->fg_ctx;
  frd->fg_ctx->ref_count++;
  init_list_head(&frd->entries);
  frd->cbs = LEPUS_DupValue(ctx, executor);
  LEPUS_SetOpaque(val, frd);
  return val;
}

QJS_STATIC const LEPUSCFunctionListEntry
    js_finalizationRegistry_proto_funcs[] = {
        LEPUS_CFUNC_DEF("register", 3, js_finalizationRegistry_register),
        LEPUS_CFUNC_DEF("unregister", 1, js_finalizationRegistry_unregister),
        LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "FinalizationRegistry",
                              LEPUS_PROP_CONFIGURABLE),
};

void JS_AddIntrinsicFinalizationRegistry(LEPUSContext *ctx) {
  const char *name = "FinalizationRegistry";
  LEPUSRuntime *rt = ctx->rt;
  JSAtom JS_ATOM_FinalizationRegistry = LEPUS_NewAtom(ctx, name);
  JSClassShortDef const js_finalization_ref_def[] = {
      {JS_ATOM_FinalizationRegistry, js_finalizationRegistry_finalizer,
       js_finalizationRegistry_mark},
  };

  if (!LEPUS_IsRegisteredClass(rt, JS_CLASS_FinalizationRegistry)) {
    init_class_range(rt, js_finalization_ref_def, JS_CLASS_FinalizationRegistry,
                     countof(js_finalization_ref_def));
  }
  LEPUSValue proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, proto, js_finalizationRegistry_proto_funcs,
                                countof(js_finalizationRegistry_proto_funcs));
  ctx->class_proto[JS_CLASS_FinalizationRegistry] = proto;
  JS_NewGlobalCConstructorOnly(ctx, name, js_finalizationRegistry_constructor,
                               1, proto);
  LEPUS_FreeAtom(ctx, JS_ATOM_FinalizationRegistry);
}

/* Promise */

int LEPUS_MoveUnhandledRejectionToException(LEPUSContext *ctx) {
  CallGCFunc(JS_MoveUnhandledRejectionToException_GC, ctx);
  //  assert(LEPUS_IsNull(ctx->rt->current_exception));
  if (!LEPUS_IsNull(ctx->rt->current_exception)) {
    LEPUS_FreeValue(ctx, LEPUS_GetException(ctx));
  }
  struct list_head *el = ctx->rt->unhandled_rejections.next;
  if (el == &ctx->rt->unhandled_rejections) return 0;
  JSUnhandledRejectionEntry *e =
      list_entry(el, JSUnhandledRejectionEntry, link);
  ctx->rt->current_exception = e->error;
  list_del(el);
  lepus_free_rt(ctx->rt, el);
  return 1;
}

size_t LEPUS_GetHeapSize(LEPUSRuntime *rt) {
  if (rt->gc_enable) {
    return rt->malloc_state.allocate_state.footprint;
  } else {
    return rt->malloc_state.malloc_size;
  }
}

QJS_STATIC int js_create_resolving_functions(LEPUSContext *ctx,
                                             LEPUSValue *args,
                                             LEPUSValueConst promise);

QJS_STATIC void promise_reaction_data_free(LEPUSRuntime *rt,
                                           JSPromiseReactionData *rd) {
  LEPUS_FreeValueRT(rt, rd->resolving_funcs[0]);
  LEPUS_FreeValueRT(rt, rd->resolving_funcs[1]);
  LEPUS_FreeValueRT(rt, rd->handler);
  lepus_free_rt(rt, rd);
}

QJS_STATIC LEPUSValue promise_reaction_job(LEPUSContext *ctx, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValueConst handler, arg, func;
  LEPUSValue res, res2;
  BOOL is_reject;

  assert(argc == 5);
#ifdef BUILD_ASYNC_STACK
  ctx->rt->current_micro_task = argv;
#endif
  handler = argv[2];
  is_reject = LEPUS_ToBool(ctx, argv[3]);
  arg = argv[4];
#ifdef DUMP_PROMISE
  printf("promise_reaction_job: is_reject=%d\n", is_reject);
#endif

  if (LEPUS_IsUndefined(handler)) {
    if (is_reject) {
      res = LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
    } else {
      res = LEPUS_DupValue(ctx, arg);
    }
  } else {
    res = JS_Call_RC(ctx, handler, LEPUS_UNDEFINED, 1, &arg);
  }
  is_reject = LEPUS_IsException(res);
  if (is_reject) res = LEPUS_GetException(ctx);
  func = argv[is_reject];
  /* as an extension, we support undefined as value to avoid
     creating a dummy promise in the 'await' implementation of async
     functions */
  if (!LEPUS_IsUndefined(func)) {
    res2 = JS_Call_RC(ctx, func, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&res);
  } else {
    res2 = LEPUS_UNDEFINED;
  }
  LEPUS_FreeValue(ctx, res);
#ifdef BUILD_ASYNC_STACK
  ctx->rt->current_micro_task = NULL;
#endif
  return res2;
}

QJS_STATIC void fulfill_or_reject_promise(LEPUSContext *ctx,
                                          LEPUSValueConst promise,
                                          LEPUSValueConst value,
                                          BOOL is_reject) {
  JSPromiseData *s =
      static_cast<JSPromiseData *>(LEPUS_GetOpaque(promise, JS_CLASS_PROMISE));
  struct list_head *el, *el1;
  JSPromiseReactionData *rd;
  LEPUSValueConst args[5];

  if (!s || s->promise_state != JS_PROMISE_PENDING)
    return; /* should never happen */
  set_value(ctx, &s->promise_result, LEPUS_DupValue(ctx, value));
  s->promise_state =
      static_cast<JSPromiseStateEnum>(JS_PROMISE_FULFILLED + is_reject);
#ifdef DUMP_PROMISE
  printf("fulfill_or_reject_promise: is_reject=%d\n", is_reject);
#endif
  BOOL rejection_handled = FALSE;
  /* Note: could call HostPromiseRejectTracker */
  list_for_each_safe(el, el1, &s->promise_reactions[is_reject]) {
    rd = list_entry(el, JSPromiseReactionData, link);
    rejection_handled = TRUE;
    args[0] = rd->resolving_funcs[0];
    args[1] = rd->resolving_funcs[1];
    args[2] = rd->handler;
    args[3] = LEPUS_NewBool(ctx, is_reject);
    args[4] = value;
    LEPUS_EnqueueJob(ctx, promise_reaction_job, 5, args);
    list_del(&rd->link);
    promise_reaction_data_free(ctx->rt, rd);
  }

  list_for_each_safe(el, el1, &s->promise_reactions[1 - is_reject]) {
    rd = list_entry(el, JSPromiseReactionData, link);
    list_del(&rd->link);
    promise_reaction_data_free(ctx->rt, rd);
  }

  if (is_reject && !rejection_handled) {
    /* Unhandled rejection detected */
    JSUnhandledRejectionEntry *e;
    e = static_cast<JSUnhandledRejectionEntry *>(lepus_malloc(ctx, sizeof(*e)));
    // only promises handled later will use this value, thus its refcount always
    // > 0 when using
    e->promise = promise;

    if (LEPUS_IsError(ctx, value)) {
      e->error = LEPUS_DupValue(ctx, value);
    } else {
      e->error = js_error_constructor(ctx, promise, 1, &value, -1);
    }
    auto stack_val = LEPUS_GetProperty(ctx, e->error, JS_ATOM_stack);
    int32_t has_stack =
        LEPUS_IsString(stack_val) && LEPUS_GetLength(ctx, stack_val) > 0;
    LEPUS_FreeValue(ctx, stack_val);
    if (has_stack) {
      list_add_tail(&e->link, &ctx->rt->unhandled_rejections);
    } else {
      LEPUS_FreeValue(ctx, e->error);
      lepus_free(ctx, e);
    }
  }
}

QJS_STATIC void reject_promise(LEPUSContext *ctx, LEPUSValueConst promise,
                               LEPUSValueConst value) {
  fulfill_or_reject_promise(ctx, promise, value, TRUE);
}

QJS_STATIC LEPUSValue js_promise_resolve_thenable_job(LEPUSContext *ctx,
                                                      int argc,
                                                      LEPUSValueConst *argv) {
  LEPUSValueConst promise, thenable, then;
  LEPUSValue res;
  LEPUSValue args[2];

#ifdef DUMP_PROMISE
  printf("js_promise_resolve_thenable_job\n");
#endif
  assert(argc == 3);
  promise = argv[0];
  thenable = argv[1];
  then = argv[2];
  if (js_create_resolving_functions(ctx, args, promise) < 0)
    return LEPUS_EXCEPTION;
  res = JS_Call_RC(ctx, then, thenable, 2, (LEPUSValueConst *)args);
  if (LEPUS_IsException(res)) {
    LEPUSValue error = LEPUS_GetException(ctx);
    res =
        JS_Call_RC(ctx, args[1], LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
  }
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
  return res;
}

QJS_STATIC void js_promise_resolve_function_free_resolved(
    LEPUSRuntime *rt, JSPromiseFunctionDataResolved *sr) {
  if (--sr->ref_count == 0) {
    lepus_free_rt(rt, sr);
  }
}

QJS_STATIC int js_create_resolving_functions(LEPUSContext *ctx,
                                             LEPUSValue *resolving_funcs,
                                             LEPUSValueConst promise)

{
  LEPUSValue obj;
  JSPromiseFunctionData *s;
  JSPromiseFunctionDataResolved *sr;
  int i, ret;

  sr = static_cast<JSPromiseFunctionDataResolved *>(
      lepus_malloc(ctx, sizeof(*sr)));
  if (!sr) return -1;
  sr->ref_count = 1;
  sr->already_resolved = FALSE; /* must be shared between the two functions */
  ret = 0;
  for (i = 0; i < 2; i++) {
    obj = JS_NewObjectProtoClass_RC(ctx, ctx->function_proto,
                                    JS_CLASS_PROMISE_RESOLVE_FUNCTION + i);
    if (LEPUS_IsException(obj)) goto fail;
    s = static_cast<JSPromiseFunctionData *>(lepus_malloc(ctx, sizeof(*s)));
    if (!s) {
      LEPUS_FreeValue(ctx, obj);
    fail:

      if (i != 0) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      ret = -1;
      break;
    }
    sr->ref_count++;
    s->presolved = sr;
    s->promise = LEPUS_DupValue(ctx, promise);
    LEPUS_SetOpaque(obj, s);
    js_function_set_properties(ctx, LEPUS_VALUE_GET_OBJ(obj),
                               JS_ATOM_empty_string, 1);
    resolving_funcs[i] = obj;
  }
  js_promise_resolve_function_free_resolved(ctx->rt, sr);
  return ret;
}

QJS_STATIC void js_promise_resolve_function_finalizer(LEPUSRuntime *rt,
                                                      LEPUSValue val) {
  JSPromiseFunctionData *s = LEPUS_VALUE_GET_OBJ(val)->u.promise_function_data;
  if (s) {
    js_promise_resolve_function_free_resolved(rt, s->presolved);
    LEPUS_FreeValueRT(rt, s->promise);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void js_promise_resolve_function_mark(LEPUSRuntime *rt,
                                                 LEPUSValueConst val,
                                                 LEPUS_MarkFunc *mark_func,
                                                 int local_idx) {
  JSPromiseFunctionData *s = LEPUS_VALUE_GET_OBJ(val)->u.promise_function_data;
  if (s) {
    JS_MarkValue_RC(rt, s->promise, mark_func);
  }
}

QJS_STATIC LEPUSValue js_promise_resolve_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
  JSPromiseFunctionData *s;
  LEPUSValueConst resolution;
  LEPUSValue args[3];
  LEPUSValue then;
  BOOL is_reject;

  s = p->u.promise_function_data;
  if (!s || s->presolved->already_resolved) return LEPUS_UNDEFINED;
  s->presolved->already_resolved = TRUE;
  is_reject = p->class_id - JS_CLASS_PROMISE_RESOLVE_FUNCTION;
  if (argc > 0)
    resolution = argv[0];
  else
    resolution = LEPUS_UNDEFINED;
#ifdef DUMP_PROMISE
  printf("js_promise_resolving_function_call: is_reject=%d resolution=",
         is_reject);
  JS_DumpValue(ctx, resolution);
  printf("\n");
#endif
  if (is_reject || !LEPUS_IsObject(resolution)) {
    goto done;
  } else if (js_same_value(ctx, resolution, s->promise)) {
    LEPUS_ThrowTypeError(ctx, "promise self resolution");
    goto fail_reject;
  }
  then =
      JS_GetPropertyInternal_RC(ctx, resolution, JS_ATOM_then, resolution, 0);
  if (LEPUS_IsException(then)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    reject_promise(ctx, s->promise, error);
    LEPUS_FreeValue(ctx, error);
  } else if (!LEPUS_IsFunction(ctx, then)) {
    LEPUS_FreeValue(ctx, then);
  done:
    fulfill_or_reject_promise(ctx, s->promise, resolution, is_reject);
  } else {
    args[0] = s->promise;
    args[1] = resolution;
    args[2] = then;
    LEPUS_EnqueueJob(ctx, js_promise_resolve_thenable_job, 3, args);
    LEPUS_FreeValue(ctx, then);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC void js_promise_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  JSPromiseData *s =
      static_cast<JSPromiseData *>(LEPUS_GetOpaque(val, JS_CLASS_PROMISE));
  struct list_head *el, *el1;
  int i;

  if (!s) return;
  for (i = 0; i < 2; i++) {
    list_for_each_safe(el, el1, &s->promise_reactions[i]) {
      JSPromiseReactionData *rd = list_entry(el, JSPromiseReactionData, link);
      promise_reaction_data_free(rt, rd);
    }
  }
  list_for_each_safe(el, el1, &rt->unhandled_rejections) {
    JSUnhandledRejectionEntry *e =
        list_entry(el, JSUnhandledRejectionEntry, link);
    if (LEPUS_VALUE_GET_PTR(e->promise) == LEPUS_VALUE_GET_PTR(val)) {
      e->promise = LEPUS_NULL;
      break;
    }
  }
  LEPUS_FreeValueRT(rt, s->promise_result);
  lepus_free_rt(rt, s);
}

QJS_STATIC void js_promise_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                LEPUS_MarkFunc *mark_func, int local_idx) {
  JSPromiseData *s =
      static_cast<JSPromiseData *>(LEPUS_GetOpaque(val, JS_CLASS_PROMISE));
  struct list_head *el;
  int i;

  if (!s) return;
  for (i = 0; i < 2; i++) {
    list_for_each(el, &s->promise_reactions[i]) {
      JSPromiseReactionData *rd = list_entry(el, JSPromiseReactionData, link);
      JS_MarkValue_RC(rt, rd->resolving_funcs[0], mark_func);
      JS_MarkValue_RC(rt, rd->resolving_funcs[1], mark_func);
      JS_MarkValue_RC(rt, rd->handler, mark_func);
    }
  }
  JS_MarkValue_RC(rt, s->promise_result, mark_func);
}

QJS_STATIC LEPUSValue js_promise_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst new_target,
                                             int argc, LEPUSValueConst *argv) {
  LEPUSValueConst executor;
  LEPUSValue obj;
  JSPromiseData *s;
  LEPUSValue args[2], ret;
  int i;

  executor = argv[0];
  if (check_function(ctx, executor)) return LEPUS_EXCEPTION;
  obj = js_create_from_ctor(ctx, new_target, JS_CLASS_PROMISE);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s = static_cast<JSPromiseData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) goto fail;
  s->promise_state = JS_PROMISE_PENDING;
  s->is_handled = FALSE;
  for (i = 0; i < 2; i++) init_list_head(&s->promise_reactions[i]);
  s->promise_result = LEPUS_UNDEFINED;
  LEPUS_SetOpaque(obj, s);
  if (js_create_resolving_functions(ctx, args, obj)) goto fail;
  ret = JS_Call_RC(ctx, executor, LEPUS_UNDEFINED, 2, (LEPUSValueConst *)args);
  if (LEPUS_IsException(ret)) {
    LEPUSValue ret2, error;
    error = LEPUS_GetException(ctx);
    ret2 =
        JS_Call_RC(ctx, args[1], LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret2)) goto fail1;
    LEPUS_FreeValue(ctx, ret2);
  }
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
  return obj;
fail1:
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_promise_executor(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv, int magic,
                                          LEPUSValue *func_data) {
  int i;

  for (i = 0; i < 2; i++) {
    if (!LEPUS_IsUndefined(func_data[i]))
      return LEPUS_ThrowTypeError(ctx, "resolving function already set");
    func_data[i] = LEPUS_DupValue(ctx, argv[i]);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue js_promise_executor_new(LEPUSContext *ctx) {
  LEPUSValueConst func_data[2];

  func_data[0] = LEPUS_UNDEFINED;
  func_data[1] = LEPUS_UNDEFINED;
  return LEPUS_NewCFunctionData(ctx, js_promise_executor, 2, 0, 2, func_data);
}

QJS_STATIC LEPUSValue js_new_promise_capability(LEPUSContext *ctx,
                                                LEPUSValue *resolving_funcs,
                                                LEPUSValueConst ctor) {
  LEPUSValue executor, result_promise;
  JSCFunctionDataRecord *s;
  int i;

  executor = js_promise_executor_new(ctx);
  if (LEPUS_IsException(executor)) return executor;

  if (LEPUS_IsUndefined(ctor)) {
    result_promise =
        js_promise_constructor(ctx, ctor, 1, (LEPUSValueConst *)&executor);
  } else {
    result_promise =
        LEPUS_CallConstructor(ctx, ctor, 1, (LEPUSValueConst *)&executor);
  }
  if (LEPUS_IsException(result_promise)) goto fail;
  s = static_cast<JSCFunctionDataRecord *>(
      LEPUS_GetOpaque(executor, JS_CLASS_C_FUNCTION_DATA));
  for (i = 0; i < 2; i++) {
    if (check_function(ctx, s->data[i])) goto fail;
  }
  for (i = 0; i < 2; i++) resolving_funcs[i] = LEPUS_DupValue(ctx, s->data[i]);
  LEPUS_FreeValue(ctx, executor);
  return result_promise;
fail:
  LEPUS_FreeValue(ctx, executor);
  LEPUS_FreeValue(ctx, result_promise);
  return LEPUS_EXCEPTION;
}

LEPUSValue LEPUS_NewPromiseCapability(LEPUSContext *ctx,
                                      LEPUSValue *resolving_funcs) {
  CallGCFunc(JS_NewPromiseCapability_GC, ctx, resolving_funcs);
  return js_new_promise_capability(ctx, resolving_funcs, LEPUS_UNDEFINED);
}

QJS_STATIC LEPUSValue js_promise_resolve(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic) {
  LEPUSValue result_promise, resolving_funcs[2], ret;
  BOOL is_reject = magic;

  if (!LEPUS_IsObject(this_val)) return JS_ThrowTypeErrorNotAnObject(ctx);
  if (!is_reject && LEPUS_GetOpaque(argv[0], JS_CLASS_PROMISE)) {
    LEPUSValue ctor;
    BOOL is_same;
    ctor = JS_GetPropertyInternal_RC(ctx, argv[0], JS_ATOM_constructor, argv[0],
                                     0);
    if (LEPUS_IsException(ctor)) return ctor;
    is_same = js_same_value(ctx, ctor, this_val);
    LEPUS_FreeValue(ctx, ctor);
    if (is_same) return LEPUS_DupValue(ctx, argv[0]);
  }
  result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  ret = JS_Call_RC(ctx, resolving_funcs[is_reject], LEPUS_UNDEFINED, 1, argv);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  if (LEPUS_IsException(ret)) {
    LEPUS_FreeValue(ctx, result_promise);
    return ret;
  }
  LEPUS_FreeValue(ctx, ret);
  return result_promise;
}

#if 0
static LEPUSValue js_promise___newPromiseCapability(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc, LEPUSValueConst *argv)
{
    LEPUSValue result_promise, resolving_funcs[2], obj;
    LEPUSValueConst ctor;
    ctor = argv[0];
    if (!LEPUS_IsObject(ctor))
        return JS_ThrowTypeErrorNotAnObject(ctx);
    result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
    if (LEPUS_IsException(result_promise))
        return result_promise;
    obj = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(obj)) {
        LEPUS_FreeValue(ctx, resolving_funcs[0]);
        LEPUS_FreeValue(ctx, resolving_funcs[1]);
        LEPUS_FreeValue(ctx, result_promise);
        return LEPUS_EXCEPTION;
    }
    JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_promise, result_promise, LEPUS_PROP_C_W_E);
    JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_resolve, resolving_funcs[0], LEPUS_PROP_C_W_E);
    JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_reject, resolving_funcs[1], LEPUS_PROP_C_W_E);
    return obj;
}
#endif

QJS_STATIC __exception int remainingElementsCount_add(
    LEPUSContext *ctx, LEPUSValueConst resolve_element_env, int addend) {
  LEPUSValue val;
  int remainingElementsCount;

  val = LEPUS_GetPropertyUint32(ctx, resolve_element_env, 0);
  if (LEPUS_IsException(val)) return -1;
  if (JS_ToInt32Free(ctx, &remainingElementsCount, val)) return -1;
  remainingElementsCount += addend;
  if (LEPUS_SetPropertyUint32(ctx, resolve_element_env, 0,
                              LEPUS_NewInt32(ctx, remainingElementsCount)) < 0)
    return -1;
  return (remainingElementsCount == 0);
}

#ifdef BUILD_ASYNC_STACK
QJS_STATIC void build_async_backtrace(LEPUSContext *ctx, const uint8_t *cur_pc,
                                      DynBuf *dbuf, BOOL is_debug_mode,
                                      LEPUSValueConst error_obj) {
  if (ctx->rt->current_micro_task == NULL) return;
  struct list_head *el, *el1;
  LEPUSValue handler = ctx->rt->current_micro_task[2];
  HandleScope func_scope(ctx, &handler, HANDLE_TYPE_LEPUS_VALUE);
  LEPUSValue new_handler = LEPUS_UNDEFINED;
  func_scope.PushHandle(&new_handler, HANDLE_TYPE_LEPUS_VALUE);
  LEPUSValue func_obj = LEPUS_UNDEFINED;
  func_scope.PushHandle(&func_obj, HANDLE_TYPE_LEPUS_VALUE);

  LEPUSStackFrame *sf;
  for (;;) {
    if (!LEPUS_IsObject(handler)) break;
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(handler);
    if (p->class_id == JS_CLASS_ASYNC_FUNCTION_RESOLVE ||
        p->class_id == JS_CLASS_ASYNC_FUNCTION_REJECT) {
      /* async function */
      JSAsyncFunctionData *s = p->u.async_function_data;
      if (s == NULL) break;
      func_obj = s->resolving_funcs[1];
    } else if (p->class_id == JS_CLASS_C_FUNCTION_DATA) {
      /* async generator */
      JSCFunctionDataRecord *s0 = static_cast<JSCFunctionDataRecord *>(
          LEPUS_GetOpaque(handler, JS_CLASS_C_FUNCTION_DATA));
      JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
          LEPUS_GetOpaque(s0->data[0], JS_CLASS_ASYNC_GENERATOR));
      if (s == NULL) break;
      if (list_empty(&(s->queue))) break;
      JSAsyncGeneratorRequest *next =
          list_entry(s->queue.next, JSAsyncGeneratorRequest, link);
      func_obj = next->resolving_funcs[1];
    } else if (p->class_id == JS_CLASS_BYTECODE_FUNCTION) {
      /* then */
      func_obj = ctx->rt->current_micro_task[1];
    } else
      break;

  retry:
    if (!LEPUS_IsObject(func_obj)) break;
    p = LEPUS_VALUE_GET_OBJ(func_obj);
    JSPromiseFunctionData *s1 = p->u.promise_function_data;
    if (s1 == NULL) break;
    HandleScope block_scope(ctx->rt);
    LEPUSValue promise = s1->promise;
    block_scope.PushHandle(&promise, HANDLE_TYPE_LEPUS_VALUE);
    JSPromiseData *s2 = static_cast<JSPromiseData *>(
        LEPUS_GetOpaque(promise, JS_CLASS_PROMISE));
    if (s2 == NULL) break;

    int count = 0;
    list_for_each_safe(el, el1, &s2->promise_reactions[1]) { count++; }
    if (count > 1) {
#if defined(ANDROID) || defined(__ANDROID__)
      __android_log_print(ANDROID_LOG_ERROR, "primjs",
                          "==== multiple reaction of promise ====\n%d%s\n",
                          count, (char *)dbuf->buf);
#endif
    }
    if (count == 0) break;

    el = s2->promise_reactions[1].next;
    JSPromiseReactionData *rd = list_entry(el, JSPromiseReactionData, link);
    new_handler = rd->handler;
    handler = new_handler;
    if (!LEPUS_IsObject(handler)) {
      if (LEPUS_IsUndefined(handler)) {
        func_obj = rd->resolving_funcs[1];
        goto retry;
      } else {
        break;
      }
    }
    if (!LEPUS_IsObject(handler)) break;

    p = LEPUS_VALUE_GET_OBJ(handler);

    if (p->class_id == JS_CLASS_ASYNC_FUNCTION_RESOLVE ||
        p->class_id == JS_CLASS_ASYNC_FUNCTION_REJECT) {
      /* async function */
      if (p->u.async_function_data != NULL)
        sf = &p->u.async_function_data->func_state.frame;
      else
        break;
    } else if (p->class_id == JS_CLASS_C_FUNCTION_DATA) {
      JSCFunctionDataRecord *s0 = static_cast<JSCFunctionDataRecord *>(
          LEPUS_GetOpaque(handler, JS_CLASS_C_FUNCTION_DATA));
      if (s0->magic == 1) {
        /* async generator */
        JSAsyncGeneratorData *s = static_cast<JSAsyncGeneratorData *>(
            LEPUS_GetOpaque(s0->data[0], JS_CLASS_ASYNC_GENERATOR));
        if (s != NULL)
          sf = &s->func_state.frame;
        else
          break;
      } else if (s0->magic == 2) {
        /* Promise.any */
        dbuf_printf(dbuf, "    at (async)Promise.any\n");
        func_obj = s0->data[3];
        goto retry;
      } else if (s0->magic == 5) {
        /* Promise.allSettled */
        dbuf_printf(dbuf, "    at (async)Promise.allSettled\n");
        func_obj = s0->data[3];
        goto retry;
      } else
        break;
    } else if (p->class_id == JS_CLASS_PROMISE_REJECT_FUNCTION) {
      /* Promise.all */
      dbuf_printf(dbuf, "    at (async)Promise.all\n");
      func_obj = handler;
      goto retry;
    } else
      break;

    if (!LEPUS_IsObject(sf->cur_func)) break;

    build_backtrace_frame(ctx, sf, dbuf, cur_pc, TRUE, is_debug_mode,
                          error_obj);
  }
}
#endif

/* used by C code. */
QJS_STATIC LEPUSValue js_aggregate_error_constructor(LEPUSContext *ctx,
                                                     LEPUSValueConst errors) {
  LEPUSValue obj;

  obj = JS_NewObjectProtoClass_RC(
      ctx, ctx->native_error_proto[JS_AGGREGATE_ERROR], JS_CLASS_ERROR);
  if (LEPUS_IsException(obj)) return obj;
  JSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
  JS_DefinePropertyValue_RC(ctx, obj, atom_errors, LEPUS_DupValue(ctx, errors),
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeAtom(ctx, atom_errors);
  return obj;
}

#define PROMISE_MAGIC_all 0
#define PROMISE_MAGIC_allSettled 1
#define PROMISE_MAGIC_any 2

QJS_STATIC LEPUSValue js_promise_all_resolve_element(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  int resolve_type = magic & 3;
  int is_reject = magic & 4;
  BOOL alreadyCalled = LEPUS_ToBool(ctx, func_data[0]);
  LEPUSValueConst values = func_data[2];
  LEPUSValueConst resolve = func_data[3];
  LEPUSValueConst resolve_element_env = func_data[4];
  LEPUSValue ret, obj;
  int is_zero, index;

  if (LEPUS_ToInt32(ctx, &index, func_data[1])) return LEPUS_EXCEPTION;
  if (alreadyCalled) return LEPUS_UNDEFINED;
  func_data[0] = LEPUS_NewBool(ctx, TRUE);

  if (resolve_type == PROMISE_MAGIC_allSettled) {
    LEPUSValue str;

    obj = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
    str = LEPUS_NewString(ctx, is_reject ? "rejected" : "fulfilled");
    if (LEPUS_IsException(str)) goto fail1;
    if (JS_DefinePropertyValue_RC(ctx, obj, JS_ATOM_status, str,
                                  LEPUS_PROP_C_W_E) < 0)
      goto fail1;
    if (JS_DefinePropertyValue_RC(
            ctx, obj, is_reject ? JS_ATOM_reason : JS_ATOM_value,
            LEPUS_DupValue(ctx, argv[0]), LEPUS_PROP_C_W_E) < 0) {
    fail1:
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  } else {
    obj = LEPUS_DupValue(ctx, argv[0]);
  }
  if (JS_DefinePropertyValueUint32_RC(ctx, values, index, obj,
                                      LEPUS_PROP_C_W_E) < 0)
    return LEPUS_EXCEPTION;

  is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
  if (is_zero < 0) return LEPUS_EXCEPTION;
  if (is_zero) {
    if (resolve_type == PROMISE_MAGIC_any) {
      LEPUSValue error;
      error = js_aggregate_error_constructor(ctx, values);
      if (LEPUS_IsException(error)) return LEPUS_EXCEPTION;
      ret = JS_Call_RC(ctx, resolve, LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&error);
      LEPUS_FreeValue(ctx, error);
    } else {
      ret = JS_Call_RC(ctx, resolve, LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&values);
    }

    if (LEPUS_IsException(ret)) return ret;
    LEPUS_FreeValue(ctx, ret);
  }
  return LEPUS_UNDEFINED;
}

/* magic = 0: Promise.all 1: Promise.allSettled */
QJS_STATIC LEPUSValue js_promise_all(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  LEPUSValue result_promise, resolving_funcs[2], item, next_promise, ret;
  LEPUSValue next_method = LEPUS_UNDEFINED, values = LEPUS_UNDEFINED;
  LEPUSValue resolve_element_env = LEPUS_UNDEFINED, resolve_element,
             reject_element;
  LEPUSValue promise_resolve = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED;
  LEPUSValueConst then_args[2];
  LEPUSValueConst resolve_element_data[5];
  BOOL done;
  int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);

  if (!LEPUS_IsObject(this_val)) return JS_ThrowTypeErrorNotAnObject(ctx);
  result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  promise_resolve =
      JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_resolve, this_val, 0);
  if (LEPUS_IsException(promise_resolve) ||
      check_function(ctx, promise_resolve))
    goto fail_reject;
  iter = JS_GetIterator(ctx, argv[0], FALSE);
  if (LEPUS_IsException(iter)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    ret = JS_Call_RC(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                     (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret)) goto fail;
    LEPUS_FreeValue(ctx, ret);
  } else {
    next_method = JS_GetPropertyInternal_RC(ctx, iter, JS_ATOM_next, iter, 0);
    if (LEPUS_IsException(next_method)) goto fail_reject;
    values = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(values)) goto fail_reject;
    resolve_element_env = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(resolve_element_env)) goto fail_reject;
    /* remainingElementsCount field */
    if (JS_DefinePropertyValueUint32_RC(
            ctx, resolve_element_env, 0, LEPUS_NewInt32(ctx, 1),
            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE |
                LEPUS_PROP_WRITABLE) < 0)
      goto fail_reject;

    index = 0;
    for (;;) {
      /* XXX: conformance: should close the iterator if error on 'done'
         access, but not on 'value' access */
      item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail_reject;
      if (done) break;
      next_promise = JS_Call_RC(ctx, promise_resolve, this_val, 1,
                                (LEPUSValueConst *)&item);
      LEPUS_FreeValue(ctx, item);
      if (LEPUS_IsException(next_promise)) {
      fail_reject1:
        JS_IteratorClose(ctx, iter, TRUE);
        goto fail_reject;
      }
      resolve_element_data[0] = LEPUS_NewBool(ctx, FALSE);
      resolve_element_data[1] = (LEPUSValueConst)LEPUS_NewInt32(ctx, index);
      resolve_element_data[2] = values;
      resolve_element_data[3] = resolving_funcs[is_promise_any];
      resolve_element_data[4] = resolve_element_env;
      resolve_element =
          LEPUS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1, magic,
                                 5, resolve_element_data);
      if (LEPUS_IsException(resolve_element)) {
        LEPUS_FreeValue(ctx, next_promise);
        goto fail_reject1;
      }

      if (magic == PROMISE_MAGIC_allSettled) {
        reject_element =
            LEPUS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
                                   magic | 4, 5, resolve_element_data);
        if (LEPUS_IsException(reject_element)) {
          LEPUS_FreeValue(ctx, next_promise);
          goto fail_reject1;
        }
      } else if (magic == PROMISE_MAGIC_any) {
        if (JS_DefinePropertyValueUint32_RC(ctx, values, index, LEPUS_UNDEFINED,
                                            LEPUS_PROP_C_W_E) < 0)
          goto fail_reject1;
        reject_element = resolve_element;
        resolve_element = LEPUS_DupValue(ctx, resolving_funcs[0]);
      } else {
        reject_element = LEPUS_DupValue(ctx, resolving_funcs[1]);
      }

      if (remainingElementsCount_add(ctx, resolve_element_env, 1) < 0) {
        LEPUS_FreeValue(ctx, next_promise);
        LEPUS_FreeValue(ctx, resolve_element);
        LEPUS_FreeValue(ctx, reject_element);
        goto fail_reject1;
      }
      then_args[0] = resolve_element;
      then_args[1] = reject_element;
      ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2, then_args);
      LEPUS_FreeValue(ctx, resolve_element);
      LEPUS_FreeValue(ctx, reject_element);
      if (check_exception_free(ctx, ret)) goto fail_reject1;
      index++;
    }

    is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
    if (is_zero < 0) goto fail_reject;
    if (is_zero) {
      if (magic == PROMISE_MAGIC_any) {
        LEPUSValue error;
        error = js_aggregate_error_constructor(ctx, values);
        if (LEPUS_IsException(error)) goto fail_reject;
        LEPUS_FreeValue(ctx, values);
        values = error;
      }
      ret = JS_Call_RC(ctx, resolving_funcs[is_promise_any], LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&values);
      if (check_exception_free(ctx, ret)) goto fail_reject;
    }
  }
done:
  LEPUS_FreeValue(ctx, promise_resolve);
  LEPUS_FreeValue(ctx, resolve_element_env);
  LEPUS_FreeValue(ctx, values);
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return result_promise;
fail:
  LEPUS_FreeValue(ctx, result_promise);
  result_promise = LEPUS_EXCEPTION;
  goto done;
}

QJS_STATIC LEPUSValue js_promise_race(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  LEPUSValue result_promise, resolving_funcs[2], item, next_promise, ret;
  LEPUSValue next_method = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED;
  LEPUSValue promise_resolve = LEPUS_UNDEFINED;
  BOOL done;

  if (!LEPUS_IsObject(this_val)) return JS_ThrowTypeErrorNotAnObject(ctx);
  result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  promise_resolve =
      JS_GetPropertyInternal_RC(ctx, this_val, JS_ATOM_resolve, this_val, 0);
  if (LEPUS_IsException(promise_resolve) ||
      check_function(ctx, promise_resolve))
    goto fail_reject;
  iter = JS_GetIterator(ctx, argv[0], FALSE);
  if (LEPUS_IsException(iter)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    ret = JS_Call_RC(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                     (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret)) goto fail;
    LEPUS_FreeValue(ctx, ret);
  } else {
    next_method = JS_GetPropertyInternal_RC(ctx, iter, JS_ATOM_next, iter, 0);
    if (LEPUS_IsException(next_method)) goto fail_reject;

    for (;;) {
      /* XXX: conformance: should close the iterator if error on 'done'
         access, but not on 'value' access */
      item = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail_reject;
      if (done) break;
      next_promise = JS_Call_RC(ctx, promise_resolve, this_val, 1,
                                (LEPUSValueConst *)&item);
      LEPUS_FreeValue(ctx, item);
      if (LEPUS_IsException(next_promise)) {
      fail_reject1:
        JS_IteratorClose(ctx, iter, TRUE);
        goto fail_reject;
      }
      ret = JS_InvokeFree(ctx, next_promise, JS_ATOM_then, 2,
                          (LEPUSValueConst *)resolving_funcs);
      if (check_exception_free(ctx, ret)) goto fail_reject1;
    }
  }
done:
  LEPUS_FreeValue(ctx, promise_resolve);
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return result_promise;
fail:
  // LEPUS_FreeValue(ctx, next_method); // why not???
  LEPUS_FreeValue(ctx, result_promise);
  result_promise = LEPUS_EXCEPTION;
  goto done;
}

LEPUSValue JS_StructuredClone(LEPUSContext *ctx, LEPUSValue src,
                              ObjectCloneState &state);
QJS_STATIC __exception int perform_promise_then(
    LEPUSContext *ctx, LEPUSValueConst promise, LEPUSValueConst *resolve_reject,
    LEPUSValueConst *cap_resolving_funcs, ObjectCloneState *state) {
  JSPromiseData *s =
      static_cast<JSPromiseData *>(LEPUS_GetOpaque(promise, JS_CLASS_PROMISE));
  JSPromiseReactionData *rd_array[2], *rd;
  int i, j;

  rd_array[0] = NULL;
  rd_array[1] = NULL;
  for (i = 0; i < 2; i++) {
    LEPUSValueConst handler;
    rd = static_cast<JSPromiseReactionData *>(lepus_mallocz(ctx, sizeof(*rd)));
    if (!rd) {
      if (i == 1) promise_reaction_data_free(ctx->rt, rd_array[0]);
      return -1;
    }
    for (j = 0; j < 2; j++)
      rd->resolving_funcs[j] = LEPUS_DupValue(ctx, cap_resolving_funcs[j]);
    handler = resolve_reject[i];
    if (!LEPUS_IsFunction(ctx, handler)) handler = LEPUS_UNDEFINED;
    rd->handler = LEPUS_DupValue(ctx, handler);
    rd_array[i] = rd;
  }

  if (s->promise_state == JS_PROMISE_PENDING) {
    for (i = 0; i < 2; i++)
      list_add_tail(&rd_array[i]->link, &s->promise_reactions[i]);
  } else {
    LEPUSValueConst args[5];
    i = s->promise_state - JS_PROMISE_FULFILLED;
    rd = rd_array[i];
    args[0] = rd->resolving_funcs[0];
    args[1] = rd->resolving_funcs[1];
    args[2] = rd->handler;
    args[3] = LEPUS_NewBool(ctx, i);
    args[4] = state ? JS_StructuredClone(ctx, s->promise_result, *state)
                    : s->promise_result;
    LEPUS_EnqueueJob(ctx, promise_reaction_job, 5, args);
    for (i = 0; i < 2; i++) promise_reaction_data_free(ctx->rt, rd_array[i]);
  }

  if (s->promise_state == JS_PROMISE_REJECTED) {
    struct list_head *el, *el1;
    list_for_each_safe(el, el1, &ctx->rt->unhandled_rejections) {
      JSUnhandledRejectionEntry *e =
          list_entry(el, JSUnhandledRejectionEntry, link);
      if (!LEPUS_IsNull(e->promise) &&
          LEPUS_GetOpaque(e->promise, JS_CLASS_PROMISE) == s) {
        LEPUS_FreeValue(ctx, e->error);
        list_del(el);
        lepus_free_rt(ctx->rt, el);
        break;
      }
    }
  }

  s->is_handled = TRUE;
  return 0;
}

QJS_STATIC LEPUSValue js_promise_then_for_deepcopy(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv,
                                                   ObjectCloneState *state) {
  LEPUSValue ctor, result_promise, resolving_funcs[2];
  JSPromiseData *s;
  int i, ret;

  s = static_cast<JSPromiseData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_PROMISE));
  if (!s) return LEPUS_EXCEPTION;

  ctor = JS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(result_promise)) return result_promise;
  ret = perform_promise_then(ctx, this_val, argv,
                             (LEPUSValueConst *)resolving_funcs, state);
  for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
  if (ret) {
    LEPUS_FreeValue(ctx, result_promise);
    return LEPUS_EXCEPTION;
  }
  return result_promise;
}

QJS_STATIC LEPUSValue js_promise_then(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  LEPUSValue ctor, result_promise, resolving_funcs[2];
  JSPromiseData *s;
  int i, ret;

  s = static_cast<JSPromiseData *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_PROMISE));
  if (!s) return LEPUS_EXCEPTION;

  ctor = JS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(result_promise)) return result_promise;
  ret = perform_promise_then(ctx, this_val, argv,
                             (LEPUSValueConst *)resolving_funcs);
  for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
  if (ret) {
    LEPUS_FreeValue(ctx, result_promise);
    return LEPUS_EXCEPTION;
  }
  return result_promise;
}

QJS_STATIC LEPUSValue js_promise_catch(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValueConst args[2];
  args[0] = LEPUS_UNDEFINED;
  args[1] = argv[0];
  return LEPUS_Invoke(ctx, this_val, JS_ATOM_then, 2, args);
}

QJS_STATIC LEPUSValue js_promise_finally_value_thunk(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return LEPUS_DupValue(ctx, func_data[0]);
}

QJS_STATIC LEPUSValue js_promise_finally_thrower(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return LEPUS_Throw(ctx, LEPUS_DupValue(ctx, func_data[0]));
}

QJS_STATIC LEPUSValue js_promise_then_finally_func(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  LEPUSValueConst ctor = func_data[0];
  LEPUSValueConst onFinally = func_data[1];
  LEPUSValue res, promise, resolving_funcs[2], ret, then_func;

  res = JS_Call_RC(ctx, onFinally, LEPUS_UNDEFINED, 0, NULL);
  if (LEPUS_IsException(res)) return res;

  promise = js_promise_resolve(ctx, ctor, 1, (LEPUSValueConst *)&res, 0);
  LEPUS_FreeValue(ctx, res);
  if (LEPUS_IsException(promise)) return promise;
  if (magic == 0) {
    then_func = LEPUS_NewCFunctionData(ctx, js_promise_finally_value_thunk, 0,
                                       0, 1, argv);
  } else {
    then_func =
        LEPUS_NewCFunctionData(ctx, js_promise_finally_thrower, 0, 0, 1, argv);
  }
  if (LEPUS_IsException(then_func)) {
    LEPUS_FreeValue(ctx, promise);
    return then_func;
  }
  ret = JS_InvokeFree(ctx, promise, JS_ATOM_then, 1,
                      (LEPUSValueConst *)&then_func);
  LEPUS_FreeValue(ctx, then_func);
  return ret;
}

QJS_STATIC LEPUSValue js_promise_finally(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValueConst onFinally = argv[0];
  LEPUSValue ctor, ret;
  LEPUSValue then_funcs[2];
  LEPUSValueConst func_data[2];
  int i;

  ctor = JS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  if (!LEPUS_IsFunction(ctx, onFinally)) {
    then_funcs[0] = LEPUS_DupValue(ctx, onFinally);
    then_funcs[1] = LEPUS_DupValue(ctx, onFinally);
  } else {
    func_data[0] = ctor;
    func_data[1] = onFinally;
    for (i = 0; i < 2; i++) {
      then_funcs[i] = LEPUS_NewCFunctionData(ctx, js_promise_then_finally_func,
                                             1, i, 2, func_data);
      if (LEPUS_IsException(then_funcs[i])) {
        if (i == 1) LEPUS_FreeValue(ctx, then_funcs[0]);
        LEPUS_FreeValue(ctx, ctor);
        return LEPUS_EXCEPTION;
      }
    }
  }
  LEPUS_FreeValue(ctx, ctor);
  ret = LEPUS_Invoke(ctx, this_val, JS_ATOM_then, 2,
                     (LEPUSValueConst *)then_funcs);
  LEPUS_FreeValue(ctx, then_funcs[0]);
  LEPUS_FreeValue(ctx, then_funcs[1]);
  return ret;
}

static const LEPUSCFunctionListEntry js_promise_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("resolve", 1, js_promise_resolve, 0),
    LEPUS_CFUNC_MAGIC_DEF("reject", 1, js_promise_resolve, 1),
    LEPUS_CFUNC_MAGIC_DEF("all", 1, js_promise_all, PROMISE_MAGIC_all),
    LEPUS_CFUNC_MAGIC_DEF("allSettled", 1, js_promise_all,
                          PROMISE_MAGIC_allSettled),
    LEPUS_CFUNC_MAGIC_DEF("any", 1, js_promise_all, PROMISE_MAGIC_any),
    LEPUS_CFUNC_DEF("race", 1, js_promise_race),
    // LEPUS_CFUNC_DEF("__newPromiseCapability", 1,
    // js_promise___newPromiseCapability ),
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
};

static const LEPUSCFunctionListEntry js_promise_proto_funcs[] = {
    LEPUS_CFUNC_DEF("then", 2, js_promise_then),
    LEPUS_CFUNC_DEF("catch", 1, js_promise_catch),
    LEPUS_CFUNC_DEF("finally", 1, js_promise_finally),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Promise",
                          LEPUS_PROP_CONFIGURABLE),
};

/* AsyncFunction */
static const LEPUSCFunctionListEntry js_async_function_proto_funcs[] = {
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncFunction",
                          LEPUS_PROP_CONFIGURABLE),
};

QJS_STATIC LEPUSValue js_async_from_async_iterator_unwrap(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return js_create_iterator_result(ctx, LEPUS_DupValue(ctx, func_data[0]),
                                   LEPUS_ToBool(ctx, func_data[1]));
}

QJS_STATIC LEPUSValue js_async_from_async_iterator_unwrap_func_create(
    LEPUSContext *ctx, LEPUSValueConst value, BOOL done) {
  LEPUSValueConst func_data[2];

  func_data[0] = value;
  func_data[1] = (LEPUSValueConst)LEPUS_NewBool(ctx, done);
  return LEPUS_NewCFunctionData(ctx, js_async_from_async_iterator_unwrap, 0, 0,
                                2, func_data);
}

/* AsyncIteratorPrototype */

static const LEPUSCFunctionListEntry js_async_iterator_proto_funcs[] = {
    LEPUS_CFUNC_DEF("[Symbol.asyncIterator]", 0, js_iterator_proto_iterator),
};

/* AsyncFromSyncIteratorPrototype */

typedef struct JSAsyncFromSyncIteratorData {
  LEPUSValue sync_iter;
  LEPUSValue next_method;
} JSAsyncFromSyncIteratorData;

QJS_STATIC void js_async_from_sync_iterator_finalizer(LEPUSRuntime *rt,
                                                      LEPUSValue val) {
  JSAsyncFromSyncIteratorData *s = static_cast<JSAsyncFromSyncIteratorData *>(
      LEPUS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (s) {
    LEPUS_FreeValueRT(rt, s->sync_iter);
    LEPUS_FreeValueRT(rt, s->next_method);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void js_async_from_sync_iterator_mark(LEPUSRuntime *rt,
                                                 LEPUSValueConst val,
                                                 LEPUS_MarkFunc *mark_func,
                                                 int local_idx) {
  JSAsyncFromSyncIteratorData *s = static_cast<JSAsyncFromSyncIteratorData *>(
      LEPUS_GetOpaque(val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (s) {
    JS_MarkValue_RC(rt, s->sync_iter, mark_func);
    JS_MarkValue_RC(rt, s->next_method, mark_func);
  }
}

QJS_STATIC LEPUSValue
JS_CreateAsyncFromSyncIterator(LEPUSContext *ctx, LEPUSValueConst sync_iter) {
  LEPUSValue async_iter, next_method;
  JSAsyncFromSyncIteratorData *s;

  next_method =
      LEPUS_GetPropertyInternal(ctx, sync_iter, JS_ATOM_next, sync_iter, 0);
  if (LEPUS_IsException(next_method)) return LEPUS_EXCEPTION;
  HandleScope func_scope(ctx, &next_method, HANDLE_TYPE_LEPUS_VALUE);
  async_iter = LEPUS_NewObjectClass(ctx, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
  if (LEPUS_IsException(async_iter)) {
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, next_method);
    return async_iter;
  }
  func_scope.PushHandle(&async_iter, HANDLE_TYPE_LEPUS_VALUE);
  s = static_cast<JSAsyncFromSyncIteratorData *>(
      lepus_mallocz(ctx, sizeof(*s), ALLOC_TAG_JSAsyncFromSyncIteratorData));
  if (!s) {
    if (!ctx->gc_enable) {
      LEPUS_FreeValue(ctx, async_iter);
      LEPUS_FreeValue(ctx, next_method);
    }
    return LEPUS_EXCEPTION;
  }
  s->sync_iter = LEPUS_DupValue(ctx, sync_iter);
  s->next_method = next_method;
  LEPUS_SetOpaque(async_iter, s);
  return async_iter;
}

QJS_STATIC LEPUSValue js_async_from_sync_iterator_next(LEPUSContext *ctx,
                                                       LEPUSValueConst this_val,
                                                       int argc,
                                                       LEPUSValueConst *argv,
                                                       int magic) {
  LEPUSValue promise, resolving_funcs[2], value, err, method;
  JSAsyncFromSyncIteratorData *s;
  int done;
  int is_reject;

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return LEPUS_EXCEPTION;
  s = static_cast<JSAsyncFromSyncIteratorData *>(
      LEPUS_GetOpaque(this_val, JS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (!s) {
    LEPUS_ThrowTypeError(ctx, "not an Async-from-Sync Iterator");
    goto reject;
  }

  if (magic == GEN_MAGIC_NEXT) {
    method = LEPUS_DupValue(ctx, s->next_method);
  } else {
    method = JS_GetPropertyInternal_RC(
        ctx, s->sync_iter,
        magic == GEN_MAGIC_RETURN ? JS_ATOM_return : JS_ATOM_throw,
        s->sync_iter, 0);
    if (LEPUS_IsException(method)) goto reject;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
      if (magic == GEN_MAGIC_RETURN) {
        err =
            js_create_iterator_result(ctx, LEPUS_DupValue(ctx, argv[0]), TRUE);
        is_reject = 0;
      } else {
        err = LEPUS_DupValue(ctx, argv[0]);
        is_reject = 1;
      }
      goto done_resolve;
    }
  }
  value = JS_IteratorNext2(ctx, s->sync_iter, method, 1, argv, &done);
  LEPUS_FreeValue(ctx, method);
  if (LEPUS_IsException(value)) goto reject;
  if (done == 2) {
    LEPUSValue obj = value;
    value = JS_IteratorGetCompleteValue(ctx, obj, &done);
    LEPUS_FreeValue(ctx, obj);
    if (LEPUS_IsException(value)) goto reject;
  }

  if (LEPUS_IsException(value)) {
    LEPUSValue res2;
  reject:
    err = LEPUS_GetException(ctx);
    is_reject = 1;
  done_resolve:
    res2 = JS_Call_RC(ctx, resolving_funcs[is_reject], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&err);
    LEPUS_FreeValue(ctx, err);
    LEPUS_FreeValue(ctx, res2);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    return promise;
  }
  {
    LEPUSValue value_wrapper_promise, resolve_reject[2];
    int res;

    value_wrapper_promise = js_promise_resolve(ctx, ctx->promise_ctor, 1,
                                               (LEPUSValueConst *)&value, 0);
    if (LEPUS_IsException(value_wrapper_promise)) {
      LEPUS_FreeValue(ctx, value);
      goto reject;
    }

    resolve_reject[0] =
        js_async_from_async_iterator_unwrap_func_create(ctx, value, done);
    if (LEPUS_IsException(resolve_reject[0])) {
      LEPUS_FreeValue(ctx, value_wrapper_promise);
      goto fail;
    }
    LEPUS_FreeValue(ctx, value);
    resolve_reject[1] = LEPUS_UNDEFINED;

    res = perform_promise_then(ctx, value_wrapper_promise,
                               (LEPUSValueConst *)resolve_reject,
                               (LEPUSValueConst *)resolving_funcs);
    LEPUS_FreeValue(ctx, resolve_reject[0]);
    LEPUS_FreeValue(ctx, value_wrapper_promise);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    if (res) {
      LEPUS_FreeValue(ctx, promise);
      return LEPUS_EXCEPTION;
    }
  }
  return promise;
fail:
  LEPUS_FreeValue(ctx, value);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  LEPUS_FreeValue(ctx, promise);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry js_async_from_sync_iterator_proto_funcs[] =
    {
        LEPUS_CFUNC_MAGIC_DEF("next", 1, js_async_from_sync_iterator_next,
                              GEN_MAGIC_NEXT),
        LEPUS_CFUNC_MAGIC_DEF("return", 1, js_async_from_sync_iterator_next,
                              GEN_MAGIC_RETURN),
        LEPUS_CFUNC_MAGIC_DEF("throw", 1, js_async_from_sync_iterator_next,
                              GEN_MAGIC_THROW),
};

/* AsyncGeneratorFunction */

static const LEPUSCFunctionListEntry js_async_generator_function_proto_funcs[] =
    {
        LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGeneratorFunction",
                              LEPUS_PROP_CONFIGURABLE),
};

/* AsyncGenerator prototype */

static const LEPUSCFunctionListEntry js_async_generator_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("next", 1, js_async_generator_next, GEN_MAGIC_NEXT),
    LEPUS_CFUNC_MAGIC_DEF("return", 1, js_async_generator_next,
                          GEN_MAGIC_RETURN),
    LEPUS_CFUNC_MAGIC_DEF("throw", 1, js_async_generator_next, GEN_MAGIC_THROW),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGenerator",
                          LEPUS_PROP_CONFIGURABLE),
};

static JSClassShortDef const js_async_class_def[] = {
    {JS_ATOM_Promise, js_promise_finalizer,
     js_promise_mark}, /* JS_CLASS_PROMISE */
    {JS_ATOM_PromiseResolveFunction, js_promise_resolve_function_finalizer,
     js_promise_resolve_function_mark}, /* JS_CLASS_PROMISE_RESOLVE_FUNCTION
                                         */
    {JS_ATOM_PromiseRejectFunction, js_promise_resolve_function_finalizer,
     js_promise_resolve_function_mark}, /* JS_CLASS_PROMISE_REJECT_FUNCTION
                                         */
    {JS_ATOM_AsyncFunction, js_bytecode_function_finalizer,
     js_bytecode_function_mark}, /* JS_CLASS_ASYNC_FUNCTION */
    {JS_ATOM_AsyncFunctionResolve, js_async_function_resolve_finalizer,
     js_async_function_resolve_mark}, /* JS_CLASS_ASYNC_FUNCTION_RESOLVE
                                       */
    {JS_ATOM_AsyncFunctionReject, js_async_function_resolve_finalizer,
     js_async_function_resolve_mark}, /* JS_CLASS_ASYNC_FUNCTION_REJECT */
    {JS_ATOM_empty_string, js_async_from_sync_iterator_finalizer,
     js_async_from_sync_iterator_mark}, /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR
                                         */
    {JS_ATOM_AsyncGeneratorFunction, js_bytecode_function_finalizer,
     js_bytecode_function_mark}, /* JS_CLASS_ASYNC_GENERATOR_FUNCTION */
    {JS_ATOM_AsyncGenerator, js_async_generator_finalizer,
     js_async_generator_mark}, /* JS_CLASS_ASYNC_GENERATOR */
};

void LEPUS_AddIntrinsicPromise(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicPromise_GC, ctx);
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue obj1;

  if (!LEPUS_IsRegisteredClass(rt, JS_CLASS_PROMISE)) {
    init_class_range(rt, js_async_class_def, JS_CLASS_PROMISE,
                     countof(js_async_class_def));
    rt->class_array[JS_CLASS_PROMISE_RESOLVE_FUNCTION].call =
        js_promise_resolve_function_call;
    rt->class_array[JS_CLASS_PROMISE_REJECT_FUNCTION].call =
        js_promise_resolve_function_call;
    rt->class_array[JS_CLASS_ASYNC_FUNCTION].call = js_async_function_call;
    rt->class_array[JS_CLASS_ASYNC_FUNCTION_RESOLVE].call =
        js_async_function_resolve_call;
    rt->class_array[JS_CLASS_ASYNC_FUNCTION_REJECT].call =
        js_async_function_resolve_call;
    rt->class_array[JS_CLASS_ASYNC_GENERATOR_FUNCTION].call =
        js_async_generator_function_call;
  }

  /* Promise */
  ctx->class_proto[JS_CLASS_PROMISE] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_PROMISE],
                                js_promise_proto_funcs,
                                countof(js_promise_proto_funcs));
  obj1 = LEPUS_NewCFunction2(ctx, js_promise_constructor, "Promise", 1,
                             LEPUS_CFUNC_constructor, 0);
  ctx->promise_ctor = LEPUS_DupValue(ctx, obj1);
  LEPUS_SetPropertyFunctionList(ctx, obj1, js_promise_funcs,
                                countof(js_promise_funcs));
  JS_NewGlobalCConstructor2(ctx, obj1, "Promise",
                            ctx->class_proto[JS_CLASS_PROMISE]);

  /* AsyncFunction */
  ctx->class_proto[JS_CLASS_ASYNC_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = JS_NewCFunction3(
      ctx, (LEPUSCFunction *)js_function_constructor, "AsyncFunction", 1,
      LEPUS_CFUNC_constructor_or_func_magic, JS_FUNC_ASYNC, ctx->function_ctor);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ASYNC_FUNCTION],
                                js_async_function_proto_funcs,
                                countof(js_async_function_proto_funcs));
  JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_ASYNC_FUNCTION], 0,
                     LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);

  /* AsyncIteratorPrototype */
  ctx->async_iterator_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->async_iterator_proto,
                                js_async_iterator_proto_funcs,
                                countof(js_async_iterator_proto_funcs));

  /* AsyncFromSyncIteratorPrototype */
  ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->async_iterator_proto);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[JS_CLASS_ASYNC_FROM_SYNC_ITERATOR],
      js_async_from_sync_iterator_proto_funcs,
      countof(js_async_from_sync_iterator_proto_funcs));

  /* AsyncGeneratorPrototype */
  ctx->class_proto[JS_CLASS_ASYNC_GENERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->async_iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],
                                js_async_generator_proto_funcs,
                                countof(js_async_generator_proto_funcs));

  /* AsyncGeneratorFunction */
  ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = JS_NewCFunction3(ctx, (LEPUSCFunction *)js_function_constructor,
                          "AsyncGeneratorFunction", 1,
                          LEPUS_CFUNC_constructor_or_func_magic,
                          JS_FUNC_ASYNC_GENERATOR, ctx->function_ctor);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],
      js_async_generator_function_proto_funcs,
      countof(js_async_generator_function_proto_funcs));
  JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION],
                     ctx->class_proto[JS_CLASS_ASYNC_GENERATOR],
                     LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_CONFIGURABLE);
  JS_SetConstructor2(ctx, obj1,
                     ctx->class_proto[JS_CLASS_ASYNC_GENERATOR_FUNCTION], 0,
                     LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);
}

/* URI handling */

QJS_STATIC int string_get_hex(JSString *p, int k, int n) {
  int c = 0, h;
  while (n-- > 0) {
    if ((h = from_hex(string_get(p, k++))) < 0) return -1;
    c = (c << 4) | h;
  }
  return c;
}

QJS_STATIC int isURIReserved(int c) {
  return c < 0x100 &&
         memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
}

int __attribute__((format(printf, 2, 3)))
js_throw_URIError(LEPUSContext *ctx, const char *fmt, ...) {
  va_list ap;

  va_start(ap, fmt);
  JS_ThrowError(ctx, JS_URI_ERROR, fmt, ap);
  va_end(ap);
  return -1;
}

QJS_STATIC int hex_decode(LEPUSContext *ctx, JSString *p, int k) {
  int c;

  if (k >= p->len || string_get(p, k) != '%')
    return js_throw_URIError(ctx, "expecting %%");
  if (k + 2 >= p->len || (c = string_get_hex(p, k + 1, 2)) < 0)
    return js_throw_URIError(ctx, "expecting hex digit");

  return c;
}

QJS_STATIC LEPUSValue js_global_decodeURI(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv,
                                          int isComponent) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int k, c, c1, n, c_min;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  string_buffer_init(ctx, b, 0);

  p = LEPUS_VALUE_GET_STRING(str);
  for (k = 0; k < p->len;) {
    c = string_get(p, k);
    if (c == '%') {
      c = hex_decode(ctx, p, k);
      if (c < 0) goto fail;
      k += 3;
      if (c < 0x80) {
        if (!isComponent && isURIReserved(c)) {
          c = '%';
          k -= 2;
        }
      } else {
        /* Decode URI-encoded UTF-8 sequence */
        if (c >= 0xc0 && c <= 0xdf) {
          n = 1;
          c_min = 0x80;
          c &= 0x1f;
        } else if (c >= 0xe0 && c <= 0xef) {
          n = 2;
          c_min = 0x800;
          c &= 0xf;
        } else if (c >= 0xf0 && c <= 0xf7) {
          n = 3;
          c_min = 0x10000;
          c &= 0x7;
        } else {
          n = 0;
          c_min = 1;
          c = 0;
        }
        while (n-- > 0) {
          c1 = hex_decode(ctx, p, k);
          if (c1 < 0) goto fail;
          k += 3;
          if ((c1 & 0xc0) != 0x80) {
            c = 0;
            break;
          }
          c = (c << 6) | (c1 & 0x3f);
        }
        if (c < c_min || c > 0x10FFFF) {
          js_throw_URIError(ctx, "malformed UTF-8");
          goto fail;
        }
      }
    } else {
      k++;
    }
    string_buffer_putc(b, c);
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int isUnescaped(int c) {
  static char const unescaped_chars[] =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789"
      "@*_+-./";
  return c < 0x100 && memchr(unescaped_chars, c, sizeof(unescaped_chars) - 1);
}

QJS_STATIC int isURIUnescaped(int c, int isComponent) {
  return c < 0x100 &&
         ((c >= 0x61 && c <= 0x7a) || (c >= 0x41 && c <= 0x5a) ||
          (c >= 0x30 && c <= 0x39) ||
          memchr("-_.!~*'()", c, sizeof("-_.!~*'()") - 1) != NULL ||
          (!isComponent && isURIReserved(c)));
}

QJS_STATIC int encodeURI_hex(StringBuffer *b, int c) {
  uint8_t buf[6];
  int n = 0;
  const char *hex = "0123456789ABCDEF";

  buf[n++] = '%';
  if (c >= 256) {
    buf[n++] = 'u';
    buf[n++] = hex[(c >> 12) & 15];
    buf[n++] = hex[(c >> 8) & 15];
  }
  buf[n++] = hex[(c >> 4) & 15];
  buf[n++] = hex[(c >> 0) & 15];
  return string_buffer_write8(b, buf, n);
}

QJS_STATIC LEPUSValue js_global_encodeURI(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv,
                                          int isComponent) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int k, c, c1;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  p = LEPUS_VALUE_GET_STRING(str);
  string_buffer_init(ctx, b, p->len);
  for (k = 0; k < p->len;) {
    c = string_get(p, k);
    k++;
    if (isURIUnescaped(c, isComponent)) {
      string_buffer_putc16(b, c);
    } else {
      if (c >= 0xdc00 && c <= 0xdfff) {
        js_throw_URIError(ctx, "invalid character");
        goto fail;
      } else if (c >= 0xd800 && c <= 0xdbff) {
        if (k >= p->len) {
          js_throw_URIError(ctx, "expecting surrogate pair");
          goto fail;
        }
        c1 = string_get(p, k);
        k++;
        if (c1 < 0xdc00 || c1 > 0xdfff) {
          js_throw_URIError(ctx, "expecting surrogate pair");
          goto fail;
        }
        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
      }
      if (c < 0x80) {
        encodeURI_hex(b, c);
      } else {
        /* XXX: use C UTF-8 conversion ? */
        if (c < 0x800) {
          encodeURI_hex(b, (c >> 6) | 0xc0);
        } else {
          if (c < 0x10000) {
            encodeURI_hex(b, (c >> 12) | 0xe0);
          } else {
            encodeURI_hex(b, (c >> 18) | 0xf0);
            encodeURI_hex(b, ((c >> 12) & 0x3f) | 0x80);
          }
          encodeURI_hex(b, ((c >> 6) & 0x3f) | 0x80);
        }
        encodeURI_hex(b, (c & 0x3f) | 0x80);
      }
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_global_escape(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int i, len, c;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  p = LEPUS_VALUE_GET_STRING(str);
  string_buffer_init(ctx, b, p->len);
  for (i = 0, len = p->len; i < len; i++) {
    c = string_get(p, i);
    if (isUnescaped(c)) {
      string_buffer_putc16(b, c);
    } else {
      encodeURI_hex(b, c);
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue js_global_unescape(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  JSString *p;
  int i, len, c, n;

  str = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  string_buffer_init(ctx, b, 0);
  p = LEPUS_VALUE_GET_STRING(str);
  for (i = 0, len = p->len; i < len; i++) {
    c = string_get(p, i);
    if (c == '%') {
      if (i + 6 <= len && string_get(p, i + 1) == 'u' &&
          (n = string_get_hex(p, i + 2, 4)) >= 0) {
        c = n;
        i += 6 - 1;
      } else if (i + 3 <= len && (n = string_get_hex(p, i + 1, 2)) >= 0) {
        c = n;
        i += 3 - 1;
      }
    }
    string_buffer_putc16(b, c);
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);
}

/* global object */

static LEPUSCFunctionListEntry js_global_funcs[] = {
    LEPUS_CFUNC_DEF("parseInt", 2, js_parseInt),
    LEPUS_CFUNC_DEF("parseFloat", 1, js_parseFloat),
    LEPUS_CFUNC_DEF("isNaN", 1, js_global_isNaN),
    LEPUS_CFUNC_DEF("isFinite", 1, js_global_isFinite),

    LEPUS_CFUNC_MAGIC_DEF("decodeURI", 1, js_global_decodeURI, 0),
    LEPUS_CFUNC_MAGIC_DEF("decodeURIComponent", 1, js_global_decodeURI, 1),
    LEPUS_CFUNC_MAGIC_DEF("encodeURI", 1, js_global_encodeURI, 0),
    LEPUS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1),
    LEPUS_CFUNC_DEF("escape", 1, js_global_escape),
    LEPUS_CFUNC_DEF("unescape", 1, js_global_unescape),
    LEPUS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0),
    LEPUS_PROP_DOUBLE_DEF("NaN", LEPUS_FLOAT64_NAN, 0),
    LEPUS_PROP_UNDEFINED_DEF("undefined", 0),

    /* for the 'Date' implementation */
    LEPUS_CFUNC_DEF("__date_clock", 0, js___date_clock),
    // LEPUS_CFUNC_DEF("__date_now", 0, js___date_now ),
    // LEPUS_CFUNC_DEF("__date_getTimezoneOffset", 1,
    // js___date_getTimezoneOffset
    // ), LEPUS_CFUNC_DEF("__date_create", 3, js___date_create ),
};

/* Date */

QJS_STATIC int64_t math_mod(int64_t a, int64_t b) {
  /* return positive modulo */
  int64_t m = a % b;
  return m + (m < 0) * b;
}

QJS_STATIC int64_t floor_div(int64_t a, int64_t b) {
  /* integer division rounding toward -Infinity */
  int64_t m = a % b;
  return (a - (m + (m < 0) * b)) / b;
}

QJS_STATIC LEPUSValue js_Date_parse(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv);

QJS_STATIC __exception int JS_ThisTimeValue(LEPUSContext *ctx, double *valp,
                                            LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_DATE && LEPUS_IsNumber(p->u.object_data))
      return LEPUS_ToFloat64(ctx, valp, p->u.object_data);
  }
  LEPUS_ThrowTypeError(ctx, "not a Date object");
  return -1;
}

QJS_STATIC LEPUSValue JS_SetThisTimeValue(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, double v) {
  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_DATE) {
      LEPUS_FreeValue(ctx, p->u.object_data);
      p->u.object_data = __JS_NewFloat64(ctx, v);
      return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a Date object");
}

QJS_STATIC int64_t days_from_year(int64_t y) {
  return 365 * (y - 1970) + floor_div(y - 1969, 4) - floor_div(y - 1901, 100) +
         floor_div(y - 1601, 400);
}

QJS_STATIC int64_t days_in_year(int64_t y) {
  return 365 + !(y % 4) - !(y % 100) + !(y % 400);
}

/* return the year, update days */
QJS_STATIC int64_t year_from_days(int64_t *days) {
  int64_t y, d1, nd, d = *days;
  y = floor_div(d * 10000, 3652425) + 1970;
  /* the initial approximation is very good, so only a few
     iterations are necessary */
  for (;;) {
    d1 = d - days_from_year(y);
    if (d1 < 0) {
      y--;
      d1 += days_in_year(y);
    } else {
      nd = days_in_year(y);
      if (d1 < nd) break;
      d1 -= nd;
      y++;
    }
  }
  *days = d1;
  return y;
}

static int const month_days[] = {31, 28, 31, 30, 31, 30,
                                 31, 31, 30, 31, 30, 31};
static char const month_names[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
static char const day_names[] = "SunMonTueWedThuFriSat";

QJS_STATIC __exception int get_date_fields(LEPUSContext *ctx,
                                           LEPUSValueConst obj,
                                           double fields[9], int is_local,
                                           int force) {
  double dval;
  int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;

  if (JS_ThisTimeValue(ctx, &dval, obj)) return -1;

  if (isnan(dval)) {
    if (!force) return FALSE; /* NaN */
    d = 0;                    /* initialize all fields to 0 */
  } else {
    d = dval;
    if (is_local) {
      tz = -getTimezoneOffset(d);
      d += tz * 60000;
    }
  }

  /* result is >= 0, we can use % */
  h = math_mod(d, 86400000);
  days = (d - h) / 86400000;
  ms = h % 1000;
  h = (h - ms) / 1000;
  s = h % 60;
  h = (h - s) / 60;
  m = h % 60;
  h = (h - m) / 60;
  wd = math_mod(days + 4, 7); /* week day */
  y = year_from_days(&days);

  for (i = 0; i < 11; i++) {
    md = month_days[i];
    if (i == 1) md += days_in_year(y) - 365;
    if (days < md) break;
    days -= md;
  }
  fields[0] = y;
  fields[1] = i;
  fields[2] = days + 1;
  fields[3] = h;
  fields[4] = m;
  fields[5] = s;
  fields[6] = ms;
  fields[7] = wd;
  fields[8] = tz;
  return TRUE;
}

QJS_STATIC double time_clip(double t) {
  if (t >= -8.64e15 && t <= 8.64e15)
    return trunc(t) + 0.0; /* convert -0 to +0 */
  else
    return LEPUS_FLOAT64_NAN;
}

QJS_STATIC double set_date_fields(double fields[], int is_local) {
  int64_t y;
  double days, h, m1;
  volatile double d; /* enforce evaluation order */
  int i, m, md;

  m1 = fields[1];
  m = fmod(m1, 12);
  if (m < 0) m += 12;
  y = (int64_t)(fields[0] + floor(m1 / 12));
  days = days_from_year(y);

  for (i = 0; i < m; i++) {
    md = month_days[i];
    if (i == 1) md += days_in_year(y) - 365;
    days += md;
  }
  days += fields[2] - 1;
  h = fields[3] * 3600000 + fields[4] * 60000 + fields[5] * 1000 + fields[6];
  d = days * 86400000;
  d += h;
  if (is_local) d += getTimezoneOffset(d) * 60000;
  return time_clip(d);
}

QJS_STATIC LEPUSValue get_date_field(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  // get_date_field(obj, n, is_local)
  double fields[9];
  int res, n, is_local;

  is_local = magic & 0x0F;
  n = (magic >> 4) & 0x0F;
  res = get_date_fields(ctx, this_val, fields, is_local, 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) return LEPUS_NAN;

  if (magic & 0x100) {  // getYear
    fields[0] -= 1900;
  }
  return LEPUS_NewFloat64(ctx, fields[n]);
}

QJS_STATIC LEPUSValue set_date_field(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  // _field(obj, first_field, end_field, args, is_local)
  double fields[9];
  int res, first_field, end_field, is_local, i, n;
  double d, a;

  d = LEPUS_FLOAT64_NAN;
  first_field = (magic >> 8) & 0x0F;
  end_field = (magic >> 4) & 0x0F;
  is_local = magic & 0x0F;

  res = get_date_fields(ctx, this_val, fields, is_local, first_field == 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (res && argc > 0) {
    n = end_field - first_field;
    if (argc < n) n = argc;
    for (i = 0; i < n; i++) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isfinite(a)) goto done;
      fields[first_field + i] = trunc(a);
    }
    d = set_date_fields(fields, is_local);
  }
done:
  return JS_SetThisTimeValue(ctx, this_val, d);
}

/* fmt:
   0: toUTCString: "Tue, 02 Jan 2018 23:04:46 GMT"
   1: toString: "Wed Jan 03 2018 00:05:22 GMT+0100 (CET)"
   2: toISOString: "2018-01-02T23:02:56.927Z"
   3: toLocaleString: "1/2/2018, 11:40:40 PM"
   part: 1=date, 2=time 3=all
   XXX: should use a variant of strftime().
 */
QJS_HIDE LEPUSValue get_date_string(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  // _string(obj, fmt, part)
  char buf[64];
  double fields[9];
  int res, fmt, part, pos;
  int y, mon, d, h, m, s, ms, wd, tz;

  fmt = (magic >> 4) & 0x0F;
  part = magic & 0x0F;

  res = get_date_fields(ctx, this_val, fields, fmt & 1, 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) {
    if (fmt == 2)
      return LEPUS_ThrowRangeError(ctx, "Date value is NaN");
    else
      return LEPUS_NewString(ctx, "Invalid Date");
  }

  y = fields[0];
  mon = fields[1];
  d = fields[2];
  h = fields[3];
  m = fields[4];
  s = fields[5];
  ms = fields[6];
  wd = fields[7];
  tz = fields[8];

  pos = 0;

  if (part & 1) { /* date part */
    switch (fmt) {
      case 0:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%.3s, %02d %.3s %0*d ",
                        day_names + wd * 3, d, month_names + mon * 3,
                        4 + (y < 0), y);
        break;
      case 1:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%.3s %.3s %02d %0*d",
                        day_names + wd * 3, month_names + mon * 3, d,
                        4 + (y < 0), y);
        if (part == 3) {
          buf[pos++] = ' ';
        }
        break;
      case 2:
        if (y >= 0 && y <= 9999) {
          pos += snprintf(buf + pos, sizeof(buf) - pos, "%04d", y);
        } else {
          pos += snprintf(buf + pos, sizeof(buf) - pos, "%+07d", y);
        }
        pos +=
            snprintf(buf + pos, sizeof(buf) - pos, "-%02d-%02dT", mon + 1, d);
        break;
      case 3:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d/%02d/%0*d", mon + 1,
                        d, 4 + (y < 0), y);
        if (part == 3) {
          buf[pos++] = ',';
          buf[pos++] = ' ';
        }
        break;
    }
  }
  if (part & 2) { /* time part */
    switch (fmt) {
      case 0:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d GMT", h,
                        m, s);
        break;
      case 1:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d GMT", h,
                        m, s);
        if (tz < 0) {
          buf[pos++] = '-';
          tz = -tz;
        } else {
          buf[pos++] = '+';
        }
        /* tz is >= 0, can use % */
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d%02d", tz / 60,
                        tz % 60);
        /* XXX: tack the time zone code? */
        break;
      case 2:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d.%03dZ", h,
                        m, s, ms);
        break;
      case 3:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d %cM",
                        (h <= 12 ? h : h - 12), m, s, (h < 12) ? 'A' : 'P');
        break;
    }
  }
  return LEPUS_NewStringLen(ctx, buf, pos);
}

/* OS dependent: return the UTC time in ms since 1970. */
QJS_HIDE int64_t date_now(void) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
}

QJS_STATIC LEPUSValue js_date_constructor(LEPUSContext *ctx,
                                          LEPUSValueConst new_target, int argc,
                                          LEPUSValueConst *argv) {
  // Date(y, mon, d, h, m, s, ms)
  LEPUSValue rv;
  int i, n;
  double a, val;

  if (LEPUS_IsUndefined(new_target)) {
    /* invoked as function */
    argc = 0;
  }
  n = argc;
  if (n == 0) {
    val = date_now();
  } else if (n == 1) {
    LEPUSValue v, dv;
    if (LEPUS_VALUE_IS_OBJECT(argv[0])) {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(argv[0]);
      if (p->class_id == JS_CLASS_DATE && LEPUS_IsNumber(p->u.object_data)) {
        if (LEPUS_ToFloat64(ctx, &val, p->u.object_data))
          return LEPUS_EXCEPTION;
        val = time_clip(val);
        goto has_val;
      }
    }
    v = JS_ToPrimitive(ctx, argv[0], HINT_NONE);
    if (LEPUS_IsString(v)) {
      dv = js_Date_parse(ctx, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&v);
      LEPUS_FreeValue(ctx, v);
      if (LEPUS_IsException(dv)) return LEPUS_EXCEPTION;
      if (JS_ToFloat64Free(ctx, &val, dv)) return LEPUS_EXCEPTION;
    } else {
      if (JS_ToFloat64Free(ctx, &val, v)) return LEPUS_EXCEPTION;
    }
    val = time_clip(val);
  } else {
    double fields[] = {0, 0, 1, 0, 0, 0, 0};
    if (n > 7) n = 7;
    for (i = 0; i < n; i++) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isfinite(a)) break;
      fields[i] = trunc(a);
      if (i == 0 && fields[0] >= 0 && fields[0] < 100) fields[0] += 1900;
    }
    val = (i == n) ? set_date_fields(fields, 1) : LEPUS_FLOAT64_NAN;
  }
has_val:
#if 0
    LEPUSValueConst args[3];
    args[0] = new_target;
    args[1] = ctx->class_proto[JS_CLASS_DATE];
    args[2] = __JS_NewFloat64(ctx, val);
    rv = js___date_create(ctx, LEPUS_UNDEFINED, 3, args);
#else
  rv = js_create_from_ctor(ctx, new_target, JS_CLASS_DATE);
  if (!LEPUS_IsException(rv))
    JS_SetObjectData(ctx, rv, __JS_NewFloat64(ctx, val));
#endif
  if (!LEPUS_IsException(rv) && LEPUS_IsUndefined(new_target)) {
    /* invoked as a function, return (new Date()).toString(); */
    LEPUSValue s;
    s = get_date_string(ctx, rv, 0, NULL, 0x13);
    LEPUS_FreeValue(ctx, rv);
    rv = s;
  }
  return rv;
}

QJS_STATIC LEPUSValue js_Date_UTC(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  // UTC(y, mon, d, h, m, s, ms)
  double fields[] = {0, 0, 1, 0, 0, 0, 0};
  int i, n;
  double a;

  n = argc;
  if (n == 0) return LEPUS_NAN;
  if (n > 7) n = 7;
  for (i = 0; i < n; i++) {
    if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
    if (!isfinite(a)) return LEPUS_NAN;
    fields[i] = trunc(a);
    if (i == 0 && fields[0] >= 0 && fields[0] < 100) fields[0] += 1900;
  }
  return LEPUS_NewFloat64(ctx, set_date_fields(fields, 0));
}

QJS_STATIC void string_skip_spaces(JSString *sp, int *pp) {
  while (*pp < sp->len && string_get(sp, *pp) == ' ') *pp += 1;
}

QJS_STATIC void string_skip_non_spaces(JSString *sp, int *pp) {
  while (*pp < sp->len && string_get(sp, *pp) != ' ') *pp += 1;
}

/* parse a numeric field */
QJS_STATIC int string_get_field(JSString *sp, int *pp, int64_t *pval) {
  int64_t v = 0;
  int c, p = *pp;

  /* skip non digits, should only skip spaces? */
  while (p < sp->len) {
    c = string_get(sp, p);
    if (c >= '0' && c <= '9') break;
    p++;
  }
  if (p >= sp->len) return -1;
  while (p < sp->len) {
    c = string_get(sp, p);
    if (!(c >= '0' && c <= '9')) break;
    v = v * 10 + c - '0';
    p++;
  }
  *pval = v;
  *pp = p;
  return 0;
}

/* parse a fixed width numeric field */
QJS_STATIC int string_get_digits(JSString *sp, int *pp, int n, int64_t *pval) {
  int64_t v = 0;
  int i, c, p = *pp;

  for (i = 0; i < n; i++) {
    if (p >= sp->len) return -1;
    c = string_get(sp, p);
    if (!(c >= '0' && c <= '9')) return -1;
    v = v * 10 + c - '0';
    p++;
  }
  *pval = v;
  *pp = p;
  return 0;
}

/* parse a signed numeric field */
QJS_STATIC int string_get_signed_field(JSString *sp, int *pp, int64_t *pval) {
  int sgn, res;

  if (*pp >= sp->len) return -1;

  sgn = string_get(sp, *pp);
  if (sgn == '-' || sgn == '+') *pp += 1;

  res = string_get_field(sp, pp, pval);
  if (res == 0 && sgn == '-') *pval = -*pval;
  return res;
}

QJS_STATIC int find_abbrev(JSString *sp, int p, const char *list, int count) {
  int n, i;

  if (p + 3 <= sp->len) {
    for (n = 0; n < count; n++) {
      for (i = 0; i < 3; i++) {
        if (string_get(sp, p + i) != month_names[n * 3 + i]) goto next;
      }
      return n;
    next:;
    }
  }
  return -1;
}

QJS_STATIC int string_get_month(JSString *sp, int *pp, int64_t *pval) {
  int n;

  string_skip_spaces(sp, pp);
  n = find_abbrev(sp, *pp, month_names, 12);
  if (n < 0) return -1;

  *pval = n;
  *pp += 3;
  return 0;
}

QJS_STATIC LEPUSValue js_Date_parse(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  // parse(s)
  LEPUSValue s, rv;
  int64_t fields[] = {0, 1, 1, 0, 0, 0, 0};
  double fields1[7];
  int64_t tz, hh, mm;
  double d;
  int p, i, c, sgn;
  JSString *sp;
  BOOL is_local = FALSE;  //  date-time forms are interpreted as a local time

  rv = LEPUS_NAN;

  s = JS_ToString_RC(ctx, argv[0]);
  if (LEPUS_IsException(s)) return LEPUS_EXCEPTION;

  sp = LEPUS_VALUE_GET_STRING(s);
  p = 0;
  if (p < sp->len &&
      (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {
    /* ISO format */
    /* year field can be negative */
    /* XXX: could be stricter */
    if (string_get_signed_field(sp, &p, &fields[0])) goto done;

    for (i = 1; i < 6; i++) {
      if (string_get_field(sp, &p, &fields[i])) break;
    }
    is_local = (i > 3);  // more than 3 fields -> date-time form
    if (i == 6 && p < sp->len && string_get(sp, p) == '.') {
      /* parse milliseconds as a fractional part, round to nearest */
      /* XXX: the spec does not indicate which rounding should be used */
      int mul = 1000, ms = 0;
      while (++p < sp->len) {
        int c = string_get(sp, p);
        if (!(c >= '0' && c <= '9')) break;
        if (mul == 1 && c >= '5') ms += 1;
        ms += (c - '0') * (mul /= 10);
      }
      fields[6] = ms;
    }
    fields[1] -= 1;

    /* parse the time zone offset if present: [+-]HH:mm */
    tz = 0;
    if (p < sp->len &&
        ((sgn = string_get(sp, p)) == '+' || sgn == '-' || sgn == 'Z')) {
      if (sgn != 'Z') {
        if (string_get_field(sp, &p, &hh)) goto done;
        if (string_get_field(sp, &p, &mm)) goto done;
        tz = hh * 60 + mm;
        if (sgn == '-') tz = -tz;
      }
      is_local = FALSE;  // UTC offset representation, use offset
    }
  } else {
    /* toString or toUTCString format */
    /* skip the day of the week */
    string_skip_non_spaces(sp, &p);
    string_skip_spaces(sp, &p);
    if (p >= sp->len) goto done;
    c = string_get(sp, p);
    if (c >= '0' && c <= '9') {
      /* day of month first */
      if (string_get_field(sp, &p, &fields[2])) goto done;
      if (string_get_month(sp, &p, &fields[1])) goto done;
    } else {
      /* month first */
      if (string_get_month(sp, &p, &fields[1])) goto done;
      if (string_get_field(sp, &p, &fields[2])) goto done;
    }
    string_skip_spaces(sp, &p);
    if (string_get_signed_field(sp, &p, &fields[0])) goto done;

    /* hour, min, seconds */
    for (i = 0; i < 3; i++) {
      if (string_get_field(sp, &p, &fields[3 + i])) goto done;
    }
    // XXX: parse optional milliseconds?

    /* parse the time zone offset if present: [+-]HHmm */
    tz = 0;
    for (tz = 0; p < sp->len; p++) {
      sgn = string_get(sp, p);
      if (sgn == '+' || sgn == '-') {
        p++;
        if (string_get_digits(sp, &p, 2, &hh)) goto done;
        if (string_get_digits(sp, &p, 2, &mm)) goto done;
        tz = hh * 60 + mm;
        if (sgn == '-') tz = -tz;
        break;
      }
    }
  }
  for (i = 0; i < 7; i++) fields1[i] = fields[i];
  d = set_date_fields(fields1, is_local) - tz * 60000;
  rv = __JS_NewFloat64(ctx, d);

done:
  LEPUS_FreeValue(ctx, s);
  return rv;
}

QJS_STATIC LEPUSValue js_Date_now(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  // now()
  return LEPUS_NewInt64(ctx, date_now());
}

QJS_STATIC LEPUSValue js_date_Symbol_toPrimitive(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  // Symbol_toPrimitive(hint)
  LEPUSValueConst obj = this_val;
  JSAtom hint = JS_ATOM_NULL;
  int hint_num;

  if (!LEPUS_IsObject(obj)) return JS_ThrowTypeErrorNotAnObject(ctx);

  if (LEPUS_IsString(argv[0])) {
    hint = js_value_to_atom(ctx, argv[0]);
    if (hint == JS_ATOM_NULL) return LEPUS_EXCEPTION;
    LEPUS_FreeAtom(ctx, hint);
  }
  switch (hint) {
    case JS_ATOM_number:
#ifdef CONFIG_BIGNUM
    case JS_ATOM_integer:
#endif
      hint_num = HINT_NUMBER;
      break;
    case JS_ATOM_string:
    case JS_ATOM_default:
      hint_num = HINT_STRING;
      break;
    default:
      return LEPUS_ThrowTypeError(ctx, "invalid hint");
  }
  return JS_ToPrimitive(ctx, obj, hint_num | HINT_FORCE_ORDINARY);
}

QJS_STATIC LEPUSValue js_date_getTimezoneOffset(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  // getTimezoneOffset()
  double v;

  if (JS_ThisTimeValue(ctx, &v, this_val)) return LEPUS_EXCEPTION;
  if (isnan(v))
    return LEPUS_NAN;
  else
    return LEPUS_NewInt64(ctx, getTimezoneOffset((int64_t)trunc(v)));
}

QJS_STATIC LEPUSValue js_date_getTime(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  // getTime()
  double v;

  if (JS_ThisTimeValue(ctx, &v, this_val)) return LEPUS_EXCEPTION;
  return __JS_NewFloat64(ctx, v);
}

QJS_STATIC LEPUSValue js_date_setTime(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  // setTime(v)
  double v;

  if (JS_ThisTimeValue(ctx, &v, this_val) || LEPUS_ToFloat64(ctx, &v, argv[0]))
    return LEPUS_EXCEPTION;
  return JS_SetThisTimeValue(ctx, this_val, time_clip(v));
}

QJS_STATIC LEPUSValue js_date_setYear(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  // setYear(y)
  double y;
  LEPUSValueConst args[1];

  if (JS_ThisTimeValue(ctx, &y, this_val) || LEPUS_ToFloat64(ctx, &y, argv[0]))
    return LEPUS_EXCEPTION;
  y = +y;
  if (isfinite(y)) {
    y = trunc(y);
    if (y >= 0 && y < 100) y += 1900;
  }
  args[0] = __JS_NewFloat64(ctx, y);
  return set_date_field(ctx, this_val, 1, args, 0x011);
}

QJS_STATIC LEPUSValue js_date_toJSON(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  // toJSON(key)
  LEPUSValue obj, tv, method, rv;
  double d;

  rv = LEPUS_EXCEPTION;
  tv = LEPUS_UNDEFINED;

  obj = LEPUS_ToObject(ctx, this_val);
  tv = JS_ToPrimitive(ctx, obj, HINT_NUMBER);
  if (LEPUS_IsException(tv)) goto exception;
  if (LEPUS_IsNumber(tv)) {
    if (LEPUS_ToFloat64(ctx, &d, tv) < 0) goto exception;
    if (!isfinite(d)) {
      rv = LEPUS_NULL;
      goto done;
    }
  }
  method = LEPUS_GetPropertyStr(ctx, obj, "toISOString");
  if (LEPUS_IsException(method)) goto exception;
  if (!LEPUS_IsFunction(ctx, method)) {
    LEPUS_ThrowTypeError(ctx, "object needs toISOString method");
    LEPUS_FreeValue(ctx, method);
    goto exception;
  }
  rv = JS_CallFree(ctx, method, obj, 0, NULL);
exception:
done:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, tv);
  return rv;
}

static const LEPUSCFunctionListEntry js_date_funcs[] = {
    LEPUS_CFUNC_DEF("now", 0, js_Date_now),
    LEPUS_CFUNC_DEF("parse", 1, js_Date_parse),
    LEPUS_CFUNC_DEF("UTC", 7, js_Date_UTC),
};

static const LEPUSCFunctionListEntry js_date_proto_funcs[] = {
    LEPUS_CFUNC_DEF("valueOf", 0, js_date_getTime),
    LEPUS_CFUNC_MAGIC_DEF("toString", 0, get_date_string, 0x13),
    LEPUS_CFUNC_DEF("[Symbol.toPrimitive]", 1, js_date_Symbol_toPrimitive),
    LEPUS_CFUNC_MAGIC_DEF("toUTCString", 0, get_date_string, 0x03),
    LEPUS_ALIAS_DEF("toGMTString", "toUTCString"),
    LEPUS_CFUNC_MAGIC_DEF("toISOString", 0, get_date_string, 0x23),
    LEPUS_CFUNC_MAGIC_DEF("toDateString", 0, get_date_string, 0x11),
    LEPUS_CFUNC_MAGIC_DEF("toTimeString", 0, get_date_string, 0x12),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, get_date_string, 0x33),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleDateString", 0, get_date_string, 0x31),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleTimeString", 0, get_date_string, 0x32),
    LEPUS_CFUNC_DEF("getTimezoneOffset", 0, js_date_getTimezoneOffset),
    LEPUS_CFUNC_DEF("getTime", 0, js_date_getTime),
    LEPUS_CFUNC_MAGIC_DEF("getYear", 0, get_date_field, 0x101),
    LEPUS_CFUNC_MAGIC_DEF("getFullYear", 0, get_date_field, 0x01),
    LEPUS_CFUNC_MAGIC_DEF("getUTCFullYear", 0, get_date_field, 0x00),
    LEPUS_CFUNC_MAGIC_DEF("getMonth", 0, get_date_field, 0x11),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMonth", 0, get_date_field, 0x10),
    LEPUS_CFUNC_MAGIC_DEF("getDate", 0, get_date_field, 0x21),
    LEPUS_CFUNC_MAGIC_DEF("getUTCDate", 0, get_date_field, 0x20),
    LEPUS_CFUNC_MAGIC_DEF("getHours", 0, get_date_field, 0x31),
    LEPUS_CFUNC_MAGIC_DEF("getUTCHours", 0, get_date_field, 0x30),
    LEPUS_CFUNC_MAGIC_DEF("getMinutes", 0, get_date_field, 0x41),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMinutes", 0, get_date_field, 0x40),
    LEPUS_CFUNC_MAGIC_DEF("getSeconds", 0, get_date_field, 0x51),
    LEPUS_CFUNC_MAGIC_DEF("getUTCSeconds", 0, get_date_field, 0x50),
    LEPUS_CFUNC_MAGIC_DEF("getMilliseconds", 0, get_date_field, 0x61),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMilliseconds", 0, get_date_field, 0x60),
    LEPUS_CFUNC_MAGIC_DEF("getDay", 0, get_date_field, 0x71),
    LEPUS_CFUNC_MAGIC_DEF("getUTCDay", 0, get_date_field, 0x70),
    LEPUS_CFUNC_DEF("setTime", 1, js_date_setTime),
    LEPUS_CFUNC_MAGIC_DEF("setMilliseconds", 1, set_date_field, 0x671),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMilliseconds", 1, set_date_field, 0x670),
    LEPUS_CFUNC_MAGIC_DEF("setSeconds", 2, set_date_field, 0x571),
    LEPUS_CFUNC_MAGIC_DEF("setUTCSeconds", 2, set_date_field, 0x570),
    LEPUS_CFUNC_MAGIC_DEF("setMinutes", 3, set_date_field, 0x471),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMinutes", 3, set_date_field, 0x470),
    LEPUS_CFUNC_MAGIC_DEF("setHours", 4, set_date_field, 0x371),
    LEPUS_CFUNC_MAGIC_DEF("setUTCHours", 4, set_date_field, 0x370),
    LEPUS_CFUNC_MAGIC_DEF("setDate", 1, set_date_field, 0x231),
    LEPUS_CFUNC_MAGIC_DEF("setUTCDate", 1, set_date_field, 0x230),
    LEPUS_CFUNC_MAGIC_DEF("setMonth", 2, set_date_field, 0x131),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMonth", 2, set_date_field, 0x130),
    LEPUS_CFUNC_DEF("setYear", 1, js_date_setYear),
    LEPUS_CFUNC_MAGIC_DEF("setFullYear", 3, set_date_field, 0x031),
    LEPUS_CFUNC_MAGIC_DEF("setUTCFullYear", 3, set_date_field, 0x030),
    LEPUS_CFUNC_DEF("toJSON", 1, js_date_toJSON),
};

void LEPUS_AddIntrinsicDate(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicDate_GC, ctx);
  LEPUSValueConst obj;

  /* Date */
  ctx->class_proto[JS_CLASS_DATE] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATE],
                                js_date_proto_funcs,
                                countof(js_date_proto_funcs));
  obj = JS_NewGlobalCConstructor(ctx, "Date", js_date_constructor, 7,
                                 ctx->class_proto[JS_CLASS_DATE]);
  LEPUS_SetPropertyFunctionList(ctx, obj, js_date_funcs,
                                countof(js_date_funcs));
}

/* eval */

void LEPUS_AddIntrinsicEval(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicEval_GC, ctx);
#ifndef NO_QUICKJS_COMPILER
  ctx->eval_internal = __JS_EvalInternal;
#else
  ctx->eval_internal = NULL;
#endif
}

#ifdef CONFIG_BIGNUM

static LEPUSValue JS_ToBigIntCtorFree(LEPUSContext *ctx, LEPUSValue val) {
  int32_t tag;
  BOOL is_legacy;
  int ret;

  is_legacy = is_bignum_mode(ctx) ^ 1;
redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_BOOL:
      if (is_legacy) {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_si(r, LEPUS_VALUE_GET_INT(val));
        val = JS_NewBigInt2(ctx, r, TRUE);
      } else {
        val = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(val));
      }
      break;
    case LEPUS_TAG_BIG_INT:
      break;
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_BIG_FLOAT: {
      bf_t *a, a_s, r_s, *r = &r_s;
      BOOL is_float;
      a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
      bf_init(ctx->bf_ctx, r);
      if (!bf_is_finite(a)) {
        LEPUS_FreeValue(ctx, val);
        val = LEPUS_ThrowRangeError(ctx,
                                    "cannot convert NaN or Infinity to bigint");
      } else {
        bf_set(r, a);
        ret = bf_rint(r, BF_PREC_INF, BF_RNDZ);
        LEPUS_FreeValue(ctx, val);
        if (is_legacy && (ret & BF_ST_INEXACT)) {
          bf_delete(r);
          val = LEPUS_ThrowRangeError(
              ctx, "cannot convert to bigint: not an integer");
        } else {
          val = JS_NewBigInt2(ctx, r, is_legacy);
        }
      }
      if (a == &a_s) bf_delete(a);
    } break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING:
      val = JS_StringToBigIntErr(ctx, val);
      if (LEPUS_IsException(val)) break;
      goto redo;
    case LEPUS_TAG_OBJECT:
      val = JS_ToPrimitiveFree_RC(ctx, val,
                                  is_legacy ? HINT_NUMBER : HINT_INTEGER);
      if (LEPUS_IsException(val)) break;
      goto redo;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    default:
      LEPUS_FreeValue(ctx, val);
      return LEPUS_ThrowTypeError(ctx, "cannot convert to bigint");
  }
  return val;
}

static LEPUSValue js_bigint_constructor(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return JS_ToBigIntCtorFree(ctx, LEPUS_DupValue(ctx, argv[0]));
}

static inline BOOL JS_IsBigInt(LEPUSContext *ctx, LEPUSValueConst v) {
  int tag = LEPUS_VALUE_GET_TAG(v);
  if (tag == LEPUS_TAG_BIG_INT) return TRUE;
  if (is_bignum_mode(ctx))
    return tag == LEPUS_TAG_INT;
  else
    return FALSE;
}

static LEPUSValue js_thisBigIntValue(LEPUSContext *ctx,
                                     LEPUSValueConst this_val) {
  if (JS_IsBigInt(ctx, this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_BIG_INT) {
      if (JS_IsBigInt(ctx, p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a bigint");
}

static LEPUSValue js_bigint_toString(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  LEPUSValue val;
  int base;
  LEPUSValue ret;

  val = js_thisBigIntValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (JS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
  ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue js_bigint_valueOf(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  return js_thisBigIntValue(ctx, this_val);
}

static LEPUSValue js_integer_div(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, b_s, *a, *b, r_s, *r = &r_s, q_s, *q = &q_s;
  int status;

  b = NULL;
  a = JS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  b = JS_ToBigInt(ctx, &b_s, argv[1]);
  if (!b) {
    JS_FreeBigInt(ctx, a, &a_s);
    return LEPUS_EXCEPTION;
  }
  bf_init(ctx->bf_ctx, q);
  bf_init(ctx->bf_ctx, r);
  status = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, magic & 0xf);
  JS_FreeBigInt(ctx, a, &a_s);
  JS_FreeBigInt(ctx, b, &b_s);
  if (unlikely(status)) {
    bf_delete(q);
    bf_delete(r);
    throw_bf_exception(ctx, status);
    return LEPUS_EXCEPTION;
  }
  if (magic & 0x10) {
    LEPUSValue ret;
    /* XXX: handle exceptions */
    ret = LEPUS_NewArray(ctx);
    LEPUS_SetPropertyUint32(ctx, ret, 0, JS_NewBigInt(ctx, q));
    LEPUS_SetPropertyUint32(ctx, ret, 1, JS_NewBigInt(ctx, r));
    return ret;
  } else {
    bf_delete(r);
    return JS_NewBigInt(ctx, q);
  }
}

static LEPUSValue js_integer_sqrt(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, r_s, *r = &r_s, rem_s, *rem = &rem_s;
  int status;

  a = JS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  bf_init(ctx->bf_ctx, r);
  bf_init(ctx->bf_ctx, rem);
  status = bf_sqrtrem(r, rem, a);
  JS_FreeBigInt(ctx, a, &a_s);
  if (unlikely(status & ~BF_ST_INEXACT)) {
    bf_delete(r);
    bf_delete(rem);
    return throw_bf_exception(ctx, status);
  }
  if (magic) {
    LEPUSValue ret;
    /* XXX: handle exceptions */
    ret = LEPUS_NewArray(ctx);
    LEPUS_SetPropertyUint32(ctx, ret, 0, JS_NewBigInt(ctx, r));
    LEPUS_SetPropertyUint32(ctx, ret, 1, JS_NewBigInt(ctx, rem));
    return ret;
  } else {
    bf_delete(rem);
    return JS_NewBigInt(ctx, r);
  }
}

static LEPUSValue js_integer_op1(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a;
  int64_t res;

  a = JS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  switch (magic) {
    case 0: /* floorLog2 */
      if (a->sign || a->expn <= 0) {
        res = -1;
      } else {
        res = a->expn - 1;
      }
      break;
    case 1: /* ctz */
      if (bf_is_zero(a)) {
        res = -1;
      } else {
        res = bf_get_exp_min(a);
      }
      break;
    default:
      abort();
  }
  JS_FreeBigInt(ctx, a, &a_s);
  return LEPUS_NewInt64(ctx, res);
}

static LEPUSValue js_integer_asUintN(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int asIntN) {
  uint64_t bits;
  bf_t a_s, *a = &a_s, r_s, *r = &r_s, mask_s, *mask = &mask_s;
  BOOL is_legacy;

  if (LEPUS_ToIndex(ctx, &bits, argv[0])) return LEPUS_EXCEPTION;
  a = JS_ToBigInt(ctx, &a_s, argv[1]);
  if (!a) return LEPUS_EXCEPTION;
  /* XXX: optimize */
  bf_init(ctx->bf_ctx, r);
  bf_init(ctx->bf_ctx, mask);
  bf_set_ui(mask, 1);
  bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);
  bf_add_si(mask, mask, -1, BF_PREC_INF, BF_RNDZ);
  bf_logic_and(r, a, mask);
  if (asIntN && bits != 0) {
    bf_set_ui(mask, 1);
    bf_mul_2exp(mask, bits - 1, BF_PREC_INF, BF_RNDZ);
    if (bf_cmpu(r, mask) >= 0) {
      bf_set_ui(mask, 1);
      bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);
      bf_sub(r, r, mask, BF_PREC_INF, BF_RNDZ);
    }
  }
  bf_delete(mask);
  JS_FreeBigInt(ctx, a, &a_s);
  is_legacy = is_bignum_mode(ctx) ^ 1;
  return JS_NewBigInt2(ctx, r, is_legacy);
}

static const LEPUSCFunctionListEntry js_integer_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("tdiv", 2, js_integer_div, BF_RNDZ),
    LEPUS_CFUNC_MAGIC_DEF("fdiv", 2, js_integer_div, BF_RNDD),
    LEPUS_CFUNC_MAGIC_DEF("cdiv", 2, js_integer_div, BF_RNDU),
    LEPUS_CFUNC_MAGIC_DEF("ediv", 2, js_integer_div, BF_DIVREM_EUCLIDIAN),
    LEPUS_CFUNC_MAGIC_DEF("tdivrem", 2, js_integer_div, BF_RNDZ | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("fdivrem", 2, js_integer_div, BF_RNDD | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("cdivrem", 2, js_integer_div, BF_RNDU | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("edivrem", 2, js_integer_div,
                          BF_DIVREM_EUCLIDIAN | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("sqrt", 1, js_integer_sqrt, 0),
    LEPUS_CFUNC_MAGIC_DEF("sqrtrem", 1, js_integer_sqrt, 1),
    LEPUS_CFUNC_MAGIC_DEF("floorLog2", 1, js_integer_op1, 0),
    LEPUS_CFUNC_MAGIC_DEF("ctz", 1, js_integer_op1, 1),
    LEPUS_CFUNC_MAGIC_DEF("asUintN", 2, js_integer_asUintN, 0),
    LEPUS_CFUNC_MAGIC_DEF("asIntN", 2, js_integer_asUintN, 1),
};

static const LEPUSCFunctionListEntry js_bigint_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_bigint_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_bigint_valueOf),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "BigInt",
                          LEPUS_PROP_CONFIGURABLE),
};

static LEPUSValue js_thisBigFloatValue(LEPUSContext *ctx,
                                       LEPUSValueConst this_val) {
  if (LEPUS_IsBigFloat(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == JS_CLASS_BIG_FLOAT) {
      if (LEPUS_IsBigFloat(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a bigfloat");
}

static LEPUSValue js_bigfloat_toString(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue val;
  int base;
  LEPUSValue ret;

  val = js_thisBigFloatValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (JS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
  ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue js_bigfloat_valueOf(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  return js_thisBigFloatValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry js_bigfloat_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, js_bigfloat_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, js_bigfloat_valueOf),
    LEPUS_CFUNC_MAGIC_DEF("toPrecision", 1, js_number_toPrecision, 1),
    LEPUS_CFUNC_MAGIC_DEF("toFixed", 1, js_number_toFixed, 1),
    LEPUS_CFUNC_MAGIC_DEF("toExponential", 1, js_number_toExponential, 1),
};

static LEPUSValue js_bigfloat_constructor(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue val;
  if (argc == 0) {
    bf_t r_s, *r = &r_s;
    bf_init(ctx->bf_ctx, r);
    bf_set_zero(r, 0);
    val = JS_NewBigFloat(ctx, r);
  } else {
    val = LEPUS_DupValue(ctx, argv[0]);
  redo:
    switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
      case LEPUS_TAG_BIG_FLOAT:
        break;
      case LEPUS_TAG_FLOAT64: {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_float64(r, LEPUS_VALUE_GET_FLOAT64(val));
        val = JS_NewBigFloat(ctx, r);
      } break;
      case LEPUS_TAG_INT: {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_si(r, LEPUS_VALUE_GET_INT(val));
        val = JS_NewBigFloat(ctx, r);
      } break;
      case LEPUS_TAG_BIG_INT:
        /* We keep the full precision of the integer */
        {
          JSBigFloat *p = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
          val = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
        }
        break;
      case LEPUS_TAG_SEPARABLE_STRING:
      case LEPUS_TAG_STRING: {
        const char *str, *p;
        int err;

        str = JS_ToCStringLen2_RC(ctx, NULL, val, 0);
        LEPUS_FreeValue(ctx, val);
        if (!str) return LEPUS_EXCEPTION;
        val = js_atof(
            ctx, str, &p, 0,
            BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN | BF_ATOF_JS_QUIRKS);
        p += skip_spaces(p);
        err = (*p != '\0');
        LEPUS_FreeCString(ctx, str);
        if (err) {
          LEPUS_FreeValue(ctx, val);
          return LEPUS_ThrowSyntaxError(ctx, "invalid bigfloat literal");
        }
      } break;
      case LEPUS_TAG_OBJECT:
        val = JS_ToPrimitiveFree_RC(ctx, val, HINT_NUMBER);
        if (LEPUS_IsException(val)) break;
        goto redo;
      case LEPUS_TAG_NULL:
      case LEPUS_TAG_UNDEFINED:
      default:
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeError(ctx, "cannot convert to bigfloat");
    }
  }
  return val;
}

static LEPUSValue js_float_get_const(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int magic) {
  bf_t r_s, *r = &r_s;
  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case 0: /* PI */
      bf_const_pi(r, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    case 1: /* LN2 */
      bf_const_log2(r, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    case 2: /* MIN_VALUE */
    case 3: /* MAX_VALUE */
    {
      slimb_t e_range, e;
      e_range = (limb_t)1 << (bf_get_exp_bits(ctx->fp_env.flags) - 1);
      bf_set_ui(r, 1);
      if (magic == 2) {
        e = -e_range + 2;
        if (ctx->fp_env.flags & BF_FLAG_SUBNORMAL) e -= ctx->fp_env.prec - 1;
        bf_mul_2exp(r, e, ctx->fp_env.prec, ctx->fp_env.flags);
      } else {
        bf_mul_2exp(r, ctx->fp_env.prec, ctx->fp_env.prec, ctx->fp_env.flags);
        bf_add_si(r, r, -1, ctx->fp_env.prec, ctx->fp_env.flags);
        bf_mul_2exp(r, e_range - ctx->fp_env.prec, ctx->fp_env.prec,
                    ctx->fp_env.flags);
      }
    } break;
    case 4: /* EPSILON */
      bf_set_ui(r, 1);
      bf_mul_2exp(r, 1 - ctx->fp_env.prec, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    default:
      abort();
  }
  return JS_NewBigFloat(ctx, r);
}

static LEPUSValue js_float_parseFloat(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  bf_t a_s, *a = &a_s;
  const char *str;
  LEPUSValue ret;
  int radix;
  JSFloatEnv *fe;

  str = JS_ToCStringLen2_RC(ctx, NULL, argv[0], 0);
  if (!str) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &radix, argv[1])) {
  fail:
    LEPUS_FreeCString(ctx, str);
    return LEPUS_EXCEPTION;
  }
  if (radix != 0 && (radix < 2 || radix > 36)) {
    LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
    goto fail;
  }
  fe = &ctx->fp_env;
  if (argc > 2) {
    fe = static_cast<JSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, (argv[2]), JS_CLASS_FLOAT_ENV));
    if (!fe) goto fail;
  }
  bf_init(ctx->bf_ctx, a);
  bf_atof(a, str, NULL, radix, fe->prec, BF_ATOF_JS_QUIRKS | fe->flags);
  ret = JS_NewBigFloat(ctx, a);
  LEPUS_FreeCString(ctx, str);
  return ret;
}

static const LEPUSCFunctionListEntry js_bigfloat_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("PI", js_float_get_const, NULL, 0),
    LEPUS_CGETSET_MAGIC_DEF("LN2", js_float_get_const, NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("MIN_VALUE", js_float_get_const, NULL, 2),
    LEPUS_CGETSET_MAGIC_DEF("MAX_VALUE", js_float_get_const, NULL, 3),
    LEPUS_CGETSET_MAGIC_DEF("EPSILON", js_float_get_const, NULL, 4),
    LEPUS_CFUNC_DEF("parseFloat", 1, js_float_parseFloat),
    LEPUS_CFUNC_MAGIC_DEF("abs", 1, js_math_fop, MATH_OP_ABS),
    LEPUS_CFUNC_MAGIC_DEF("fpRound", 1, js_math_fop, MATH_OP_FPROUND),
    LEPUS_CFUNC_MAGIC_DEF("floor", 1, js_math_fop, MATH_OP_FLOOR),
    LEPUS_CFUNC_MAGIC_DEF("ceil", 1, js_math_fop, MATH_OP_CEIL),
    LEPUS_CFUNC_MAGIC_DEF("round", 1, js_math_fop, MATH_OP_ROUND),
    LEPUS_CFUNC_MAGIC_DEF("trunc", 1, js_math_fop, MATH_OP_TRUNC),
    LEPUS_CFUNC_MAGIC_DEF("sqrt", 1, js_math_fop, MATH_OP_SQRT),
    LEPUS_CFUNC_MAGIC_DEF("acos", 1, js_math_fop, MATH_OP_ACOS),
    LEPUS_CFUNC_MAGIC_DEF("asin", 1, js_math_fop, MATH_OP_ASIN),
    LEPUS_CFUNC_MAGIC_DEF("atan", 1, js_math_fop, MATH_OP_ATAN),
    LEPUS_CFUNC_MAGIC_DEF("atan2", 2, js_math_fop2, MATH_OP_ATAN2),
    LEPUS_CFUNC_MAGIC_DEF("cos", 1, js_math_fop, MATH_OP_COS),
    LEPUS_CFUNC_MAGIC_DEF("exp", 1, js_math_fop, MATH_OP_EXP),
    LEPUS_CFUNC_MAGIC_DEF("log", 1, js_math_fop, MATH_OP_LOG),
    LEPUS_CFUNC_MAGIC_DEF("pow", 2, js_math_fop2, MATH_OP_POW),
    LEPUS_CFUNC_MAGIC_DEF("sin", 1, js_math_fop, MATH_OP_SIN),
    LEPUS_CFUNC_MAGIC_DEF("tan", 1, js_math_fop, MATH_OP_TAN),
    LEPUS_CFUNC_MAGIC_DEF("sign", 1, js_math_fop, MATH_OP_SIGN),
    LEPUS_CFUNC_MAGIC_DEF("add", 2, js_math_fop2, MATH_OP_ADD),
    LEPUS_CFUNC_MAGIC_DEF("sub", 2, js_math_fop2, MATH_OP_SUB),
    LEPUS_CFUNC_MAGIC_DEF("mul", 2, js_math_fop2, MATH_OP_MUL),
    LEPUS_CFUNC_MAGIC_DEF("div", 2, js_math_fop2, MATH_OP_DIV),
    LEPUS_CFUNC_MAGIC_DEF("fmod", 2, js_math_fop2, MATH_OP_FMOD),
    LEPUS_CFUNC_MAGIC_DEF("remainder", 2, js_math_fop2, MATH_OP_REM),
};

/* FloatEnv */

static LEPUSValue js_float_env_constructor(LEPUSContext *ctx,
                                           LEPUSValueConst new_target, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj;
  JSFloatEnv *fe;
  int64_t prec;
  int flags, rndmode;

  prec = ctx->fp_env.prec;
  flags = ctx->fp_env.flags;
  if (!LEPUS_IsUndefined(argv[0])) {
    if (JS_ToInt64Sat(ctx, &prec, argv[0])) return LEPUS_EXCEPTION;
    if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
      return LEPUS_ThrowRangeError(ctx, "invalid precision");
    flags = BF_RNDN; /* RNDN, max exponent size, no subnormal */
    if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
      if (JS_ToInt32Sat(ctx, &rndmode, argv[1])) return LEPUS_EXCEPTION;
      if (rndmode < BF_RNDN || rndmode > BF_RNDF)
        return LEPUS_ThrowRangeError(ctx, "invalid rounding mode");
      flags = rndmode;
    }
  }

  obj = LEPUS_NewObjectClass(ctx, JS_CLASS_FLOAT_ENV);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  fe = static_cast<JSFloatEnv *>(lepus_malloc(ctx, sizeof(*fe)));
  if (!fe) return LEPUS_EXCEPTION;
  fe->prec = prec;
  fe->flags = flags;
  fe->status = 0;
  LEPUS_SetOpaque(obj, fe);
  return obj;
}

static void js_float_env_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  JSFloatEnv *fe =
      static_cast<JSFloatEnv *>(LEPUS_GetOpaque(val, JS_CLASS_FLOAT_ENV));
  lepus_free_rt(rt, fe);
}

static LEPUSValue js_float_env_get_prec(LEPUSContext *ctx,
                                        LEPUSValueConst this_val) {
  return LEPUS_NewInt64(ctx, ctx->fp_env.prec);
}

static LEPUSValue js_float_env_get_expBits(LEPUSContext *ctx,
                                           LEPUSValueConst this_val) {
  return LEPUS_NewInt32(ctx, bf_get_exp_bits(ctx->fp_env.flags));
}

/* temporary fix for string conversion overflows */
#define BF_EXP_BITS_MAX1 (BF_EXP_BITS_MAX - 1)

static LEPUSValue js_float_env_setPrec(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValueConst func;
  int exp_bits, flags, saved_flags;
  LEPUSValue ret;
  limb_t saved_prec;
  int64_t prec;

  func = argv[0];
  if (JS_ToInt64Sat(ctx, &prec, argv[1])) return LEPUS_EXCEPTION;
  if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
    return LEPUS_ThrowRangeError(ctx, "invalid precision");
  exp_bits = BF_EXP_BITS_MAX1;

  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (JS_ToInt32Sat(ctx, &exp_bits, argv[2])) return LEPUS_EXCEPTION;
    if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX1)
      return LEPUS_ThrowRangeError(ctx, "invalid number of exponent bits");
  }

  flags = BF_RNDN | bf_set_exp_bits(exp_bits);
  if (exp_bits != BF_EXP_BITS_MAX1) flags |= BF_FLAG_SUBNORMAL;

  saved_prec = ctx->fp_env.prec;
  saved_flags = ctx->fp_env.flags;

  ctx->fp_env.prec = prec;
  ctx->fp_env.flags = flags;

  ret = JS_Call_RC(ctx, func, LEPUS_UNDEFINED, 0, NULL);
  /* always restore the floating point precision */
  ctx->fp_env.prec = saved_prec;
  ctx->fp_env.flags = saved_flags;
  return ret;
}

#define FE_PREC (-1)
#define FE_EXP (-2)
#define FE_RNDMODE (-3)
#define FE_SUBNORMAL (-4)

static LEPUSValue js_float_env_proto_get_status(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int magic) {
  JSFloatEnv *fe;
  fe = static_cast<JSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  switch (magic) {
    case FE_PREC:
      return LEPUS_NewInt64(ctx, fe->prec);
    case FE_EXP:
      return LEPUS_NewInt32(ctx, bf_get_exp_bits(fe->flags));
    case FE_RNDMODE:
      return LEPUS_NewInt32(ctx, fe->flags & BF_RND_MASK);
    case FE_SUBNORMAL:
      return LEPUS_NewBool(ctx, (fe->flags & BF_FLAG_SUBNORMAL) != 0);
    default:
      return LEPUS_NewBool(ctx, (fe->status & magic) != 0);
  }
}

static LEPUSValue js_float_env_proto_set_status(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                LEPUSValue val, int magic) {
  JSFloatEnv *fe;
  int b;
  int64_t prec;

  fe = static_cast<JSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  switch (magic) {
    case FE_PREC:
      if (JS_ToInt64Sat(ctx, &prec, val)) return LEPUS_EXCEPTION;
      if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
        return LEPUS_ThrowRangeError(ctx, "invalid precision");
      fe->prec = prec;
      break;
    case FE_EXP:
      if (JS_ToInt32Sat(ctx, &b, val)) return LEPUS_EXCEPTION;
      if (b < BF_EXP_BITS_MIN || b > BF_EXP_BITS_MAX1)
        return LEPUS_ThrowRangeError(ctx, "invalid number of exponent bits");
      if (b == BF_EXP_BITS_MAX1) fe->flags &= ~BF_FLAG_SUBNORMAL;
      fe->flags = (fe->flags & ~(BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)) |
                  bf_set_exp_bits(b);
      break;
    case FE_RNDMODE:
      b = get_rnd_mode(ctx, val);
      if (b < 0) return LEPUS_EXCEPTION;
      fe->flags = (fe->flags & ~BF_RND_MASK) | b;
      break;
    case FE_SUBNORMAL:
      b = LEPUS_ToBool(ctx, val);
      if (bf_get_exp_bits(fe->flags) != BF_EXP_BITS_MAX1) {
        fe->flags =
            (fe->flags & ~BF_FLAG_SUBNORMAL) | (b ? BF_FLAG_SUBNORMAL : 0);
      }
      break;
    default:
      b = LEPUS_ToBool(ctx, val);
      fe->status = (fe->status & ~magic) & ((-b) & magic);
      break;
  }
  return LEPUS_UNDEFINED;
}

static LEPUSValue js_float_env_clearStatus(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  JSFloatEnv *fe = static_cast<JSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, JS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  fe->status = 0;
  return LEPUS_UNDEFINED;
}

static const LEPUSCFunctionListEntry js_float_env_funcs[] = {
    LEPUS_CGETSET_DEF("prec", js_float_env_get_prec, NULL),
    LEPUS_CGETSET_DEF("expBits", js_float_env_get_expBits, NULL),
    LEPUS_CFUNC_DEF("setPrec", 2, js_float_env_setPrec),
    LEPUS_PROP_INT32_DEF("RNDN", BF_RNDN, 0),
    LEPUS_PROP_INT32_DEF("RNDZ", BF_RNDZ, 0),
    LEPUS_PROP_INT32_DEF("RNDU", BF_RNDU, 0),
    LEPUS_PROP_INT32_DEF("RNDD", BF_RNDD, 0),
    LEPUS_PROP_INT32_DEF("RNDNA", BF_RNDNA, 0),
    LEPUS_PROP_INT32_DEF("RNDNU", BF_RNDNU, 0),
    LEPUS_PROP_INT32_DEF("RNDF", BF_RNDF, 0),
    LEPUS_PROP_INT32_DEF("precMin", BF_PREC_MIN, 0),
    LEPUS_PROP_INT64_DEF("precMax", BF_PREC_MAX, 0),
    LEPUS_PROP_INT32_DEF("expBitsMin", BF_EXP_BITS_MIN, 0),
    LEPUS_PROP_INT32_DEF("expBitsMax", BF_EXP_BITS_MAX1, 0),
};

static const LEPUSCFunctionListEntry js_float_env_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("prec", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, FE_PREC),
    LEPUS_CGETSET_MAGIC_DEF("expBits", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, FE_EXP),
    LEPUS_CGETSET_MAGIC_DEF("rndMode", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, FE_RNDMODE),
    LEPUS_CGETSET_MAGIC_DEF("subnormal", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, FE_SUBNORMAL),
    LEPUS_CGETSET_MAGIC_DEF("invalidOperation", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, BF_ST_INVALID_OP),
    LEPUS_CGETSET_MAGIC_DEF("divideByZero", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, BF_ST_DIVIDE_ZERO),
    LEPUS_CGETSET_MAGIC_DEF("overflow", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, BF_ST_OVERFLOW),
    LEPUS_CGETSET_MAGIC_DEF("underflow", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, BF_ST_UNDERFLOW),
    LEPUS_CGETSET_MAGIC_DEF("inexact", js_float_env_proto_get_status,
                            js_float_env_proto_set_status, BF_ST_INEXACT),
    LEPUS_CFUNC_DEF("clearStatus", 0, js_float_env_clearStatus),
};

#endif /* CONFIG_BIGNUM */

/* Minimum amount of objects to be able to compile code and display
   error messages. No JSAtom should be allocated by this function. */
QJS_STATIC void JS_AddIntrinsicBasicObjects(LEPUSContext *ctx) {
  LEPUSValue proto;
  int i;

  ctx->class_proto[JS_CLASS_OBJECT] = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
  ctx->function_proto =
      JS_NewCFunction3(ctx, js_function_proto, "", 0, LEPUS_CFUNC_generic, 0,
                       ctx->class_proto[JS_CLASS_OBJECT]);
  ctx->class_proto[JS_CLASS_BYTECODE_FUNCTION] =
      LEPUS_DupValue(ctx, ctx->function_proto);
  ctx->class_proto[JS_CLASS_ERROR] = LEPUS_NewObject(ctx);
#if 0
    /* these are auto-initialized from js_error_proto_funcs,
       but delaying might be a problem */
    JS_DefinePropertyValue_RC(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_name,
                           LEPUS_AtomToString(ctx, JS_ATOM_Error),
                           LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    JS_DefinePropertyValue_RC(ctx, ctx->class_proto[JS_CLASS_ERROR], JS_ATOM_message,
                           LEPUS_AtomToString(ctx, JS_ATOM_empty_string),
                           LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
#endif
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ERROR],
                                js_error_proto_funcs,
                                countof(js_error_proto_funcs));

  for (i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
    proto = LEPUS_NewObjectProto(ctx, ctx->class_proto[JS_CLASS_ERROR]);
    JS_DefinePropertyValue_RC(ctx, proto, JS_ATOM_name,
                              LEPUS_NewAtomString(ctx, native_error_name[i]),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    JS_DefinePropertyValue_RC(ctx, proto, JS_ATOM_message,
                              LEPUS_AtomToString(ctx, JS_ATOM_empty_string),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    ctx->native_error_proto[i] = proto;
  }

  /* the array prototype is an array */
  ctx->class_proto[JS_CLASS_ARRAY] = JS_NewObjectProtoClass_RC(
      ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_ARRAY);

  ctx->array_shape =
      js_new_shape2(ctx, get_proto_obj(ctx->class_proto[JS_CLASS_ARRAY]),
                    JS_PROP_INITIAL_HASH_SIZE, 1);
  add_shape_property(ctx, &ctx->array_shape, NULL, JS_ATOM_length,
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH);

  /* XXX: could test it on first context creation to ensure that no
     new atoms are created in JS_AddIntrinsicBasicObjects(). It is
     necessary to avoid useless renumbering of atoms after
     LEPUS_EvalBinary() if it is done just after
     JS_AddIntrinsicBasicObjects(). */
  //    assert(ctx->rt->atom_count == JS_ATOM_END);
}

void LEPUS_AddIntrinsicBaseObjects(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicBaseObjects_GC, ctx);
  int i;
  LEPUSValueConst obj, number_obj;
  LEPUSValue obj1;

  ctx->throw_type_error = LEPUS_NewCFunction(ctx, js_throw_type_error, NULL, 0);

  /* add caller and arguments properties to throw a TypeError */
  obj1 = LEPUS_NewCFunction(ctx, js_function_proto_caller, "get caller", 0);
  JS_DefineProperty_RC(ctx, ctx->function_proto, JS_ATOM_caller,
                       LEPUS_UNDEFINED, obj1, ctx->throw_type_error,
                       LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET |
                           LEPUS_PROP_HAS_CONFIGURABLE |
                           LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);
  JS_DefineProperty_RC(
      ctx, ctx->function_proto, JS_ATOM_arguments, LEPUS_UNDEFINED,
      ctx->throw_type_error, ctx->throw_type_error,
      LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET | LEPUS_PROP_HAS_CONFIGURABLE |
          LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx,
                  js_object_seal(ctx, LEPUS_UNDEFINED, 1,
                                 (LEPUSValueConst *)&ctx->throw_type_error, 1));

  ctx->global_obj = LEPUS_NewObject(ctx);
  ctx->global_var_obj = LEPUS_NewObjectProto(ctx, LEPUS_NULL);

  /* Object */
  obj = JS_NewGlobalCConstructor(ctx, "Object", js_object_constructor, 1,
                                 ctx->class_proto[JS_CLASS_OBJECT]);
  LEPUS_SetPropertyFunctionList(ctx, obj, js_object_funcs,
                                countof(js_object_funcs));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                js_object_proto_funcs,
                                countof(js_object_proto_funcs));

  /* Function */
  LEPUS_SetPropertyFunctionList(ctx, ctx->function_proto,
                                js_function_proto_funcs,
                                countof(js_function_proto_funcs));
  ctx->function_ctor = LEPUS_NewCFunctionMagic(
      ctx, js_function_constructor, "Function", 1,
      LEPUS_CFUNC_constructor_or_func_magic, JS_FUNC_NORMAL);
  JS_NewGlobalCConstructor2(ctx, LEPUS_DupValue(ctx, ctx->function_ctor),
                            "Function", ctx->function_proto);

  /* Error */
  obj1 = LEPUS_NewCFunctionMagic(ctx, js_error_constructor, "Error", 1,
                                 LEPUS_CFUNC_constructor_or_func_magic, -1);
  JS_NewGlobalCConstructor2(ctx, obj1, "Error",
                            ctx->class_proto[JS_CLASS_ERROR]);

  for (i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
    int n_args = 1 + (i == JS_AGGREGATE_ERROR);
    LEPUSValue func_obj = JS_NewCFunction3(
        ctx, (LEPUSCFunction *)js_error_constructor, native_error_name[i],
        n_args, LEPUS_CFUNC_constructor_or_func_magic, i, obj1);
    JS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],
                              ctx->native_error_proto[i]);
  }

  /* Iterator prototype */
  ctx->iterator_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->iterator_proto,
                                js_iterator_proto_funcs,
                                countof(js_iterator_proto_funcs));

  /* Array */
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY],
                                js_array_proto_funcs,
                                countof(js_array_proto_funcs));

  obj = JS_NewGlobalCConstructor(ctx, "Array", js_array_constructor, 1,
                                 ctx->class_proto[JS_CLASS_ARRAY]);
  LEPUS_SetPropertyFunctionList(ctx, obj, js_array_funcs,
                                countof(js_array_funcs));

  /* XXX: create auto_initializer */
  {
    /* initialize Array.prototype[Symbol.unscopables] */
    char const unscopables[] =
        "copyWithin"
        "\0"
        "entries"
        "\0"
        "fill"
        "\0"
        "find"
        "\0"
        "findIndex"
        "\0"
        "flat"
        "\0"
        "flatMap"
        "\0"
        "includes"
        "\0"
        "keys"
        "\0"
        "values"
        "\0";
    const char *p = unscopables;
    obj1 = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
    for (p = unscopables; *p; p += strlen(p) + 1) {
      JS_DefinePropertyValueStr_RC(ctx, obj1, p, LEPUS_TRUE, LEPUS_PROP_C_W_E);
    }
    JS_DefinePropertyValue_RC(ctx, ctx->class_proto[JS_CLASS_ARRAY],
                              JS_ATOM_Symbol_unscopables, obj1,
                              LEPUS_PROP_CONFIGURABLE);
  }

  /* needed to initialize arguments[Symbol.iterator] */
  ctx->array_proto_values = JS_GetPropertyInternal_RC(
      ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_values,
      ctx->class_proto[JS_CLASS_ARRAY], 0);

  ctx->class_proto[JS_CLASS_ARRAY_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_ITERATOR],
                                js_array_iterator_proto_funcs,
                                countof(js_array_iterator_proto_funcs));
  /* parseFloat and parseInteger must be defined before Number
       because of the Number.parseFloat and Number.parseInteger
       aliases */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_global_funcs,
                                countof(js_global_funcs));

  /* Number */
  ctx->class_proto[JS_CLASS_NUMBER] = JS_NewObjectProtoClass_RC(
      ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_NUMBER);
  JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_NUMBER],
                   LEPUS_NewInt32(ctx, 0));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_NUMBER],
                                js_number_proto_funcs,
                                countof(js_number_proto_funcs));
  number_obj = JS_NewGlobalCConstructor(ctx, "Number", js_number_constructor, 1,
                                        ctx->class_proto[JS_CLASS_NUMBER]);
  LEPUS_SetPropertyFunctionList(ctx, number_obj, js_number_funcs,
                                countof(js_number_funcs));

  /* Boolean */
  ctx->class_proto[JS_CLASS_BOOLEAN] = JS_NewObjectProtoClass_RC(
      ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_BOOLEAN);
  JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_BOOLEAN],
                   LEPUS_NewBool(ctx, FALSE));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BOOLEAN],
                                js_boolean_proto_funcs,
                                countof(js_boolean_proto_funcs));
  JS_NewGlobalCConstructor(ctx, "Boolean", js_boolean_constructor, 1,
                           ctx->class_proto[JS_CLASS_BOOLEAN]);

  /* String */
  ctx->class_proto[JS_CLASS_STRING] = JS_NewObjectProtoClass_RC(
      ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_STRING);
  JS_SetObjectData(ctx, ctx->class_proto[JS_CLASS_STRING],
                   LEPUS_AtomToString(ctx, JS_ATOM_empty_string));
  obj = JS_NewGlobalCConstructor(ctx, "String", js_string_constructor, 1,
                                 ctx->class_proto[JS_CLASS_STRING]);
  LEPUS_SetPropertyFunctionList(ctx, obj, js_string_funcs,
                                countof(js_string_funcs));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING],
                                js_string_proto_funcs,
                                countof(js_string_proto_funcs));

  ctx->class_proto[JS_CLASS_STRING_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_STRING_ITERATOR],
                                js_string_iterator_proto_funcs,
                                countof(js_string_iterator_proto_funcs));

  /* Math: create as autoinit object */
  js_random_init(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_math_obj,
                                countof(js_math_obj));

  /* ES6 Reflect: create as autoinit object */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_reflect_obj,
                                countof(js_reflect_obj));

  /* ES6 Symbol */
  ctx->class_proto[JS_CLASS_SYMBOL] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_SYMBOL],
                                js_symbol_proto_funcs,
                                countof(js_symbol_proto_funcs));
  obj = JS_NewGlobalCConstructor(ctx, "Symbol", js_symbol_constructor, 0,
                                 ctx->class_proto[JS_CLASS_SYMBOL]);
  LEPUS_SetPropertyFunctionList(ctx, obj, js_symbol_funcs,
                                countof(js_symbol_funcs));
  for (i = JS_ATOM_Symbol_toPrimitive; i < JS_ATOM_END; i++) {
    char buf[ATOM_GET_STR_BUF_SIZE];
    const char *str, *p;
    str = JS_AtomGetStr(ctx, buf, sizeof(buf), i);
    /* skip "Symbol." */
    p = strchr(str, '.');
    if (p) str = p + 1;
    JS_DefinePropertyValueStr_RC(ctx, obj, str, JS_AtomToValue_RC(ctx, i), 0);
  }

  /* ES6 Generator */
  ctx->class_proto[JS_CLASS_GENERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_GENERATOR],
                                js_generator_proto_funcs,
                                countof(js_generator_proto_funcs));

  ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = LEPUS_NewCFunctionMagic(
      ctx, js_function_constructor, "GeneratorFunction", 1,
      LEPUS_CFUNC_constructor_or_func_magic, JS_FUNC_GENERATOR);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
                                js_generator_function_proto_funcs,
                                countof(js_generator_function_proto_funcs));
  JS_SetConstructor2(ctx, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
                     ctx->class_proto[JS_CLASS_GENERATOR],
                     LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_CONFIGURABLE);
  JS_SetConstructor2(ctx, obj1, ctx->class_proto[JS_CLASS_GENERATOR_FUNCTION],
                     0, LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);

#ifdef CONFIG_BIGNUM
  ctx->class_proto[JS_CLASS_BIG_INT] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
                                js_bigint_proto_funcs,
                                countof(js_bigint_proto_funcs));
  obj1 = LEPUS_NewCFunction(ctx, js_bigint_constructor, "BigInt", 1);
  JS_NewGlobalCConstructor2(ctx, obj1, "BigInt",
                            ctx->class_proto[JS_CLASS_BIG_INT]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, js_integer_funcs,
                                countof(js_integer_funcs));

  ctx->class_proto[JS_CLASS_BIG_FLOAT] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT],
                                js_bigfloat_proto_funcs,
                                countof(js_bigfloat_proto_funcs));
  obj1 = LEPUS_NewCFunction(ctx, js_bigfloat_constructor, "BigFloat", 1);
  JS_NewGlobalCConstructor2(ctx, obj1, "BigFloat",
                            ctx->class_proto[JS_CLASS_BIG_FLOAT]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, js_bigfloat_funcs,
                                countof(js_bigfloat_funcs));

  ctx->class_proto[JS_CLASS_FLOAT_ENV] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_FLOAT_ENV],
                                js_float_env_proto_funcs,
                                countof(js_float_env_proto_funcs));
  obj1 =
      JS_NewGlobalCConstructorOnly(ctx, "BigFloatEnv", js_float_env_constructor,
                                   1, ctx->class_proto[JS_CLASS_FLOAT_ENV]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, js_float_env_funcs,
                                countof(js_float_env_funcs));
#endif
  /* global properties */
  ctx->eval_obj = LEPUS_NewCFunction(ctx, js_global_eval, "eval", 1);
  JS_DefinePropertyValue_RC(ctx, ctx->global_obj, JS_ATOM_eval,
                            LEPUS_DupValue(ctx, ctx->eval_obj),
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  JS_DefinePropertyValueStr_RC(ctx, ctx->global_obj, "globalThis",
                               LEPUS_DupValue(ctx, ctx->global_obj),
                               LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
}

QJS_STATIC LEPUSValue js_array_buffer_constructor3(
    LEPUSContext *ctx, LEPUSValueConst new_target, uint64_t len,
    LEPUSClassID class_id, uint8_t *buf,
    LEPUSFreeArrayBufferDataFunc *free_func, void *opaque, BOOL alloc_flag) {
  LEPUSValue obj;
  JSArrayBuffer *abuf = NULL;

  obj = js_create_from_ctor(ctx, new_target, class_id);
  if (LEPUS_IsException(obj)) return obj;
  /* XXX: we are currently limited to 2 GB */
  if (len > INT32_MAX) {
    LEPUS_ThrowRangeError(ctx, "invalid array buffer length");
    goto fail;
  }
  abuf = static_cast<JSArrayBuffer *>(lepus_malloc(ctx, sizeof(*abuf)));
  if (!abuf) goto fail;
  abuf->byte_length = len;
  if (alloc_flag) {
    /* the allocation must be done after the object creation */
    abuf->data = static_cast<uint8_t *>(lepus_mallocz(ctx, max_int(len, 1)));
    if (!abuf->data) goto fail;
  } else {
    abuf->data = buf;
  }
  init_list_head(&abuf->array_list);
  abuf->detached = FALSE;
  abuf->shared = (class_id == JS_CLASS_SHARED_ARRAY_BUFFER);
  abuf->opaque = opaque;
  abuf->free_func = free_func;
  if (alloc_flag && buf) memcpy(abuf->data, buf, len);
  LEPUS_SetOpaque(obj, abuf);
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  lepus_free(ctx, abuf);
  return LEPUS_EXCEPTION;
}

QJS_STATIC void js_array_buffer_free(LEPUSRuntime *rt, void *opaque,
                                     void *ptr) {
  lepus_free_rt(rt, ptr);
}

QJS_STATIC LEPUSValue js_array_buffer_constructor2(LEPUSContext *ctx,
                                                   LEPUSValueConst new_target,
                                                   uint64_t len,
                                                   LEPUSClassID class_id) {
  return js_array_buffer_constructor3(ctx, new_target, len, class_id, NULL,
                                      js_array_buffer_free, NULL, TRUE);
}

QJS_STATIC LEPUSValue js_array_buffer_constructor1(LEPUSContext *ctx,
                                                   LEPUSValueConst new_target,
                                                   uint64_t len) {
  return js_array_buffer_constructor2(ctx, new_target, len,
                                      JS_CLASS_ARRAY_BUFFER);
}

// <Primjs begin>
LEPUS_BOOL LEPUS_IsArrayBuffer(LEPUSValueConst v) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(v)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(v);
  if (p && p->class_id != JS_CLASS_ARRAY_BUFFER &&
      p->class_id != JS_CLASS_SHARED_ARRAY_BUFFER) {
    return FALSE;
  }
  return TRUE;
}

LEPUS_BOOL LEPUS_IsTypedArray(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return (p->class_id >= JS_CLASS_UINT8C_ARRAY) &&
         (p->class_id <= JS_CLASS_FLOAT64_ARRAY);
}

LEPUS_BOOL LEPUS_StrictEq(LEPUSContext *ctx, LEPUSValueConst op1,
                          LEPUSValueConst op2) {
  CallGCFunc(JS_StrictEq_GC, ctx, op1, op2);
  return js_strict_eq(ctx, op1, op2);
}

LEPUS_BOOL LEPUS_SameValue(LEPUSContext *ctx, LEPUSValueConst op1,
                           LEPUSValueConst op2) {
  CallGCFunc(JS_SameValue_GC, ctx, op1, op2);
  return js_same_value(ctx, op1, op2);
}
// <Primjs end>

LEPUSValue LEPUS_NewArrayBuffer(LEPUSContext *ctx, uint8_t *buf, size_t len,
                                LEPUSFreeArrayBufferDataFunc *free_func,
                                void *opaque, BOOL is_shared) {
  CallGCFunc(JS_NewArrayBuffer_GC, ctx, buf, len, free_func, opaque, is_shared);
  return js_array_buffer_constructor3(
      ctx, LEPUS_UNDEFINED, len,
      is_shared ? JS_CLASS_SHARED_ARRAY_BUFFER : JS_CLASS_ARRAY_BUFFER, buf,
      free_func, opaque, FALSE);
}

/* create a new ArrayBuffer of length 'len' and copy 'buf' to it */
LEPUSValue LEPUS_NewArrayBufferCopy(LEPUSContext *ctx, const uint8_t *buf,
                                    size_t len) {
  CallGCFunc(JS_NewArrayBufferCopy_GC, ctx, buf, len);
  return js_array_buffer_constructor3(ctx, LEPUS_UNDEFINED, len,
                                      JS_CLASS_ARRAY_BUFFER, (uint8_t *)buf,
                                      js_array_buffer_free, NULL, TRUE);
}

QJS_STATIC LEPUSValue js_array_buffer_constructor(LEPUSContext *ctx,
                                                  LEPUSValueConst new_target,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  uint64_t len;
  if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
  return js_array_buffer_constructor1(ctx, new_target, len);
}

QJS_STATIC LEPUSValue js_shared_array_buffer_constructor(
    LEPUSContext *ctx, LEPUSValueConst new_target, int argc,
    LEPUSValueConst *argv) {
  uint64_t len;
  if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
  return js_array_buffer_constructor2(ctx, new_target, len,
                                      JS_CLASS_SHARED_ARRAY_BUFFER);
}

/* also used for SharedArrayBuffer */
QJS_STATIC void js_array_buffer_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSArrayBuffer *abuf = p->u.array_buffer;
  if (abuf) {
    /* The ArrayBuffer finalizer may be called before the typed
        array finalizers using it, so abuf->array_list is not
        necessarily empty. */
    // assert(list_empty(&abuf->array_list));
    if (abuf->free_func) abuf->free_func(rt, abuf->opaque, abuf->data);
    lepus_free_rt(rt, abuf);
  }
}

QJS_STATIC LEPUSValue js_array_buffer_isView(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSObject *p;
  BOOL res;
  res = FALSE;
  if (LEPUS_VALUE_IS_OBJECT(argv[0])) {
    p = LEPUS_VALUE_GET_OBJ(argv[0]);
    if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
        p->class_id <= JS_CLASS_DATAVIEW) {
      res = TRUE;
    }
  }
  return LEPUS_NewBool(ctx, res);
}

static const LEPUSCFunctionListEntry js_array_buffer_funcs[] = {
    LEPUS_CFUNC_DEF("isView", 1, js_array_buffer_isView),
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
};

QJS_STATIC LEPUSValue JS_ThrowTypeErrorDetachedArrayBuffer(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "ArrayBuffer is detached");
}

QJS_HIDE LEPUSValue js_array_buffer_get_byteLength(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int class_id) {
  JSArrayBuffer *abuf =
      static_cast<JSArrayBuffer *>(LEPUS_GetOpaque2(ctx, this_val, class_id));
  if (!abuf) return LEPUS_EXCEPTION;
  /* return 0 if detached */
  return JS_NewUint32(ctx, abuf->byte_length);
}

void LEPUS_DetachArrayBuffer(LEPUSContext *ctx, LEPUSValueConst obj) {
  CallGCFunc(JS_DetachArrayBuffer_GC, ctx, obj);
  JSArrayBuffer *abuf =
      static_cast<JSArrayBuffer *>(LEPUS_GetOpaque(obj, JS_CLASS_ARRAY_BUFFER));
  struct list_head *el;

  if (!abuf || abuf->detached) return;
  if (abuf->free_func) abuf->free_func(ctx->rt, abuf->opaque, abuf->data);
  abuf->data = NULL;
  abuf->byte_length = 0;
  abuf->detached = TRUE;

  list_for_each(el, &abuf->array_list) {
    JSTypedArray *ta;
    LEPUSObject *p;

    ta = list_entry(el, JSTypedArray, link);
    p = ta->obj;
    /* Note: the typed array length and offset fields are not modified */
    if (p->class_id != JS_CLASS_DATAVIEW) {
      p->u.array.count = 0;
      p->u.array.u.ptr = NULL;
    }
  }
}

/* get an ArrayBuffer or SharedArrayBuffer */
JSArrayBuffer *js_get_array_buffer(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id != JS_CLASS_ARRAY_BUFFER &&
      p->class_id != JS_CLASS_SHARED_ARRAY_BUFFER) {
  fail:
    JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_ARRAY_BUFFER);
    return NULL;
  }
  return p->u.array_buffer;
}

/* return NULL if exception. WARNING: any LEPUS call can detach the
   buffer and render the returned pointer invalid */
uint8_t *LEPUS_GetArrayBuffer(LEPUSContext *ctx, size_t *psize,
                              LEPUSValueConst obj) {
  CallGCFunc(JS_GetArrayBuffer_GC, ctx, psize, obj);
  JSArrayBuffer *abuf = js_get_array_buffer(ctx, obj);
  if (!abuf) goto fail;
  if (abuf->detached) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  *psize = abuf->byte_length;
  return abuf->data;
fail:
  *psize = 0;
  return NULL;
}

uint8_t *LEPUS_MoveArrayBuffer(LEPUSContext *ctx, size_t *psize,
                               LEPUSValueConst obj) {
  CallGCFunc(JS_MoveArrayBuffer_GC, ctx, psize, obj);
  auto *abuf = js_get_array_buffer(ctx, obj);
  void *ret = nullptr;
  if (!abuf) goto fail;
  if (abuf->detached) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  *psize = abuf->byte_length;
  ret = abuf->data;
  abuf->data = nullptr;
  abuf->byte_length = 0;
  LEPUS_DetachArrayBuffer(ctx, obj);
  return static_cast<uint8_t *>(ret);
fail:
  *psize = 0;
  return nullptr;
}

QJS_STATIC LEPUSValue js_array_buffer_slice(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv,
                                            int class_id) {
  JSArrayBuffer *abuf, *new_abuf;
  int64_t len, start, end, new_len;
  LEPUSValue ctor, new_obj;

  abuf =
      static_cast<JSArrayBuffer *>(LEPUS_GetOpaque2(ctx, this_val, class_id));
  if (!abuf) return LEPUS_EXCEPTION;
  if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  len = abuf->byte_length;

  if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
    return LEPUS_EXCEPTION;

  end = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt64Clamp(ctx, &end, argv[1], 0, len, len))
      return LEPUS_EXCEPTION;
  }
  new_len = max_int64(end - start, 0);
  ctor = JS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  if (LEPUS_IsUndefined(ctor)) {
    new_obj =
        js_array_buffer_constructor2(ctx, LEPUS_UNDEFINED, new_len, class_id);
  } else {
    LEPUSValue args[1];
    args[0] = LEPUS_NewInt64(ctx, new_len);
    new_obj = LEPUS_CallConstructor(ctx, ctor, 1, (LEPUSValueConst *)args);
    LEPUS_FreeValue(ctx, ctor);
    LEPUS_FreeValue(ctx, args[0]);
  }
  if (LEPUS_IsException(new_obj)) return new_obj;
  new_abuf =
      static_cast<JSArrayBuffer *>(LEPUS_GetOpaque2(ctx, new_obj, class_id));
  if (!new_abuf) goto fail;
  if (js_same_value(ctx, new_obj, this_val)) {
    LEPUS_ThrowTypeError(ctx, "cannot use identical ArrayBuffer");
    goto fail;
  }
  if (new_abuf->detached) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  if (new_abuf->byte_length < new_len) {
    LEPUS_ThrowTypeError(ctx, "new ArrayBuffer is too small");
    goto fail;
  }
  /* must test again because of side effects */
  if (abuf->detached) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  memcpy(new_abuf->data, abuf->data + start, new_len);
  return new_obj;
fail:
  LEPUS_FreeValue(ctx, new_obj);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry js_array_buffer_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("byteLength", js_array_buffer_get_byteLength, NULL,
                            JS_CLASS_ARRAY_BUFFER),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, js_array_buffer_slice,
                          JS_CLASS_ARRAY_BUFFER),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "ArrayBuffer",
                          LEPUS_PROP_CONFIGURABLE),
};

/* SharedArrayBuffer */

static const LEPUSCFunctionListEntry js_shared_array_buffer_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
};

static const LEPUSCFunctionListEntry js_shared_array_buffer_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("byteLength", js_array_buffer_get_byteLength, NULL,
                            JS_CLASS_SHARED_ARRAY_BUFFER),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, js_array_buffer_slice,
                          JS_CLASS_SHARED_ARRAY_BUFFER),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "SharedArrayBuffer",
                          LEPUS_PROP_CONFIGURABLE),
};

LEPUSObject *get_typed_array(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int is_dataview) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (is_dataview) {
    if (p->class_id != JS_CLASS_DATAVIEW) goto fail;
  } else {
    if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&
          p->class_id <= JS_CLASS_FLOAT64_ARRAY)) {
    fail:
      LEPUS_ThrowTypeError(ctx, "not a %s",
                           is_dataview ? "DataView" : "TypedArray");
      return NULL;
    }
  }
  return p;
}

/* WARNING: 'p' must be a typed array */
BOOL typed_array_is_detached(LEPUSContext *ctx, LEPUSObject *p) {
  JSTypedArray *ta = p->u.typed_array;
  JSArrayBuffer *abuf = ta->buffer->u.array_buffer;
  /* XXX: could simplify test by ensuring that
     p->u.array.u.ptr is NULL iff it is detached */
  return abuf->detached;
}

/* WARNING: 'p' must be a typed array. Works even if the array buffer
   is detached */
QJS_STATIC uint32_t typed_array_get_length(LEPUSContext *ctx, LEPUSObject *p) {
  JSTypedArray *ta = p->u.typed_array;
  int size_log2 = typed_array_size_log2(p->class_id);
  return ta->length >> size_log2;
}

QJS_STATIC int validate_typed_array(LEPUSContext *ctx,
                                    LEPUSValueConst this_val) {
  LEPUSObject *p;
  p = get_typed_array(ctx, this_val, 0);
  if (!p) return -1;
  if (typed_array_is_detached(ctx, p)) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    return -1;
  }
  return 0;
}

LEPUSValue js_typed_array_get_length(LEPUSContext *ctx,
                                     LEPUSValueConst this_val) {
  LEPUSObject *p;
  p = get_typed_array(ctx, this_val, 0);
  if (!p) return LEPUS_EXCEPTION;
  return LEPUS_NewInt32(ctx, p->u.array.count);
}

LEPUSValue js_typed_array_get_buffer(LEPUSContext *ctx,
                                     LEPUSValueConst this_val,
                                     int is_dataview) {
  LEPUSObject *p;
  JSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  ta = p->u.typed_array;
  LEPUSValue ret = LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer);
  if (!ctx->gc_enable) LEPUS_DupValue(ctx, ret);
  return ret;
}

LEPUSValue js_typed_array_get_byteLength(LEPUSContext *ctx,
                                         LEPUSValueConst this_val,
                                         int is_dataview) {
  LEPUSObject *p;
  JSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p)) {
    if (is_dataview) {
      return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
      return LEPUS_NewInt32(ctx, 0);
    }
  }
  ta = p->u.typed_array;
  return LEPUS_NewInt32(ctx, ta->length);
}

LEPUSValue js_typed_array_get_byteOffset(LEPUSContext *ctx,
                                         LEPUSValueConst this_val,
                                         int is_dataview) {
  LEPUSObject *p;
  JSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p)) {
    if (is_dataview) {
      return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
      return LEPUS_NewInt32(ctx, 0);
    }
  }
  ta = p->u.typed_array;
  return LEPUS_NewInt32(ctx, ta->offset);
}

QJS_STATIC LEPUSValue js_typed_array_get_toStringTag(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val)) return LEPUS_UNDEFINED;
  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (!(p->class_id >= JS_CLASS_UINT8C_ARRAY &&
        p->class_id <= JS_CLASS_FLOAT64_ARRAY))
    return LEPUS_UNDEFINED;
  return LEPUS_AtomToString(ctx, ctx->rt->class_array[p->class_id].class_name);
}

QJS_STATIC LEPUSValue js_typed_array_set_internal(LEPUSContext *ctx,
                                                  LEPUSValueConst dst,
                                                  LEPUSValueConst src,
                                                  LEPUSValueConst off) {
  LEPUSObject *p;
  LEPUSObject *src_p;
  uint32_t i;
  int64_t src_len, offset;
  LEPUSValue val, src_obj = LEPUS_UNDEFINED;

  p = get_typed_array(ctx, dst, 0);
  if (!p) goto fail;
  if (JS_ToInt64Sat(ctx, &offset, off)) goto fail;
  if (offset < 0) goto range_error;
  if (typed_array_is_detached(ctx, p)) {
  detached:
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  src_obj = LEPUS_ToObject(ctx, src);
  if (LEPUS_IsException(src_obj)) goto fail;
  src_p = LEPUS_VALUE_GET_OBJ(src_obj);
  if (src_p->class_id >= JS_CLASS_UINT8C_ARRAY &&
      src_p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
    JSTypedArray *dest_ta = p->u.typed_array;
    JSArrayBuffer *dest_abuf = dest_ta->buffer->u.array_buffer;
    JSTypedArray *src_ta = src_p->u.typed_array;
    JSArrayBuffer *src_abuf = src_ta->buffer->u.array_buffer;
    int shift = typed_array_size_log2(p->class_id);

    if (src_abuf->detached) goto detached;

    src_len = src_p->u.array.count;
    if (offset > (int64_t)(p->u.array.count - src_len)) goto range_error;

    /* copying between typed objects */
    if (src_p->class_id == p->class_id) {
      /* same type, use memmove */
      memmove(dest_abuf->data + dest_ta->offset + (offset << shift),
              src_abuf->data + src_ta->offset, src_len << shift);
      goto done;
    }
    if (dest_abuf->data == src_abuf->data) {
      /* copying between the same buffer using different types of mappings
         would require a temporary buffer */
    }
    /* otherwise, default behavior is slow but correct */
  } else {
    if (js_get_length64(ctx, &src_len, src_obj)) goto fail;
    if (offset > (int64_t)(p->u.array.count - src_len)) {
    range_error:
      LEPUS_ThrowRangeError(ctx, "invalid array length");
      goto fail;
    }
  }
  for (i = 0; i < src_len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, src_obj, i);
    if (LEPUS_IsException(val)) goto fail;
    if (LEPUS_SetPropertyUint32(ctx, dst, offset + i, val) < 0) goto fail;
  }
done:
  LEPUS_FreeValue(ctx, src_obj);
  return LEPUS_UNDEFINED;
fail:
  LEPUS_FreeValue(ctx, src_obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_set(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValueConst offset = LEPUS_UNDEFINED;
  if (argc > 1) {
    offset = argv[1];
  }
  return js_typed_array_set_internal(ctx, this_val, argv[0], offset);
}

QJS_STATIC LEPUSValue js_create_typed_array_iterator(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv,
                                                     int magic) {
  if (validate_typed_array(ctx, this_val)) return LEPUS_EXCEPTION;
  return js_create_array_iterator(ctx, this_val, argc, argv, magic);
}

/* return < 0 if exception */
QJS_STATIC int js_typed_array_get_length_internal(LEPUSContext *ctx,
                                                  LEPUSValueConst obj) {
  LEPUSObject *p;
  p = get_typed_array(ctx, obj, 0);
  if (!p) return -1;
  if (typed_array_is_detached(ctx, p)) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    return -1;
  }
  return p->u.array.count;
}

#if 0
/* validate a typed array and return its length */
static LEPUSValue js_typed_array___getLength(LEPUSContext *ctx,
                                          LEPUSValueConst this_val,
                                          int argc, LEPUSValueConst *argv)
{
    BOOL ignore_detached = LEPUS_ToBool(ctx, argv[1]);

    if (ignore_detached) {
        return js_typed_array_get_length(ctx, argv[0]);
    } else {
        int len;
        len = js_typed_array_get_length_internal(ctx, argv[0]);
        if (len < 0)
            return LEPUS_EXCEPTION;
        return LEPUS_NewInt32(ctx, len);
    }
}
#endif

QJS_STATIC LEPUSValue js_typed_array_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int classid);

QJS_STATIC LEPUSValue js_typed_array_create(LEPUSContext *ctx,
                                            LEPUSValueConst ctor, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue ret;
  int new_len;
  int64_t len;

  ret = LEPUS_CallConstructor(ctx, ctor, argc, argv);
  if (LEPUS_IsException(ret)) return ret;
  /* validate the typed array */
  new_len = js_typed_array_get_length_internal(ctx, ret);
  if (new_len < 0) goto fail;
  if (argc == 1) {
    /* ensure that it is large enough */
    if (JS_ToLengthFree(ctx, &len, LEPUS_DupValue(ctx, argv[0]))) goto fail;
    if (new_len < len) {
      LEPUS_ThrowTypeError(ctx, "TypedArray length is too small");
    fail:
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
  }
  return ret;
}

#if 0
static LEPUSValue js_typed_array___create(LEPUSContext *ctx,
                                       LEPUSValueConst this_val,
                                       int argc, LEPUSValueConst *argv)
{
    return js_typed_array_create(ctx, argv[0], max_int(argc - 1, 0), argv + 1);
}
#endif

QJS_STATIC LEPUSValue js_typed_array___speciesCreate(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  LEPUSObject *p;
  LEPUSValue ctor, ret;
  int argc1;

  obj = argv[0];
  p = get_typed_array(ctx, obj, 0);
  if (!p) return LEPUS_EXCEPTION;
  ctor = JS_SpeciesConstructor(ctx, obj, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  argc1 = max_int(argc - 1, 0);
  if (LEPUS_IsUndefined(ctor)) {
    ret = js_typed_array_constructor(ctx, LEPUS_UNDEFINED, argc1, argv + 1,
                                     p->class_id);
  } else {
    ret = js_typed_array_create(ctx, ctor, argc1, argv + 1);
    LEPUS_FreeValue(ctx, ctor);
  }
  return ret;
}

QJS_STATIC LEPUSValue js_typed_array_from(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  // from(items, mapfn = void 0, this_arg = void 0)
  LEPUSValueConst items = argv[0], mapfn, this_arg;
  LEPUSValueConst args[2];
  LEPUSValue stack[2];
  LEPUSValue iter, arr, r, v, v2;
  int64_t k, len;
  int done, mapping;

  mapping = FALSE;
  mapfn = LEPUS_UNDEFINED;
  this_arg = LEPUS_UNDEFINED;
  r = LEPUS_UNDEFINED;
  arr = LEPUS_UNDEFINED;
  stack[0] = LEPUS_UNDEFINED;
  stack[1] = LEPUS_UNDEFINED;

  if (argc > 1) {
    mapfn = argv[1];
    if (!LEPUS_IsUndefined(mapfn)) {
      if (check_function(ctx, mapfn)) goto exception;
      mapping = 1;
      if (argc > 2) this_arg = argv[2];
    }
  }
  iter =
      JS_GetPropertyInternal_RC(ctx, items, JS_ATOM_Symbol_iterator, items, 0);
  if (LEPUS_IsException(iter)) goto exception;
  if (!LEPUS_IsUndefined(iter)) {
    LEPUS_FreeValue(ctx, iter);
    arr = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(arr)) goto exception;
    stack[0] = LEPUS_DupValue(ctx, items);
    if (js_for_of_start(ctx, &stack[1], FALSE)) goto exception;
    for (k = 0;; k++) {
      v = JS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
      if (LEPUS_IsException(v)) goto exception_close;
      if (done) break;
      if (JS_DefinePropertyValueInt64(ctx, arr, k, v,
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception_close;
    }
  } else {
    arr = LEPUS_ToObject(ctx, items);
    if (LEPUS_IsException(arr)) goto exception;
  }
  if (js_get_length64(ctx, &len, arr) < 0) goto exception;
  v = LEPUS_NewInt64(ctx, len);
  args[0] = v;
  r = js_typed_array_create(ctx, this_val, 1, args);
  LEPUS_FreeValue(ctx, v);
  if (LEPUS_IsException(r)) goto exception;
  for (k = 0; k < len; k++) {
    v = JS_GetPropertyInt64(ctx, arr, k);
    if (LEPUS_IsException(v)) goto exception;
    if (mapping) {
      args[0] = v;
      args[1] = LEPUS_NewInt32(ctx, k);
      v2 = JS_Call_RC(ctx, mapfn, this_arg, 2, args);
      LEPUS_FreeValue(ctx, v);
      v = v2;
      if (LEPUS_IsException(v)) goto exception;
    }
    if (LEPUS_SetPropertyInt64(ctx, r, k, v) < 0) goto exception;
  }
  goto done;

exception_close:
  if (!LEPUS_IsUndefined(stack[0])) JS_IteratorClose(ctx, stack[0], TRUE);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, stack[0]);
  LEPUS_FreeValue(ctx, stack[1]);
  return r;
}

QJS_STATIC LEPUSValue js_typed_array_of(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSValueConst args[1];
  int i;

  args[0] = LEPUS_NewInt32(ctx, argc);
  obj = js_typed_array_create(ctx, this_val, 1, args);
  if (LEPUS_IsException(obj)) return obj;

  for (i = 0; i < argc; i++) {
    if (LEPUS_SetPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, argv[i])) <
        0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue js_typed_array_copyWithin(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, to, from, final, count, shift;

  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;

  if (JS_ToInt32Clamp(ctx, &to, argv[0], 0, len, len)) return LEPUS_EXCEPTION;

  if (JS_ToInt32Clamp(ctx, &from, argv[1], 0, len, len)) return LEPUS_EXCEPTION;

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
      return LEPUS_EXCEPTION;
  }

  count = min_int(final - from, len - to);
  if (count > 0) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    if (typed_array_is_detached(ctx, p))
      return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    shift = typed_array_size_log2(p->class_id);
    memmove(p->u.array.u.uint8_ptr + (to << shift),
            p->u.array.u.uint8_ptr + (from << shift), count << shift);
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_typed_array_fill(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, k, final, shift;
  uint64_t v64;

  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(this_val);

  if (p->class_id == JS_CLASS_UINT8C_ARRAY) {
    int32_t v;
    if (JS_ToUint8ClampFree(ctx, &v, LEPUS_DupValue(ctx, argv[0])))
      return LEPUS_EXCEPTION;
    v64 = v;
  } else if (p->class_id <= JS_CLASS_UINT32_ARRAY) {
    uint32_t v;
    if (LEPUS_ToUint32(ctx, &v, argv[0])) return LEPUS_EXCEPTION;
    v64 = v;
  } else
#ifdef CONFIG_BIGNUM
      if (p->class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
    if (LEPUS_ToBigInt64(ctx, (int64_t *)&v64, argv[0])) return LEPUS_EXCEPTION;
  } else
#endif
  {
    double d;
    if (LEPUS_ToFloat64(ctx, &d, argv[0])) return LEPUS_EXCEPTION;
    if (p->class_id == JS_CLASS_FLOAT32_ARRAY) {
      union {
        float f;
        uint32_t u32;
      } u;
      u.f = d;
      v64 = u.u32;
    } else {
      JSFloat64Union u;
      u.d = d;
      v64 = u.u64;
    }
  }

  k = 0;
  if (argc > 1) {
    if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len)) return LEPUS_EXCEPTION;
  }

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (JS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
      return LEPUS_EXCEPTION;
  }

  if (typed_array_is_detached(ctx, p))
    return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  shift = typed_array_size_log2(p->class_id);
  switch (shift) {
    case 0:
      if (k < final) {
        memset(p->u.array.u.uint8_ptr + k, v64, final - k);
      }
      break;
    case 1:
      for (; k < final; k++) {
        p->u.array.u.uint16_ptr[k] = v64;
      }
      break;
    case 2:
      for (; k < final; k++) {
        p->u.array.u.uint32_ptr[k] = v64;
      }
      break;
    case 3:
      for (; k < final; k++) {
        p->u.array.u.uint64_ptr[k] = v64;
      }
      break;
    default:
      abort();
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_typed_array_find(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv,
                                          int findIndex) {
  LEPUSValueConst func, this_arg;
  LEPUSValueConst args[3];
  LEPUSValue val, index_val, res;
  int len, k;

  val = LEPUS_UNDEFINED;
  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;

  func = argv[0];
  if (check_function(ctx, func)) goto exception;

  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  for (k = 0; k < len; k++) {
    index_val = LEPUS_NewInt32(ctx, k);
    val = JS_GetPropertyValue(ctx, this_val, index_val);
    if (LEPUS_IsException(val)) goto exception;
    args[0] = val;
    args[1] = index_val;
    args[2] = this_val;
    res = JS_Call_RC(ctx, func, this_arg, 3, args);
    if (LEPUS_IsException(res)) goto exception;
    if (JS_ToBoolFree_RC(ctx, res)) {
      if (findIndex) {
        LEPUS_FreeValue(ctx, val);
        return index_val;
      } else {
        return val;
      }
    }
    LEPUS_FreeValue(ctx, val);
  }
  if (findIndex)
    return LEPUS_NewInt32(ctx, -1);
  else
    return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

#define special_indexOf 0
#define special_lastIndexOf 1
#define special_includes -1

QJS_STATIC LEPUSValue js_typed_array_indexOf(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int special) {
  LEPUSObject *p;
  int len, is_int, is_big, k, stop, inc, res = -1;
  int64_t tag;
  int64_t v64;
  double d;
  float f;

  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;
  if (len == 0) goto done;

  if (special == special_lastIndexOf) {
    k = len - 1;
    if (argc > 1) {
      if (LEPUS_ToFloat64(ctx, &d, argv[1])) goto exception;
      // need convert (double)d to int.
      d = DoubleToInteger(d);
      if (d >= 0) {
        if (d < k) {
          k = d;
        }
      } else {
        d += len;
        if (d < 0) goto done;
        k = d;
      }
    }
    stop = -1;
    inc = -1;
  } else {
    k = 0;
    if (argc > 1) {
      if (JS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len)) goto exception;
    }
    stop = len;
    inc = 1;
  }

  p = LEPUS_VALUE_GET_OBJ(this_val);
  /* if the array was detached, no need to go further (but no
     exception is raised) */
  if (typed_array_is_detached(ctx, p)) {
    /* "includes" scans all the properties, so "undefined" can match */
    if (special == special_includes && LEPUS_IsUndefined(argv[0]) && len > 0)
      res = 0;
    goto done;
  }

  is_big = 0;
  is_int = 0; /* avoid warning */
  v64 = 0;    /* avoid warning */
  tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
  if (tag == LEPUS_TAG_INT) {
    is_int = 1;
    v64 = LEPUS_VALUE_GET_INT(argv[0]);
    d = v64;
  } else if (tag == LEPUS_TAG_FLOAT64) {
    d = LEPUS_VALUE_GET_FLOAT64(argv[0]);
    v64 = d;
    is_int = (v64 == d);
  } else
#ifdef CONFIG_BIGNUM
      if (tag == LEPUS_TAG_BIG_INT || tag == LEPUS_TAG_BIG_FLOAT) {
    /* will a generic loop for bigint and bigfloat */
    /* XXX: should use the generic loop in math_mode? */
    is_big = 1;
  } else
#endif
  {
    goto done;
  }

  p = LEPUS_VALUE_GET_OBJ(this_val);
  switch (p->class_id) {
    case JS_CLASS_INT8_ARRAY:
      if (is_int && (int8_t)v64 == v64) goto scan8;
      break;
    case JS_CLASS_UINT8C_ARRAY:
    case JS_CLASS_UINT8_ARRAY:
      if (is_int && (uint8_t)v64 == v64) {
        const uint8_t *pv, *pp;
        uint16_t v;
      scan8:
        pv = p->u.array.u.uint8_ptr;
        v = v64;
        if (inc > 0) {
          pp = static_cast<const uint8_t *>(memchr(pv + k, v, len - k));
          if (pp) res = pp - pv;
        } else {
          for (; k != stop; k += inc) {
            if (pv[k] == v) {
              res = k;
              break;
            }
          }
        }
      }
      break;
    case JS_CLASS_INT16_ARRAY:
      if (is_int && (int16_t)v64 == v64) goto scan16;
      break;
    case JS_CLASS_UINT16_ARRAY:
      if (is_int && (uint16_t)v64 == v64) {
        const uint16_t *pv;
        uint16_t v;
      scan16:
        pv = p->u.array.u.uint16_ptr;
        v = v64;
        for (; k != stop; k += inc) {
          if (pv[k] == v) {
            res = k;
            break;
          }
        }
      }
      break;
    case JS_CLASS_INT32_ARRAY:
      if (is_int && (int32_t)v64 == v64) goto scan32;
      break;
    case JS_CLASS_UINT32_ARRAY:
      if (is_int && (uint32_t)v64 == v64) {
        const uint32_t *pv;
        uint32_t v;
      scan32:
        pv = p->u.array.u.uint32_ptr;
        v = v64;
        for (; k != stop; k += inc) {
          if (pv[k] == v) {
            res = k;
            break;
          }
        }
      }
      break;
    case JS_CLASS_FLOAT32_ARRAY:
      if (is_big) break;
      if (isnan(d)) {
        const float *pv = p->u.array.u.float_ptr;
        /* special case: indexOf returns -1, includes finds NaN */
        if (special != special_includes) goto done;
        for (; k != stop; k += inc) {
          if (isnan(pv[k])) {
            res = k;
            break;
          }
        }
      } else if ((f = (float)d) == d) {
        const float *pv = p->u.array.u.float_ptr;
        for (; k != stop; k += inc) {
          if (pv[k] == f) {
            res = k;
            break;
          }
        }
      }
      break;
    case JS_CLASS_FLOAT64_ARRAY:
      if (is_big) break;
      if (isnan(d)) {
        const double *pv = p->u.array.u.double_ptr;
        /* special case: indexOf returns -1, includes finds NaN */
        if (special != special_includes) goto done;
        for (; k != stop; k += inc) {
          if (isnan(pv[k])) {
            res = k;
            break;
          }
        }
      } else {
        const double *pv = p->u.array.u.double_ptr;
        for (; k != stop; k += inc) {
          if (pv[k] == d) {
            res = k;
            break;
          }
        }
      }
      break;
#ifdef CONFIG_BIGNUM
    case JS_CLASS_BIG_INT64_ARRAY:
    case JS_CLASS_BIG_UINT64_ARRAY:
      if (is_big || is_strict_mode(ctx)) {
        /* generic loop for bignums, argv[0] is a bignum != NaN */
        /* XXX: optimize with explicit values */
        for (; k != stop; k += inc) {
          LEPUSValue v = LEPUS_GetPropertyUint32(ctx, this_val, k);
          int ret;
          if (LEPUS_IsException(v)) goto exception;
          ret = js_same_value_zero(ctx, v, argv[0]);
          LEPUS_FreeValue(ctx, v);
          if (ret) {
            if (ret < 0) goto exception;
            res = k;
            break;
          }
        }
      }
      break;
#endif
  }

done:
  if (special == special_includes)
    return LEPUS_NewBool(ctx, res >= 0);
  else
    return LEPUS_NewInt32(ctx, res);

exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_join(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv,
                                          int toLocaleString) {
  LEPUSValue sep = LEPUS_UNDEFINED, el;
  StringBuffer b_s, *b = &b_s;
  JSString *p = NULL;
  int i, n;
  int c;

  n = js_typed_array_get_length_internal(ctx, this_val);
  if (n < 0) goto exception;

  c = ','; /* default separator */
  if (!toLocaleString && argc > 0 && !LEPUS_IsUndefined(argv[0])) {
    sep = JS_ToString_RC(ctx, argv[0]);
    if (LEPUS_IsException(sep)) goto exception;
    p = LEPUS_VALUE_GET_STRING(sep);
    if (p->len == 1 && !p->is_wide_char)
      c = p->u.str8[0];
    else
      c = -1;
  }
  string_buffer_init(ctx, b, 0);

  /* XXX: optimize with direct access */
  for (i = 0; i < n; i++) {
    if (i > 0) {
      if (c >= 0) {
        if (string_buffer_putc8(b, c)) goto fail;
      } else {
        if (string_buffer_concat(b, p, 0, p->len)) goto fail;
      }
    }
    el = LEPUS_GetPropertyUint32(ctx, this_val, i);
    /* Can return undefined for example if the typed array is detached */
    if (!LEPUS_IsNull(el) && !LEPUS_IsUndefined(el)) {
      if (LEPUS_IsException(el)) goto fail;
      if (toLocaleString) {
        el = JS_ToLocaleStringFree(ctx, el);
      }
      if (string_buffer_concat_value_free(b, el)) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, sep);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, sep);
exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_reverse(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len;

  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  if (len > 0) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    switch (typed_array_size_log2(p->class_id)) {
      case 0: {
        uint8_t *p1 = p->u.array.u.uint8_ptr;
        uint8_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint8_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 1: {
        uint16_t *p1 = p->u.array.u.uint16_ptr;
        uint16_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint16_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 2: {
        uint32_t *p1 = p->u.array.u.uint32_ptr;
        uint32_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint32_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 3: {
        uint64_t *p1 = p->u.array.u.uint64_ptr;
        uint64_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint64_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      default:
        abort();
    }
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue js_typed_array_slice(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValueConst args[2];
  LEPUSValue arr, val;
  LEPUSObject *p, *p1;
  int n, len, start, final, count, shift;

  arr = LEPUS_UNDEFINED;
  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;

  if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;
  final = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
  }
  count = max_int(final - start, 0);

  p = get_typed_array(ctx, this_val, 0);
  if (p == NULL) goto exception;
  shift = typed_array_size_log2(p->class_id);

  args[0] = this_val;
  args[1] = LEPUS_NewInt32(ctx, count);
  arr = js_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
  if (LEPUS_IsException(arr)) goto exception;

  if (count > 0) {
    if (validate_typed_array(ctx, this_val) || validate_typed_array(ctx, arr))
      goto exception;

    p1 = get_typed_array(ctx, arr, 0);
    if (p1 != NULL && p->class_id == p1->class_id &&
        typed_array_get_length(ctx, p1) >= count &&
        typed_array_get_length(ctx, p) >= start + count) {
      memmove(p1->u.array.u.uint8_ptr,
              p->u.array.u.uint8_ptr + (start << shift), count << shift);
    } else {
      for (n = 0; n < count; n++) {
        val =
            JS_GetPropertyValue(ctx, this_val, LEPUS_NewInt32(ctx, start + n));
        if (LEPUS_IsException(val)) goto exception;
        if (JS_SetPropertyValue(ctx, arr, LEPUS_NewInt32(ctx, n), val,
                                LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
  }
  return arr;

exception:
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_subarray(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValueConst args[4];
  LEPUSValue arr, byteOffset, ta_buffer;
  LEPUSObject *p;
  int len, start, final, count, shift, offset;

  p = get_typed_array(ctx, this_val, 0);
  if (!p) goto exception;
  len = p->u.array.count;
  if (JS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;

  final = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (JS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
  }
  count = max_int(final - start, 0);
  byteOffset = js_typed_array_get_byteOffset(ctx, this_val, 0);
  if (LEPUS_IsException(byteOffset)) goto exception;
  shift = typed_array_size_log2(p->class_id);
  offset = LEPUS_VALUE_GET_INT(byteOffset) + (start << shift);
  LEPUS_FreeValue(ctx, byteOffset);
  ta_buffer = js_typed_array_get_buffer(ctx, this_val, 0);
  if (LEPUS_IsException(ta_buffer)) goto exception;
  args[0] = this_val;
  args[1] = ta_buffer;
  args[2] = LEPUS_NewInt32(ctx, offset);
  args[3] = LEPUS_NewInt32(ctx, count);
  arr = js_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 4, args);
  LEPUS_FreeValue(ctx, ta_buffer);
  return arr;

exception:
  return LEPUS_EXCEPTION;
}

/* TypedArray.prototype.sort */

QJS_STATIC int js_cmp_doubles(double x, double y) {
  if (isnan(x)) return isnan(y) ? 0 : +1;
  if (isnan(y)) return -1;
  if (x < y) return -1;
  if (x > y) return 1;
  if (x != 0) return 0;
  if (signbit(x))
    return signbit(y) ? 0 : -1;
  else
    return signbit(y) ? -1 : 0;
}

QJS_STATIC int js_TA_cmp_int8(const void *a, const void *b, void *opaque) {
  return *(const int8_t *)a - *(const int8_t *)b;
}

QJS_STATIC int js_TA_cmp_uint8(const void *a, const void *b, void *opaque) {
  return *(const uint8_t *)a - *(const uint8_t *)b;
}

QJS_STATIC int js_TA_cmp_int16(const void *a, const void *b, void *opaque) {
  return *(const int16_t *)a - *(const int16_t *)b;
}

QJS_STATIC int js_TA_cmp_uint16(const void *a, const void *b, void *opaque) {
  return *(const uint16_t *)a - *(const uint16_t *)b;
}

QJS_STATIC int js_TA_cmp_int32(const void *a, const void *b, void *opaque) {
  int32_t x = *(const int32_t *)a;
  int32_t y = *(const int32_t *)b;
  return (y < x) - (y > x);
}

QJS_STATIC int js_TA_cmp_uint32(const void *a, const void *b, void *opaque) {
  uint32_t x = *(const uint32_t *)a;
  uint32_t y = *(const uint32_t *)b;
  return (y < x) - (y > x);
}

#ifdef CONFIG_BIGNUM
static int js_TA_cmp_int64(const void *a, const void *b, void *opaque) {
  int64_t x = *(const int64_t *)a;
  int64_t y = *(const int64_t *)b;
  return (y < x) - (y > x);
}

static int js_TA_cmp_uint64(const void *a, const void *b, void *opaque) {
  uint64_t x = *(const uint64_t *)a;
  uint64_t y = *(const uint64_t *)b;
  return (y < x) - (y > x);
}
#endif

QJS_STATIC int js_TA_cmp_float32(const void *a, const void *b, void *opaque) {
  return js_cmp_doubles(*(const float *)a, *(const float *)b);
}

QJS_STATIC int js_TA_cmp_float64(const void *a, const void *b, void *opaque) {
  return js_cmp_doubles(*(const double *)a, *(const double *)b);
}

QJS_STATIC LEPUSValue js_TA_get_int8(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int8_t *)a);
}

QJS_STATIC LEPUSValue js_TA_get_uint8(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const uint8_t *)a);
}

QJS_STATIC LEPUSValue js_TA_get_int16(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int16_t *)a);
}

QJS_STATIC LEPUSValue js_TA_get_uint16(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const uint16_t *)a);
}

QJS_STATIC LEPUSValue js_TA_get_int32(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int32_t *)a);
}

QJS_STATIC LEPUSValue js_TA_get_uint32(LEPUSContext *ctx, const void *a) {
  return JS_NewUint32(ctx, *(const uint32_t *)a);
}

#ifdef CONFIG_BIGNUM
static LEPUSValue js_TA_get_int64(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewBigInt64(ctx, *(int64_t *)a);
}

static LEPUSValue js_TA_get_uint64(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewBigUint64(ctx, *(uint64_t *)a);
}
#endif

QJS_STATIC LEPUSValue js_TA_get_float32(LEPUSContext *ctx, const void *a) {
  return __JS_NewFloat64(ctx, *(const float *)a);
}

QJS_STATIC LEPUSValue js_TA_get_float64(LEPUSContext *ctx, const void *a) {
  return __JS_NewFloat64(ctx, *(const double *)a);
}

struct TA_sort_context {
  LEPUSContext *ctx;
  int exception;
  LEPUSValueConst arr;
  LEPUSValueConst cmp;
  LEPUSValue (*getfun)(LEPUSContext *ctx, const void *a);
  int (*cmpfun)(const void *a, const void *b, void *opaque);
  uint8_t *array_ptr;
  int elt_size;
};

QJS_STATIC int js_TA_cmp_generic(const void *a, const void *b, void *opaque) {
  struct TA_sort_context *psc = static_cast<struct TA_sort_context *>(opaque);
  LEPUSContext *ctx = psc->ctx;
  uint32_t a_idx, b_idx;
  LEPUSValueConst argv[2];
  LEPUSValue res;
  int cmp;

  cmp = 0;
  if (!psc->exception) {
    a_idx = *(uint32_t *)a;
    b_idx = *(uint32_t *)b;
    argv[0] = psc->getfun(ctx, psc->array_ptr + a_idx * (size_t)psc->elt_size);
    argv[1] =
        psc->getfun(ctx, psc->array_ptr + b_idx * (size_t)(psc->elt_size));
    res = JS_Call_RC(ctx, psc->cmp, LEPUS_UNDEFINED, 2, argv);
    if (LEPUS_IsException(res)) {
      psc->exception = 1;
      goto done;
    }
    if (LEPUS_VALUE_IS_INT(res)) {
      int val = LEPUS_VALUE_GET_INT(res);
      cmp = (val > 0) - (val < 0);
    } else {
      double val;
      if (JS_ToFloat64Free(ctx, &val, res) < 0) {
        psc->exception = 1;
        goto done;
      } else {
        cmp = (val > 0) - (val < 0);
      }
    }
    if (cmp == 0) {
      /* make sort stable: compare array offsets */
      cmp = (a_idx > b_idx) - (a_idx < b_idx);
    }
    if (validate_typed_array(ctx, psc->arr) < 0) {
      psc->exception = 1;
    }
  done:
    LEPUS_FreeValue(ctx, (LEPUSValue)argv[0]);
    LEPUS_FreeValue(ctx, (LEPUSValue)argv[1]);
  }
  return cmp;
}

QJS_STATIC LEPUSValue js_typed_array_sort(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, elt_size;
  struct TA_sort_context tsc;
  void *array_ptr, *array_copy = NULL, *array_org;
  int (*cmpfun)(const void *a, const void *b, void *opaque);

  tsc.ctx = ctx;
  tsc.exception = 0;
  tsc.arr = this_val;
  tsc.cmp = argv[0];

  len = js_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  if (!LEPUS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))
    return LEPUS_EXCEPTION;

  if (len > 1) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    switch (p->class_id) {
      case JS_CLASS_INT8_ARRAY:
        tsc.getfun = js_TA_get_int8;
        tsc.cmpfun = js_TA_cmp_int8;
        break;
      case JS_CLASS_UINT8C_ARRAY:
      case JS_CLASS_UINT8_ARRAY:
        tsc.getfun = js_TA_get_uint8;
        tsc.cmpfun = js_TA_cmp_uint8;
        break;
      case JS_CLASS_INT16_ARRAY:
        tsc.getfun = js_TA_get_int16;
        tsc.cmpfun = js_TA_cmp_int16;
        break;
      case JS_CLASS_UINT16_ARRAY:
        tsc.getfun = js_TA_get_uint16;
        tsc.cmpfun = js_TA_cmp_uint16;
        break;
      case JS_CLASS_INT32_ARRAY:
        tsc.getfun = js_TA_get_int32;
        tsc.cmpfun = js_TA_cmp_int32;
        break;
      case JS_CLASS_UINT32_ARRAY:
        tsc.getfun = js_TA_get_uint32;
        tsc.cmpfun = js_TA_cmp_uint32;
        break;
#ifdef CONFIG_BIGNUM
      case JS_CLASS_BIG_INT64_ARRAY:
        tsc.getfun = js_TA_get_int64;
        tsc.cmpfun = js_TA_cmp_int64;
        break;
      case JS_CLASS_BIG_UINT64_ARRAY:
        tsc.getfun = js_TA_get_uint64;
        tsc.cmpfun = js_TA_cmp_uint64;
        break;
#endif
      case JS_CLASS_FLOAT32_ARRAY:
        tsc.getfun = js_TA_get_float32;
        tsc.cmpfun = js_TA_cmp_float32;
        break;
      case JS_CLASS_FLOAT64_ARRAY:
        tsc.getfun = js_TA_get_float64;
        tsc.cmpfun = js_TA_cmp_float64;
        break;
      default:
        abort();
    }
    array_ptr = array_org = p->u.array.u.ptr;
    elt_size = 1 << typed_array_size_log2(p->class_id);
    cmpfun = tsc.cmpfun;
    if (!LEPUS_IsUndefined(tsc.cmp)) {
      uint32_t *array_idx;
      void *array_tmp;
      size_t i, j;

      /* XXX: a stable sort would use less memory */
      array_idx = static_cast<uint32_t *>(
          lepus_malloc(ctx, len * sizeof(array_idx[0])));
      if (!array_idx) return LEPUS_EXCEPTION;
      for (i = 0; i < len; i++) array_idx[i] = i;
      tsc.array_ptr = static_cast<uint8_t *>(array_ptr);
      tsc.elt_size = elt_size;
      rqsort(array_idx, len, sizeof(array_idx[0]), js_TA_cmp_generic, &tsc);
      if (tsc.exception) goto fail;
      array_tmp = lepus_malloc(ctx, len * elt_size);
      if (!array_tmp) {
      fail:
        lepus_free(ctx, array_idx);
        return LEPUS_EXCEPTION;
      }
      memcpy(array_tmp, array_ptr, len * elt_size);
      switch (elt_size) {
        case 1:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];
          }
          break;
        case 2:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];
          }
          break;
        case 4:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];
          }
          break;
        case 8:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];
          }
          break;
        default:
          abort();
      }
      lepus_free(ctx, array_tmp);
      lepus_free(ctx, array_idx);
    } else {
      rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
      if (tsc.exception) {
        return LEPUS_EXCEPTION;
      }
    }
  }
  return LEPUS_DupValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry js_typed_array_base_funcs[] = {
    LEPUS_CFUNC_DEF("from", 1, js_typed_array_from),
    LEPUS_CFUNC_DEF("of", 0, js_typed_array_of),
    LEPUS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
    // LEPUS_CFUNC_DEF("__getLength", 2, js_typed_array___getLength ),
    // LEPUS_CFUNC_DEF("__create", 2, js_typed_array___create ),
    // LEPUS_CFUNC_DEF("__speciesCreate", 2, js_typed_array___speciesCreate
    // ),
};

static const LEPUSCFunctionListEntry js_typed_array_base_proto_funcs[] = {
    LEPUS_CGETSET_DEF("length", js_typed_array_get_length, NULL),
    LEPUS_CGETSET_MAGIC_DEF("buffer", js_typed_array_get_buffer, NULL, 0),
    LEPUS_CGETSET_MAGIC_DEF("byteLength", js_typed_array_get_byteLength, NULL,
                            0),
    LEPUS_CGETSET_MAGIC_DEF("byteOffset", js_typed_array_get_byteOffset, NULL,
                            0),
    LEPUS_CFUNC_DEF("set", 1, js_typed_array_set),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, js_create_typed_array_iterator,
                          JS_ITERATOR_KIND_VALUE),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, js_create_typed_array_iterator,
                          JS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, js_create_typed_array_iterator,
                          JS_ITERATOR_KIND_KEY_AND_VALUE),
    LEPUS_CGETSET_DEF("[Symbol.toStringTag]", js_typed_array_get_toStringTag,
                      NULL),
    LEPUS_CFUNC_DEF("copyWithin", 2, js_typed_array_copyWithin),
    LEPUS_CFUNC_MAGIC_DEF("every", 1, js_array_every,
                          special_every | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, js_array_every,
                          special_forEach | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("map", 1, js_array_every, special_map | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("filter", 1, js_array_every,
                          special_filter | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce,
                          special_reduce | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce,
                          special_reduceRight | special_TA),
    LEPUS_CFUNC_DEF("fill", 1, js_typed_array_fill),
    LEPUS_CFUNC_MAGIC_DEF("find", 1, js_typed_array_find, 0),
    LEPUS_CFUNC_MAGIC_DEF("findIndex", 1, js_typed_array_find, 1),
    LEPUS_CFUNC_DEF("reverse", 0, js_typed_array_reverse),
    LEPUS_CFUNC_DEF("slice", 2, js_typed_array_slice),
    LEPUS_CFUNC_DEF("subarray", 2, js_typed_array_subarray),
    LEPUS_CFUNC_DEF("sort", 1, js_typed_array_sort),
    LEPUS_CFUNC_MAGIC_DEF("join", 1, js_typed_array_join, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_typed_array_join, 1),
    LEPUS_CFUNC_MAGIC_DEF("indexOf", 1, js_typed_array_indexOf,
                          special_indexOf),
    LEPUS_CFUNC_MAGIC_DEF("lastIndexOf", 1, js_typed_array_indexOf,
                          special_lastIndexOf),
    LEPUS_CFUNC_MAGIC_DEF("includes", 1, js_typed_array_indexOf,
                          special_includes),
    // LEPUS_ALIAS_BASE_DEF("toString", "toString", 2 /* Array.prototype. */),
    // @@@
};

QJS_STATIC LEPUSValue js_typed_array_base_constructor(LEPUSContext *ctx,
                                                      LEPUSValueConst this_val,
                                                      int argc,
                                                      LEPUSValueConst *argv) {
  return LEPUS_ThrowTypeError(ctx, "cannot be called");
}

/* 'obj' must be an allocated typed array object */
QJS_STATIC int typed_array_init(LEPUSContext *ctx, LEPUSValueConst obj,
                                LEPUSValue buffer, uint64_t offset,
                                uint64_t len) {
  JSTypedArray *ta;
  LEPUSObject *p, *pbuffer;
  JSArrayBuffer *abuf;
  int size_log2;

  p = LEPUS_VALUE_GET_OBJ(obj);
  size_log2 = typed_array_size_log2(p->class_id);
  ta = static_cast<JSTypedArray *>(lepus_malloc(ctx, sizeof(*ta)));
  if (!ta) {
    LEPUS_FreeValue(ctx, buffer);
    return -1;
  }
  pbuffer = LEPUS_VALUE_GET_OBJ(buffer);
  abuf = pbuffer->u.array_buffer;
  ta->obj = p;
  ta->buffer = pbuffer;
  ta->offset = offset;
  ta->length = len << size_log2;
  list_add_tail(&ta->link, &abuf->array_list);
  p->u.typed_array = ta;
  p->u.array.count = len;
  p->u.array.u.ptr = abuf->data + offset;
  return 0;
}

QJS_STATIC LEPUSValue js_array_from_iterator(LEPUSContext *ctx, uint32_t *plen,
                                             LEPUSValueConst obj,
                                             LEPUSValueConst method) {
  LEPUSValue arr, iter, next_method = LEPUS_UNDEFINED, val;
  BOOL done;
  uint32_t k;

  *plen = 0;
  arr = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(arr)) return arr;
  iter = JS_GetIterator2(ctx, obj, method);
  if (LEPUS_IsException(iter)) goto fail;
  next_method = JS_GetPropertyInternal_RC(ctx, iter, JS_ATOM_next, iter, 0);
  if (LEPUS_IsException(next_method)) goto fail;
  k = 0;
  for (;;) {
    val = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(val)) goto fail;
    if (done) {
      LEPUS_FreeValue(ctx, val);
      break;
    }
    if (JS_CreateDataPropertyUint32(ctx, arr, k, val, LEPUS_PROP_THROW) < 0)
      goto fail;
    k++;
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  *plen = k;
  return arr;
fail:
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_constructor_obj(LEPUSContext *ctx,
                                                     LEPUSValueConst new_target,
                                                     LEPUSValueConst obj,
                                                     int classid) {
  LEPUSValue iter, ret, arr = LEPUS_UNDEFINED, val, buffer;
  uint32_t i;
  int size_log2;
  int64_t len;

  size_log2 = typed_array_size_log2(classid);
  ret = js_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(ret)) return LEPUS_EXCEPTION;

  iter = JS_GetPropertyInternal_RC(ctx, obj, JS_ATOM_Symbol_iterator, obj, 0);
  if (LEPUS_IsException(iter)) goto fail;
  if (!LEPUS_IsUndefined(iter) && !LEPUS_IsNull(iter)) {
    uint32_t len1;
    arr = js_array_from_iterator(ctx, &len1, obj, iter);
    LEPUS_FreeValue(ctx, iter);
    if (LEPUS_IsException(arr)) goto fail;
    len = len1;
  } else {
    if (js_get_length64(ctx, &len, obj)) goto fail;
    arr = LEPUS_DupValue(ctx, obj);
  }

  buffer = js_array_buffer_constructor1(ctx, LEPUS_UNDEFINED, len << size_log2);
  if (LEPUS_IsException(buffer)) goto fail;
  if (typed_array_init(ctx, ret, buffer, 0, len)) goto fail;

  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, arr, i);
    if (LEPUS_IsException(val)) goto fail;
    if (LEPUS_SetPropertyUint32(ctx, ret, i, val) < 0) goto fail;
  }
  LEPUS_FreeValue(ctx, arr);
  return ret;
fail:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, ret);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_constructor_ta(LEPUSContext *ctx,
                                                    LEPUSValueConst new_target,
                                                    LEPUSValueConst src_obj,
                                                    int classid) {
  LEPUSObject *p, *src_buffer;
  JSTypedArray *ta;
  LEPUSValue ctor, obj, buffer;
  uint32_t len, i;
  int size_log2;
  JSArrayBuffer *src_abuf, *abuf;

  obj = js_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(obj)) return obj;
  p = LEPUS_VALUE_GET_OBJ(src_obj);
  if (typed_array_is_detached(ctx, p)) {
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  ta = p->u.typed_array;
  len = p->u.array.count;
  src_buffer = ta->buffer;
  src_abuf = src_buffer->u.array_buffer;
  if (!src_abuf->shared) {
    ctor = JS_SpeciesConstructor(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, src_buffer),
                                 LEPUS_UNDEFINED);
    if (LEPUS_IsException(ctor)) goto fail;
  } else {
    /* force ArrayBuffer default constructor */
    ctor = LEPUS_UNDEFINED;
  }
  size_log2 = typed_array_size_log2(classid);
  buffer = js_array_buffer_constructor1(ctx, ctor, (uint64_t)len << size_log2);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(buffer)) goto fail;
  /* necessary because it could have been detached */
  if (typed_array_is_detached(ctx, p)) {
    LEPUS_FreeValue(ctx, buffer);
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  abuf = static_cast<JSArrayBuffer *>(
      LEPUS_GetOpaque(buffer, JS_CLASS_ARRAY_BUFFER));
  if (typed_array_init(ctx, obj, buffer, 0, len)) goto fail;
  if (p->class_id == classid) {
    /* same type: copy the content */
    memcpy(abuf->data, src_abuf->data + ta->offset, abuf->byte_length);
  } else {
    for (i = 0; i < len; i++) {
      LEPUSValue val;
      val = LEPUS_GetPropertyUint32(ctx, src_obj, i);
      if (LEPUS_IsException(val)) goto fail;
      if (LEPUS_SetPropertyUint32(ctx, obj, i, val) < 0) goto fail;
    }
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue js_typed_array_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst new_target,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int classid) {
  CallGCFunc(js_typed_array_constructor_GC, ctx, new_target, argc, argv,
             classid);
  LEPUSValue buffer, obj;
  JSArrayBuffer *abuf;
  int size_log2;
  uint64_t len, offset;

  size_log2 = typed_array_size_log2(classid);
  if (LEPUS_VALUE_IS_NOT_OBJECT(argv[0])) {
    if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
    buffer =
        js_array_buffer_constructor1(ctx, LEPUS_UNDEFINED, len << size_log2);
    if (LEPUS_IsException(buffer)) return LEPUS_EXCEPTION;
    offset = 0;
  } else {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(argv[0]);
    if (p->class_id == JS_CLASS_ARRAY_BUFFER ||
        p->class_id == JS_CLASS_SHARED_ARRAY_BUFFER) {
      abuf = p->u.array_buffer;
      if (LEPUS_ToIndex(ctx, &offset, argv[1])) return LEPUS_EXCEPTION;
      if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
      if ((offset & ((1 << size_log2) - 1)) != 0 || offset > abuf->byte_length)
        return LEPUS_ThrowRangeError(ctx, "invalid offset");
      if (LEPUS_IsUndefined(argv[2])) {
        if ((abuf->byte_length & ((1 << size_log2) - 1)) != 0)
          goto invalid_length;
        len = (abuf->byte_length - offset) >> size_log2;
      } else {
        if (LEPUS_ToIndex(ctx, &len, argv[2])) return LEPUS_EXCEPTION;
        if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        if ((offset + (len << size_log2)) > abuf->byte_length) {
        invalid_length:
          return LEPUS_ThrowRangeError(ctx, "invalid length");
        }
      }
      buffer = LEPUS_DupValue(ctx, argv[0]);
    } else {
      if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
          p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
        return js_typed_array_constructor_ta(ctx, new_target, argv[0], classid);
      } else {
        return js_typed_array_constructor_obj(ctx, new_target, argv[0],
                                              classid);
      }
    }
  }

  obj = js_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeValue(ctx, buffer);
    return LEPUS_EXCEPTION;
  }
  if (typed_array_init(ctx, obj, buffer, offset, len)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC void js_typed_array_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSTypedArray *ta = p->u.typed_array;
  if (ta) {
    /* during the GC the finalizers are called in an arbitrary
       order so the ArrayBuffer finalizer may have been called */
    if (JS_IsLiveObject(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer))) {
      list_del(&ta->link);
    }
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer));
    lepus_free_rt(rt, ta);
  }
}

QJS_STATIC void js_typed_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                    LEPUS_MarkFunc *mark_func, int local_idx) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  JSTypedArray *ta = p->u.typed_array;
  if (ta) {
    JS_MarkValue_RC(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer), mark_func);
  }
}

LEPUSValue js_dataview_constructor(LEPUSContext *ctx,
                                   LEPUSValueConst new_target, int argc,
                                   LEPUSValueConst *argv) {
  JSArrayBuffer *abuf;
  uint64_t offset;
  uint32_t len;
  LEPUSValueConst buffer;
  LEPUSValue obj;
  JSTypedArray *ta;
  LEPUSObject *p;

  buffer = argv[0];
  HandleScope func_scope(ctx, &buffer, HANDLE_TYPE_LEPUS_VALUE);
  abuf = js_get_array_buffer(ctx, buffer);
  if (!abuf) return LEPUS_EXCEPTION;
  offset = 0;
  if (argc > 1) {
    if (LEPUS_ToIndex(ctx, &offset, argv[1])) return LEPUS_EXCEPTION;
  }
  if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if (offset > abuf->byte_length)
    return LEPUS_ThrowRangeError(ctx, "invalid byteOffset");
  len = abuf->byte_length - offset;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    uint64_t l;
    if (LEPUS_ToIndex(ctx, &l, argv[2])) return LEPUS_EXCEPTION;
    if (l > len) return LEPUS_ThrowRangeError(ctx, "invalid byteLength");
    len = l;
  }

  obj = js_create_from_ctor(ctx, new_target, JS_CLASS_DATAVIEW);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  func_scope.PushHandle(&obj, HANDLE_TYPE_LEPUS_VALUE);
  if (abuf->detached) {
    /* could have been detached in js_create_from_ctor() */
    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  ta = static_cast<JSTypedArray *>(
      lepus_malloc(ctx, sizeof(*ta), ALLOC_TAG_JSTypedArray));
  if (!ta) {
  fail:
    if (!ctx->gc_enable) LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  ta->obj = p;
  if (!ctx->gc_enable) LEPUS_DupValue(ctx, buffer);
  ta->buffer = LEPUS_VALUE_GET_OBJ(buffer);
  ta->offset = offset;
  ta->length = len;
  list_add_tail(&ta->link, &abuf->array_list);
  p->u.typed_array = ta;
  return obj;
}

LEPUSValue js_dataview_getValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                int argc, LEPUSValueConst *argv, int class_id) {
  JSTypedArray *ta;
  JSArrayBuffer *abuf;
  int is_swap, size;
  uint8_t *ptr;
  uint32_t v;
  uint64_t pos;

  ta = static_cast<JSTypedArray *>(
      LEPUS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW));
  if (!ta) return LEPUS_EXCEPTION;
  size = 1 << typed_array_size_log2(class_id);
  if (LEPUS_ToIndex(ctx, &pos, argv[0])) return LEPUS_EXCEPTION;
  is_swap = FALSE;
  if (argc > 1) is_swap = LEPUS_ToBool(ctx, argv[1]);
#ifndef WORDS_BIGENDIAN
  is_swap ^= 1;
#endif
  abuf = ta->buffer->u.array_buffer;
  if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if ((pos + size) > ta->length)
    return LEPUS_ThrowRangeError(ctx, "out of bound");
  ptr = abuf->data + ta->offset + pos;

  switch (class_id) {
    case JS_CLASS_INT8_ARRAY:
      return LEPUS_NewInt32(ctx, *(int8_t *)ptr);
    case JS_CLASS_UINT8_ARRAY:
      return LEPUS_NewInt32(ctx, *(uint8_t *)ptr);
    case JS_CLASS_INT16_ARRAY:
      v = get_u16(ptr);
      if (is_swap) v = bswap16(v);
      return LEPUS_NewInt32(ctx, (int16_t)v);
    case JS_CLASS_UINT16_ARRAY:
      v = get_u16(ptr);
      if (is_swap) v = bswap16(v);
      return LEPUS_NewInt32(ctx, v);
    case JS_CLASS_INT32_ARRAY:
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      return LEPUS_NewInt32(ctx, v);
    case JS_CLASS_UINT32_ARRAY:
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      return JS_NewUint32(ctx, v);
#ifdef CONFIG_BIGNUM
    case JS_CLASS_BIG_INT64_ARRAY: {
      uint64_t v;
      v = get_u64(ptr);
      if (is_swap) v = bswap64(v);
      return LEPUS_NewBigInt64(ctx, v);
    } break;
    case JS_CLASS_BIG_UINT64_ARRAY: {
      uint64_t v;
      v = get_u64(ptr);
      if (is_swap) v = bswap64(v);
      return LEPUS_NewBigUint64(ctx, v);
    } break;
#endif
    case JS_CLASS_FLOAT32_ARRAY: {
      union {
        float f;
        uint32_t i;
      } u;
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      u.i = v;
      return __JS_NewFloat64(ctx, u.f);
    }
    case JS_CLASS_FLOAT64_ARRAY: {
      union {
        double f;
        uint64_t i;
      } u;
      u.i = get_u64(ptr);
      if (is_swap) u.i = bswap64(u.i);
      return __JS_NewFloat64(ctx, u.f);
    }
    default:
      abort();
  }
}

LEPUSValue js_dataview_setValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                int argc, LEPUSValueConst *argv, int class_id) {
  JSTypedArray *ta;
  JSArrayBuffer *abuf;
  int is_swap, size;
  uint8_t *ptr;
  uint64_t v64;
  uint32_t v;
  uint64_t pos;
  LEPUSValueConst val;

  ta = static_cast<JSTypedArray *>(
      LEPUS_GetOpaque2(ctx, this_obj, JS_CLASS_DATAVIEW));
  if (!ta) return LEPUS_EXCEPTION;
  size = 1 << typed_array_size_log2(class_id);
  if (LEPUS_ToIndex(ctx, &pos, argv[0])) return LEPUS_EXCEPTION;
  val = argv[1];
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);
  v = 0;   /* avoid warning */
  v64 = 0; /* avoid warning */
  if (class_id <= JS_CLASS_UINT32_ARRAY) {
    if (LEPUS_ToUint32(ctx, &v, val)) return LEPUS_EXCEPTION;
  } else
#ifdef CONFIG_BIGNUM
      if (class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
    if (LEPUS_ToBigInt64(ctx, (int64_t *)&v64, val)) return LEPUS_EXCEPTION;
  } else
#endif
  {
    double d;
    if (LEPUS_ToFloat64(ctx, &d, val)) return LEPUS_EXCEPTION;
    if (class_id == JS_CLASS_FLOAT32_ARRAY) {
      union {
        float f;
        uint32_t i;
      } u;
      u.f = d;
      v = u.i;
    } else {
      JSFloat64Union u;
      u.d = d;
      v64 = u.u64;
    }
  }
  is_swap = FALSE;
  if (argc > 2) is_swap = LEPUS_ToBool(ctx, argv[2]);
#ifndef WORDS_BIGENDIAN
  is_swap ^= 1;
#endif
  abuf = ta->buffer->u.array_buffer;
  if (abuf->detached) return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if ((pos + size) > ta->length)
    return LEPUS_ThrowRangeError(ctx, "out of bound");
  ptr = abuf->data + ta->offset + pos;

  switch (class_id) {
    case JS_CLASS_INT8_ARRAY:
    case JS_CLASS_UINT8_ARRAY:
      *ptr = v;
      break;
    case JS_CLASS_INT16_ARRAY:
    case JS_CLASS_UINT16_ARRAY:
      if (is_swap) v = bswap16(v);
      put_u16(ptr, v);
      break;
    case JS_CLASS_INT32_ARRAY:
    case JS_CLASS_UINT32_ARRAY:
    case JS_CLASS_FLOAT32_ARRAY:
      if (is_swap) v = bswap32(v);
      put_u32(ptr, v);
      break;
#ifdef CONFIG_BIGNUM
    case JS_CLASS_BIG_INT64_ARRAY:
    case JS_CLASS_BIG_UINT64_ARRAY:
#endif
    case JS_CLASS_FLOAT64_ARRAY:
      if (is_swap) v64 = bswap64(v64);
      put_u64(ptr, v64);
      break;
    default:
      abort();
  }
  return LEPUS_UNDEFINED;
}

/* Atomics */
#ifdef CONFIG_ATOMICS

typedef enum AtomicsOpEnum {
  ATOMICS_OP_ADD,
  ATOMICS_OP_AND,
  ATOMICS_OP_OR,
  ATOMICS_OP_SUB,
  ATOMICS_OP_XOR,
  ATOMICS_OP_EXCHANGE,
  ATOMICS_OP_COMPARE_EXCHANGE,
  ATOMICS_OP_LOAD,
} AtomicsOpEnum;

static void *js_atomics_get_ptr(LEPUSContext *ctx, int *psize_log2,
                                LEPUSClassID *pclass_id, LEPUSValueConst obj,
                                LEPUSValueConst idx_val, BOOL is_waitable) {
  LEPUSObject *p;
  JSTypedArray *ta;
  JSArrayBuffer *abuf;
  void *ptr;
  uint64_t idx;
  BOOL err;
  int size_log2;

  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
#ifdef CONFIG_BIGNUM
  if (is_waitable)
    err = (p->class_id != JS_CLASS_INT32_ARRAY &&
           p->class_id != JS_CLASS_BIG_INT64_ARRAY);
  else
    err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&
            p->class_id <= JS_CLASS_BIG_UINT64_ARRAY);
#else
  if (is_waitable)
    err = (p->class_id != JS_CLASS_INT32_ARRAY);
  else
    err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&
            p->class_id <= JS_CLASS_UINT32_ARRAY);
#endif
  if (err) {
  fail:
    LEPUS_ThrowTypeError(ctx, "integer TypedArray expected");
    return NULL;
  }
  ta = p->u.typed_array;
  abuf = ta->buffer->u.array_buffer;
  if (!abuf->shared) {
    LEPUS_ThrowTypeError(ctx, "not a SharedArrayBuffer TypedArray");
    return NULL;
  }
  if (LEPUS_ToIndex(ctx, &idx, idx_val)) {
    return NULL;
  }
  if (idx >= p->u.array.count) {
    LEPUS_ThrowRangeError(ctx, "out-of-bound access");
    return NULL;
  }
  size_log2 = typed_array_size_log2(p->class_id);
  ptr = p->u.array.u.uint8_ptr + ((uintptr_t)idx << size_log2);
  if (psize_log2) *psize_log2 = size_log2;
  if (pclass_id) *pclass_id = p->class_id;
  return ptr;
}

static LEPUSValue js_atomics_op(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                int argc, LEPUSValueConst *argv, int op) {
  int size_log2;
#ifdef CONFIG_BIGNUM
  uint64_t v, a, rep_val;
#else
  uint32_t v, a, rep_val;
#endif
  void *ptr;
  LEPUSValue ret;
  LEPUSClassID class_id;

  ptr = js_atomics_get_ptr(ctx, &size_log2, &class_id, argv[0], argv[1], FALSE);
  if (!ptr) return LEPUS_EXCEPTION;
  rep_val = 0;
  if (op == ATOMICS_OP_LOAD) {
    v = 0;
  } else
#ifdef CONFIG_BIGNUM
      if (size_log2 == 3) {
    int64_t v64;
    if (LEPUS_ToBigInt64(ctx, &v64, argv[2])) return LEPUS_EXCEPTION;
    v = v64;
    if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
      if (LEPUS_ToBigInt64(ctx, &v64, argv[3])) return LEPUS_EXCEPTION;
      rep_val = v64;
    }
  } else
#endif
  {
    uint32_t v32;
    if (LEPUS_ToUint32(ctx, &v32, argv[2])) return LEPUS_EXCEPTION;
    v = v32;
    if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
      if (LEPUS_ToUint32(ctx, &v32, argv[3])) return LEPUS_EXCEPTION;
      rep_val = v32;
    }
  }
  switch (op | (size_log2 << 3)) {
#ifdef CONFIG_BIGNUM
#define OP(op_name, func_name)                  \
  case ATOMICS_OP_##op_name | (0 << 3):         \
    a = func_name((_Atomic(uint8_t) *)ptr, v);  \
    break;                                      \
  case ATOMICS_OP_##op_name | (1 << 3):         \
    a = func_name((_Atomic(uint16_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (2 << 3):         \
    a = func_name((_Atomic(uint32_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (3 << 3):         \
    a = func_name((_Atomic(uint64_t) *)ptr, v); \
    break;
#else
#define OP(op_name, func_name)                  \
  case ATOMICS_OP_##op_name | (0 << 3):         \
    a = func_name((_Atomic(uint8_t) *)ptr, v);  \
    break;                                      \
  case ATOMICS_OP_##op_name | (1 << 3):         \
    a = func_name((_Atomic(uint16_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (2 << 3):         \
    a = func_name((_Atomic(uint32_t) *)ptr, v); \
    break;
#endif
    OP(ADD, atomic_fetch_add)
    OP(AND, atomic_fetch_and)
    OP(OR, atomic_fetch_or)
    OP(SUB, atomic_fetch_sub)
    OP(XOR, atomic_fetch_xor)
    OP(EXCHANGE, atomic_exchange)
#undef OP

    case ATOMICS_OP_LOAD | (0 << 3):
      a = atomic_load((_Atomic(uint8_t) *)ptr);
      break;
    case ATOMICS_OP_LOAD | (1 << 3):
      a = atomic_load((_Atomic(uint16_t) *)ptr);
      break;
    case ATOMICS_OP_LOAD | (2 << 3):
      a = atomic_load((_Atomic(uint32_t) *)ptr);
      break;
#ifdef CONFIG_BIGNUM
    case ATOMICS_OP_LOAD | (3 << 3):
      a = atomic_load((_Atomic(uint64_t) *)ptr);
      break;
#endif

    case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3): {
      uint8_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint8_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
    case ATOMICS_OP_COMPARE_EXCHANGE | (1 << 3): {
      uint16_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint16_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
    case ATOMICS_OP_COMPARE_EXCHANGE | (2 << 3): {
      uint32_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint32_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
#ifdef CONFIG_BIGNUM
    case ATOMICS_OP_COMPARE_EXCHANGE | (3 << 3): {
      uint64_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint64_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
#endif
    default:
      abort();
  }

  switch (class_id) {
    case JS_CLASS_INT8_ARRAY:
      a = (int8_t)a;
      goto done;
    case JS_CLASS_UINT8_ARRAY:
      a = (uint8_t)a;
      goto done;
    case JS_CLASS_INT16_ARRAY:
      a = (int16_t)a;
      goto done;
    case JS_CLASS_UINT16_ARRAY:
      a = (uint16_t)a;
      goto done;
    case JS_CLASS_INT32_ARRAY:
    done:
      ret = LEPUS_NewInt32(ctx, a);
      break;
    case JS_CLASS_UINT32_ARRAY:
      ret = JS_NewUint32(ctx, a);
      break;
#ifdef CONFIG_BIGNUM
    case JS_CLASS_BIG_INT64_ARRAY:
      ret = LEPUS_NewBigInt64(ctx, a);
      break;
    case JS_CLASS_BIG_UINT64_ARRAY:
      ret = LEPUS_NewBigUint64(ctx, a);
      break;
#endif
    default:
      abort();
  }
  return ret;
}

static LEPUSValue js_atomics_store(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   int argc, LEPUSValueConst *argv) {
  int size_log2;
  void *ptr;
  LEPUSValue ret;

  ptr = js_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], FALSE);
  if (!ptr) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  if (size_log2 == 3) {
    int64_t v64;
    ret = JS_ToBigIntValueFree(ctx, LEPUS_DupValue(ctx, argv[2]));
    if (LEPUS_IsException(ret)) return ret;
    if (LEPUS_ToBigInt64(ctx, &v64, ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    atomic_store((_Atomic(uint64_t) *)ptr, v64);
  } else
#endif
  {
    uint32_t v;
    /* XXX: spec, would be simpler to return the written value */
    ret = JS_ToIntegerFree(ctx, LEPUS_DupValue(ctx, argv[2]));
    if (LEPUS_IsException(ret)) return ret;
    if (LEPUS_ToUint32(ctx, &v, ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    switch (size_log2) {
      case 0:
        atomic_store((_Atomic(uint8_t) *)ptr, v);
        break;
      case 1:
        atomic_store((_Atomic(uint16_t) *)ptr, v);
        break;
      case 2:
        atomic_store((_Atomic(uint32_t) *)ptr, v);
        break;
      default:
        abort();
    }
  }
  return ret;
}

static LEPUSValue js_atomics_isLockFree(LEPUSContext *ctx,
                                        LEPUSValueConst this_obj, int argc,
                                        LEPUSValueConst *argv) {
  int v, ret;
  if (JS_ToInt32Sat(ctx, &v, argv[0])) return LEPUS_EXCEPTION;
  ret = (v == 1 || v == 2 || v == 4
#ifdef CONFIG_BIGNUM
         || v == 8
#endif
  );
  return LEPUS_NewBool(ctx, ret);
}

typedef struct JSAtomicsWaiter {
  struct list_head link;
  BOOL linked;
  pthread_cond_t cond;
  int32_t *ptr;
} JSAtomicsWaiter;

static pthread_mutex_t js_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
static struct list_head js_atomics_waiter_list =
    LIST_HEAD_INIT(js_atomics_waiter_list);

static LEPUSValue js_atomics_wait(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                  int argc, LEPUSValueConst *argv) {
  int64_t v;
  int32_t v32;
  void *ptr;
  int64_t timeout;
  struct timespec ts;
  JSAtomicsWaiter waiter_s, *waiter;
  int ret, size_log2, res;
  double d;

  ptr = js_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], TRUE);
  if (!ptr) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  if (size_log2 == 3) {
    if (LEPUS_ToBigInt64(ctx, &v, argv[2])) return LEPUS_EXCEPTION;
  } else
#endif
  {
    if (LEPUS_ToInt32(ctx, &v32, argv[2])) return LEPUS_EXCEPTION;
    v = v32;
  }
  if (LEPUS_ToFloat64(ctx, &d, argv[3])) return LEPUS_EXCEPTION;
  if (isnan(d) || d > INT64_MAX)
    timeout = INT64_MAX;
  else if (d < 0)
    timeout = 0;
  else
    timeout = (int64_t)d;
  if (!ctx->rt->can_block)
    return LEPUS_ThrowTypeError(ctx, "cannot block in this thread");

  /* XXX: inefficient if large number of waiters, should hash on
     'ptr' value */
  /* XXX: use Linux futexes when available ? */
  pthread_mutex_lock(&js_atomics_mutex);
  if (size_log2 == 3) {
    res = *(int64_t *)ptr != v;
  } else {
    res = *(int32_t *)ptr != v;
  }
  if (res) {
    pthread_mutex_unlock(&js_atomics_mutex);
    return LEPUS_AtomToString(ctx, JS_ATOM_not_equal);
  }

  waiter = &waiter_s;
  waiter->ptr = ptr;
  pthread_cond_init(&waiter->cond, NULL);
  waiter->linked = TRUE;
  list_add_tail(&waiter->link, &js_atomics_waiter_list);

  if (timeout == INT64_MAX) {
    pthread_cond_wait(&waiter->cond, &js_atomics_mutex);
    ret = 0;
  } else {
    /* XXX: use clock monotonic */
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += timeout / 1000;
    ts.tv_nsec += (timeout % 1000) * 1000000;
    if (ts.tv_nsec >= 1000000000) {
      ts.tv_nsec -= 1000000000;
      ts.tv_sec++;
    }
    ret = pthread_cond_timedwait(&waiter->cond, &js_atomics_mutex, &ts);
  }
  if (waiter->linked) list_del(&waiter->link);
  pthread_mutex_unlock(&js_atomics_mutex);
  pthread_cond_destroy(&waiter->cond);
  if (ret == ETIMEDOUT) {
    return LEPUS_AtomToString(ctx, JS_ATOM_timed_out);
  } else {
    return LEPUS_AtomToString(ctx, JS_ATOM_ok);
  }
}

static LEPUSValue js_atomics_notify(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                    int argc, LEPUSValueConst *argv) {
  struct list_head *el, *el1, waiter_list;
  int32_t count, n;
  void *ptr;
  JSAtomicsWaiter *waiter;

  ptr = js_atomics_get_ptr(ctx, NULL, NULL, argv[0], argv[1], TRUE);
  if (!ptr) return LEPUS_EXCEPTION;

  if (LEPUS_IsUndefined(argv[2])) {
    count = INT32_MAX;
  } else {
    if (JS_ToInt32Clamp(ctx, &count, argv[2], 0, INT32_MAX, 0))
      return LEPUS_EXCEPTION;
  }

  n = 0;
  if (count > 0) {
    pthread_mutex_lock(&js_atomics_mutex);
    init_list_head(&waiter_list);
    list_for_each_safe(el, el1, &js_atomics_waiter_list) {
      waiter = list_entry(el, JSAtomicsWaiter, link);
      if (waiter->ptr == ptr) {
        list_del(&waiter->link);
        waiter->linked = FALSE;
        list_add_tail(&waiter->link, &waiter_list);
        n++;
        if (n >= count) break;
      }
    }
    list_for_each(el, &waiter_list) {
      waiter = list_entry(el, JSAtomicsWaiter, link);
      pthread_cond_signal(&waiter->cond);
    }
    pthread_mutex_unlock(&js_atomics_mutex);
  }
  return LEPUS_NewInt32(ctx, n);
}

static const LEPUSCFunctionListEntry js_atomics_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 3, js_atomics_op, ATOMICS_OP_ADD),
    LEPUS_CFUNC_MAGIC_DEF("and", 3, js_atomics_op, ATOMICS_OP_AND),
    LEPUS_CFUNC_MAGIC_DEF("or", 3, js_atomics_op, ATOMICS_OP_OR),
    LEPUS_CFUNC_MAGIC_DEF("sub", 3, js_atomics_op, ATOMICS_OP_SUB),
    LEPUS_CFUNC_MAGIC_DEF("xor", 3, js_atomics_op, ATOMICS_OP_XOR),
    LEPUS_CFUNC_MAGIC_DEF("exchange", 3, js_atomics_op, ATOMICS_OP_EXCHANGE),
    LEPUS_CFUNC_MAGIC_DEF("compareExchange", 4, js_atomics_op,
                          ATOMICS_OP_COMPARE_EXCHANGE),
    LEPUS_CFUNC_MAGIC_DEF("load", 2, js_atomics_op, ATOMICS_OP_LOAD),
    LEPUS_CFUNC_DEF("store", 3, js_atomics_store),
    LEPUS_CFUNC_DEF("isLockFree", 1, js_atomics_isLockFree),
    LEPUS_CFUNC_DEF("wait", 4, js_atomics_wait),
    LEPUS_CFUNC_DEF("notify", 3, js_atomics_notify),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Atomics",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry js_atomics_obj[] = {
    LEPUS_OBJECT_DEF("Atomics", js_atomics_funcs, countof(js_atomics_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

void JS_AddIntrinsicAtomics(LEPUSContext *ctx) {
  /* add Atomics as autoinit object */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, js_atomics_obj,
                                countof(js_atomics_obj));
}

#endif /* CONFIG_ATOMICS */

void LEPUS_AddIntrinsicTypedArrays(LEPUSContext *ctx) {
  CallGCFunc(JS_AddIntrinsicTypedArrays_GC, ctx);
  LEPUSValue typed_array_base_proto, typed_array_base_func;
  LEPUSValueConst array_buffer_func, shared_array_buffer_func;
  int i;

  ctx->class_proto[JS_CLASS_ARRAY_BUFFER] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_ARRAY_BUFFER],
                                js_array_buffer_proto_funcs,
                                countof(js_array_buffer_proto_funcs));

  array_buffer_func = JS_NewGlobalCConstructorOnly(
      ctx, "ArrayBuffer", js_array_buffer_constructor, 1,
      ctx->class_proto[JS_CLASS_ARRAY_BUFFER]);
  LEPUS_SetPropertyFunctionList(ctx, array_buffer_func, js_array_buffer_funcs,
                                countof(js_array_buffer_funcs));

  ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER],
                                js_shared_array_buffer_proto_funcs,
                                countof(js_shared_array_buffer_proto_funcs));

  shared_array_buffer_func = JS_NewGlobalCConstructorOnly(
      ctx, "SharedArrayBuffer", js_shared_array_buffer_constructor, 1,
      ctx->class_proto[JS_CLASS_SHARED_ARRAY_BUFFER]);
  LEPUS_SetPropertyFunctionList(ctx, shared_array_buffer_func,
                                js_shared_array_buffer_funcs,
                                countof(js_shared_array_buffer_funcs));

  typed_array_base_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, typed_array_base_proto,
                                js_typed_array_base_proto_funcs,
                                countof(js_typed_array_base_proto_funcs));

  /* TypedArray.prototype.toString must be the same object as
   * Array.prototype.toString */
  LEPUSValue obj = JS_GetPropertyInternal_RC(
      ctx, ctx->class_proto[JS_CLASS_ARRAY], JS_ATOM_toString,
      ctx->class_proto[JS_CLASS_ARRAY], 0);
  /* XXX: should use alias method in LEPUSCFunctionListEntry */  //@@@
  JS_DefinePropertyValue_RC(ctx, typed_array_base_proto, JS_ATOM_toString, obj,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);

  typed_array_base_func =
      LEPUS_NewCFunction(ctx, js_typed_array_base_constructor, "TypedArray", 0);
  LEPUS_SetPropertyFunctionList(ctx, typed_array_base_func,
                                js_typed_array_base_funcs,
                                countof(js_typed_array_base_funcs));
  JS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);

  for (i = JS_CLASS_UINT8C_ARRAY;
       i < JS_CLASS_UINT8C_ARRAY + JS_TYPED_ARRAY_COUNT; i++) {
    LEPUSValue func_obj;
    char buf[ATOM_GET_STR_BUF_SIZE];
    const char *name;

    ctx->class_proto[i] = LEPUS_NewObjectProto(ctx, typed_array_base_proto);
    JS_DefinePropertyValueStr_RC(
        ctx, ctx->class_proto[i], "BYTES_PER_ELEMENT",
        LEPUS_NewInt32(ctx, 1 << typed_array_size_log2(i)), 0);
    name = JS_AtomGetStr(ctx, buf, sizeof(buf),
                         JS_ATOM_Uint8ClampedArray + i - JS_CLASS_UINT8C_ARRAY);
    func_obj = JS_NewCFunction3(
        ctx, (LEPUSCFunction *)js_typed_array_constructor, name, 3,
        LEPUS_CFUNC_constructor_magic, i, typed_array_base_func);
    JS_NewGlobalCConstructor2(ctx, func_obj, name, ctx->class_proto[i]);
    JS_DefinePropertyValueStr_RC(
        ctx, func_obj, "BYTES_PER_ELEMENT",
        LEPUS_NewInt32(ctx, 1 << typed_array_size_log2(i)), 0);
  }
  LEPUS_FreeValue(ctx, typed_array_base_proto);
  LEPUS_FreeValue(ctx, typed_array_base_func);

  /* DataView */
  ctx->class_proto[JS_CLASS_DATAVIEW] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATAVIEW],
                                js_dataview_proto_funcs,
                                countof(js_dataview_proto_funcs));
  JS_NewGlobalCConstructorOnly(ctx, "DataView", js_dataview_constructor, 1,
                               ctx->class_proto[JS_CLASS_DATAVIEW]);
  /* Atomics */
#ifdef CONFIG_ATOMICS
  JS_AddIntrinsicAtomics(ctx);
#endif
}

LEPUSValue LEPUS_ToJSON(LEPUSContext *ctx, LEPUSValueConst val, int indent) {
  LEPUSValue args[3];
  args[0] = val;
  args[1] = LEPUS_NULL;
  args[2] = LEPUS_MKVAL(LEPUS_TAG_INT, indent);
  return js_json_stringify(ctx, val, 3, args);
}

LEPUSValue LEPUS_NewWString(LEPUSContext *ctx, const uint16_t *buf,
                            size_t length) {
  CallGCFunc(JS_NewWString_GC, ctx, buf, length);
  return js_new_string16(ctx, buf, length);
}

LEPUSValue LEPUS_ToWString(LEPUSContext *ctx, LEPUSValueConst val1) {
  LEPUSValue val;
  JSString *str, *str_new;
  int pos, len;
  uint8_t *src;
  uint16_t *q;

  if (!LEPUS_VALUE_IS_STRING(val1)) {
    val = LEPUS_ToString(ctx, val1);
    if (LEPUS_IsException(val)) return val;
  } else {
    val = ctx->gc_enable ? val1 : LEPUS_DupValue(ctx, val1);
  }
  HandleScope func_scope(ctx, &val, HANDLE_TYPE_LEPUS_VALUE);

  str = LEPUS_VALUE_GET_STRING(val);
  len = str->len;
  if (str->is_wide_char) {
    return val;
  }
  str_new = js_alloc_string(ctx, len, 1);
  if (!str_new) return LEPUS_EXCEPTION;
  src = str->u.str8;
  q = str_new->u.str16;
  pos = 0;
  while (pos < len) {
    *q++ = src[pos++];
  }

  if (!ctx->gc_enable) LEPUS_FreeValue(ctx, val);
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str_new);
}

uint32_t LEPUS_GetStringLength(LEPUSContext *ctx, LEPUSValueConst str) {
  if (JS_IsSeparableString(str)) {
    auto *separable_string = JS_GetSeparableString(str);
    if (!separable_string->is_wide_char) {
      return 0;
    }
    return separable_string->len;
  }

  if (!LEPUS_VALUE_IS_STRING(str)) return 0;
  JSString *s = LEPUS_VALUE_GET_STRING(str);
  if (!s->is_wide_char) return 0;
  return s->len;
}

const uint16_t *LEPUS_GetStringChars(LEPUSContext *ctx, LEPUSValueConst str) {
  CallGCFunc(JS_GetStringChars_GC, ctx, str);
  if (JS_IsSeparableString(str)) {
    str = JS_GetSeparableStringContentNotDup(ctx, str);
  }

  if (!LEPUS_VALUE_IS_STRING(str)) return 0;
  JSString *s = LEPUS_VALUE_GET_STRING(str);
  if (!s->is_wide_char) return 0;
  return s->u.str16;
}

LEPUSClassID LEPUS_GetClassID(LEPUSContext *ctx, LEPUSValueConst obj) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return 0;

  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  return p->class_id;
}

LEPUSValue LEPUS_NewArrayWithValue(LEPUSContext *ctx, uint32_t length,
                                   LEPUSValueConst *values) {
  CallGCFunc(JS_NewArrayWithValue_GC, ctx, length, values);
  return js_build_rest(ctx, 0, length, values);
}

LEPUSValue LEPUS_NewTypedArray(LEPUSContext *ctx, uint32_t length,
                               LEPUSClassID class_id) {
  CallGCFunc(JS_NewTypedArray_GC, ctx, length, class_id);
  LEPUSValue arg0 = LEPUS_NewInt32(ctx, length);
  return js_typed_array_constructor(ctx, LEPUS_UNDEFINED, 1, &arg0, class_id);
}

LEPUSValue LEPUS_NewTypedArrayWithBuffer(LEPUSContext *ctx,
                                         LEPUSValueConst buffer,
                                         uint32_t byteOffset, uint32_t length,
                                         LEPUSClassID class_id) {
  CallGCFunc(JS_NewTypedArrayWithBuffer_GC, ctx, buffer, byteOffset, length,
             class_id);
  LEPUSValue args[3] = {buffer, LEPUS_NewInt32(ctx, byteOffset),
                        LEPUS_NewInt32(ctx, length)};
  return js_typed_array_constructor(ctx, LEPUS_UNDEFINED, 3, args, class_id);
}

LEPUSValue LEPUS_CallConstructorV(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  int argc, LEPUSValue *argv) {
  CallGCFunc(JS_CallConstructorV_GC, ctx, func_obj, argc, argv);
  return JS_CallConstructorInternal(ctx, func_obj, func_obj, argc, argv, 0);
}

LEPUSValue LEPUS_CallV(LEPUSContext *ctx, LEPUSValueConst func_obj,
                       LEPUSValueConst this_obj, int argc, LEPUSValue *argv) {
  CallGCFunc(JS_CallInternalTI_GC, ctx, func_obj, this_obj, LEPUS_UNDEFINED,
             argc, argv, 0);
  return JS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc, argv,
                           0);
}

LEPUS_BOOL LEPUS_IsPrimjsEnabled(LEPUSRuntime *rt) {
#ifdef ENABLE_PRIMJS_SNAPSHOT
  return rt && rt->use_primjs;
#else
  return false;
#endif
}

/* return JS_ATOM_NULL in case of exception */
JSAtom LEPUS_ValueToAtom(LEPUSContext *ctx, LEPUSValueConst val) {
  CallGCFunc(JS_ValueToAtom_GC, ctx, val);
  JSAtom atom;
  if (LEPUS_VALUE_IS_INT(val) &&
      (uint32_t)LEPUS_VALUE_GET_INT(val) <= JS_ATOM_MAX_INT) {
    /* fast path for integer values */
    atom = __JS_AtomFromUInt32(LEPUS_VALUE_GET_INT(val));
  } else if (LEPUS_VALUE_IS_SYMBOL(val)) {
    JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
    atom = LEPUS_DupAtom(ctx, js_get_atom_index(ctx->rt, p));
  } else {
    LEPUSValue str;
    str = LEPUS_ToPropertyKey(ctx, val);
    if (LEPUS_IsException(str)) return JS_ATOM_NULL;
    if (LEPUS_VALUE_IS_SYMBOL(str)) {
      atom = js_symbol_to_atom(ctx, str);
    } else {
      atom = JS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(str));
    }
  }
  return atom;
}

/* Return the buffer associated to the typed array or an exception if
   it is not a typed array or if the buffer is detached. pbyte_offset,
   pbyte_length or pbytes_per_element can be NULL. */
LEPUSValue LEPUS_GetTypedArrayBuffer(LEPUSContext *ctx, LEPUSValueConst obj,
                                     size_t *pbyte_offset, size_t *pbyte_length,
                                     size_t *pbytes_per_element) {
  LEPUSObject *p;
  JSTypedArray *ta;
  p = get_typed_array(ctx, obj, FALSE);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p))
    return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  ta = p->u.typed_array;
  if (pbyte_offset) *pbyte_offset = ta->offset;
  if (pbyte_length) *pbyte_length = ta->length;
  if (pbytes_per_element) {
    *pbytes_per_element = 1 << typed_array_size_log2(p->class_id);
  }
  LEPUSValue ret = LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer);
  if (!ctx->gc_enable) LEPUS_DupValue(ctx, ret);
  return ret;
}

// <Primjs begin>
LEPUSTypedArrayType LEPUS_GetTypedArrayType(LEPUSContext *ctx,
                                            LEPUSValueConst val) {
  if (!LEPUS_IsObject(val)) return LEPUS_TYPED_UNKNOW;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  switch (p->class_id) {
    case JS_CLASS_UINT8C_ARRAY:
      return LEPUS_TYPED_UINT8C_ARRAY;
    case JS_CLASS_UINT8_ARRAY:
      return LEPUS_TYPED_UINT8_ARRAY;
    case JS_CLASS_INT8_ARRAY:
      return LEPUS_TYPED_INT8_ARRAY;
    case JS_CLASS_INT16_ARRAY:
      return LEPUS_TYPED_INT16_ARRAY;
    case JS_CLASS_UINT16_ARRAY:
      return LEPUS_TYPED_UINT16_ARRAY;
    case JS_CLASS_INT32_ARRAY:
      return LEPUS_TYPED_INT32_ARRAY;
    case JS_CLASS_UINT32_ARRAY:
      return LEPUS_TYPED_UINT32_ARRAY;
    case JS_CLASS_FLOAT32_ARRAY:
      return LEPUS_TYPED_FLOAT32_ARRAY;
    case JS_CLASS_FLOAT64_ARRAY:
      return LEPUS_TYPED_FLOAT64_ARRAY;
    default:
      return LEPUS_TYPED_UNKNOW;
  }
  return LEPUS_TYPED_UNKNOW;
}

LEPUS_BOOL LEPUS_IsDataView(LEPUSContext *ctx, LEPUSValueConst val) {
  if (!LEPUS_IsObject(val)) return FALSE;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  return p->class_id == JS_CLASS_DATAVIEW;
}

LEPUSClassID LEPUS_GetTypedArrayClassID(LEPUSTypedArrayType type) {
  if (type == LEPUS_TYPED_UNKNOW) return -1;
  return (type - LEPUS_TYPED_UINT8C_ARRAY) + JS_CLASS_UINT8C_ARRAY;
}

class ObjectCloneState {
 public:
  using key_t = LEPUSObject *;
  using val_t = LEPUSObject *;

  ObjectCloneState(LEPUSContext *ctx) : ctx_(ctx) {
    handled_obj_ = LEPUS_NewObject(ctx_);
  }

  ~ObjectCloneState() { LEPUS_FreeValue(ctx_, handled_obj_); }

  val_t GetVal(const key_t &key) const {
    auto ret = JS_GetPropertyInt64(ctx_, handled_obj_, (int64_t)key);
    if (LEPUS_IsUndefined(ret)) {
      return nullptr;
    }
    int64_t val = 0;
    if (LEPUS_ToInt64(ctx_, &val, ret)) {
      return nullptr;
    }
    return (val_t)val;
  }

  void SetValue(const key_t &key, const val_t &val) {
    LEPUS_SetPropertyInt64(ctx_, handled_obj_, (int64_t)key,
                           LEPUS_NewInt64(ctx_, (int64_t)val));
  }

  void EraseKey(const key_t &key) {
    JS_DeletePropertyInt64(ctx_, handled_obj_, (int64_t)key, 0);
  }

 private:
  LEPUSContext *ctx_ = nullptr;
  LEPUSValue handled_obj_ = LEPUS_UNDEFINED;
  ObjectCloneState(const ObjectCloneState &) {}
  ObjectCloneState(ObjectCloneState &&) {}
};

LEPUSValue JS_StructuredClone(LEPUSContext *ctx, LEPUSValue src,
                              ObjectCloneState &state) {
  auto tag = LEPUS_VALUE_GET_NORM_TAG(src);

  switch (tag) {
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64: {
      return src;
    }
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SEPARABLE_STRING: {
      return LEPUS_DupValue(ctx, src);
    }

#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSLepusRef *pref =
          reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(src));

      if (auto *p = state.GetVal((LEPUSObject *)(pref->p))) {
        return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
      }
      LEPUSValue ret = JS_StructuredClone(ctx, JSRef2Value(ctx, src), state);

      if (!LEPUS_IsException(ret)) {
        state.SetValue((LEPUSObject *)(pref->p), LEPUS_VALUE_GET_OBJ(ret));
      }
      return ret;
    }
#endif

    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(src);
      if (auto *result = state.GetVal(p)) {
        // find
        return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, result));
      }
      LEPUSClassID class_id = p->class_id;
      LEPUSObject *proto = nullptr;
      JSShape *sh = nullptr;
      LEPUSValue ret = LEPUS_UNDEFINED;

      if (!deepclone_opt_disabled(ctx->rt)) {
        if (class_id != JS_CLASS_PROMISE &&
            ((class_id >= JS_CLASS_C_FUNCTION &&
              class_id <= JS_CLASS_GENERATOR_FUNCTION) ||
             (class_id >= JS_CLASS_MAP_ITERATOR &&
              class_id <= JS_CLASS_ASYNC_GENERATOR) ||
             class_id >= JS_CLASS_INIT_COUNT)) {
          return LEPUS_DupValue(ctx, src);
        }
        sh = p->shape;
        proto = sh->proto;
        ret = JS_NewObjectProtoClass_RC(
            ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, proto), class_id);
      } else {
        sh = p->shape;
        ret = LEPUS_NewObjectClass(ctx, class_id);
      }

      LEPUSObject *ret_p = LEPUS_VALUE_GET_OBJ(ret);
      state.SetValue(p, ret_p);
      if (sh && p->prop) {
        // clone property
        JSShapeProperty *prs = sh->prop;
        for (uint32_t i = 0; i < sh->prop_count; ++i, ++prs) {
          int32_t flags = prs->flags;
          if (prs->atom != JS_ATOM_NULL && (flags & LEPUS_PROP_TMASK) == 0) {
            LEPUSValue cloned_prop =
                JS_StructuredClone(ctx, p->prop[i].u.value, state);
            if (LEPUS_IsException(cloned_prop) ||
                (JS_DefinePropertyValue_RC(ctx, ret, prs->atom, cloned_prop,
                                           flags & LEPUS_PROP_C_W_E) < 0)) {
              goto fail;
            }
          }
        }
      }

      switch (class_id) {
        case JS_CLASS_OBJECT:
        case JS_CLASS_ERROR: {
          break;
        }
        case JS_CLASS_ARRAY: {
          if (p->fast_array) {
            for (uint32_t i = 0; i < p->u.array.count; ++i) {
              LEPUSValue cloned_element =
                  JS_StructuredClone(ctx, p->u.array.u.values[i], state);
              if (LEPUS_IsException(cloned_element) ||
                  (JS_DefinePropertyValueUint32_RC(ctx, ret, i, cloned_element,
                                                   LEPUS_PROP_C_W_E) < 0)) {
                goto fail;
              }
            }
          }
        } break;
        case JS_CLASS_REGEXP: {
          ret_p->u.regexp.pattern = LEPUS_VALUE_GET_STRING(JS_StructuredClone(
              ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.pattern), state));
          ret_p->u.regexp.bytecode = LEPUS_VALUE_GET_STRING(JS_StructuredClone(
              ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.bytecode), state));
        } break;
        case JS_CLASS_NUMBER:
        case JS_CLASS_STRING:
        case JS_CLASS_BOOLEAN:
        case JS_CLASS_DATE: {
          LEPUSValue object_data =
              JS_StructuredClone(ctx, p->u.object_data, state);
          JS_SetObjectData(ctx, ret, object_data);
        } break;
        case JS_CLASS_PROMISE: {
          JSPromiseData *s =
              static_cast<JSPromiseData *>(lepus_mallocz(ctx, sizeof(*s)));
          if (!s) goto fail;
          s->promise_state = JS_PROMISE_PENDING;
          s->is_handled = FALSE;
          for (int i = 0; i < 2; i++) init_list_head(&s->promise_reactions[i]);
          s->promise_result = LEPUS_UNDEFINED;
          LEPUS_SetOpaque(ret, s);
          LEPUSValue args[2];
          if (js_create_resolving_functions(ctx, args, ret)) goto fail;

          LEPUSValue executor =
              js_promise_then_for_deepcopy(ctx, src, 2, args, &state);

          if (LEPUS_IsException(executor)) {
            LEPUSValue res2, error;
            error = LEPUS_GetException(ctx);
            res2 = JS_Call_RC(ctx, args[1], LEPUS_UNDEFINED, 1,
                              (LEPUSValueConst *)&error);
            LEPUS_FreeValue(ctx, error);
            if (LEPUS_IsException(res2)) {
              LEPUS_FreeValue(ctx, args[0]);
              LEPUS_FreeValue(ctx, args[1]);
              goto fail;
            }
            LEPUS_FreeValue(ctx, res2);
          }
          LEPUS_FreeValue(ctx, executor);
          LEPUS_FreeValue(ctx, args[0]);
          LEPUS_FreeValue(ctx, args[1]);
        } break;
        case JS_CLASS_ARRAY_BUFFER: {
          auto *array_buffer = p->u.array_buffer;
          if (array_buffer && !array_buffer->detached) {
            auto *abuf = reinterpret_cast<JSArrayBuffer *>(
                lepus_mallocz(ctx, sizeof(JSArrayBuffer)));
            if (!abuf) goto fail;
            abuf->byte_length = array_buffer->byte_length;
            abuf->data = reinterpret_cast<uint8_t *>(
                lepus_malloc(ctx, abuf->byte_length));
            if (!abuf->data) {
              lepus_free(ctx, abuf);
              goto fail;
            }
            abuf->free_func = js_array_buffer_free;
            abuf->opaque = array_buffer->opaque;
            init_list_head(&abuf->array_list);
            memcpy(abuf->data, array_buffer->data, abuf->byte_length);
            LEPUS_SetOpaque(ret, abuf);
          }
        } break;
        case JS_CLASS_UINT8C_ARRAY ... JS_CLASS_DATAVIEW: {
          auto *typearray = p->u.typed_array;
          auto *arraybuffer =
              typearray ? typearray->buffer->u.array_buffer : nullptr;
          if (arraybuffer && !arraybuffer->detached) {
            auto *ta = reinterpret_cast<JSTypedArray *>(
                lepus_mallocz(ctx, sizeof(JSTypedArray)));
            if (!ta) goto fail;
            ta->obj = ret_p;
            ta->offset = typearray->offset;
            ta->length = typearray->length;
            LEPUSValue new_buffer = JS_StructuredClone(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, typearray->buffer), state);

            if (LEPUS_IsException(new_buffer)) {
              lepus_free(ctx, ta);
              goto fail;
            }
            auto *pbuffer = LEPUS_VALUE_GET_OBJ(new_buffer);
            ta->buffer = pbuffer;
            auto *abuf = pbuffer->u.array_buffer;
            list_add_tail(&ta->link, &(abuf->array_list));

            ret_p->u.typed_array = ta;
            if (class_id != JS_CLASS_DATAVIEW) {
              ret_p->u.array.count = p->u.array.count;
              ret_p->u.array.u.ptr = abuf->data + ta->offset;
            }
          }
        } break;
        case JS_CLASS_MAP ... JS_CLASS_WEAKSET: {
          if (!deepclone_opt_disabled(ctx->rt)) {
            uint8_t magic = class_id - JS_CLASS_MAP;
            bool is_set = magic & MAGIC_SET;
            auto map_state = p->u.map_state;
            auto *ms = reinterpret_cast<JSMapState *>(
                lepus_mallocz(ctx, sizeof(JSMapState)));
            if (!ms) goto fail;
            init_list_head(&ms->records);
            LEPUS_SetOpaque(ret, ms);
            ms->is_weak = map_state->is_weak;
            ms->record_count = 0;
            ms->hash_size = 1;
            ms->hash_table = static_cast<struct list_head *>(
                lepus_malloc(ctx, sizeof(ms->hash_table[0]) * ms->hash_size));
            if (!ms->hash_table) goto fail;
            init_list_head(&ms->hash_table[0]);
            ms->record_count_threshold = 4;
            LEPUSValue adder = JS_GetPropertyInternal_RC(
                ctx, ret, is_set ? JS_ATOM_add : JS_ATOM_set, ret, 0);
            if (unlikely(LEPUS_IsException(adder))) goto fail;
            if (unlikely(!LEPUS_IsFunction(ctx, adder))) {
              LEPUS_ThrowTypeError(ctx, "set/add is not a function");
              goto fail1;
            }
            list_head *el;
            JSMapRecord *rec;
            LEPUSValue res;
            list_for_each(el, &map_state->records) {
              rec = list_entry(el, JSMapRecord, link);
              if (rec->empty) continue;
              LEPUSValue ms_key = JS_StructuredClone(ctx, rec->key, state);
              if (LEPUS_IsException(ms_key)) {
                goto fail1;
              }
              LEPUSValue ms_value = LEPUS_UNDEFINED;
              if (!is_set) {
                LEPUSValue args[2];
                args[0] = ms_key;
                ms_value = JS_StructuredClone(ctx, rec->value, state);
                if (LEPUS_IsException(ms_value)) {
                  goto fail1;
                }
                args[1] = ms_value;

                res = JS_Call_RC(ctx, adder, ret, 2, args);
                LEPUS_FreeValue(ctx, ms_value);
              } else {
                res = JS_Call_RC(ctx, adder, ret, 1, &ms_key);
              }
              LEPUS_FreeValue(ctx, ms_key);
              if (unlikely(LEPUS_IsException(res))) goto fail1;
              LEPUS_FreeValue(ctx, res);
            }
            LEPUS_FreeValue(ctx, adder);
            break;
          fail1:
            LEPUS_FreeValue(ctx, adder);
            goto fail;
          } else {
            LEPUS_ThrowTypeError(
                ctx, "object classid: %d is not supported in StructuredClone",
                p->class_id);
            goto fail;
          }
        }
        default: {
          LEPUS_ThrowTypeError(
              ctx, "object classid: %d is not supported in StructuredClone",
              p->class_id);
          goto fail;
        }
      }
      return ret;
    fail:
      state.EraseKey(p);
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    } break;
    default: {
      goto use_snapshot;
    }

    use_snapshot:
#ifndef NO_QUICKJS_COMPILER
      size_t psize = 0;
      uint8_t *buf = LEPUS_WriteObject(ctx, &psize, src, 0);

      if (buf) {
        LEPUSValue val = LEPUS_ReadObject(ctx, buf, psize, 0);
        lepus_free(ctx, buf);
        return val;
      } else {
        return LEPUS_UNDEFINED;
      }
#else
      return LEPUS_UNDEFINED;
#endif
  }
}

LEPUSValue LEPUS_DeepCopy(LEPUSContext *ctx, LEPUSValueConst obj) {
  CallGCFunc(JS_DeepCopy_GC, ctx, obj);
  ObjectCloneState state(ctx);
  return JS_StructuredClone(ctx, obj, state);
}

LEPUSValue LEPUS_NewObjectWithArgs(LEPUSContext *ctx, int32_t size,
                                   const char **keys, LEPUSValue *values) {
  CallGCFunc(JS_NewObjectWithArgs_GC, ctx, size, keys, values);
  auto ret = LEPUS_NewObject(ctx);
  if (LEPUS_VALUE_IS_NOT_OBJECT(ret)) return LEPUS_EXCEPTION;
  auto *p = LEPUS_VALUE_GET_OBJ(ret);

  for (int32_t i = 0; i < size; ++i) {
    auto atom = LEPUS_NewAtom(ctx, keys[i]);
    auto *prop = add_property(ctx, p, atom, LEPUS_PROP_C_W_E);
    LEPUS_FreeAtom(ctx, atom);
    if (prop) {
      prop->u.value = values[i];
    } else {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
  }
  return ret;
}

LEPUSValue LEPUS_NewArrayWithArgs(LEPUSContext *ctx, int32_t size,
                                  LEPUSValue *values) {
  CallGCFunc(JS_NewArrayWithArgs_GC, ctx, size, values);
  auto array = LEPUS_NewArray(ctx);
  if (size == 0) return array;
  LEPUSObject *p = nullptr;
  if (!LEPUS_IsArray(ctx, array)) goto failed;
  p = LEPUS_VALUE_GET_OBJ(array);

  p->u.array.u.values = reinterpret_cast<LEPUSValue *>(
      lepus_malloc(ctx, sizeof(LEPUSValue) * size));
  if (p->u.array.u.values == nullptr) goto failed;

  for (int32_t i = 0; i < size; ++i) {
    p->u.array.u.values[i] = values[i];
  }
  p->u.array.count = size;
  p->u.array.u1.size = size;

  // length prop
  p->prop[0].u.value = LEPUS_NewInt32(ctx, size);
  return array;
failed:
  LEPUS_FreeValue(ctx, array);
  return LEPUS_EXCEPTION;
}

const char *LEPUS_GetStringUtf8(LEPUSContext *ctx, const JSString *p) {
  if (p->is_wide_char) return nullptr;
  const uint8_t *src = p->u.str8;
  int count = 0;
  for (int pos = 0, len = p->len; pos < len; ++pos) {
    count += src[pos] >> 7;
  }

  if (count == 0) {
    return (const char *)(src);
  }
  return nullptr;
}

#ifdef ENABLE_LEPUSNG
void SetLynxTargetSdkVersion(LEPUSContext *ctx, const char *version) {
  if (!version) return;
  char *target_sdk_version = static_cast<char *>(
      lepus_malloc(ctx, strlen(version) + 1, ALLOC_TAG_WITHOUT_PTR));
  if (!target_sdk_version) return;
  strcpy(target_sdk_version, version);
  if (!ctx->gc_enable) lepus_free(ctx, ctx->lynx_target_sdk_version);
  ctx->lynx_target_sdk_version = target_sdk_version;
  return;
}
#endif

void SetDebugInfoOutside(LEPUSContext *ctx, bool enable) {
  ctx->debuginfo_outside = enable;
  return;
}

#ifdef QJS_UNITTEST
int32_t GetContextDebugInfoOutside(LEPUSContext *ctx) {
  return ctx->debuginfo_outside;
}

int64_t GetContextDebugInfoNewFlag(LEPUSContext *ctx) {
  return ctx->binary_version & NEW_DEBUGINFO_FLAG;
}
#endif

#ifdef ENABLE_QUICKJS_DEBUGGER

void ComputeLineCol(int64_t line_col_num, int32_t *line, int64_t *column) {
  // for line and column compatibility
  // if the highest bit is 1, use 24 bits for line number, 38 bits for column
  // number if the highest bit is 0, use 12 bits for line number, 20 bits for
  // column number
  int32_t type = line_col_num >> LINE_COLUMN_TYPE_SHIFT;
  if (type == 1) {
    *line = line_col_num & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
    *column =
        (int64_t)((line_col_num ^ ((uint64_t)1 << LINE_COLUMN_TYPE_SHIFT)) >>
                  LINE_NUMBER_BITS_COUNT);
  } else if (type == 0) {
    *line = line_col_num & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
    *column = (int64_t)(line_col_num >> OLD_LINE_NUMBER_BITS_COUNT);
  }
  // line and column start from 0
  *line = *line - 1;
  *column = *column - 1;
  if (*line < 0 || *column < 0) {
    *line = 0;
    *column = 0;
  }
}

LEPUSValue GetFunctionCallerString(LEPUSContext *ctx,
                                   const LEPUSFunctionBytecode *b) {
  LEPUSValue ret = LEPUS_NewObject(ctx);
  HandleScope func_scope{ctx, &ret, HANDLE_TYPE_LEPUS_VALUE};
  for (uint32_t i = 0, size = b->debug.caller_size; i < size; ++i) {
    auto &slot = b->debug.caller_slots[i];
    LEPUSValue name = LEPUS_UNDEFINED;
    HandleScope block_scope{ctx, &name, HANDLE_TYPE_LEPUS_VALUE};
    if (slot.is_str) {
      name = LEPUS_NewStringLen(ctx, slot.str, slot.size);
    } else {
      name = LEPUS_NewStringLen(ctx, b->debug.source + slot.off, slot.size);
    }
    LEPUS_SetPropertyUint32(ctx, ret, slot.pc - 1, name);
  }
  return ret;
}

void RegisterQJSDebuggerCallbacks(LEPUSRuntime *rt, void **funcs,
                                  int32_t callback_size) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (!rt || !funcs) {
    return;
  }
  int32_t num = 0;
#define Name(name)                                                \
  if (num < callback_size) {                                      \
    rt->debugger_callbacks_.name =                                \
        reinterpret_cast<decltype(rt->debugger_callbacks_.name)>( \
            funcs[num++]);                                        \
  } else {                                                        \
    rt->debugger_callbacks_.name = NULL;                          \
  }
  QJSCallBackName(Name)
#undef Name
#endif
}

void PrepareQJSDebuggerDefer(LEPUSContext *ctx, void **funcs,
                             int32_t callback_size) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->debugger_callbacks_.run_message_loop_on_pause) {
    RegisterQJSDebuggerCallbacks(rt, funcs, callback_size);
  }
#endif
  return;
}

void PrepareQJSDebuggerForSharedContext(LEPUSContext *ctx, void **funcs,
                                        int32_t callback_size,
                                        bool devtool_connect) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->debugger_callbacks_.run_message_loop_on_pause) {
    RegisterQJSDebuggerCallbacks(rt, funcs, callback_size);
  }

  if (devtool_connect) {
    ctx->debugger_mode = 1;
  } else {
    ctx->debugger_parse_script = 1;
    ctx->debugger_mode = 0;
  }
  RegisterLynxConsole(ctx);
#endif
  return;
}

#ifdef QJS_UNITTEST
LEPUSValue GetAnonFunc(LEPUSFunctionBytecode *b) {
  LEPUSValue func_obj = LEPUS_UNDEFINED;
  for (int32_t i = 0; i < b->cpool_count; i++) {
    LEPUSValue child = b->cpool[i];
    if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(child)) {
      func_obj = child;
      break;
    }
  }
  return func_obj;
}
#endif

#endif  // end of quickjs debugger

// <primjs begin>
#ifdef ENABLE_PRIMJS_SNAPSHOT

no_inline void prim_js_print(const char *msg) { printf("msg: %s\n", msg); }

no_inline void prim_js_print_register(uint64_t reg_val) {
  printf("Register: %p\n", (void *)reg_val);
}

static int trace_id = 0;

void prim_js_print_trace(int bytecode, int tos) {
  const char *name = short_opcode_info((OPCodeEnum)bytecode).name;
  PRIM_LOG("TRACE: id: %d, opcode %d, %s tos %d\n", trace_id++, bytecode, name,
           tos);
}

no_inline void prim_js_print_func(LEPUSContext *ctx, LEPUSValue func_obj) {
  if (LEPUS_VALUE_IS_OBJECT(func_obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    if (p->class_id == JS_CLASS_BYTECODE_FUNCTION) {
      const char *func_name = get_func_name(ctx, func_obj);
      if (!func_name || func_name[0] == '\0') {
        PRIM_LOG("primjs call bytecode function: \n");
      } else {
        PRIM_LOG("primjs call bytecode function: %s\n", func_name);
      }
    }
  }
}

LEPUSValue prim_js_op_eval(LEPUSContext *ctx, int scope_idx, LEPUSValue op1) {
  LEPUSValue ret_val;

  ret_val = JS_EvalObject(ctx, LEPUS_UNDEFINED, op1, LEPUS_EVAL_TYPE_DIRECT,
                          scope_idx);
  LEPUS_FreeValue(ctx, op1);
  return ret_val;
}

void prim_close_var_refs(LEPUSContext *ctx, LEPUSStackFrame *sf) {
  struct list_head *el, *el1;
  JSVarRef *var_ref;
  int var_idx;
  list_for_each_safe(el, el1, &sf->var_ref_list) {
    var_ref = list_entry(el, JSVarRef, link);
    if (var_ref->header.ref_count > 1) {
      var_ref->value = LEPUS_DupValue(ctx, *var_ref->pvalue);
      var_ref->pvalue = &var_ref->value;
      var_ref->is_detached = 1;
      var_ref->header.ref_count--;
    } else {
      lepus_free(ctx, var_ref);
    }
  }
  lepus_free(ctx, sf->var_refs);
  return;
}

/* called with the ref_count of 'v' reaches zero. */
void JS_FreeValueRef(LEPUSContext *ctx, LEPUSValue v) {
  LEPUSRuntime *rt = ctx->rt;
  int64_t tag = LEPUS_VALUE_GET_TAG(v);

#ifdef DUMP_FREE
  {
    printf("Freeing ");
    if (tag == LEPUS_TAG_OBJECT) {
      JS_DumpObject(rt, LEPUS_VALUE_GET_OBJ(v));
    } else {
      JS_DumpValueShort(rt, v);
      printf("\n");
    }
  }
#endif

  switch (tag) {
    case LEPUS_TAG_STRING: {
      JSString *p = LEPUS_VALUE_GET_STRING(v);
      if (p->atom_type) {
        JS_FreeAtomStruct(rt, p);
      } else {
#ifdef DUMP_LEAKS
        list_del(&p->link);
#endif

#ifdef ENABLE_LEPUSNG
        // <Primjs begin>
        JS_FreeStringCache(rt, p);
        // <Primjs end>
#endif
        lepus_free_rt(rt, p);
      }
    } break;
    case LEPUS_TAG_SEPARABLE_STRING: {
      JS_FreeSeparableString(rt, v);
    } break;
    case LEPUS_TAG_OBJECT:
      free_object(rt, LEPUS_VALUE_GET_OBJ(v));
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      free_function_bytecode(
          rt, static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(v)));
      break;
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_MODULE:
      abort(); /* never freed here */
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      JSBigFloat *bf = reinterpret_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      bf_delete(&bf->num);
      lepus_free_rt(rt, bf);
    } break;
#else
#ifdef ENABLE_LEPUSNG
    // <Primjs begin>
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      JSBigFloat *bf = static_cast<JSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      lepus_free_rt(rt, bf);
      break;
    }
    case LEPUS_TAG_LEPUS_REF: {
      if (rt->js_callbacks_.free_value) {
        rt->js_callbacks_.free_value(rt, v);
      }
      break;
    }
    // <Primjs end>
#endif
#endif
    case LEPUS_TAG_SYMBOL: {
      JSAtomStruct *p = static_cast<JSAtomStruct *>(LEPUS_VALUE_GET_PTR(v));
      JS_FreeAtomStruct(rt, p);
    } break;
    default:
      printf("__JS_FreeValue: unknown tag=%p\n", (void *)tag);
      abort();
  }
}

int prim_js_copy_data_properties(LEPUSContext *ctx, LEPUSValue *sp, int mask) {
  if (JS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],
                            sp[-1 - ((mask >> 2) & 7)],
                            sp[-1 - ((mask >> 5) & 7)], 0)) {
    return -1;
  }
  return 0;
}

int prim_js_with_op(LEPUSContext *ctx, LEPUSValue *sp, JSAtom atom, int is_with,
                    int opcode) {
  LEPUSValue obj, val;
  obj = sp[-1];
  int ret = LEPUS_HasProperty(ctx, obj, atom);
  if (unlikely(ret < 0)) goto exception;
  if (ret) {
    if (is_with) {
      ret = js_has_unscopable(ctx, obj, atom);
      if (unlikely(ret < 0)) goto exception;
      if (ret) goto no_with;
    }
    switch (opcode) {
      case OP_with_get_var:
        val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        set_value(ctx, &sp[-1], val);
        break;
      case OP_with_put_var:
        ret = JS_SetPropertyInternal_RC(ctx, obj, atom, sp[-2],
                                        LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-1]);
        if (unlikely(ret < 0)) goto exception;
        break;
      case OP_with_delete_var:
        ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
        if (unlikely(ret < 0)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = LEPUS_NewBool(ctx, ret);
        break;
      case OP_with_make_ref:
        /* produce a pair object/propname on the stack */
        *sp++ = JS_AtomToValue_RC(ctx, atom);
        break;
      case OP_with_get_ref:
        /* produce a pair object/method on the stack */
        val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
        break;
      case OP_with_get_ref_undef:
        /* produce a pair undefined/function on the stack */
        val = JS_GetPropertyInternal_RC(ctx, obj, atom, obj, 0);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = LEPUS_UNDEFINED;
        *sp++ = val;
        break;
    }
    return 1;
  } else {
  no_with:
    /* if not jumping, drop the object argument */
    LEPUS_FreeValue(ctx, sp[-1]);
    return 0;
  }
exception:
  return -1;
}

LEPUSValue prim_js_for_in_start(LEPUSContext *ctx, LEPUSValue op) {
  LEPUSValue res = build_for_in_iterator(ctx, op);
  return res;
}

LEPUSValue *prim_js_iterator_close_return(LEPUSContext *ctx, LEPUSValue *sp,
                                          LEPUSValue *stack_buf) {
  LEPUSValue ret_val;
  /* iter_obj next catch_offset ... ret_val ->
      ret_eval iter_obj next catch_offset */
  ret_val = *--sp;
  while (sp > stack_buf && !LEPUS_VALUE_IS_CATCH_OFFSET(sp[-1])) {
    LEPUS_FreeValue(ctx, *--sp);
  }
  if (unlikely(sp < stack_buf + 3)) {
    LEPUS_ThrowInternalError(ctx, "iterator_close_return");
    LEPUS_FreeValue(ctx, ret_val);
    goto exception;
  }
  sp[0] = sp[-1];
  sp[-1] = sp[-2];
  sp[-2] = sp[-3];
  sp[-3] = ret_val;
  sp++;
exception:
  return sp;
}

int prim_js_async_iterator_close(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue ret, method;
  int ret_flag;
  method = JS_GetPropertyInternal_RC(ctx, sp[-3], JS_ATOM_return, sp[-3], 0);
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    ret = LEPUS_UNDEFINED;
    ret_flag = TRUE;
  } else {
    ret = JS_CallFree(ctx, method, sp[-3], 0, NULL);
    if (LEPUS_IsException(ret)) goto exception;
    ret_flag = FALSE;
  }
  LEPUS_FreeValue(ctx, sp[-3]);
  LEPUS_FreeValue(ctx, sp[-2]);
  LEPUS_FreeValue(ctx, sp[-1]);
  sp[-3] = ret;
  sp[-2] = LEPUS_NewBool(ctx, ret_flag);
  return 0;
exception:
  return -1;
}

int prim_js_async_iterator_get(LEPUSContext *ctx, LEPUSValue *sp, int flags) {
  LEPUSValue method, ret;
  BOOL ret_flag;
  if (flags == 2) {
    LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
    goto exception;
  }
  method = JS_GetPropertyInternal_RC(
      ctx, sp[-4], flags ? JS_ATOM_throw : JS_ATOM_return, sp[-4], 0);
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    ret_flag = TRUE;
  } else {
    ret = JS_CallFree(ctx, method, sp[-4], 1, (LEPUSValueConst *)(sp - 1));
    if (LEPUS_IsException(ret)) goto exception;
    LEPUS_FreeValue(ctx, sp[-1]);
    sp[-1] = ret;
    ret_flag = FALSE;
  }
  sp[0] = LEPUS_NewBool(ctx, ret_flag);
  // sp += 1;
  return 0;
exception:
  return -1;
}

LEPUSValue primjs_get_super_ctor(LEPUSContext *ctx, LEPUSValue op) {
  LEPUSValue proto;
  proto = LEPUS_DupValue(ctx, JS_GetPrototype_RC(ctx, op));
  if (LEPUS_IsException(proto)) {
    LEPUS_FreeValue(ctx, op);
    return LEPUS_EXCEPTION;
  }
  if (!LEPUS_IsConstructor(ctx, proto)) {
    LEPUS_FreeValue(ctx, proto);
    LEPUS_FreeValue(ctx, op);
    LEPUS_ThrowTypeError(ctx, "not a constructor");
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op);
  return proto;
}

LEPUSValue prim_js_unary_arith_slow(LEPUSContext *ctx, LEPUSValue op1,
                                    OPCodeEnum op) {
  double d;

  if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {
    return LEPUS_EXCEPTION;
  }
  switch (op) {
    case OP_inc:
    case OP_inc_loc:
      d++;
      break;
    case OP_dec:
    case OP_dec_loc:
      d--;
      break;
    case OP_plus:
      break;
    case OP_neg:
      d = -d;
      break;
    default: {
      abort();
    }
  }
  return LEPUS_NewFloat64(ctx, d);
}

LEPUSValue prim_js_add_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2) {
  LEPUSValue ret_val;
  if ((LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) &&
      (LEPUS_VALUE_IS_INT(op2) || LEPUS_VALUE_IS_FLOAT64(op2))) {
    goto add_numbers;
  } else {
    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    if (LEPUS_IsString(op1) || LEPUS_IsString(op2)) {
      ret_val = JS_ConcatString(ctx, op1, op2);
      if (LEPUS_IsException(ret_val)) goto exception;
    } else {
      double d1, d2;
    add_numbers:
      if (JS_ToFloat64Free(ctx, &d1, op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
      ret_val = LEPUS_NewFloat64(ctx, d1 + d2);
    }
  }
  return ret_val;
exception:
  return LEPUS_EXCEPTION;
}

no_inline LEPUSValue prim_js_not_slow(LEPUSContext *ctx, LEPUSValue op) {
  int32_t v1;

  if (unlikely(JS_ToInt32Free(ctx, &v1, op))) {
    return LEPUS_EXCEPTION;
  }
  return LEPUS_NewInt32(ctx, ~v1);
}

LEPUSValue prim_js_binary_arith_slow(LEPUSContext *ctx, LEPUSValue op1,
                                     LEPUSValue op2, OPCodeEnum op) {
  double d1, d2, r;
  if (unlikely(JS_ToFloat64Free(ctx, &d1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  if (unlikely(JS_ToFloat64Free(ctx, &d2, op2))) {
    return LEPUS_EXCEPTION;
  }
  switch (op) {
    case OP_sub:
      r = d1 - d2;
      break;
    case OP_mul:
      r = d1 * d2;
      break;
    case OP_div:
      r = d1 / d2;
      break;
    case OP_mod:
      r = fmod(d1, d2);
      break;
    case OP_pow:
      r = js_pow(d1, d2);
      break;
    default: {
      prim_abort();
    }
  }
  return LEPUS_NewFloat64(ctx, r);
}

double prim_js_fmod_double(double a, double b) {
  double c = fmod(a, b);
  return c;
}

LEPUSValue prim_js_binary_logic_slow(LEPUSContext *ctx, LEPUSValue op1,
                                     LEPUSValue op2, OPCodeEnum op) {
  uint32_t v1, v2, r;
  if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
  switch (op) {
    case OP_shl:
      r = v1 << (v2 & 0x1f);
      break;
    case OP_sar:
      r = (int)v1 >> (v2 & 0x1f);
      break;
    case OP_and:
      r = v1 & v2;
      break;
    case OP_or:
      r = v1 | v2;
      break;
    case OP_xor:
      r = v1 ^ v2;
      break;
    default:
      prim_abort();
  }
  return LEPUS_NewInt32(ctx, r);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_shr_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2) {
  uint32_t v1, v2, r;
  if (unlikely(JS_ToUint32Free(ctx, &v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(JS_ToUint32Free(ctx, &v2, op2))) goto exception;
  r = v1 >> (v2 & 0x1f);
  return JS_NewUint32(ctx, r);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_relation_slow(LEPUSContext *ctx, LEPUSValue op1,
                                 LEPUSValue op2, OPCodeEnum op) {
  int res;
  op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }

  if (JS_IsSeparableString(op1)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op1);
    LEPUS_FreeValue(ctx, op1);
    op1 = tmp;
  }

  if (JS_IsSeparableString(op2)) {
    auto tmp = JS_GetSeparableStringContent(ctx, op2);
    LEPUS_FreeValue(ctx, op2);
    op2 = tmp;
  }
  if (LEPUS_VALUE_IS_STRING(op1) && LEPUS_VALUE_IS_STRING(op2)) {
    JSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = js_string_compare(ctx, p1, p2);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
  } else {
    double d1, d2;
    if (JS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  }
  return LEPUS_NewBool(ctx, res);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_eq_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2,
                           int is_neq) {
  uint64_t tag1, tag2;
  BOOL res;
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag1 == tag2 || (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_FLOAT64) ||
      (tag2 == LEPUS_TAG_INT && tag1 == LEPUS_TAG_FLOAT64) ||
      (LEPUS_IsString(op1) && LEPUS_IsString(op2))) {
    res = js_strict_eq(ctx, op1, op2);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((LEPUS_IsString(op1) &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
             (LEPUS_IsString(op2) &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
    double d1;
    double d2;
    if (JS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (JS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    res = (d1 == d2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op2));
    goto redo;
  } else if (tag1 == LEPUS_TAG_OBJECT &&
             (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64 ||
              tag2 == LEPUS_TAG_STRING || tag2 == LEPUS_TAG_SYMBOL ||
              tag2 == LEPUS_TAG_SEPARABLE_STRING)) {
    op1 = JS_ToPrimitiveFree_RC(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    goto redo;
  } else if (tag2 == LEPUS_TAG_OBJECT &&
             (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64 ||
              tag1 == LEPUS_TAG_STRING || tag1 == LEPUS_TAG_SYMBOL ||
              tag1 == LEPUS_TAG_SEPARABLE_STRING)) {
    op2 = JS_ToPrimitiveFree_RC(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    res = FALSE;
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  }
  return LEPUS_NewBool(ctx, res ^ is_neq);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_strict_eq_slow(LEPUSContext *ctx, LEPUSValue op1,
                                  LEPUSValue op2, BOOL is_neq) {
  BOOL res;
  res = js_strict_eq(ctx, op1, op2);
  return LEPUS_NewBool(ctx, res ^ is_neq);
}

LEPUSValue prim_js_operator_instanceof(LEPUSContext *ctx, LEPUSValue op1,
                                       LEPUSValue op2) {
  BOOL ret;
  ret = JS_IsInstanceOf_RC(ctx, op1, op2);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}

LEPUSValue prim_js_operator_in(LEPUSContext *ctx, LEPUSValue op1,
                               LEPUSValue op2) {
  JSAtom atom;
  int ret;

  if (LEPUS_VALUE_IS_NOT_OBJECT(op2) && !LEPUS_VALUE_IS_LEPUS_REF(op2)) {
    atom = js_value_to_atom(ctx, op1);
    if (unlikely(atom == JS_ATOM_NULL)) {
      LEPUS_ThrowTypeError(ctx, "invalid 'in' operand search for null");
      return LEPUS_EXCEPTION;
    }
    const char *msg = LEPUS_AtomToCString(ctx, atom);
    char buffer[200];
    if (msg) {
      snprintf(buffer, 199, "invalid 'in' operand search for '%s'", msg);
      LEPUS_FreeCString(ctx, msg);
    } else {
      snprintf(buffer, 199, "invalid 'in' operand search for null");
    }
    LEPUS_ThrowTypeError(ctx, "%s", buffer);
    LEPUS_FreeAtom(ctx, atom);
    return LEPUS_EXCEPTION;
  }
  atom = LEPUS_ValueToAtom(ctx, op1);
  if (unlikely(atom == JS_ATOM_NULL)) {
    return LEPUS_EXCEPTION;
  }
  ret = LEPUS_HasProperty(ctx, op2, atom);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  };
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}

LEPUSValue prim_js_operator_delete(LEPUSContext *ctx, LEPUSValue op1,
                                   LEPUSValue op2) {
  JSAtom atom = LEPUS_ValueToAtom(ctx, op2);
  if (unlikely(atom == JS_ATOM_NULL)) {
    return LEPUS_EXCEPTION;
  };
  int ret = LEPUS_DeleteProperty(ctx, op1, atom, LEPUS_PROP_THROW_STRICT);
  LEPUS_FreeAtom(ctx, atom);
  if (unlikely(ret < 0)) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}
#endif

#ifdef ENABLE_PRIMJS_SNAPSHOT
extern "C" void _call_stub_entry();

extern "C" void _dispatch_table();

extern "C" void _dispatch_table_offset();

typedef unsigned char u_char;
typedef u_char *address;

address _table[NUM_OF_TOS_STATES][OP_COUNT];

#define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast<func_type>(value))

QuickJsCallStub entry;
uint8_t *prim_normal_entry;

static void initialize_dispatchTable(LEPUSContext *ctx) {
  for (int i = 0; i < NUM_OF_TOS_STATES; i++) {
    for (int j = 1; j < OP_COUNT; j++) {
      int offset = i * (OP_COUNT - 1) + j - 1;
      int *table_entry = (int *)&_dispatch_table_offset + offset;
      int table_offset = *table_entry;
      _table[i][j] = (address)&_dispatch_table + table_offset;
    }
  }
  ctx->dispatch_table = _table;
}

static QuickJsCallStub call_stub() {
  return CAST_TO_FN_PTR(QuickJsCallStub, &_call_stub_entry);
}

void PrimInit(LEPUSContext *ctx) {
  initialize_dispatchTable(ctx);
#ifdef ENABLE_PRIMJS_SNAPSHOT
  entry = call_stub();
#endif
}

#endif

// <primjs end>

void *AllocateQJSValueValue(LEPUSRuntime *runtime) {
  return runtime->qjsvaluevalue_allocator->Create();
}

void FreeQJSValueValue(LEPUSRuntime *runtime, void *instance) {
#ifdef ENABLE_GC_DEBUG_TOOLS
  DCHECK(CheckValidNode(runtime, (void *)instance, 2));
  DeleteCurNode(runtime, (void *)instance, 2);
#endif
  runtime->qjsvaluevalue_allocator->Destroy((LEPUSValue *)instance);
}

void ClearGlobalWeak(LEPUSRuntime *runtime, LEPUSValue *global_handle) {
  CallGCFunc(ClearGlobalWeak_GC, runtime, global_handle);
}

void SetGlobalWeak(LEPUSRuntime *runtime, LEPUSValue *global_handle, void *data,
                   void (*cb)(void *)) {
  CallGCFunc(SetGlobalWeak_GC, runtime, global_handle, data, cb);
}

void *GetNapiScope(LEPUSContext *ctx) {
  CallGCFunc(GetNapiScope_GC, ctx);
  return nullptr;
}

void InitNapiScope(LEPUSContext *ctx) { CallGCFunc(InitNapiScope_GC, ctx); }

void FreeNapiScope(LEPUSContext *ctx) { CallGCFunc(FreeNapiScope_GC, ctx); }

void SetNapiScope(LEPUSContext *ctx, void *scope) {
  CallGCFunc(SetNapiScope_GC, ctx, scope);
}

void SetWeakState(LEPUSRuntime *runtime, LEPUSValue *global_handle) {
  CallGCFunc(SetWeakState_GC, runtime, global_handle);
}

void LEPUS_SetGCPauseSuppressionMode(LEPUSRuntime *rt, bool mode) {
  CallGCFunc(JS_SetGCPauseSuppressionMode_GC, rt, mode);
}

bool LEPUS_GetGCPauseSuppressionMode(LEPUSRuntime *rt) {
#ifdef ENABLE_COMPATIBLE_MM
  if (rt->gc_enable) {
    return JS_GetGCPauseSuppressionMode_GC(rt);
  }
#endif
  return false;
}

__attribute__((unused)) bool CheckValidPtr(void *runtime, void *ptr) {
#ifdef ENABLE_COMPATIBLE_MM
  if (static_cast<LEPUSRuntime *>(runtime)->gc_enable) {
    return CheckValidPtr_GC(runtime, ptr);
  }
#endif
  return true;
}

void LEPUS_SetFuncFileName(LEPUSContext *ctx, LEPUSValue obj,
                           const char *filename) {
  if (!LEPUS_VALUE_IS_FUNCTION_BYTECODE(obj) || !filename) return;
  static thread_local list_head all_funcs;
  list_head *el, *el1;
  init_list_head(&all_funcs);
  bool gc_enable = ctx->gc_enable;
  LEPUSFunctionBytecode *b =
      static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
  list_add_tail(&b->debug.link, &all_funcs);
  auto add_child_wrapper = [](LEPUSRuntime *rt, LEPUSValue val, int32_t) {
    if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(val)) {
      auto *b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
      list_add_tail(&b->debug.link, &all_funcs);
    }
    return;
  };

  JSAtom filename_atom = LEPUS_NewAtom(ctx, filename);
  list_for_each(el, &all_funcs) {
    auto *b = list_entry(el, LEPUSFunctionBytecode, debug.link);
    if (gc_enable) {
      b->debug.filename = filename_atom;
    } else {
      LEPUS_FreeAtom(ctx, b->debug.filename);
      b->debug.filename = LEPUS_DupAtom(ctx, filename_atom);
    }
    mark_children(ctx->rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b),
                  add_child_wrapper);
  }
  if (!gc_enable) LEPUS_FreeAtom(ctx, filename_atom);
  return;
}

void InitLynxTraceEnv(void *(*begin)(const char *), void (*end)(void *ptr)) {
  auto &lynx_trace = LynxTraceInstance::GetInstance();
  lynx_trace.InitBeginPtr(begin);
  lynx_trace.InitEndPtr(end);
  return;
}
